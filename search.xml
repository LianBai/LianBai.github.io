<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Unity杂文——循环的字节序列Stream</title>
      <link href="/2023/09/27/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97Stream/"/>
      <url>/2023/09/27/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97Stream/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这篇博客主要介绍了一个字节序列类CircularBuffer，它是用于频繁创建Stream数据的循环利用。CircularBuffer类继承自Stream类，并实现了其各种方法，包括读写、查找、设置长度等。</p><p>在CircularBuffer类中，主要定义了一些关键的属性，如字节数组、偏移值、开始坐标、结束坐标、长度、当前位置、容量、限制读取长度和标记等。其中，字节数组用于存储数据，偏移值用于定位数据，开始坐标和结束坐标用于定义数据的起始和结束位置，长度表示数据的长度，当前位置表示当前读写的位置，容量表示最大可以存储的数据量，限制读取长度用于限制读取的数据长度，标记用于标记当前对象。</p><p>在CircularBuffer类中，还定义了一些方法，如初始化、设置限制读取长度、读取字节、查找字节、设置长度、写入字节、收缩、扩展、开始接收、结束接收、开始发送、结束发送、重置等。这些方法主要用于操作和管理数据。</p><p>CircularBuffer类的主要优点是可以有效地管理和操作数据，特别是在需要频繁创建Stream数据的情况下，可以有效地提高性能和效率。同时，CircularBuffer类的设计也非常灵活和通用，可以适应各种不同的应用场景。</p><p>总的来说，CircularBuffer类是一个非常实用和高效的字节序列类，值得大家在实际的开发中使用和学习。</p><h1 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h1><pre><code>public class CircularBuffer : Stream&#123;    /// &lt;summary&gt;    /// 字节数组    /// &lt;/summary&gt;    private byte[] m_Buffer;    /// &lt;summary&gt;    /// 偏移值    /// &lt;/summary&gt;    private int m_Offset; // []    /// &lt;summary&gt;    /// 开始坐标    /// &lt;/summary&gt;    private int m_Begin;  // [0, m_Capacity)    /// &lt;summary&gt;    /// 结束坐标    /// &lt;/summary&gt;    private int m_End;    // [0, m_Capacity)    /// &lt;summary&gt;    /// 长度    /// &lt;/summary&gt;    private int m_Length;    /// &lt;summary&gt;    /// 当前位置    /// &lt;/summary&gt;    private int m_Position;    /// &lt;summary&gt;    /// 容量    /// &lt;/summary&gt;    private int m_Capacity;    /// &lt;summary&gt;    /// 限制读取长度    /// &lt;/summary&gt;    private int m_LimitReadLength;    /// &lt;summary&gt;    /// 标记    /// &lt;/summary&gt;    private string m_Tag;    /// &lt;summary&gt;    /// 缓存    /// &lt;/summary&gt;    private byte[] m_Cached = new byte[4];    /// &lt;summary&gt;    /// 是否刻度    /// &lt;/summary&gt;    public override bool CanRead =&gt; true;    /// &lt;summary&gt;    /// 是否可定位    /// &lt;/summary&gt;    public override bool CanSeek =&gt; true;    /// &lt;summary&gt;    /// 是否可写入    /// &lt;/summary&gt;    public override bool CanWrite =&gt; true;    /// &lt;summary&gt;    /// 长度    /// &lt;/summary&gt;    public override long Length =&gt; m_Length;    /// &lt;summary&gt;    /// 当前位置坐标    /// &lt;/summary&gt;    public override long Position    &#123;        get =&gt; m_Position;        set        &#123;            if (m_Position == value) return;            Seek(value, SeekOrigin.Begin);        &#125;    &#125;    /// &lt;summary&gt;    /// 容器长度    /// &lt;/summary&gt;    public int Capacity =&gt; m_Capacity;    /// &lt;summary&gt;    /// 标记    /// &lt;/summary&gt;    public string Tag =&gt; m_Tag;        /// &lt;summary&gt;    /// 索引读取    /// &lt;/summary&gt;    /// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt;    /// &lt;exception cref=&quot;ArgumentOutOfRangeException&quot;&gt;&lt;/exception&gt;    public byte this[int index]    &#123;        get        &#123;            if (index &lt; 0 || index &gt;= m_Length)            &#123;                throw new ArgumentOutOfRangeException($&quot;index &#123;index&#125; length &#123;m_Length&#125;&quot;);            &#125;            var begin = m_Begin;            var end = m_End;            if (end &gt; begin)            &#123;                //    0    m_Begin  m_End   m_Capacity                //    |_______|_______|_______|                //                |                //            m_Position                return m_Buffer[m_Offset + begin + index];            &#125;            else            &#123;                //    0     m_End  m_Begin   m_Capacity                //    |_______|_______|_______|                //        |               |                //       (1)  m_Position (2)                var blockLen = m_Capacity - begin;                return blockLen &gt; index ?                    //(2)                    m_Buffer[m_Offset + begin + index] :                    //(1)                    m_Buffer[m_Offset + index - blockLen];            &#125;        &#125;        set        &#123;            if (index &lt; 0 || index &gt;= m_Length)            &#123;                throw new ArgumentOutOfRangeException($&quot;index &#123;index&#125; length &#123;m_Length&#125;&quot;);            &#125;            var begin = m_Begin;            var end = m_End;            if (end &gt; begin)            &#123;                //    0    m_Begin  m_End   m_Capacity                //    |_______|_______|_______|                //                |                //            m_Position                m_Buffer[m_Offset + begin + index] = value;            &#125;            else            &#123;                //    0     m_End  m_Begin   m_Capacity                //    |_______|_______|_______|                //        |               |                //       (1)  m_Position (2)                var blockLen = m_Capacity - begin;                if (blockLen &gt; index)                &#123;                    //(2)                    m_Buffer[m_Offset + begin + index] = value;                &#125;                else                &#123;                    //(1)                    m_Buffer[m_Offset + index - blockLen] = value;                &#125;            &#125;        &#125;    &#125;    /// &lt;summary&gt;    /// 初始化    /// &lt;/summary&gt;    /// &lt;param name=&quot;tag&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;capcity&quot;&gt;&lt;/param&gt;    public CircularBuffer(string tag, int capcity)    &#123;        m_Capacity = capcity;        m_Buffer = new byte[m_Capacity];        m_Offset = 0;        m_Begin = 0;        m_End = 0;        m_Length = 0;        m_Position = 0;        m_Tag = tag;    &#125;    /// &lt;summary&gt;    /// 设置限制读取长度    /// &lt;/summary&gt;    /// &lt;param name=&quot;length&quot;&gt;&lt;/param&gt;    public void SetLimitReadLength(int length)    &#123;        Trace($&quot;&#123;length&#125;&quot;);        m_LimitReadLength = length;    &#125;    #region Override    /// &lt;summary&gt;    /// 继承的类必须实现此方法，以便在流中写入字节。    /// &lt;/summary&gt;    /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt;    public override void Flush()    &#123;        throw new NotImplementedException();    &#125;    /// &lt;summary&gt;    /// 打印日志    /// &lt;/summary&gt;    /// &lt;param name=&quot;msg&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;memberName&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;lineNum&quot;&gt;&lt;/param&gt;    [Conditional(&quot;DEBUG_STREAM_TRACE&quot;)]    private static void Trace(string msg, [CallerMemberName] string memberName = &quot;&quot;, [CallerLineNumber] int lineNum = 0)    &#123;        //Logging.Log($&quot;&#123;m_Tag&#125; &#123;memberName&#125;:&#123;lineNum&#125;:&#123;Thread.CurrentThread.ManagedThreadId&#125; &#123;m_Begin&#125; &#123;m_End&#125; &#123;m_Position&#125; &#123;m_LimitReadLength&#125; &#123;m_Length&#125;/&#123;m_Capacity&#125; &#123;msg&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 读取字节未见    /// &lt;/summary&gt;    /// &lt;param name=&quot;buffer&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;offset&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;count&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    /// &lt;exception cref=&quot;Exception&quot;&gt;&lt;/exception&gt;    public override int Read(byte[] buffer, int offset, int count)    &#123;        Trace($&quot;&#123;offset&#125; &#123;count&#125;&quot;);        var position = m_Position;        var dataLen = (int)Math.Min(count, (0 == m_LimitReadLength ? m_Length : m_LimitReadLength) - position);        if (0 == dataLen) return 0;        try        &#123;            var begin = m_Begin;            var end = m_End;            if (end &gt; begin)            &#123;                //    0    m_Begin  m_End   m_Capacity                //    |_______|_______|_______|                //                |                //            m_Position                Buffer.BlockCopy(m_Buffer, m_Offset + begin + position, buffer, offset, dataLen);            &#125;            else            &#123;                //    0     m_End  m_Begin   m_Capacity                //    |_______|_______|_______|                //        |               |                //       (1)  m_Position (2)                var blockLen = m_Capacity - begin;                if (blockLen &gt; position)                &#123;                    //(2)                    var copyLen = blockLen - position;                    var remain = dataLen - copyLen;                    if (remain &gt; 0)                    &#123;                        Buffer.BlockCopy(m_Buffer, m_Offset + begin + position, buffer, offset, copyLen);                        Buffer.BlockCopy(m_Buffer, m_Offset, buffer, offset + copyLen, remain);                    &#125;                    else                    &#123;                        Buffer.BlockCopy(m_Buffer, m_Offset + begin + position, buffer, offset, dataLen);                    &#125;                &#125;                else                &#123;                    //(1)                    Buffer.BlockCopy(m_Buffer, m_Offset + position - blockLen, buffer, offset, dataLen);                &#125;            &#125;        &#125;        catch (Exception e)        &#123;            UnityEngine.Debug.LogError($&quot;read &#123;m_Position&#125; &#123;m_LimitReadLength&#125; &#123;m_Length&#125; &#123;m_Begin&#125; &#123;m_End&#125; &#123;m_Offset&#125; &#123;m_Capacity&#125;&quot;);            throw e;        &#125;        m_Position += dataLen;        return dataLen;    &#125;    /// &lt;summary&gt;    /// 查找字节    /// &lt;/summary&gt;    /// &lt;param name=&quot;offset&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;origin&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    /// &lt;exception cref=&quot;ArgumentOutOfRangeException&quot;&gt;&lt;/exception&gt;    public override long Seek(long offset, SeekOrigin origin)    &#123;        Trace($&quot;&#123;offset&#125; &#123;origin&#125;&quot;);        var length = m_Length;        long position = m_Position;        switch (origin)        &#123;            case SeekOrigin.Begin:                position = offset;                break;            case SeekOrigin.End:                position = offset + length;                break;            case SeekOrigin.Current:                position += offset;                break;            default:                throw new ArgumentOutOfRangeException(nameof(origin), origin, null);        &#125;        m_Position = (int)Math.Max(0, Math.Min(position, length));        return m_Position;    &#125;    /// &lt;summary&gt;    /// 设置长度    /// &lt;/summary&gt;    /// &lt;param name=&quot;value&quot;&gt;&lt;/param&gt;    /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt;    public override void SetLength(long value)    &#123;        throw new NotImplementedException();    &#125;        /// &lt;summary&gt;    /// 写入字节    /// &lt;/summary&gt;    /// &lt;param name=&quot;length&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public StringBuilder GetHexData(int length = -1)    &#123;        var sb = new StringBuilder();        var begin = m_Begin;        var end = m_End;        var count = 0;        var maxCount = -1 == length ? m_Length : length;        if (end &gt; begin || 0 == m_Length)        &#123;            for (var i = begin; i &lt; end &amp;&amp; count &lt; maxCount; i++, count++)            &#123;                sb.Append($&quot;&#123;m_Buffer[m_Offset + i]:x2&#125; &quot;);            &#125;        &#125;        else        &#123;            for (var i = begin; i &lt; m_Capacity &amp;&amp; count &lt; maxCount; i++, count++)            &#123;                sb.Append($&quot;&#123;m_Buffer[m_Offset + i]:x2&#125; &quot;);            &#125;            for (var i = 0; i &lt; m_End &amp;&amp; count &lt; maxCount; i++, count++)            &#123;                sb.Append($&quot;&#123;m_Buffer[m_Offset + i]:x2&#125; &quot;);            &#125;        &#125;        return sb;    &#125;    /// &lt;summary&gt;    /// 获取字节    /// &lt;/summary&gt;    /// &lt;param name=&quot;buffer&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;offset&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;count&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    private StringBuilder GetHexData(byte[] buffer, int offset, int count)    &#123;        var sb = new StringBuilder();        for (var i = 0; i &lt; count; i++)        &#123;            sb.Append($&quot;&#123;buffer[offset + i]:x2&#125; &quot;);        &#125;        return sb;    &#125;    /// &lt;summary&gt;    /// 写入字节    /// &lt;/summary&gt;    /// &lt;param name=&quot;buffer&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;offset&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;count&quot;&gt;&lt;/param&gt;    /// &lt;exception cref=&quot;OutOfMemoryException&quot;&gt;&lt;/exception&gt;    /// &lt;exception cref=&quot;Exception&quot;&gt;&lt;/exception&gt;    public override void Write(byte[] buffer, int offset, int count)    &#123;        if (0 == count) return;        Trace($&quot;&#123;GetHexData(buffer, offset, count)&#125;&quot;);        var position = m_Position;        var length = m_Length;        if (m_Capacity - position &lt; count)        &#123;            throw new OutOfMemoryException();        &#125;        try        &#123;            var begin = m_Begin;            var end = m_End;            var replaceLen = length - position;            if (end &gt; begin || 0 == m_Length)            &#123;                //    0    m_Begin  m_End   m_Capacity                //    |_______|_______|_______|                //                |                //            m_Position                var copyLen = m_Capacity - (begin + position);                var remain = count - copyLen;                if (remain &gt; 0)                &#123;                    Buffer.BlockCopy(buffer, offset, m_Buffer, m_Offset + begin + position, copyLen);                    Buffer.BlockCopy(buffer, offset + copyLen, m_Buffer, m_Offset, remain);                &#125;                else                &#123;                    Buffer.BlockCopy(buffer, offset, m_Buffer, m_Offset + begin + position, count);                &#125;            &#125;            else            &#123;                //    0     m_End  m_Begin   m_Capacity                //    |_______|_______|_______|                //        |               |                //       (1)  m_Position (2)                var blockLen = m_Capacity - begin;                if (blockLen &gt; position)                &#123;                    //(2)                    var copyLen = blockLen - position;                    var remain = count - copyLen;                    if (remain &gt; 0)                    &#123;                        Buffer.BlockCopy(buffer, offset, m_Buffer, m_Offset + begin + position, copyLen);                        Buffer.BlockCopy(buffer, offset + copyLen, m_Buffer, m_Offset, remain);                    &#125;                    else                    &#123;                        Buffer.BlockCopy(buffer, offset, m_Buffer, m_Offset + begin + position, count);                    &#125;                &#125;                else                &#123;                    //(1)                    Buffer.BlockCopy(buffer, offset, m_Buffer, m_Offset + position - blockLen, count);                &#125;            &#125;            if (count &gt; replaceLen)            &#123;                Expand(count - replaceLen);            &#125;            else            &#123;                m_Position += count;            &#125;        &#125;        catch (Exception e)        &#123;            UnityEngine.Debug.LogError($&quot;write &#123;m_Position&#125; &#123;m_LimitReadLength&#125; &#123;m_Length&#125; &#123;m_Begin&#125; &#123;m_End&#125; &#123;m_Offset&#125; &#123;m_Capacity&#125; &#123;count&#125;&quot;);            throw e;        &#125;        Trace($&quot;&#123;GetHexData()&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 释放    /// &lt;/summary&gt;    /// &lt;param name=&quot;disposing&quot;&gt;&lt;/param&gt;    protected override void Dispose(bool disposing)    &#123;        base.Dispose(disposing);        if (m_Capacity &gt; 0)        &#123;            m_Buffer = null;            m_Capacity = 0;        &#125;    &#125;    #endregion    /// &lt;summary&gt;    /// 收缩    /// &lt;/summary&gt;    /// &lt;param name=&quot;length&quot;&gt;&lt;/param&gt;    public void Shrink(int length)    &#123;        Trace($&quot;start &#123;length&#125;&quot;);        m_Begin += length;        if (m_Begin &gt;= m_Capacity)        &#123;            m_Begin -= m_Capacity;        &#125;        if (m_Position &lt;= length)        &#123;            m_Position = 0;        &#125;        else        &#123;            m_Position -= length;        &#125;        m_Length -= length;        Trace($&quot;end &#123;length&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 扩展    /// &lt;/summary&gt;    /// &lt;param name=&quot;length&quot;&gt;&lt;/param&gt;    public void Expand(int length)    &#123;        Trace($&quot;start &#123;length&#125;&quot;);        m_End += length;        if (m_End &gt;= m_Capacity)        &#123;            m_End -= m_Capacity;        &#125;        m_Length += length;        m_Position = m_Length;        Trace($&quot;end &#123;length&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 开始接收    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    /// &lt;exception cref=&quot;Exception&quot;&gt;&lt;/exception&gt;    public ArraySegment&lt;byte&gt;[] BeginRcv()    &#123;        Trace(&quot;&quot;);        try        &#123;            var length = m_Length;            if (m_Capacity == length)            &#123;                return Array.Empty&lt;ArraySegment&lt;byte&gt;&gt;();            &#125;            var begin = m_Begin;            var end = m_End;            if (end &gt; begin || 0 == m_Length)            &#123;                //    0    m_Begin  m_End   m_Capacity                //    |_______|_______|_______|                if (0 == begin)                &#123;                    return new ArraySegment&lt;byte&gt;[]                    &#123;                        new ArraySegment&lt;byte&gt;(m_Buffer, m_Offset + end, m_Capacity - end)                    &#125;;                &#125;                return new ArraySegment&lt;byte&gt;[]                &#123;                    new ArraySegment&lt;byte&gt;(m_Buffer, m_Offset + end, m_Capacity - end),                    new ArraySegment&lt;byte&gt;(m_Buffer, m_Offset, begin)                &#125;;            &#125;            else            &#123;                //    0     m_End  m_Begin   m_Capacity                //    |_______|_______|_______|                return new ArraySegment&lt;byte&gt;[]                &#123;                    new ArraySegment&lt;byte&gt;(m_Buffer, m_Offset + end, begin - end)                &#125;;            &#125;        &#125;        catch (Exception ex)        &#123;            UnityEngine.Debug.LogError($&quot;&#123;m_Length&#125; &#123;m_Capacity&#125; &#123;m_Begin&#125; &#123;m_End&#125; &#123;m_Offset&#125;&quot;);            throw ex;        &#125;    &#125;    /// &lt;summary&gt;    /// 结束接收    /// &lt;/summary&gt;    /// &lt;param name=&quot;length&quot;&gt;&lt;/param&gt;    /// &lt;exception cref=&quot;OutOfMemoryException&quot;&gt;&lt;/exception&gt;    public void EndRcv(int length)    &#123;        Trace($&quot;&#123;length&#125;&quot;);        if (m_Capacity &gt;= m_Length + length)        &#123;            Expand(length);        &#125;        else        &#123;            throw new OutOfMemoryException();        &#125;    &#125;    /// &lt;summary&gt;    /// 开始发送    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public ArraySegment&lt;byte&gt;[] BeginSend()    &#123;        if (0 == m_Length) return Array.Empty&lt;ArraySegment&lt;byte&gt;&gt;();        var begin = m_Begin;        var end = m_End;        if (end &gt; begin)        &#123;            Trace($&quot;offset &#123;m_Offset + begin&#125; len &#123;end - begin&#125;&quot;);            //    0    m_Begin  m_End   m_Capacity            //    |_______|_______|_______|            return new ArraySegment&lt;byte&gt;[]            &#123;                new ArraySegment&lt;byte&gt;(m_Buffer, m_Offset + begin, end - begin)            &#125;;        &#125;        else        &#123;            Trace($&quot;offset &#123;m_Offset + begin&#125; len &#123;m_Capacity - begin&#125; offset &#123;m_Offset&#125; len &#123;end&#125;&quot;);            //    0     m_End  m_Begin   m_Capacity            //    |_______|_______|_______|            return new ArraySegment&lt;byte&gt;[]            &#123;                new ArraySegment&lt;byte&gt;(m_Buffer, m_Offset + begin, m_Capacity - begin),                new ArraySegment&lt;byte&gt;(m_Buffer, m_Offset, end)            &#125;;        &#125;    &#125;    /// &lt;summary&gt;    /// 结束发送    /// &lt;/summary&gt;    /// &lt;param name=&quot;length&quot;&gt;&lt;/param&gt;    /// &lt;exception cref=&quot;IndexOutOfRangeException&quot;&gt;&lt;/exception&gt;    public void EndSend(int length)    &#123;        Trace($&quot;&#123;GetHexData(length)&#125;&quot;);        if (m_Length &gt;= length)        &#123;            Shrink(length);        &#125;        else        &#123;            throw new IndexOutOfRangeException();        &#125;    &#125;    /// &lt;summary&gt;    /// 重置    /// &lt;/summary&gt;    public void Reset()    &#123;        Trace(&quot;&quot;);        m_Length = 0;        m_Begin = 0;        m_End = 0;        m_Position = 0;    &#125;    /// &lt;summary&gt;    /// 写入    /// &lt;/summary&gt;    /// &lt;param name=&quot;v&quot;&gt;&lt;/param&gt;    public void Write(int v)    &#123;        m_Cached[0] = (byte)(v &gt;&gt; 0);        m_Cached[1] = (byte)(v &gt;&gt; 8);        m_Cached[2] = (byte)(v &gt;&gt; 16);        m_Cached[3] = (byte)(v &gt;&gt; 24);        Write(m_Cached, 0, 4);    &#125;    /// &lt;summary&gt;    /// 读取    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public int ReadInt32()    &#123;        Read(m_Cached, 0, 4);        var result = 0;        result |= (int)m_Cached[0];        result |= (int)(m_Cached[1] &lt;&lt; 8);        result |= (int)(m_Cached[2] &lt;&lt; 16);        result |= (int)(m_Cached[3] &lt;&lt; 24);        return result;    &#125;    /// &lt;summary&gt;    /// 写入    /// &lt;/summary&gt;    /// &lt;param name=&quot;v&quot;&gt;&lt;/param&gt;    public void Write(uint v)    &#123;        m_Cached[0] = (byte)(v &gt;&gt; 0);        m_Cached[1] = (byte)(v &gt;&gt; 8);        m_Cached[2] = (byte)(v &gt;&gt; 16);        m_Cached[3] = (byte)(v &gt;&gt; 24);        Write(m_Cached, 0, 4);    &#125;    /// &lt;summary&gt;    /// 读取    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public uint ReadUInt32()    &#123;        Read(m_Cached, 0, 4);        uint result = 0;        result |= (uint)m_Cached[0];        result |= (uint)(m_Cached[1] &lt;&lt; 8);        result |= (uint)(m_Cached[2] &lt;&lt; 16);        result |= (uint)(m_Cached[3] &lt;&lt; 24);        return result;    &#125;    /// &lt;summary&gt;    /// 写入    /// &lt;/summary&gt;    /// &lt;param name=&quot;v&quot;&gt;&lt;/param&gt;    public void Write(ushort v)    &#123;        m_Cached[0] = (byte)(v &gt;&gt; 0);        m_Cached[1] = (byte)(v &gt;&gt; 8);        Write(m_Cached, 0, 2);    &#125;    /// &lt;summary&gt;    /// 读取    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public uint ReadUInt16()    &#123;        Read(m_Cached, 0, 2);        ushort result = 0;        result |= (ushort)m_Cached[0];        result |= (ushort)(m_Cached[1] &lt;&lt; 8);        return result;    &#125;    /// &lt;summary&gt;    /// 写入    /// &lt;/summary&gt;    /// &lt;param name=&quot;v&quot;&gt;&lt;/param&gt;    public void Write(short v)    &#123;        m_Cached[0] = (byte)(v &gt;&gt; 0);        m_Cached[1] = (byte)(v &gt;&gt; 8);        Write(m_Cached, 0, 2);    &#125;    /// &lt;summary&gt;    /// 读取    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public int ReadInt16()    &#123;        Read(m_Cached, 0, 2);        short result = 0;        result |= (short)m_Cached[0];        result |= (short)(m_Cached[1] &lt;&lt; 8);        return result;    &#125;    /// &lt;summary&gt;    /// 写入    /// &lt;/summary&gt;    /// &lt;param name=&quot;v&quot;&gt;&lt;/param&gt;    public void Write(byte v)    &#123;        m_Cached[0] = v;        Write(m_Cached, 0, 1);    &#125;    /// &lt;summary&gt;    /// 读取    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public byte ReadUInt8()    &#123;        Read(m_Cached, 0, 1);        return m_Cached[0];    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——python开发的导表工具</title>
      <link href="/2023/09/21/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94python%E5%BC%80%E5%8F%91%E7%9A%84%E5%AF%BC%E8%A1%A8%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/09/21/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94python%E5%BC%80%E5%8F%91%E7%9A%84%E5%AF%BC%E8%A1%A8%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="Excel2Bytes-v0-1-0"><a href="#Excel2Bytes-v0-1-0" class="headerlink" title="Excel2Bytes(v0.1.0)"></a>Excel2Bytes(v0.1.0)</h1><p><a href="https://github.com/LBGTeam/Excel2Bytes"><strong>Excel2Bytes仓库</strong></a>  </p><p>py写的游戏开发用的导表工具。目前支持C#脚本。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>该工具的原理是将表格数据转换为二进制数据，并生成对应的bytes文件。同时，它还会生成可供访问的C#脚本，使得在游戏中可以通过C#按照二进制字节的方式读取所需的数据。</p><p>这个工具的优势在于它可以提高游戏的加载速度和性能。通过将表格数据转换为二进制格式，可以减少文件大小和加载时间。同时，使用C#脚本读取二进制数据可以更高效地访问和处理数据。</p><p>该工具目前正在开发中，预计会提供更多功能和优化。敬请期待！  </p><h2 id="工具配置"><a href="#工具配置" class="headerlink" title="工具配置"></a>工具配置</h2><p>首次运行会在当前目录的Config文件夹下生成一个Config.json配置文件，这个文件里面是导表工具的配置。<br>这里的配置<strong>后续开发</strong>将支持QT面板进行修改，不用修改文件。  </p><p>示例  </p><pre><code>&#123;    &quot;IsUpdateAllLNG&quot;: true,    &quot;TablePath&quot;: &quot;F:\\MyPrograme\\Excel2Bytes\\Excel2Bytes\\Save\\Table&quot;,    &quot;BytesPath&quot;: &quot;F:\\MyPrograme\\Excel2Bytes\\Excel2Bytes\\Save\\Bytes&quot;,    &quot;ScriptsPath&quot;: &quot;F:\\MyPrograme\\Excel2Bytes\\Excel2Bytes\\Save\\Scripts&quot;,    &quot;CorePath&quot;: &quot;F:\\MyPrograme\\Excel2Bytes\\Excel2Bytes\\Save\\Core&quot;,    &quot;LNGBytesPath&quot;: &quot;F:\\MyPrograme\\Excel2Bytes\\Excel2Bytes\\Save\\Bytes&quot;,    &quot;ResRefFileListPath&quot;: &quot;F:\\MyPrograme\\Excel2Bytes\\Excel2Bytes\\Save\\reslist.json&quot;,    &quot;LanguageXlsxPath&quot;: &quot;F:\\MyPrograme\\Excel2Bytes\\Excel2Bytes\\Save\\Table\\Languages.xlsx&quot;,    &quot;CNLanguage&quot;: &quot;cn&quot;,    &quot;TableLanguageCSName&quot;: &quot;Languages&quot;,    &quot;BytesExportPath&quot;: &quot;&quot;,    &quot;ScriptsExportPath&quot;: &quot;&quot;,    &quot;CoreExportPath&quot;: &quot;&quot;,    &quot;TableRootNamespace&quot;: &quot;LBRuntime&quot;,    &quot;TableResLoadAssembly&quot;: &quot;LBUnity&quot;,    &quot;ResLoadScripts&quot;: &quot;ResManager.OpenFile(\&quot;&#123;0&#125;\&quot;)&quot;,    &quot;LanguageKey&quot;: [        &quot;tw&quot;,        &quot;en&quot;    ],    &quot;SupportExcelFormats&quot;: [        &quot;.xlsx&quot;,        &quot;.csv&quot;    ],    &quot;TableSheetInfo&quot;: &#123;        &quot;ScriptsName&quot;: &quot;&quot;,        &quot;ImportType&quot;: &quot;NoneType&quot;,        &quot;ExtraNamespace&quot;: &quot;&quot;    &#125;&#125;</code></pre><table><thead><tr><th align="left">字段</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">IsUpdateAllLNG</td><td align="left">表示是否要更新多语言，如果为False，只有中文语言表会更新，其他的语言不会更新</td></tr><tr><td align="left">TablePath</td><td align="left">表格存放的目录</td></tr><tr><td align="left">BytesPath</td><td align="left">生成的字节文件存放的目录（非项目内路径，后面有项目内的路径配置，会把这里的文件复制到后面配置的项目路径）</td></tr><tr><td align="left">ScriptsPath</td><td align="left">生成的脚本文件存放目录（和BytesPath一样是临时存放目录)</td></tr><tr><td align="left">CorePath</td><td align="left">核心脚本目录，初次导入的时候会生成TableManager等管理脚本存放目录（也是临时存放目录）</td></tr><tr><td align="left">LNGBytesPath</td><td align="left">多语言的字节生成目录，所有的语言生成的字节文件都是一样的名字，会放在与语言页签同样名字的文件夹下，开发者加载的时候处理不同语言访问的字节文件。</td></tr><tr><td align="left">ResRefFileListPath</td><td align="left">收集配置的资源名字的json文件路径（里面存放的都是表里配置的资源的名字）</td></tr><tr><td align="left">LanguageXlsxPath</td><td align="left">多语言的表格路径，这个是自动生成的。<font color="Red">只有处理其他语言显示文字才会修改这个表，这个表的中文页签是会自动更新的</font></td></tr><tr><td align="left">CNLanguage</td><td align="left">多语言表中文页签的页签名</td></tr><tr><td align="left">TableLanguageCSName</td><td align="left">读取语言的脚本名字，这里不需要带前缀”Table”（如上图配置，游戏中访问语言就是：TableLanguages.Find(10)）</td></tr><tr><td align="left">BytesExportPath</td><td align="left">项目里表格字节文件存放的路径，工具会把临时存放的字节文件复制到这个文件里</td></tr><tr><td align="left">ScriptsExportPath</td><td align="left">项目里表格脚本文件存放的路径，同上</td></tr><tr><td align="left">CoreExportPath</td><td align="left">表格核心脚本存放路径，同上</td></tr><tr><td align="left">TableRootNamespace</td><td align="left">表格脚本所在的程序集名字（把导表生成的脚本都放在这个程序集下）</td></tr><tr><td align="left">TableResLoadAssembly</td><td align="left">脚本加载字节文件的时候需要用到的项目资源加载脚本所在的命名空间</td></tr><tr><td align="left">ResLoadScripts</td><td align="left">加载字节文件用到的项目里的方法</td></tr><tr><td align="left">LanguageKey</td><td align="left">多语言中其他语言的页签名字</td></tr><tr><td align="left">SupportExcelFormats</td><td align="left">表格文件支持的后缀</td></tr><tr><td align="left">TableSheetInfo</td><td align="left">页签文件要包含的信息，扩展使用（正常情况下不要修改，增加需要修改代码以作支持）</td></tr></tbody></table><h2 id="表格类型"><a href="#表格类型" class="headerlink" title="表格类型"></a>表格类型</h2><p>首次运行会在当前目录的Config文件夹下生成一个TableConfig.json配置文件，这个文件里面是导表工具的配置。  </p><p>示例  </p><pre><code>&#123;    &quot;Global.xlsx&quot;: &#123;        &quot;Global&quot;: &#123;            &quot;ScriptsName&quot;: &quot;TableGlobal&quot;,            &quot;ImportType&quot;: &quot;CustomTypeField&quot;,            &quot;ExtraNamespace&quot;: &quot;&quot;        &#125;    &#125;,    &quot;Languages.xlsx&quot;: &#123;        &quot;cn&quot;: &#123;            &quot;ScriptsName&quot;: &quot;TableLanguagescn&quot;,            &quot;ImportType&quot;: &quot;LNGType&quot;,            &quot;ExtraNamespace&quot;: &quot;&quot;        &#125;,        &quot;tw&quot;: &#123;            &quot;ScriptsName&quot;: &quot;TableLanguagestw&quot;,            &quot;ImportType&quot;: &quot;LNGType&quot;,            &quot;ExtraNamespace&quot;: &quot;&quot;        &#125;,        &quot;en&quot;: &#123;            &quot;ScriptsName&quot;: &quot;TableLanguagesen&quot;,            &quot;ImportType&quot;: &quot;LNGType&quot;,            &quot;ExtraNamespace&quot;: &quot;&quot;        &#125;    &#125;,    &quot;LanguagesUI.xlsx&quot;: &#123;        &quot;UI&quot;: &#123;            &quot;ScriptsName&quot;: &quot;TableLanguagesUIUI&quot;,            &quot;ImportType&quot;: &quot;NoExportLNGType&quot;,            &quot;ExtraNamespace&quot;: &quot;&quot;        &#125;    &#125;,    &quot;Level.xlsx&quot;: &#123;        &quot;Level&quot;: &#123;            &quot;ScriptsName&quot;: &quot;TableLevel&quot;,            &quot;ImportType&quot;: &quot;FindType&quot;,            &quot;ExtraNamespace&quot;: &quot;&quot;        &#125;,        &quot;Chase&quot;: &#123;            &quot;ScriptsName&quot;: &quot;TableLevelChase&quot;,            &quot;ImportType&quot;: &quot;FindType&quot;,            &quot;ExtraNamespace&quot;: &quot;&quot;        &#125;    &#125;,    &quot;ResName.xlsx&quot;: &#123;        &quot;ResName&quot;: &#123;            &quot;ScriptsName&quot;: &quot;TableResName&quot;,            &quot;ImportType&quot;: &quot;FieldType&quot;,            &quot;ExtraNamespace&quot;: &quot;&quot;        &#125;,        &quot;ArrayResName&quot;: &#123;            &quot;ScriptsName&quot;: &quot;TableResNameArrayResName&quot;,            &quot;ImportType&quot;: &quot;FieldType&quot;,            &quot;ExtraNamespace&quot;: &quot;&quot;        &#125;    &#125;,    &quot;Text.xlsx&quot;: &#123;        &quot;System&quot;: &#123;            &quot;ScriptsName&quot;: &quot;TableTextSystem&quot;,            &quot;ImportType&quot;: &quot;FieldType&quot;,            &quot;ExtraNamespace&quot;: &quot;&quot;        &#125;,        &quot;Network&quot;: &#123;            &quot;ScriptsName&quot;: &quot;TableTextNetwork&quot;,            &quot;ImportType&quot;: &quot;NoneType&quot;,            &quot;ExtraNamespace&quot;: &quot;&quot;        &#125;,        &quot;SystemFind&quot;: &#123;            &quot;ScriptsName&quot;: &quot;TableTextSystemFind&quot;,            &quot;ImportType&quot;: &quot;NoneType&quot;,            &quot;ExtraNamespace&quot;: &quot;&quot;        &#125;,        &quot;SystemArray&quot;: &#123;            &quot;ScriptsName&quot;: &quot;TableTextSystemArray&quot;,            &quot;ImportType&quot;: &quot;FieldType&quot;,            &quot;ExtraNamespace&quot;: &quot;&quot;        &#125;,        &quot;Rich&quot;: &#123;            &quot;ScriptsName&quot;: &quot;TableTextRich&quot;,            &quot;ImportType&quot;: &quot;NoneType&quot;,            &quot;ExtraNamespace&quot;: &quot;&quot;        &#125;    &#125;&#125;</code></pre><table><thead><tr><th align="left">key</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">ScriptsName</td><td align="left">表示生成的脚本的名字，也是字节文件的名字</td></tr><tr><td align="left">ImportType</td><td align="left">表示导入类型，NoneType代表不导入，其他类型下文会介绍</td></tr><tr><td align="left">ExtraNamespace</td><td align="left">表示生成脚本文件需要额外引用的命名空间</td></tr></tbody></table><h3 id="导入类型"><a href="#导入类型" class="headerlink" title="导入类型"></a>导入类型</h3><p>每个表格得每个页签都需要选择一个导入类型，没选择导入类型得页签代表不进行导入。导入类型决定了生成得表格数据得bytes文件和对应得脚本文件。  </p><p>类型总览：  </p><table><thead><tr><th align="left">导入类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">FieldType</td><td align="left">字段类型，用于配置游戏中动态替换的数据（注：只允许含有c的字段两列，一列是代码访问关键字，一列是值）</td></tr><tr><td align="left">FindType</td><td align="left">查找类型，用于配置游戏中的数据，根据关键字进行查找对应数据。</td></tr><tr><td align="left">LNGType</td><td align="left">语言类型，用于存放所有语言的表，这个表工具会自动生成，不需要手动创建</td></tr><tr><td align="left">NoExportLNGType</td><td align="left">无导入语言类型，用于游戏中固定的文字，非代码访问的，需要玩家自动创建并收集游戏中的文字（注：导表是不会生成脚本和bytes文件，只是为了收集游戏中语言到语言表里）</td></tr><tr><td align="left">CustomTypeField</td><td align="left">针对此类型表专门做的类型。(注：只允许含有c的字段三列，一列是代码访问关键字，一列是值得类型，一列是值)</td></tr></tbody></table><h4 id="FieldType"><a href="#FieldType" class="headerlink" title="FieldType"></a>FieldType</h4><p>字段的导入类型，用于根据字段的关键字来访问对应的值。此类型只允许有两列第一行包含’c’的列（第一行包含’c’代表要导入的数据），一列是代码访问关键字，一列是值。   </p><p>示例  </p><table><thead><tr><th align="left">c</th><th align="left">c</th></tr></thead><tbody><tr><td align="left">ID</td><td align="left">text</td></tr><tr><td align="left">int</td><td align="left">LNGRef</td></tr><tr><td align="left">名称</td><td align="left">内容</td></tr><tr><td align="left">NetworkUnreachable</td><td align="left">连接出错，请检查您的网络！</td></tr><tr><td align="left">GetServerListFailed</td><td align="left">拉取服务器列表失败，请稍后再试！</td></tr><tr><td align="left">TipsFormatInitParamFailed</td><td align="left">初始化参数请求失败，请检查您的网络！{0}</td></tr></tbody></table><p>在这个示例中，我们展示了一个普通表格的结构。每一列都有一个对应的数据类型和字段描述。<br>在第一行中，我们使用了字符c来表示是否要导入该列的数据。只有含有c的列才会被导入到数据文件中。<br>在第二行中，我们列出了每一列的字段名字。这些字段名字用于标识每一列所代表的数据。<br>在第三行中，我们指定了每一列数据的类型。这些类型可以是整数(int)、字符串(string)、长整型(long)等。<br>在第四行中，我们提供了对每一列所代表的字段的描述。这些描述可以帮助读者更好地理解每一列数据的含义。<br>接下来的行中，第一列表示的是我们要搜索的关键字，第二列就是关键字对应的数值</p><h4 id="FindType"><a href="#FindType" class="headerlink" title="FindType"></a>FindType</h4><p>查找的导入类型，用于根据数据的key查找对应的数据，此类型包含’c’的列至少是两列，一列是查找的时候的关键字，后面就是一系列的配置数据了。  </p><p>示例  </p><table><thead><tr><th align="left">c</th><th align="left">c</th><th align="left"></th><th align="left">c</th></tr></thead><tbody><tr><td align="left">ID</td><td align="left">Level</td><td align="left">des</td><td align="left">Exp</td></tr><tr><td align="left">int</td><td align="left">int</td><td align="left">string</td><td align="left">long</td></tr><tr><td align="left">关键key</td><td align="left">等级</td><td align="left">描述</td><td align="left">经验</td></tr><tr><td align="left">1</td><td align="left">1</td><td align="left">练气</td><td align="left">100</td></tr></tbody></table><p>在这个示例中，我们展示了一个普通表格的结构。每一列都有一个对应的数据类型和字段描述。<br>在第一行中，我们使用了字符c来表示是否要导入该列的数据。只有含有c的列才会被导入到数据文件中。<br>在第二行中，我们列出了每一列的字段名字。这些字段名字用于标识每一列所代表的数据。<br>在第三行中，我们指定了每一列数据的类型。这些类型可以是整数(int)、字符串(string)、长整型(long)等。<br>在第四行中，我们提供了对每一列所代表的字段的描述。这些描述可以帮助读者更好地理解每一列数据的含义。<br>接下来的行中，我们可以输入对应的数据。在这个示例中，我们输入了一条数据，其中ID为1，等级为1，描述为”练气”，经验为100。<br>以上是对普通表格的描述和示例。你可以根据需要调整表格的结构和内容。 </p><h4 id="LNGType"><a href="#LNGType" class="headerlink" title="LNGType"></a>LNGType</h4><p>这个是语言表类型，是导表工具自动生成的多语言表内的页签用的类型，这个类型的表在生成多语言的时候每页都会生成一个语言的字节文件，游戏可以在加载字节文件里做处理，只需要加载对应语言即可。  </p><p>示例  </p><table><thead><tr><th align="left">c</th><th align="left">c</th></tr></thead><tbody><tr><td align="left">ID</td><td align="left">text</td></tr><tr><td align="left">uint</td><td align="left">string</td></tr><tr><td align="left">编号</td><td align="left">文本</td></tr><tr><td align="left">1</td><td align="left">多语言1</td></tr><tr><td align="left">2</td><td align="left">多语言2</td></tr></tbody></table><p>这个语言表会自动生成，不需要创建，只需要添加要生成语言的配置即可</p><h4 id="NoExportLNGType"><a href="#NoExportLNGType" class="headerlink" title="NoExportLNGType"></a>NoExportLNGType</h4><p>这个类型的表也是语言类型表，这个表需要玩家自己收集游戏中不是动态变化的语言，类似Unity的prefab上的语言，导表的时候会把这些语言收集到多语言表中，并且不会生成脚本和字节文件，游戏中开发者只需要通过id访问语言表的字节文件即可。  </p><p>示例  </p><table><thead><tr><th align="left">c</th><th align="left">c</th></tr></thead><tbody><tr><td align="left">ID</td><td align="left">text</td></tr><tr><td align="left">uint</td><td align="left">LNGRef</td></tr><tr><td align="left">编号</td><td align="left">文本</td></tr><tr><td align="left">1</td><td align="left">多语言1</td></tr><tr><td align="left">2</td><td align="left">多语言2</td></tr></tbody></table><h4 id="CustomTypeField"><a href="#CustomTypeField" class="headerlink" title="CustomTypeField"></a>CustomTypeField</h4><p>自定义类型的字段导入类型，这个和字段导入类型差不多，但是要求有效列(第一行含’c’)的列必须是三列。  </p><p>示例  </p><table><thead><tr><th align="left">c</th><th align="left">c</th><th align="left">c</th></tr></thead><tbody><tr><td align="left">关键字</td><td align="left">类型</td><td align="left">值</td></tr><tr><td align="left">currencyFormatSplit</td><td align="left">nt[]</td><td align="left">5|7</td></tr><tr><td align="left">currencyNumSplit</td><td align="left">slc|int</td><td align="left">4|7</td></tr><tr><td align="left">currencyFormatSplitMap</td><td align="left">map|int</td><td align="left">string</td></tr><tr><td align="left">currencyFormatSplitDic</td><td align="left">Dictionary&lt;int,LNGRef&gt;</td><td align="left">1:你好|2:我不好</td></tr></tbody></table><p>在这个示例中，我们展示了一个多类型表格的结构。每一行都有一个对应的数据类型和字段描述。<br>在第一行中，我们使用了字符c来表示是否要导入该列的数据。只有含有c的列才会被导入到数据文件中。<br>在第二行中，我们提供了对每一列所代表的字段的描述。这些描述可以帮助读者更好地理解每一列数据的含义。<br>以上是对多类型表格的描述和示例。你可以根据需要调整表格的结构和内容。  </p><h2 id="导入命令"><a href="#导入命令" class="headerlink" title="导入命令"></a>导入命令</h2><p>后续版本会支持界面按钮调用，目前仅支持命令。(注：需要配置python环境)  </p><table><thead><tr><th align="left">命令</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">python Excel2Bytes.py -a</td><td align="left">表示要导入表格配置里的所有表格数据，并且会生成多语言</td></tr><tr><td align="left">python Excel2Bytes.py -e</td><td align="left">表示只导入NoExportLNGType类型的表，用于游戏中固定文本的多语言生成</td></tr><tr><td align="left">python Excel2Bytes.py -c [“Global.xlsx”,”Level.xlsx”]</td><td align="left">表示只导入我传入的第二个参数里面包含的表，只会生成中文的语言，其他多语言不会生成</td></tr></tbody></table><h2 id="支持的数据格式"><a href="#支持的数据格式" class="headerlink" title="支持的数据格式"></a>支持的数据格式</h2><table><thead><tr><th align="left">类型</th><th align="left">写法</th><th>描述</th></tr></thead><tbody><tr><td align="left">uint8</td><td align="left">1</td><td>基础类型</td></tr><tr><td align="left">byte</td><td align="left">1</td><td>基础类型</td></tr><tr><td align="left">int</td><td align="left">1</td><td>基础类型</td></tr><tr><td align="left">uint</td><td align="left">1</td><td>基础类型</td></tr><tr><td align="left">float</td><td align="left">1</td><td>基础类型</td></tr><tr><td align="left">double</td><td align="left">1</td><td>基础类型</td></tr><tr><td align="left">bool</td><td align="left">false、true或者空</td><td>基础类型</td></tr><tr><td align="left">long</td><td align="left">1</td><td>基础类型</td></tr><tr><td align="left">ulong</td><td align="left">1</td><td>基础类型</td></tr><tr><td align="left">int64</td><td align="left">1</td><td>基础类型</td></tr><tr><td align="left">uint</td><td align="left">64</td><td>基础类型</td></tr><tr><td align="left">short</td><td align="left">1</td><td>基础类型</td></tr><tr><td align="left">ushort</td><td align="left">1</td><td>基础类型</td></tr><tr><td align="left">string</td><td align="left">文本描述</td><td>基础类型</td></tr><tr><td align="left">基础类型[]</td><td align="left">1|1</td><td>3</td></tr><tr><td align="left">slc|基础类型</td><td align="left">1|1</td><td>3</td></tr><tr><td align="left">基础类型[][]</td><td align="left">1:2:3|1:2</td><td>1:2:3:4</td></tr><tr><td align="left">double_slc|基础类型</td><td align="left">1:2:3|1:2</td><td>1:2:3:4</td></tr><tr><td align="left">map|基础类型</td><td align="left">基础类型</td><td>1:2|3:4</td></tr><tr><td align="left">Dictionary&lt;基础类型，基础类型&gt;</td><td align="left">1:2|3:4</td><td>5:6</td></tr><tr><td align="left">LNGRef</td><td align="left">这段话多语言</td><td>字符串类型，会在多语言表生成，用于游戏语言切换功能</td></tr><tr><td align="left">ResName</td><td align="left">Icon.png</td><td>资源类型，这里会收集表里配置的所有资源，可根据自身需求来获取，Save目录会生成reslist.json，记录了所有的资源</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python杂文——CShap脚本生成辅助工具</title>
      <link href="/2023/09/17/Python%E6%9D%82%E6%96%87/Python%E6%9D%82%E6%96%87%E2%80%94%E2%80%94CShap%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/09/17/Python%E6%9D%82%E6%96%87/Python%E6%9D%82%E6%96%87%E2%80%94%E2%80%94CShap%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文介绍了一个用于辅助生成C#脚本的Python工具。该工具可以帮助用户快速生成C#脚本，并提供了一些常用的代码生成方法。  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>import osfrom PathUtil import ScriptsPathclass CSScriptBuilder(list):    BlackNum = 0    def Append(self, message):        if self.BlackNum &gt; 0:            self.append(&#39;\t&#39; * self.BlackNum + message)        else:            self.append(message)    def AppendEnter(self):        self.Append(&#39;\n&#39;)    def AppendLine(self, message):        if len(self) &gt; 0:            self.append(&#39;\n&#39;)        if self.BlackNum &gt; 0:            self.append(&#39;\t&#39; * self.BlackNum + message)        else:            self.append(message)    def AppendEmptyLine(self):        self.AppendLine(&#39;&#39;)    def AppendUsing(self, namespace):        self.AppendLine(f&#39;using &#123;namespace&#125;;&#39;)    def BeginNamespace(self, namespace):        self.AppendLine(f&#39;namespace &#123;namespace&#125;&#39;)        self.BeginBrace()    def EndNamespace(self):        self.EndBrace()    def BeginClass(self, className, modifier=&quot;public&quot;, superclass=None):        if superclass is not None:            self.AppendLine(f&#39;&#123;modifier&#125; class &#123;className&#125; : &#123;superclass&#125;&#39;)        else:            self.AppendLine(f&#39;&#123;modifier&#125; class &#123;className&#125;&#39;)        self.BeginBrace()    def EndClass(self):        self.EndBrace()    def BeginStruct(self, structName, modifier=&quot;public&quot;):        self.AppendLine(f&#39;&#123;modifier&#125; struct &#123;structName&#125;&#39;)        self.BeginBrace()    def EndStruct(self):        self.EndBrace()    def BeginEnum(self, enumName, modifier=&quot;public&quot;):        self.AppendLine(f&#39;&#123;modifier&#125; enum &#123;enumName&#125;&#39;)        self.BeginBrace()    def EndEnum(self):        self.EndBrace()    def AppendEnumField(self, fieldName, fieldValue):        self.AppendLine(f&#39;&#123;fieldName&#125; = &#123;fieldValue&#125;,&#39;)    def BeginInterface(self, interfaceName, modifier=&quot;public&quot;):        self.AppendLine(f&#39;&#123;modifier&#125; interface &#123;interfaceName&#125;&#39;)        self.BeginBrace()    def EndInterface(self):        self.EndBrace()    def AppendInterfaceMethod(self, methodName, returnType=&#39;void&#39;, parameters=&#39;&#39;):        self.AppendLine(f&#39;&#123;returnType&#125; &#123;methodName&#125;(&#123;parameters&#125;);&#39;)    def AppendField(self, propertyName, propertyType, modifier=&quot;public&quot;, init=&#39;&#39;):        if len(init) &gt; 0:            self.AppendLine(f&#39;&#123;modifier&#125; &#123;propertyType&#125; &#123;propertyName&#125; = &#123;init&#125;;&#39;)        else:            self.AppendLine(f&#39;&#123;modifier&#125; &#123;propertyType&#125; &#123;propertyName&#125;;&#39;)    def AppendProperty(self, propertyName, propertyType, field=None, modifier=&quot;public&quot;):        if field is not None:            self.AppendLine(f&#39;&#123;modifier&#125; &#123;propertyType&#125; &#123;propertyName&#125; =&gt; &#123;field&#125;;&#39;)        else:            self.AppendLine(f&#39;&#123;modifier&#125; &#123;propertyType&#125; &#123;propertyName&#125; &#123;&#123; get; set; &#125;&#125;&#39;)    def BeginProperty(self, propertyName, propertyType, modifier=&quot;public&quot;):        self.AppendLine(f&#39;&#123;modifier&#125; &#123;propertyType&#125; &#123;propertyName&#125;&#39;)        self.BeginBrace()    def EndProperty(self):        self.EndBrace()    def BeginMethod(self, methodName, modifier=&quot;public&quot;, returnType=&#39;void&#39;, parameters=&#39;&#39;):        self.AppendLine(f&#39;&#123;modifier&#125; &#123;returnType&#125; &#123;methodName&#125;(&#123;parameters&#125;)&#39;)        self.BeginBrace()    def BeginConstructionMethod(self, methodName, modifier=&quot;public&quot;, parameters=&#39;&#39;):        self.AppendLine(f&#39;&#123;modifier&#125; &#123;methodName&#125;(&#123;parameters&#125;)&#39;)        self.BeginBrace()    def EndMethod(self):        self.EndBrace()    def BeginIf(self, condition):        self.AppendLine(f&#39;if (&#123;condition&#125;)&#39;)        self.BeginBrace()    def BeginElif(self, condition):        self.AppendLine(f&#39;else if (&#123;condition&#125;)&#39;)        self.BeginBrace()    def EndIf(self):        self.EndBrace()    def BeginWhile(self, condition):        self.AppendLine(f&#39;while (&#123;condition&#125;)&#39;)        self.BeginBrace()    def EndWhile(self):        self.EndBrace()    def BeginTry(self):        self.AppendLine(&#39;try&#39;)        self.BeginBrace()    def EndTry(self):        self.EndBrace()    def BeginCatch(self, exceptionType):        self.AppendLine(f&#39;catch (&#123;exceptionType&#125;)&#39;)        self.BeginBrace()    def BeginForEach(self, name, collection, singleType=&#39;var&#39;):        self.AppendLine(f&#39;foreach (&#123;singleType&#125; &#123;name&#125; in &#123;collection&#125;)&#39;)        self.BeginBrace()    def EndForEach(self):        self.EndBrace()    def BeginFor(self, condition):        self.AppendLine(f&#39;for (&#123;condition&#125;)&#39;)        self.BeginBrace()    def EndFor(self):        self.EndBrace()    def BeginForRange(self, name, start, end):        self.AppendLine(f&#39;for (int &#123;name&#125; = &#123;start&#125;; &#123;name&#125; &lt; &#123;end&#125;; &#123;name&#125;++)&#39;)        self.BeginBrace()    def EndForRange(self):        self.EndBrace()    def EndCatch(self):        self.EndBrace()    def BeginBlank(self):        self.BlackNum += 1    def EndBlank(self):        self.BlackNum -= 1    def BeginBrace(self):        self.AppendLine(&#39;&#123;&#39;)        self.BeginBlank()    def EndBrace(self):        self.EndBlank()        self.AppendLine(&#39;&#125;&#39;)    def BeginRegion(self, regionName):        self.AppendLine(f&#39;#region &#123;regionName&#125;&#39;)        self.AppendEmptyLine()    def EndRegion(self):        self.AppendEmptyLine()        self.AppendLine(&#39;#endregion&#39;)        self.AppendEmptyLine()    def ToString(self):        return &#39;&#39;.join(self)    def GenerateScript(self, fileName, isDefPath=True):        fileName = fileName.replace(&#39;.cs&#39;, &#39;&#39;)        if isDefPath:            fileName = os.path.join(ScriptsPath, fileName)        with open(f&#39;&#123;fileName&#125;.cs&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:            f.write(self.ToString())</code></pre><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><pre><code>def CreateTableManagerCs():    script = CSScriptBuilder()    script.AppendUsing(&#39;System.Collections.Generic&#39;)    script.AppendUsing(&#39;UnityEngine&#39;)    script.BeginNamespace(TableLoadAssembly)    script.BeginInterface(&#39;ITable&#39;, &#39;public&#39;)    script.AppendInterfaceMethod(&#39;Dispose&#39;)    script.EndInterface()    script.AppendEmptyLine()    script.BeginClass(&#39;TableManager&#39;, &#39;public static&#39;)    script.AppendField(&#39;s_Inited&#39;, &#39;bool&#39;, &#39;private static&#39;)    script.AppendField(&#39;s_Cached&#39;, &#39;List&lt;ITable&gt;&#39;, &#39;private static&#39;, &#39;new List&lt;ITable&gt;()&#39;)    # 添加方法    script.AppendEmptyLine()    script.BeginMethod(&quot;Add&quot;, parameters=&quot;ITable table&quot;)    script.AppendLine(&quot;Debug.Assert(s_Inited, \&quot;add but TableManager not init \&quot;);&quot;)    script.AppendLine(&quot;s_Cached.Add(table);&quot;)    script.EndMethod()    script.AppendEmptyLine()    script.BeginMethod(&quot;Remove&quot;, parameters=&quot;ITable table&quot;)    script.AppendLine(&quot;Debug.Assert(s_Inited, \&quot;remove but TableManager not init\&quot;);&quot;)    script.AppendLine(&quot;if (s_Cached.Remove(table))&quot;)    script.BeginBrace()    script.AppendLine(&quot;table.Dispose();&quot;)    script.EndBrace()    script.EndMethod()    script.AppendEmptyLine()    script.BeginMethod(&quot;Init&quot;)    script.AppendLine(&quot;Debug.Assert(!s_Inited, \&quot;TableManager already init\&quot;);&quot;)    script.AppendLine(&quot;s_Inited = true;&quot;)    script.EndMethod()    script.AppendEmptyLine()    script.BeginMethod(&quot;UnInit&quot;)    script.AppendLine(&quot;Debug.Assert(s_Inited, \&quot;TableManager not init\&quot;);&quot;)    script.AppendLine(&quot;s_Inited = false;&quot;)    script.AppendLine(&quot;foreach (var table in s_Cached)&quot;)    script.BeginBrace()    script.AppendLine(&quot;table.Dispose();&quot;)    script.EndBrace()    script.AppendLine(&quot;s_Cached.Clear();&quot;)    script.EndMethod()    script.EndClass()    script.EndNamespace()    script.GenerateScript(os.path.join(ScriptsPath, &#39;TableManager&#39;))</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上是本文介绍的C#脚本生成辅助工具的代码示例。工具的核心是一个名为CSScriptBuilder的类，它继承自list，并提供了一系列用于生成C#脚本的方法。</p><p>通过使用这个工具，用户可以更加方便地生成C#脚本，提高开发效率。</p><p>希望本文对您理解这个工具的用途和使用方法有所帮助。如果您有任何问题或建议，欢迎留言讨论。</p>]]></content>
      
      
      <categories>
          
          <category> Python杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人作品展示</title>
      <link href="/2023/09/04/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E4%BD%9C%E5%93%81%E5%B1%95%E7%A4%BA/"/>
      <url>/2023/09/04/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E4%BD%9C%E5%93%81%E5%B1%95%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity参与项目"><a href="#Unity参与项目" class="headerlink" title="Unity参与项目"></a>Unity参与项目</h1><h2 id="Game-Of-Honor"><a href="#Game-Of-Honor" class="headerlink" title="Game Of Honor"></a>Game Of Honor</h2><details>    <summary> 点击展开 </summary> <p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1694956179652-2023-9-1721:09:40.png" alt="1694956179652-2023-9-1721:09:40.png">  </p></details> <h1 id="Unity工具"><a href="#Unity工具" class="headerlink" title="Unity工具"></a>Unity工具</h1><h2 id="布NPC和怪物编辑器"><a href="#布NPC和怪物编辑器" class="headerlink" title="布NPC和怪物编辑器"></a>布NPC和怪物编辑器</h2><details>    <summary> 点击展开 </summary> <p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/20230917_210529-2023-9-1721:06:52.gif" alt="20230917_210529-2023-9-1721:06:52.gif">  </p></details> <h2 id="UI动画编辑器"><a href="#UI动画编辑器" class="headerlink" title="UI动画编辑器"></a>UI动画编辑器</h2><details>    <summary> 点击展开 </summary> <p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/20230917_211925-2023-9-1721:20:32.gif" alt="20230917_211925-2023-9-1721:20:32.gif">  </p></details> <h1 id="Python工具"><a href="#Python工具" class="headerlink" title="Python工具"></a>Python工具</h1><p><a href="https://github.com/LianBai/PyTools.git"><strong>仓库地址</strong></a>  </p><h2 id="C-工程配置导表工具"><a href="#C-工程配置导表工具" class="headerlink" title="C#工程配置导表工具"></a>C#工程配置导表工具</h2><p><a href="https://github.com/LBGTeam/Excel2Bytes"><strong>Excel2Bytes仓库</strong></a></p><h2 id="项目工具"><a href="#项目工具" class="headerlink" title="项目工具"></a>项目工具</h2><details>    <summary> 点击展开 </summary> <h3 id="演示视频"><a href="#演示视频" class="headerlink" title="演示视频"></a>演示视频</h3><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/20230904_100721-2023-9-410:36:14.gif" alt="20230904_100721-2023-9-410:36:14.gif"></p><h3 id="工具截图"><a href="#工具截图" class="headerlink" title="工具截图"></a>工具截图</h3><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1693795113797-2023-9-410:38:34.png" alt="1693795113797-2023-9-410:38:34.png"><br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1693795142194-2023-9-410:39:03.png" alt="1693795142194-2023-9-410:39:03.png"><br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1693795157340-2023-9-410:39:18.png" alt="1693795157340-2023-9-410:39:18.png"><br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1693795175142-2023-9-410:39:35.png" alt="1693795175142-2023-9-410:39:35.png"><br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1693795225733-2023-9-410:40:26.png" alt="1693795225733-2023-9-410:40:26.png">  </p></details>  <h2 id="博客工具"><a href="#博客工具" class="headerlink" title="博客工具"></a>博客工具</h2><details>    <summary> 点击展开 </summary> <p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1693795268866-2023-9-410:41:09.png" alt="1693795268866-2023-9-410:41:09.png">  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1693795304153-2023-9-410:41:45.png" alt="1693795304153-2023-9-410:41:45.png">  </p></details> ]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——Editor的Tree</title>
      <link href="/2023/09/02/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Editor%E7%9A%84Tree/"/>
      <url>/2023/09/02/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Editor%E7%9A%84Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文介绍了一种用于编辑器开发过程中树形结构数据进行渲染的辅助脚本。</p><h1 id="TreeElementGUI"><a href="#TreeElementGUI" class="headerlink" title="TreeElementGUI"></a>TreeElementGUI</h1><p>TreeElementGUI是树形结构元素渲染的基类，包含了节点深度、父节点、子节点、节点名字、节点ID等属性，并且提供了无参构造函数和有参构造函数。 </p><details>    <summary> TreeElementGUI </summary>  <pre><code>/// &lt;summary&gt;/// 树结构的元素/// &lt;/summary&gt;public abstract class TreeElementGUI&#123;    private int m_ID;    private string m_Name;    private int m_Depth;    [NonSerialized] private TreeElementGUI m_Parent;    [NonSerialized] private List&lt;TreeElementGUI&gt; m_Children;    /// &lt;summary&gt;    /// 深度    /// &lt;/summary&gt;    public int Depth    &#123;        get =&gt; m_Depth;        set =&gt; m_Depth = value;    &#125;    /// &lt;summary&gt;    /// 父节点    /// &lt;/summary&gt;    public TreeElementGUI Parent    &#123;        get =&gt; m_Parent;        set =&gt; m_Parent = value;    &#125;    /// &lt;summary&gt;    /// 子节点    /// &lt;/summary&gt;    public List&lt;TreeElementGUI&gt; Children    &#123;        get =&gt; m_Children;        set =&gt; m_Children = value;    &#125;        /// &lt;summary&gt;    /// 是否有子节点    /// &lt;/summary&gt;    public bool HasChildren =&gt; m_Children != null &amp;&amp; m_Children.Count &gt; 0;    /// &lt;summary&gt;    /// 节点名字    /// &lt;/summary&gt;    public string Name    &#123;        get =&gt; m_Name;        set =&gt; m_Name = value;    &#125;    /// &lt;summary&gt;    /// 节点ID    /// &lt;/summary&gt;    public int Id    &#123;        get =&gt; m_ID;        set =&gt; m_ID = value;    &#125;    /// &lt;summary&gt;    /// 无参构造函数    /// &lt;/summary&gt;    protected TreeElementGUI() :this(-1, -1, &quot;&quot;)    &#123;            &#125;    /// &lt;summary&gt;    /// 有参构造函数    /// &lt;/summary&gt;    /// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;depth&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt;    protected TreeElementGUI(int id, int depth, string name)    &#123;        m_Name = name;        m_ID = id;        m_Depth = depth;    &#125;    public abstract void OnGUI(Rect rect, int columnIndex);    public abstract bool IsMatchSearch(string search);&#125;</code></pre></details><h1 id="TreeViewItemGUI"><a href="#TreeViewItemGUI" class="headerlink" title="TreeViewItemGUI"></a>TreeViewItemGUI<T></T></h1><p>TreeViewItemGUI<T>是节点元素显示的类，继承自TreeViewItem，并且包含了一个泛型参数T，其中T必须是TreeElementGUI的子类。TreeViewItemGUI<T>包含了一个Data属性，用于获取节点元素的数据，同时提供了OnGUI和IsMatchSearch方法，用于在UI上绘制节点元素和进行搜索匹配。  </T></T></p><details>    <summary> TreeViewItemGUI<T> </T></summary>   <pre><code>/// &lt;summary&gt;/// 树结构编辑器显示/// &lt;/summary&gt;/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;public class TreeViewItemGUI&lt;T&gt; : TreeViewItem where T : TreeElementGUI&#123;    private readonly T m_Data;    public T Data =&gt; m_Data;    public TreeViewItemGUI(int id, int depth, string displayName, T data) : base(id, depth, displayName)    &#123;        m_Data = data;    &#125;    public void OnGUI(Rect rect, int columnIndex)    &#123;        m_Data.OnGUI(rect, columnIndex);    &#125;    public bool IsMatchSearch(string search)    &#123;        return m_Data.IsMatchSearch(search);    &#125;&#125;</code></pre></details><h1 id="TreeGUIUtility"><a href="#TreeGUIUtility" class="headerlink" title="TreeGUIUtility"></a>TreeGUIUtility</h1><p>TreeGUIUtility是一个用于编辑器开发过程中树形结构数据进行渲染的辅助脚本。该脚本包含了一些常用的方法，可以帮助开发者处理树形结构数据。  </p><p>其中，TreeToList<T>方法可以将树形结构数据转换为列表形式，Find<T>方法可以在树形结构数据中查找符合条件的节点元素，ListToTree<T>方法可以将列表形式的数据转换为树形结构数据，ValidateDepthValues<T>方法可以检查列表中的深度值是否合法，UpdateDepthValues<T>方法可以更新树形结构数据中的深度值，FindCommonAncestorsWithinList<T>方法可以查找列表中共同的祖先节点。   </T></T></T></T></T></T></p><details>    <summary> TreeGUIUtility<T> </T></summary>  <pre><code>public static class TreeGUIUtility&#123;    public static void TreeToList&lt;T&gt;(T root, IList&lt;T&gt; result) where T : TreeElementGUI    &#123;        if (result == null)            throw new NullReferenceException(&quot;The input &#39;IList&lt;T&gt; result&#39; list is null&quot;);        result.Clear();        var stack = new Stack&lt;T&gt;();        stack.Push(root);        while (stack.Count &gt; 0)        &#123;            var current = stack.Pop();            result.Add(current);            if (current.Children != null &amp;&amp; current.Children.Count &gt; 0)            &#123;                for (var i = current.Children.Count - 1; i &gt;= 0; i--)                &#123;                    stack.Push((T)current.Children[i]);                &#125;            &#125;        &#125;    &#125;        public static T Find&lt;T&gt;(T root, Func&lt;T, bool&gt; comparer) where T : TreeElementGUI    &#123;        var stack = new Stack&lt;T&gt;();        stack.Push(root);        while (stack.Count &gt; 0)        &#123;            var current = stack.Pop();            if(root != current &amp;&amp; comparer(current))            &#123;                return current;            &#125;            if (current.Children != null &amp;&amp; current.Children.Count &gt; 0)            &#123;                for (var i = current.Children.Count - 1; i &gt;= 0; i--)                &#123;                    stack.Push((T)current.Children[i]);                &#125;            &#125;        &#125;        return null;    &#125;    /// &lt;summary&gt;    /// List转成树结构    /// &lt;/summary&gt;    /// &lt;param name=&quot;list&quot;&gt;&lt;/param&gt;    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static T ListToTree&lt;T&gt;(IList&lt;T&gt; list) where T : TreeElementGUI    &#123;        // 验证深度的值        ValidateDepthValues(list);        // 清理状态        foreach (var element in list)        &#123;            element.Parent = null;            element.Children = null;        &#125;        // 设置子节点和父节点        for (var parentIndex = 0; parentIndex &lt; list.Count; parentIndex++)        &#123;            var parent = list[parentIndex];            var alreadyHasValidChildren = parent.Children != null;            if (alreadyHasValidChildren)                continue;            var parentDepth = parent.Depth;            var childCount = 0;            // Count children based depth value, we are looking at children until it&#39;s the same depth as this object            for (var i = parentIndex + 1; i &lt; list.Count; i++)            &#123;                if (list[i].Depth == parentDepth + 1)                    childCount++;                if (list[i].Depth &lt;= parentDepth)                    break;            &#125;            // Fill child array            List&lt;TreeElementGUI&gt; childList = null;            if (childCount != 0)            &#123;                childList = new List&lt;TreeElementGUI&gt;(childCount); // Allocate once                childCount = 0;                for (var i = parentIndex + 1; i &lt; list.Count; i++)                &#123;                    if (list[i].Depth == parentDepth + 1)                    &#123;                        list[i].Parent = parent;                        childList.Add(list[i]);                        childCount++;                    &#125;                    if (list[i].Depth &lt;= parentDepth)                        break;                &#125;            &#125;            parent.Children = childList;        &#125;        return list[0];    &#125;    /// &lt;summary&gt;    /// 检查List的深度值    /// &lt;/summary&gt;    /// &lt;param name=&quot;list&quot;&gt;&lt;/param&gt;    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;    /// &lt;exception cref=&quot;ArgumentException&quot;&gt;&lt;/exception&gt;    public static void ValidateDepthValues&lt;T&gt;(IList&lt;T&gt; list) where T : TreeElementGUI    &#123;        if (list.Count == 0)            throw new ArgumentException(&quot;list should have items, count is 0, check before calling ValidateDepthValues&quot;, nameof(list));        if (list[0].Depth != -1)            throw new ArgumentException(&quot;list item at index 0 should have a depth of -1 (since this should be the hidden root of the tree). Depth is: &quot; + list[0].Depth, nameof(list));        for (var i = 0; i &lt; list.Count - 1; i++)        &#123;            var depth = list[i].Depth;            var nextDepth = list[i + 1].Depth;            if (nextDepth &gt; depth &amp;&amp; nextDepth - depth &gt; 1)                throw new ArgumentException(string.Format(&quot;Invalid depth info in input list. Depth cannot increase more than 1 per row. Index &#123;0&#125; has depth &#123;1&#125; while index &#123;2&#125; has depth &#123;3&#125;&quot;, i, depth, i + 1, nextDepth));        &#125;        for (var i = 1; i &lt; list.Count; ++i)            if (list[i].Depth &lt; 0)                throw new ArgumentException(&quot;Invalid depth value for item at index &quot; + i + &quot;. Only the first item (the root) should have depth below 0.&quot;);        if (list.Count &gt; 1 &amp;&amp; list[1].Depth != 0)            throw new ArgumentException(&quot;Input list item at index 1 is assumed to have a depth of 0&quot;, nameof(list));    &#125;    /// &lt;summary&gt;    /// 更新深度值    /// &lt;/summary&gt;    /// &lt;param name=&quot;root&quot;&gt;&lt;/param&gt;    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;    /// &lt;exception cref=&quot;ArgumentNullException&quot;&gt;&lt;/exception&gt;    public static void UpdateDepthValues&lt;T&gt;(T root) where T : TreeElementGUI    &#123;        if (root == null)            throw new ArgumentNullException(nameof(root), &quot;The root is null&quot;);        if (!root.HasChildren)            return;        var stack = new Stack&lt;TreeElementGUI&gt;();        stack.Push(root);        while (stack.Count &gt; 0)        &#123;            var current = stack.Pop();            if (current.Children != null)            &#123;                foreach (var child in current.Children)                &#123;                    child.Depth = current.Depth + 1;                    stack.Push(child);                &#125;            &#125;        &#125;    &#125;    /// &lt;summary&gt;    /// 判断是否是子节点    /// &lt;/summary&gt;    /// &lt;param name=&quot;child&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;elements&quot;&gt;&lt;/param&gt;    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;    /// &lt;returns&gt;&lt;/returns&gt;    static bool IsChildOf&lt;T&gt;(T child, IList&lt;T&gt; elements) where T : TreeElementGUI    &#123;        while (child != null)        &#123;            child = (T)child.Parent;            if (elements.Contains(child))                return true;        &#125;        return false;    &#125;    /// &lt;summary&gt;    /// 查找共同的祖先节点    /// &lt;/summary&gt;    /// &lt;param name=&quot;elements&quot;&gt;&lt;/param&gt;    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static IList&lt;T&gt; FindCommonAncestorsWithinList&lt;T&gt;(IList&lt;T&gt; elements) where T : TreeElementGUI    &#123;        if (elements.Count == 1)            return new List&lt;T&gt;(elements);        var result = new List&lt;T&gt;(elements);        result.RemoveAll(g =&gt; IsChildOf(g, elements));        return result;    &#125;&#125;</code></pre></details><h1 id="TreeGUIModel"><a href="#TreeGUIModel" class="headerlink" title="TreeGUIModel"></a>TreeGUIModel<T></T></h1><p>TreeGUIModel<T>是一个用于管理树形结构数据的类，包含了增加、移除、移动、清空、更新等方法，可以帮助开发者更方便地处理树形结构数据。  </T></p><details>    <summary> TreeGUIModel<T> </T></summary>  <pre><code>public class TreeGUIModel&lt;T&gt; where T : TreeElementGUI, new()&#123;    private T m_Root;    private int m_MaxID;    private bool m_IsDirty;    public T Root =&gt; m_Root;    public event Action&lt;T&gt; added;    public event Action&lt;T&gt; removed;    public int Count =&gt; m_Root.Children.Count;    public bool IsDirty =&gt; m_IsDirty;    public TreeGUIModel()    &#123;        m_Root = new T        &#123;            Id = GenerateUniqueID(), Depth = -1, Name = $&quot;&#123;typeof(T).Name&#125; - Root&quot;,            Children = new List&lt;TreeElementGUI&gt;()        &#125;;        m_IsDirty = true;    &#125;    /// &lt;summary&gt;    /// 根据id查找元素    /// &lt;/summary&gt;    /// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public T Find(int id)    &#123;        return (T)m_Root.Children.FirstOrDefault(element =&gt; element.Id == id);    &#125;    /// &lt;summary&gt;    /// 自动生成唯一ID    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public int GenerateUniqueID()    &#123;        return ++m_MaxID;    &#125;    /// &lt;summary&gt;    /// 获得所有的子节点    /// &lt;/summary&gt;    /// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public IList&lt;int&gt; GetAncestors(int id)    &#123;        var parents = new List&lt;int&gt;();        var item = Find(id);        if (item != null)        &#123;            while (item.Parent != null)            &#123;                parents.Add(item.Parent.Id);                item = (T)item.Parent;            &#125;        &#125;        return parents;    &#125;    /// &lt;summary&gt;    /// 获得有子节点的所有子节点    /// &lt;/summary&gt;    /// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public IList&lt;int&gt; GetDescendantsThatHaveChildren(int id)    &#123;        var searchFromThis = Find(id);        return searchFromThis != null ? GetParentsBelowStackBased(searchFromThis) : new List&lt;int&gt;();    &#125;    /// &lt;summary&gt;    /// 获得基于栈的所有子节点    /// &lt;/summary&gt;    /// &lt;param name=&quot;searchFromThis&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    private IList&lt;int&gt; GetParentsBelowStackBased(TreeElementGUI searchFromThis)    &#123;        var stack = new Stack&lt;TreeElementGUI&gt;();        stack.Push(searchFromThis);        var parentsBelow = new List&lt;int&gt;();        while (stack.Count &gt; 0)        &#123;            var current = stack.Pop();            if (current.HasChildren)            &#123;                parentsBelow.Add(current.Id);                foreach (var T in current.Children)                &#123;                    stack.Push(T);                &#125;            &#125;        &#125;        return parentsBelow;    &#125;    /// &lt;summary&gt;    /// 移除元素    /// &lt;/summary&gt;    /// &lt;param name=&quot;elementID&quot;&gt;&lt;/param&gt;    public void RemoveElements(int elementID)    &#123;        var elements = m_Root.Children.Where(element =&gt; element.Id == elementID).Cast&lt;T&gt;().ToArray();        RemoveElements(elements);    &#125;    /// &lt;summary&gt;    /// 移除元素    /// &lt;/summary&gt;    /// &lt;param name=&quot;elementIDs&quot;&gt;&lt;/param&gt;    public void RemoveElements(IList&lt;int&gt; elementIDs)    &#123;        var elements = m_Root.Children.Where(element =&gt; elementIDs.Contains(element.Id)).Cast&lt;T&gt;().ToArray();        RemoveElements(elements);    &#125;    /// &lt;summary&gt;    /// 移除元素    /// &lt;/summary&gt;    /// &lt;param name=&quot;elements&quot;&gt;&lt;/param&gt;    public void RemoveElements(IList&lt;T&gt; elements)    &#123;        var commonAncestors = TreeGUIUtility.FindCommonAncestorsWithinList(elements);        foreach (var element in commonAncestors)        &#123;            element.Parent.Children.Remove(element);            element.Parent = null;            removed?.Invoke(element);        &#125;        SetDirty();    &#125;    /// &lt;summary&gt;    /// 增加元素    /// &lt;/summary&gt;    /// &lt;param name=&quot;elements&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;parent&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;insertPosition&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;isNew&quot;&gt;&lt;/param&gt;    /// &lt;exception cref=&quot;ArgumentNullException&quot;&gt;&lt;/exception&gt;    public void AddElements(IList&lt;T&gt; elements, TreeElementGUI parent, int insertPosition, bool isNew = false)    &#123;        if (elements == null)            throw new ArgumentNullException(nameof(elements), &quot;elements is null&quot;);        if (elements.Count == 0)            throw new ArgumentNullException(nameof(elements), &quot;elements Count is 0: nothing to add&quot;);        if (parent == null)            throw new ArgumentNullException(nameof(parent), &quot;parent is null&quot;);        parent.Children ??= new List&lt;TreeElementGUI&gt;();        parent.Children.InsertRange(insertPosition, elements);        foreach (var element in elements)        &#123;            element.Parent = parent;            element.Depth = parent.Depth + 1;            TreeGUIUtility.UpdateDepthValues(element);            if(isNew)            &#123;                added?.Invoke(element);            &#125;        &#125;        SetDirty();    &#125;    /// &lt;summary&gt;    /// 增加元素    /// &lt;/summary&gt;    /// &lt;param name=&quot;root&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;isNew&quot;&gt;&lt;/param&gt;    public void AddElement(T root, bool isNew = false)    &#123;        root.Id = GenerateUniqueID();        root.Depth = -1;        root.Parent = m_Root;        m_Root.Children.Add(root);        if(isNew)        &#123;            added?.Invoke(root);        &#125;        SetDirty();    &#125;    /// &lt;summary&gt;    /// 增加元素    /// &lt;/summary&gt;    /// &lt;param name=&quot;element&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;parent&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;insertPosition&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;isNew&quot;&gt;&lt;/param&gt;    public void AddElement(T element, T parent, int insertPosition, bool isNew = false)    &#123;        parent.Children ??= new List&lt;TreeElementGUI&gt;();        parent.Children.Insert(insertPosition, element);        element.Parent = parent;        TreeGUIUtility.UpdateDepthValues(parent);        if (isNew)        &#123;            added?.Invoke(element);        &#125;        SetDirty();    &#125;    /// &lt;summary&gt;    /// 移动元素    /// &lt;/summary&gt;    /// &lt;param name=&quot;parentElement&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;insertionIndex&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;elements&quot;&gt;&lt;/param&gt;    /// &lt;exception cref=&quot;ArgumentException&quot;&gt;&lt;/exception&gt;    public void MoveElements(TreeElementGUI parentElement, int insertionIndex, List&lt;TreeElementGUI&gt; elements)    &#123;        if (insertionIndex &lt; 0)            throw new ArgumentException(&quot;Invalid input: insertionIndex is -1, client needs to decide what index elements should be reparented at&quot;);        // Invalid reparenting input        if (parentElement == null)            return;        // We are moving items so we adjust the insertion index to accomodate that any items above the insertion index is removed before inserting        if (insertionIndex &gt; 0)            insertionIndex -= parentElement.Children.GetRange(0, insertionIndex).Count(elements.Contains);        // Remove draggedItems from their parents        foreach (var draggedItem in elements)        &#123;            draggedItem.Parent.Children.Remove(draggedItem);    // remove from old parent            draggedItem.Parent = parentElement;                 // set new parent        &#125;        parentElement.Children ??= new List&lt;TreeElementGUI&gt;();        // Insert dragged items under new parent        parentElement.Children.InsertRange(insertionIndex, elements);        TreeGUIUtility.UpdateDepthValues(Root);        SetDirty();    &#125;    /// &lt;summary&gt;    /// 标记为脏    /// &lt;/summary&gt;    private void SetDirty()    &#123;        m_IsDirty = true;    &#125;    /// &lt;summary&gt;    /// 清理    /// &lt;/summary&gt;    public void Clear()    &#123;        m_Root.Children.Clear();        SetDirty();    &#125;    /// &lt;summary&gt;    /// 更新    /// &lt;/summary&gt;    internal void Update()    &#123;        m_IsDirty = true;    &#125;&#125;</code></pre></details><h1 id="TreeViewWithGUIModel"><a href="#TreeViewWithGUIModel" class="headerlink" title="TreeViewWithGUIModel"></a>TreeViewWithGUIModel<T></T></h1><p>TreeViewWithGUIModel<T>是一个抽象类，继承自TreeView，用于在编辑器中渲染树形结构数据。该类包含了一些常用的方法，可以帮助开发者处理树形结构数据。  </T></p><p>该类还包含了一些属性，用于控制树形结构数据的外观和行高等。  </p><p>TreeViewWithGUIModel<T>类的子类可以通过实现抽象方法来自定义树形结构数据的渲染和行为。  </T></p><details>    <summary> TreeViewWithGUIModel<T> </T></summary>  <pre><code>public abstract class TreeViewWithGUIModel&lt;T&gt; : TreeView where  T : TreeElementGUI, new()&#123;    protected TreeGUIModel&lt;T&gt; m_TreeModel;    private readonly List&lt;TreeViewItem&gt; m_Rows = new List&lt;TreeViewItem&gt;(100);    public bool ShowAlternatingRowBackgrounds    &#123;        get =&gt; showAlternatingRowBackgrounds;        set =&gt; showAlternatingRowBackgrounds = value;    &#125;    public bool ShowBorder    &#123;        get =&gt; showBorder;        set =&gt; showBorder = value;    &#125;    public float RowHeight    &#123;        get =&gt; rowHeight;        set =&gt; rowHeight = value;    &#125;    protected TreeViewWithGUIModel(TreeViewState state, TreeGUIModel&lt;T&gt; model) : base(state)    &#123;        Init(model);    &#125;    protected TreeViewWithGUIModel(TreeViewState state, MultiColumnHeader multiColumnHeader, TreeGUIModel&lt;T&gt; model) : base(state, multiColumnHeader)    &#123;        Init(model);        multiColumnHeader.sortingChanged += OnSortingChanged;    &#125;    private void Init(TreeGUIModel&lt;T&gt; model)    &#123;        m_TreeModel = model;    &#125;    private void OnSortingChanged(MultiColumnHeader _multiColumnHeader)    &#123;        SortIfNeeded(rootItem, m_Rows);    &#125;    private void SortIfNeeded(TreeViewItem root, List&lt;TreeViewItem&gt; rows)    &#123;        if( null == multiColumnHeader) return;        if ( rows.Count &lt;= 1)            return;        if (multiColumnHeader.sortedColumnIndex == -1)        &#123;            return; // No column to sort for (just use the order the data are in)        &#125;        // Sort the roots of the existing tree items        rootItem.children = SortByMultipleColumns(rows);        TreeToList(root, rows);        Repaint();    &#125;    public static void TreeToList(TreeViewItem root, IList&lt;TreeViewItem&gt; result)    &#123;        if (root == null)            throw new NullReferenceException(&quot;root&quot;);        if (result == null)            throw new NullReferenceException(&quot;result&quot;);        result.Clear();        if (root.children == null)            return;        var stack = new Stack&lt;TreeViewItem&gt;();        for (var i = root.children.Count - 1; i &gt;= 0; i--)            stack.Push(root.children[i]);        while (stack.Count &gt; 0)        &#123;            var current = stack.Pop();            result.Add(current);            if (current.hasChildren &amp;&amp; current.children[0] != null)            &#123;                for (var i = current.children.Count - 1; i &gt;= 0; i--)                &#123;                    stack.Push(current.children[i]);                &#125;            &#125;        &#125;    &#125;    protected override TreeViewItem BuildRoot()    &#123;        return null == m_TreeModel.Root            ? new TreeViewItemGUI&lt;T&gt;(0, -1, &quot;Root&quot;, null)            : new TreeViewItemGUI&lt;T&gt;(m_TreeModel.Root.Id, -1, m_TreeModel.Root.Name, m_TreeModel.Root);    &#125;    protected override bool DoesItemMatchSearch(TreeViewItem item, string search)    &#123;        var target = (TreeViewItemGUI&lt;T&gt;)item;        return target.IsMatchSearch(search);    &#125;    protected override void RowGUI(RowGUIArgs args)    &#123;        var item = (TreeViewItemGUI&lt;T&gt;) args.item;        if (null == multiColumnHeader)        &#123;            item.OnGUI(args.rowRect, 0);        &#125;        else        &#123;            var columns = args.GetNumVisibleColumns();            for (var i = 0; i &lt; columns; i++)            &#123;                var rt = args.GetCellRect(i);                CenterRectUsingSingleLineHeight(ref rt);                item.OnGUI(rt, args.GetColumn(i));            &#125;        &#125;    &#125;    protected override IList&lt;TreeViewItem&gt; BuildRows(TreeViewItem root)    &#123;        m_Rows.Clear();        if (m_TreeModel.Root == null)        &#123;            return m_Rows;        &#125;        if (hasSearch)        &#123;            Search(m_TreeModel.Root, searchString, m_Rows);        &#125;        else if (m_TreeModel.Root.HasChildren)        &#123;            AddChildrenRecursive(root, m_TreeModel.Root, 0, m_Rows);        &#125;        SortIfNeeded(root, m_Rows);        return m_Rows;    &#125;    private void AddChildrenRecursive(TreeViewItem root, T parent, int depth, IList&lt;TreeViewItem&gt; newRows)    &#123;        foreach (var treeElement in parent.Children)        &#123;            var child = (T) treeElement;            var item = new TreeViewItemGUI&lt;T&gt;(child.Id, depth, child.Name, child);            newRows.Add(item);            root.AddChild(item);            if (child.HasChildren)            &#123;                if (IsExpanded(child.Id))                &#123;                    AddChildrenRecursive(item, child, depth + 1, newRows);                &#125;                else                &#123;                    item.children = CreateChildListForCollapsedParent();                &#125;            &#125;        &#125;    &#125;    private void Search(T searchFromThis, string search, List&lt;TreeViewItem&gt; result)    &#123;        if (string.IsNullOrEmpty(search))            throw new ArgumentException(&quot;Invalid search: cannot be null or empty&quot;, nameof(search));        var stack = new Stack&lt;T&gt;();        foreach (var element in searchFromThis.Children)            stack.Push((T)element);        while (stack.Count &gt; 0)        &#123;            var current = stack.Pop();            // Matches search?            if (current.IsMatchSearch(search))            &#123;                result.Add(new TreeViewItemGUI&lt;T&gt;(current.Id, 0, current.Name, current));            &#125;            if (current.Children != null &amp;&amp; current.Children.Count &gt; 0)            &#123;                foreach (var element in current.Children)                &#123;                    stack.Push((T)element);                &#125;            &#125;        &#125;        SortSearchResult(result);    &#125;    public override IList&lt;TreeViewItem&gt; GetRows()    &#123;        return m_Rows;    &#125;    protected virtual void SortSearchResult(List&lt;TreeViewItem&gt; rows)    &#123;        // sort by displayName by default, can be overriden for multColumn solutions        rows.Sort((x, y) =&gt; EditorUtility.NaturalCompare(x.displayName, y.displayName));    &#125;    protected virtual List&lt;TreeViewItem&gt; SortByMultipleColumns(List&lt;TreeViewItem&gt; children)    &#123;        return children;    &#125;    public Rect DoLayout(params GUILayoutOption[] options)    &#123;        if(m_TreeModel.IsDirty)        &#123;            m_TreeModel.Update();            Reload();        &#125;        GUILayout.BeginVertical();        var rect = GUILayoutUtility.GetRect(GUIContent.none,                                           GUIStyle.none,                                           options);        OnGUI(rect);        GUILayout.EndVertical();        return rect;    &#125;&#125;</code></pre></details>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——FPS计算并显示</title>
      <link href="/2023/08/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94FPS%E8%AE%A1%E7%AE%97%E5%B9%B6%E6%98%BE%E7%A4%BA/"/>
      <url>/2023/08/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94FPS%E8%AE%A1%E7%AE%97%E5%B9%B6%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="自制游戏FPS显示工具"><a href="#自制游戏FPS显示工具" class="headerlink" title="自制游戏FPS显示工具"></a>自制游戏FPS显示工具</h1><p>在游戏开发中，FPS（Frames Per Second）是一个非常重要的指标，它可以反映出游戏的流畅度和性能。为了帮助开发者更好地优化游戏性能，我们可以使用一个自制的游戏FPS显示工具，实时显示当前的帧率。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>以下是自制的游戏FPS显示工具的代码实现：  </p><pre><code>public class FPSUtils : MonoBehaviour&#123;    #region 实例化        private static FPSUtils s_FPS = null;    /// &lt;summary&gt;    /// 实例化一个FPS单位    /// &lt;/summary&gt;    /// &lt;param name=&quot;parent&quot;&gt;&lt;/param&gt;    public static void CreateInstance(GameObject parent = null)    &#123;        if (s_FPS != null) return;        var go = new GameObject(&quot;FPS&quot;);        s_FPS = go.AddComponent&lt;FPSUtils&gt;();        if (null == parent)        &#123;            DontDestroyOnLoad(go);        &#125;        else        &#123;            go.SetParent(parent);            go.SetAsFirstSibling();        &#125;    &#125;    /// &lt;summary&gt;    /// 销毁一个FPS单位    /// &lt;/summary&gt;    public static void DestroyInstance()    &#123;        if (null != s_FPS)        &#123;            Destroy(s_FPS.gameObject);            s_FPS = null;        &#125;    &#125;    #endregion    #region FPS统计    /// &lt;summary&gt;    /// 是否显示FPS    /// &lt;/summary&gt;    private bool m_IsShowFPS = true;    /// &lt;summary&gt;    /// 帧数计算刷新时间（s）    /// &lt;/summary&gt;    private const float m_ShowTime = 1f;    /// &lt;summary&gt;    /// 当前时间    /// &lt;/summary&gt;    private float m_CurTime = 0f;    /// &lt;summary&gt;    /// 当前帧数    /// &lt;/summary&gt;    private static int m_Frames = 0;    /// &lt;summary&gt;    /// 临时FPS    /// &lt;/summary&gt;    private int m_TempFPS = 0;    /// &lt;summary&gt;    /// 帧数变化比较容忍度    /// &lt;/summary&gt;    private const int TOLERANCE = 5;    /// &lt;summary&gt;    /// 当前FPS    /// &lt;/summary&gt;    private int m_CurFPS;    /// &lt;summary&gt;    /// 当前显示的帧数    /// &lt;/summary&gt;    private int m_CurShowFPS;    /// &lt;summary&gt;    /// 品质当前时间    /// &lt;/summary&gt;    private float m_QualityCurTime = 0f;    /// &lt;summary&gt;    /// 品质的容忍度    /// &lt;/summary&gt;    private const int m_TotalTime = 10;    /// &lt;summary&gt;    /// 帧数容忍度    /// &lt;/summary&gt;    private const int m_MaxFrameCount = 200;    /// &lt;summary&gt;    /// 最小FPS容忍度    /// &lt;/summary&gt;    private const int m_MinFPS = 10;        /// &lt;summary&gt;    /// 当前最小帧数    /// &lt;/summary&gt;    private int m_CurMinFrmCount = 0;    private void Update()    &#123;        m_CurTime += Time.unscaledDeltaTime;        m_Frames++;        m_CurFPS = (int)(1.0f / Time.unscaledDeltaTime);        if (m_CurTime &gt;= m_ShowTime)        &#123;            m_CurShowFPS = (int)(m_Frames / m_CurTime);            if (Math.Abs(m_CurShowFPS - m_TempFPS) &gt; TOLERANCE)            &#123;                m_TempFPS = m_CurShowFPS;            &#125;            m_CurTime = 0;            m_Frames = 0;        &#125;    &#125;    private void FixedUpdate()    &#123;        m_QualityCurTime += Time.unscaledDeltaTime;        if (m_QualityCurTime &gt;= m_TotalTime)        &#123;            m_CurMinFrmCount = 0;            m_QualityCurTime = 0;        &#125;        if (m_CurFPS &gt;= m_MinFPS) return;        m_CurMinFrmCount++;        if (m_CurMinFrmCount &gt; m_MaxFrameCount)        &#123;            //检测到帧率过低，可以做切换品质的功能        &#125;    &#125;    /// &lt;summary&gt;    /// 绘制FPS    /// &lt;/summary&gt;    private void OnGUI()    &#123;        if (m_IsShowFPS)        &#123;            var fpsStr = $&quot;FPS:&#123;m_CurShowFPS&#125;&quot;;            GUI.Label(new Rect(0, 0, 100, 20), fpsStr);        &#125;    &#125;    #endregion&#125;</code></pre><h1 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h1><p>以上代码中，FPSUtils类继承自MonoBehaviour，用于实现FPS统计和显示。  </p><p>首先，定义了一个静态的CreateInstance方法，用于创建一个FPSUtils实例。在该方法中，首先判断是否已经存在一个FPSUtils实例，如果存在则直接返回。如果不存在，则创建一个新的GameObject对象，并将FPSUtils组件添加到该对象上。如果指定了parent参数，则将新创建的对象设置为该parent对象的第一个子对象，否则将其设置为不会被销毁的对象。  </p><p>然后，定义了一个静态的DestroyInstance方法，用于销毁FPSUtils实例。在该方法中，首先判断是否存在FPSUtils实例，如果存在则销毁该实例，并将其设置为null。  </p><p>接下来，定义了一些用于FPS统计的变量，包括是否显示FPS、帧数计算刷新时间、当前时间、当前帧数、临时FPS、帧数变化比较容忍度、当前FPS、当前显示的帧数、品质当前时间、品质的容忍度、帧数容忍度、最小FPS容忍度、当前最小帧数等。  </p><p>然后，在Update方法中，每帧更新当前时间、帧数和当前FPS。如果当前时间超过了帧数计算刷新时间，则计算当前显示的帧数，并将临时FPS设置为当前显示的帧数。在计算当前显示的帧数时，如果当前显示的帧数与临时FPS的差值超过了帧数变化比较容忍度，则将临时FPS设置为当前显示的帧数，并将当前时间和帧数重置为0。  </p><p>在FixedUpdate方法中，每帧更新品质当前时间和当前最小帧数。如果当前FPS大于等于最小FPS，则直接返回。如果当前FPS小于最小FPS，则将当前最小帧数加1。如果当前最小帧数超过了帧数容忍度，则可以做一些切换品质的功能。  </p><p>最后，在OnGUI方法中，如果需要显示FPS，则绘制当前显示的帧数。  </p>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python杂文——Label文字自适应大小</title>
      <link href="/2023/08/19/Python%E6%9D%82%E6%96%87/Python%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Label%E6%96%87%E5%AD%97%E8%87%AA%E9%80%82%E5%BA%94%E5%A4%A7%E5%B0%8F/"/>
      <url>/2023/08/19/Python%E6%9D%82%E6%96%87/Python%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Label%E6%96%87%E5%AD%97%E8%87%AA%E9%80%82%E5%BA%94%E5%A4%A7%E5%B0%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="PyQt5中Label自适应大小的实现"><a href="#PyQt5中Label自适应大小的实现" class="headerlink" title="PyQt5中Label自适应大小的实现"></a>PyQt5中Label自适应大小的实现</h1><p>在PyQt5中，我们经常需要在widget中添加label来显示文本信息。但是，由于文本长度和label大小的不确定性，有时候会出现文本显示不全或者字体过小难以阅读的问题。本文将介绍如何使用Python编写脚本来实现label的自适应大小。  </p><h1 id="单行文本的自适应"><a href="#单行文本的自适应" class="headerlink" title="单行文本的自适应"></a>单行文本的自适应</h1><p>对于单行文本，我们可以使用以下脚本来实现自适应大小：  </p><pre><code>def AutoSingleLabelFontSize(label):    # 创建一个QFont对象    font = label.font()    # 计算字体大小的范围    fm = QFontMetrics(font)    min_size = 1    max_size = 20    # 二分查找适应的字体大小    low, high = min_size, max_size    while low &lt;= high:        mid = (low + high) // 2        font.setPointSize(mid)        fm = QFontMetrics(font)        rect = fm.boundingRect(label.text())        if rect.width() &lt;= label.width():            low = mid + 1        else:            high = mid - 1    # 设置QLabel的字体    font.setPointSize(high)    label.setFont(font)</code></pre><p>这个脚本使用二分查找来适应字体大小。我们可以通过调整min_size和max_size参数来控制字体大小的范围。  </p><h1 id="多行文本自适应"><a href="#多行文本自适应" class="headerlink" title="多行文本自适应"></a>多行文本自适应</h1><p>对于多行文本，我们可以使用以下脚本来实现自适应大小：  </p><pre><code>def AutoMultipleLabelFontSize(label):    # 创建一个QFont对象    font = label.font()    # 计算字体大小的范围    fm = QFontMetrics(font)    min_size = 1    max_size = 20    # 二分查找适应的字体大小    low, high = min_size, max_size    while low &lt;= high:        mid = (low + high) // 2        font.setPointSize(mid)        fm = QFontMetrics(font)        rect = fm.boundingRect(label.rect(), Qt.TextWordWrap, label.text())        if rect.width() &lt;= label.width() and rect.height() &lt;= label.height():            low = mid + 1        else:            high = mid - 1    # 设置QLabel的字体    font.setPointSize(high)    label.setFont(font)</code></pre><p>这个脚本与单行文本的脚本类似，但是我们可以通过word_wrap参数来控制文本是否自动换行。</p><p>以上就是使用Python编写的label自适应大小的脚本。希望这篇文章能够帮助您解决label大小自适应的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Python杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决无法显示图床图片问题</title>
      <link href="/2023/08/06/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%BA%8A%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/"/>
      <url>/2023/08/06/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%BA%8A%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Hexo 博客中使用的图床无法访问，经查询是图床拦截问题，需要修改 referrer 信息。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li><p>找到博客文件中的 head.ejs 或 header.ejs，路径一般在 {博客路径}\themes\3-hexo\layout_partial\ 下。</p></li><li><p>在 <head> 标签中添加以下代码：</head></p> <meta name="referrer" content="no-referrer"></li></ol><p>这将禁用 referrer 信息，从而绕过图床的防盗链限制。</p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1691314374889-2023-8-617:32:55.png" alt="1691314374889-2023-8-617:32:55.png"></p><p>通过以上优化，可以使文章更加清晰易懂，让读者更容易理解和操作。</p>]]></content>
      
      
      <categories>
          
          <category> 搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python杂文——PyCharm配置QT环境</title>
      <link href="/2023/08/06/Python%E6%9D%82%E6%96%87/Python%E6%9D%82%E6%96%87%E2%80%94%E2%80%94PyCharm%E9%85%8D%E7%BD%AEQT%E7%8E%AF%E5%A2%83/"/>
      <url>/2023/08/06/Python%E6%9D%82%E6%96%87/Python%E6%9D%82%E6%96%87%E2%80%94%E2%80%94PyCharm%E9%85%8D%E7%BD%AEQT%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="安装pyqt5对应的库"><a href="#安装pyqt5对应的库" class="headerlink" title="安装pyqt5对应的库"></a>安装pyqt5对应的库</h1><h2 id="使用PyCharm安装（方法一）"><a href="#使用PyCharm安装（方法一）" class="headerlink" title="使用PyCharm安装（方法一）"></a>使用PyCharm安装（方法一）</h2><h3 id="安装pyqt5库"><a href="#安装pyqt5库" class="headerlink" title="安装pyqt5库"></a>安装pyqt5库</h3><ol><li>打开 PyCharm，进入安装源位置：File -&gt; Settings -&gt; Project -&gt; Python Interpreter  </li><li>在搜索框中输入 pyqt5，点击安装  </li><li>在搜索框中输入 pyqt5-tools，点击安装<br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1691306206191-2023-8-615:16:46.png" alt="这是一张图片"></li></ol><h3 id="安装PyQt5-tool库"><a href="#安装PyQt5-tool库" class="headerlink" title="安装PyQt5-tool库"></a>安装PyQt5-tool库</h3><p>同样的方法搜索PyQt5-tool这个库进行安装即可  </p><h2 id="使用终端命令安装（方法二）"><a href="#使用终端命令安装（方法二）" class="headerlink" title="使用终端命令安装（方法二）"></a>使用终端命令安装（方法二）</h2><p>在终端中输入以下两个命令即可安装对应的库：</p><pre><code>pip install pyqt5  pip install pyqt5-tool  </code></pre><h1 id="配置QT-Designer-界面设计-和PyUIC-界面转代码"><a href="#配置QT-Designer-界面设计-和PyUIC-界面转代码" class="headerlink" title="配置QT Designer(界面设计)和PyUIC(界面转代码)"></a>配置QT Designer(界面设计)和PyUIC(界面转代码)</h1><h2 id="配置QT-Designer"><a href="#配置QT-Designer" class="headerlink" title="配置QT Designer"></a>配置QT Designer</h2><ol><li>打开 PyCharm，进入配置位置：File -&gt; Settings -&gt; Tools -&gt; External Tools</li><li>点击“+”号，弹出一个编辑配置的框</li><li>配置扩展工具的参数：  <blockquote><p><strong>Name</strong>: 自己随便起个名字，一般都是<strong>QT Designer</strong><br><strong>Program</strong>: designer.exe软件所在的路径，路径位置一般为：{python路径}\Lib\site-packages\qt5_applications\Qt\bin\designer.exe<br><strong>Working directory</strong>: <strong>$FileDir$</strong></p></blockquote></li></ol><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1691307145291-2023-8-615:32:26.png" alt="这是一张图片"></p><h2 id="配置PyUIC"><a href="#配置PyUIC" class="headerlink" title="配置PyUIC"></a>配置PyUIC</h2><ol><li>打开 PyCharm，进入配置位置：File -&gt; Settings -&gt; Tools -&gt; External Tools</li><li>点击“+”号，弹出一个编辑配置的框</li><li>配置扩展工具的参数： <blockquote><p>Name: 自己随便起个名字，一般都是<strong>配置PyUIC</strong><br> Program: python.exe软件所在的路径，路径位置一般为：{python路径}\python.exe<br> Arguments: $FileName$ -o $FileNameWithoutExtension$.py<br> Working directory: <strong>$FileDir$</strong></p></blockquote></li></ol><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1691375885378-2023-8-710:38:06.png" alt="1691375885378-2023-8-710:38:06.png"></p><h1 id="使用配置"><a href="#使用配置" class="headerlink" title="使用配置"></a>使用配置</h1><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1691307415934-2023-8-615:36:56.png" alt="这是一张图片">  </p><h2 id="制作界面"><a href="#制作界面" class="headerlink" title="制作界面"></a>制作界面</h2><p>点击上图编号①就可以打开编辑界面 UI 的编辑器了，也可以使用快捷键 Ctrl + Alt + Shift + D<br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1691307518635-2023-8-615:38:39.png" alt="这是一张图片">  </p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>制作好界面后，在 PyCharm 中选中刚才制作的 UI 文件，右键 -&gt; External Tools -&gt; PyUIC 即可生成对应的代码。<br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1691307659438-2023-8-615:41:00.png" alt="这是一张图片">  </p>]]></content>
      
      
      <categories>
          
          <category> Python杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——宏管理脚本</title>
      <link href="/2023/05/21/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%AE%8F%E7%AE%A1%E7%90%86%E8%84%9A%E6%9C%AC/"/>
      <url>/2023/05/21/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%AE%8F%E7%AE%A1%E7%90%86%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这是一个管理Unity宏设置的脚本工具，能快速的增删改查项目的脚本。<br>下面是效果图：<br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1684677675196-2023-5-2122:01:15.png"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="依赖的代码"><a href="#依赖的代码" class="headerlink" title="依赖的代码"></a>依赖的代码</h2><details>    <summary> ResCatalog </summary>  <pre><code>/// &lt;summary&gt;/// 资源路径/// &lt;/summary&gt;public static class ResCatalog&#123;    public const string DefaultRes = &quot;Library/unity default resources&quot;;    public const string Temporary = &quot;Assets/_Temporary&quot;;    public const string Library = &quot;Assets/_Library&quot;;&#125;</code></pre></details>  <details>    <summary> BuildTargetUtility </summary>  <pre><code>/// &lt;summary&gt;/// 构建的辅助工具/// &lt;/summary&gt;public class BuildTargetUtility&#123;    /// &lt;summary&gt;    /// 获取对应平台的组    /// &lt;/summary&gt;    /// &lt;param name=&quot;p&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static BuildTargetGroup PlatformToGroup(RuntimePlatform p)    &#123;        return p switch        &#123;            RuntimePlatform.OSXEditor =&gt; BuildTargetGroup.Standalone,            RuntimePlatform.OSXPlayer =&gt; BuildTargetGroup.Standalone,            RuntimePlatform.WindowsPlayer =&gt; BuildTargetGroup.Standalone,            RuntimePlatform.WindowsEditor =&gt; BuildTargetGroup.Standalone,            RuntimePlatform.IPhonePlayer =&gt; BuildTargetGroup.iOS,            RuntimePlatform.Android =&gt; BuildTargetGroup.Android,            RuntimePlatform.LinuxPlayer =&gt; BuildTargetGroup.Standalone,            RuntimePlatform.LinuxEditor =&gt; BuildTargetGroup.Standalone,            RuntimePlatform.WebGLPlayer =&gt; BuildTargetGroup.WebGL,            RuntimePlatform.PS4 =&gt; BuildTargetGroup.PS4,            RuntimePlatform.XboxOne =&gt; BuildTargetGroup.XboxOne,            RuntimePlatform.tvOS =&gt; BuildTargetGroup.tvOS,            RuntimePlatform.Switch =&gt; BuildTargetGroup.Switch,            _ =&gt; BuildTargetGroup.Unknown        &#125;;    &#125;&#125;</code></pre></details> <details>    <summary> AssetLibrary </summary>  <pre><code>/// &lt;summary&gt;/// 资源的Library/// &lt;/summary&gt;public static class AssetLibrary&#123;    /// &lt;summary&gt;    /// 判断文件是否存在    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static bool Exists(string path, bool temporary)    &#123;        return File.Exists(GetPath(path, temporary));    &#125;    /// &lt;summary&gt;    /// 获取文件的地址    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件名字&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;是否是临时文件&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static string GetPath(string path, bool temporary)    &#123;        return Path.Combine(temporary ? ResCatalog.Temporary : ResCatalog.Library, path);    &#125;    /// &lt;summary&gt;    /// 保存文件    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件地址&lt;/param&gt;    /// &lt;param name=&quot;text&quot;&gt;文件内容&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;是否是临时文件&lt;/param&gt;    public static void Save(string path, string text, bool temporary)    &#123;        WriteAllText(path, text, temporary);    &#125;    /// &lt;summary&gt;    /// 保存文件    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件地址&lt;/param&gt;    /// &lt;param name=&quot;bytes&quot;&gt;写入的字节&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;是否是临时资源&lt;/param&gt;    public static void Save(string path, byte[] bytes, bool temporary)    &#123;        WriteAllBytes(path, bytes, temporary);    &#125;    /// &lt;summary&gt;    /// 获取文件内的所有内容    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件地址&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;是否是临时文件&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static string GetString(string path, bool temporary)    &#123;        return File.ReadAllText(GetPath(path, temporary));    &#125;    /// &lt;summary&gt;    /// 获取文件的所有字节    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件地址&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;是否是临时资源&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static byte[] GetBytes(string path, bool temporary)    &#123;        return File.ReadAllBytes(GetPath(path, temporary));    &#125;    /// &lt;summary&gt;    /// 写入所有的字节    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件路径&lt;/param&gt;    /// &lt;param name=&quot;bytes&quot;&gt;写入字节&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;是否是临时资源&lt;/param&gt;    private static void WriteAllBytes(string path, byte[] bytes, bool temporary)    &#123;        var realPath = GetPath(path, temporary);        PathUtils.MakeDirectory(realPath);        File.WriteAllBytes(realPath, bytes);    &#125;    /// &lt;summary&gt;    /// 写入所有的文本内容    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件路径&lt;/param&gt;    /// &lt;param name=&quot;text&quot;&gt;写入字符串&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;是否是临时资源&lt;/param&gt;    private static void WriteAllText(string path, string text, bool temporary)    &#123;        var realPath = GetPath(path, temporary);        PathUtils.MakeDirectory(realPath);        File.WriteAllText(realPath, text);    &#125;&#125;</code></pre></details>  <details>    <summary> SymbolsUtility </summary>  <pre><code>/// &lt;summary&gt;/// 宏的辅助工具/// &lt;/summary&gt;public static class SymbolsUtility&#123;    /// &lt;summary&gt;    /// 设置宏    /// &lt;/summary&gt;    /// &lt;param name=&quot;symbols&quot;&gt;&lt;/param&gt;    public static void SetSymbols(params string[] symbols)    &#123;        var result = string.Join(&quot;;&quot;, symbols);        PlayerSettings.SetScriptingDefineSymbolsForGroup(BuildTargetGroup.Standalone, result);        PlayerSettings.SetScriptingDefineSymbolsForGroup(BuildTargetGroup.iOS, result);        PlayerSettings.SetScriptingDefineSymbolsForGroup(BuildTargetGroup.Android, result);    &#125;    /// &lt;summary&gt;    /// 获取所有的宏    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static string[] GetSymbols()    &#123;        var group = BuildTargetUtility.PlatformToGroup(Application.platform);        var symbols = PlayerSettings.GetScriptingDefineSymbolsForGroup(group);        return symbols.Split(&#39;;&#39;);    &#125;    /// &lt;summary&gt;    /// 增加宏    /// &lt;/summary&gt;    /// &lt;param name=&quot;symbols&quot;&gt;宏的组&lt;/param&gt;    public static void AddSymbols(params string[] symbols)    &#123;        SetSymbols(GetSymbols().Union(symbols).ToArray());    &#125;    /// &lt;summary&gt;    /// 移除宏    /// &lt;/summary&gt;    /// &lt;param name=&quot;symbols&quot;&gt;宏的组&lt;/param&gt;    public static void RemoveSymbols(params string[] symbols)    &#123;        SetSymbols(GetSymbols().Except(symbols).ToArray());    &#125;    /// &lt;summary&gt;    /// 判断是否拥有宏    /// &lt;/summary&gt;    /// &lt;param name=&quot;symbol&quot;&gt;宏的名字&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static bool HasSymbols(string symbol)    &#123;        return -1 != Array.IndexOf(GetSymbols(), symbol);    &#125;&#125;</code></pre></details> <h2 id="管理工具代码"><a href="#管理工具代码" class="headerlink" title="管理工具代码"></a>管理工具代码</h2><pre><code>internal class SymbolsManager : EditorWindow&#123;    /// &lt;summary&gt;    /// 宏的配置    /// &lt;/summary&gt;    public class SymbolsConfig    &#123;        /// &lt;summary&gt;        /// 宏的名字        /// &lt;/summary&gt;        public string name;        /// &lt;summary&gt;        /// 是否使用        /// &lt;/summary&gt;        [NonSerialized]        public bool used;    &#125;    /// &lt;summary&gt;    /// 宏的组    /// &lt;/summary&gt;    public class SymbolsGroup    &#123;        /// &lt;summary&gt;        /// 组的名字        /// &lt;/summary&gt;        public string name;        /// &lt;summary&gt;        /// 组的宏列表        /// &lt;/summary&gt;        public List&lt;SymbolsConfig&gt; list;        /// &lt;summary&gt;        /// 用于显示的List        /// &lt;/summary&gt;        [NonSerialized]        public ReorderableList reorderableList;        /// &lt;summary&gt;        /// 是否已经删除        /// &lt;/summary&gt;        [NonSerialized]        public bool deleted;    &#125;    /// &lt;summary&gt;    /// 组的列表    /// &lt;/summary&gt;    private List&lt;SymbolsGroup&gt; m_Groups;    /// &lt;summary&gt;    /// 宏管理窗口    /// &lt;/summary&gt;    [MenuItem(&quot;Tools/SymbolsManager&quot;, false)]    private static void OpenWindow()    &#123;        var window = GetWindow&lt;SymbolsManager&gt;(&quot;SymbolsManager&quot;);        window.minSize = new Vector2(350, 100);    &#125;    private void OnEnable()    &#123;        var path = GetSettingsFileName();        if (AssetLibrary.Exists(path, false))        &#123;            var text = AssetLibrary.GetString(path, false);            JsonUtils.ToObject(text, out m_Groups);            foreach (var group in m_Groups)            &#123;                if (null == group.list)                &#123;                    group.list = new List&lt;SymbolsConfig&gt;();                &#125;                else                &#123;                    foreach (var config in group.list)                    &#123;                        config.used = SymbolsUtility.HasSymbols(config.name);                    &#125;                &#125;            &#125;        &#125;        m_Groups ??= new List&lt;SymbolsGroup&gt;();    &#125;    /// &lt;summary&gt;    /// 绘制面板    /// &lt;/summary&gt;    private void OnGUI()    &#123;        for (var i = 0; i &lt; m_Groups.Count;)        &#123;            var group = m_Groups[i];            GUILayout.BeginVertical(EditorStyles.helpBox);            &#123;                if (null == group.reorderableList)                &#123;                    group.list ??= new List&lt;SymbolsConfig&gt;();                    group.reorderableList = new ReorderableList(group.list, typeof(SymbolsConfig))                    &#123;                        drawHeaderCallback = rect =&gt;                        &#123;                            var textRt = rect;                            textRt.width /= 2f;                            group.name = EditorGUI.TextField(textRt, group.name, EditorStyles.boldLabel);                            var btnRt = rect;                            btnRt.x = btnRt.xMax - Styles.closeButton.lineHeight;                            if (GUI.Button(btnRt, GUIContent.none, Styles.closeButton))                            &#123;                                if (EditorUtility.DisplayDialog(                                    &quot;提示&quot;, &quot;是否确认删除?&quot;, &quot;确认&quot;, &quot;取消&quot;))                                &#123;                                    group.deleted = true;                                &#125;                            &#125;                        &#125;,                        drawElementCallback = (rect, index, active, focused) =&gt;                        &#123;                            var item = group.list[index];                            var textRect = new Rect(                                rect.position + Vector2.up * 2,                                new Vector2(rect.width - 100, EditorGUIUtility.singleLineHeight));                            item.name = GUI.TextField(textRect, item.name)?.Trim();                            const int btnWidth = 80;                            var oldColor = GUI.color;                            GUI.color = SymbolsUtility.HasSymbols(item.name) ? Color.green : Color.red;                            var btnRect = new Rect(                                rect.position + Vector2.up + Vector2.right * (rect.width - btnWidth),                                new Vector2(btnWidth, EditorGUIUtility.singleLineHeight));                            item.used = GUI.Toggle(btnRect, item.used,                                item.used ? Styles.used : Styles.unused,                                EditorStyles.toolbarButton);                            GUI.color = oldColor;                        &#125;,                        elementHeight = 22,                    &#125;;                &#125;                group.reorderableList.DoLayoutList();                GUILayout.BeginHorizontal();                GUILayout.FlexibleSpace();                if (GUILayout.Button(Styles.apply, GUILayout.Height(30), GUILayout.Width(100)))                &#123;                    foreach (var config in group.list)                    &#123;                        if (config.used)                        &#123;                            SymbolsUtility.AddSymbols(config.name);                        &#125;                        else                        &#123;                            SymbolsUtility.RemoveSymbols(config.name);                        &#125;                    &#125;                    AssetDatabase.SaveAssets();                    AssetDatabase.Refresh();                &#125;                GUILayout.FlexibleSpace();                GUILayout.EndHorizontal();                GUILayout.Space(5);            &#125;            GUILayout.EndVertical();            if (group.deleted)            &#123;                m_Groups.RemoveAt(i);            &#125;            else            &#123;                ++i;            &#125;        &#125;        //        GUILayout.BeginHorizontal();        GUILayout.FlexibleSpace();        if (GUILayout.Button(Styles.addGroup, GUILayout.Height(30), GUILayout.Width(200)))        &#123;            m_Groups.Add(new SymbolsGroup            &#123;                name = Styles.customName,                list = new List&lt;SymbolsConfig&gt;()            &#125;);        &#125;        GUILayout.FlexibleSpace();        GUILayout.EndHorizontal();        var e = Event.current;        if (e.keyCode == KeyCode.S &amp;&amp; e.type == EventType.KeyUp)        &#123;            e.Use();            Save();        &#125;    &#125;    /// &lt;summary&gt;    /// 销毁的时候保存    /// &lt;/summary&gt;    private void OnDisable()    &#123;        Save();    &#125;    /// &lt;summary&gt;    /// 保存    /// &lt;/summary&gt;    private void Save()    &#123;        JsonResolver.NotSerializeDefault = true;        var text = JsonUtils.ToPrettyString(m_Groups);        AssetLibrary.Save(GetSettingsFileName(), text, false);        JsonResolver.NotSerializeDefault = false;    &#125;    /// &lt;summary&gt;    /// 序列化Json文件的名字，采用 “类名Settings.json”格式    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    private string GetSettingsFileName()    &#123;        return $&quot;&#123;GetType().Name&#125;Settings.json&quot;;    &#125;    #region 显示风格Style    /// &lt;summary&gt;    /// 编辑器的风格    /// &lt;/summary&gt;    private static class Styles    &#123;        /// &lt;summary&gt;        /// 已经使用        /// &lt;/summary&gt;        public static GUIContent used;        /// &lt;summary&gt;        /// 未使用        /// &lt;/summary&gt;        public static GUIContent unused;        /// &lt;summary&gt;        /// 应用        /// &lt;/summary&gt;        public static GUIContent apply;        /// &lt;summary&gt;        /// 新增分组        /// &lt;/summary&gt;        public static GUIContent addGroup;        /// &lt;summary&gt;        /// 自定义名称(点击修改)        /// &lt;/summary&gt;        public static string customName;        /// &lt;summary&gt;        /// WinBtnClose        /// &lt;/summary&gt;        public static GUIStyle closeButton;        static Styles()        &#123;            used = new GUIContent(&quot;已使用&quot;);            unused = new GUIContent(&quot;未使用&quot;);            apply = new GUIContent(&quot;应用&quot;);            addGroup = new GUIContent(&quot;新增分组&quot;);            customName = &quot;自定义名称(点击修改)&quot;;            closeButton = new GUIStyle(&quot;WinBtnClose&quot;);        &#125;    &#125;    #endregion&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——脚本创建辅助ScriptBuilder</title>
      <link href="/2023/05/17/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%84%9A%E6%9C%AC%E5%88%9B%E5%BB%BA%E8%BE%85%E5%8A%A9ScriptBuilder/"/>
      <url>/2023/05/17/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%84%9A%E6%9C%AC%E5%88%9B%E5%BB%BA%E8%BE%85%E5%8A%A9ScriptBuilder/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一个辅助快速生成需要的C#脚本的脚本。主要是快速生成引用，命名空间，类和方法一些。</p><h1 id="脚本和解析"><a href="#脚本和解析" class="headerlink" title="脚本和解析"></a>脚本和解析</h1><pre><code>public class ScriptBuilder&#123;    /// &lt;summary&gt;    /// 脚本的字符串    /// &lt;/summary&gt;    private StringBuilder m_Builder = new StringBuilder();    /// &lt;summary&gt;    /// 空白地字符串    /// &lt;/summary&gt;    private StringBuilder m_Blank = new StringBuilder();    /// &lt;summary&gt;    /// 用于判断是否在方法内生成脚本    /// &lt;/summary&gt;    public bool MarkInMethod &#123; get; set; &#125;    /// &lt;summary&gt;    /// 增加一行数据    /// &lt;/summary&gt;    /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;    public void AppendLine(string message)    &#123;        m_Builder.Append(m_Blank);        m_Builder.AppendLine(message);    &#125;    /// &lt;summary&gt;    /// 开始增加空白    /// &lt;/summary&gt;    private void BeginBlank()    &#123;        m_Blank.Append(&#39;\t&#39;);    &#125;    /// &lt;summary&gt;    /// 结束增加空白    /// &lt;/summary&gt;    private void EndBlank()    &#123;        m_Blank.Remove(m_Blank.Length - 1, 1);    &#125;    /// &lt;summary&gt;    ///开始增加命名空间    /// &lt;/summary&gt;    /// &lt;param name=&quot;name&quot;&gt;命名空间的名字&lt;/param&gt;    public void BeginNamespace(string name)    &#123;        BeginBrace($&quot;namespace &#123;name&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 结束增加命名空间    /// &lt;/summary&gt;    public void EndNamespace()    &#123;        EndBrace();    &#125;    /// &lt;summary&gt;    /// 开始增加类    /// &lt;/summary&gt;    /// &lt;param name=&quot;modifier&quot;&gt;类的修饰字符串&lt;/param&gt;    /// &lt;param name=&quot;className&quot;&gt;类的名字&lt;/param&gt;    /// &lt;param name=&quot;superclass&quot;&gt;继承类的名字&lt;/param&gt;    public void BeginClass(string modifier, string className, string superclass)    &#123;        BeginBrace($&quot;public &#123;modifier&#125; class &#123;className&#125; : &#123;superclass&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 开始增加类    /// &lt;/summary&gt;    /// &lt;param name=&quot;modifier&quot;&gt;类的修饰字符串&lt;/param&gt;    /// &lt;param name=&quot;className&quot;&gt;类的名字&lt;/param&gt;    public void BeginClass(string modifier, string className)    &#123;        BeginBrace($&quot;public &#123;modifier&#125; class &#123;className&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 开始增加类    /// &lt;/summary&gt;    /// &lt;param name=&quot;className&quot;&gt;类的名字&lt;/param&gt;    public void BeginClass(string className)    &#123;        BeginBrace($&quot;public class &#123;className&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 结束类    /// &lt;/summary&gt;    public void EndClass()    &#123;        EndBrace();    &#125;    /// &lt;summary&gt;    /// 开始增加方法    /// &lt;/summary&gt;    /// &lt;param name=&quot;method&quot;&gt;方法名&lt;/param&gt;    /// &lt;param name=&quot;permission&quot;&gt;访问权限&lt;/param&gt;    /// &lt;param name=&quot;returnType&quot;&gt;返回类型&lt;/param&gt;    /// &lt;param name=&quot;modifier&quot;&gt;修饰符&lt;/param&gt;    public void BeginMethod(string method, string permission = &quot;public&quot;, string returnType = &quot;void&quot;,        string modifier = &quot;&quot;)    &#123;        MarkInMethod = true;        BeginBrace(string.IsNullOrEmpty(modifier)            ? $&quot;&#123;permission&#125; &#123;returnType&#125; &#123;method&#125;&quot;            : $&quot;&#123;permission&#125; &#123;modifier&#125; &#123;returnType&#125; &#123;method&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 结束方法    /// &lt;/summary&gt;    public void EndMethod()    &#123;        EndBrace();        MarkInMethod = false;    &#125;    /// &lt;summary&gt;    /// 开始属性    /// &lt;/summary&gt;    /// &lt;param name=&quot;property&quot;&gt;属性名字&lt;/param&gt;    public void BeginProperty(string property)    &#123;        BeginBrace(property);    &#125;    /// &lt;summary&gt;    /// 结束属性    /// &lt;/summary&gt;    public void EndProperty()    &#123;        EndBrace();    &#125;    /// &lt;summary&gt;    /// 大括号的开始    /// &lt;/summary&gt;    /// &lt;param name=&quot;code&quot;&gt;&lt;/param&gt;    public void BeginBrace(string code)    &#123;        AppendLine($&quot;&#123;code&#125;&quot;);        AppendLine(&quot;&#123;&quot;);        BeginBlank();    &#125;    /// &lt;summary&gt;    /// 结束大括号    /// &lt;/summary&gt;    public void EndBrace()    &#123;        EndBlank();        AppendLine(&quot;&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 开始字段    /// &lt;/summary&gt;    /// &lt;param name=&quot;code&quot;&gt;Field的名字&lt;/param&gt;    public void BeginField(string code)    &#123;        AppendLine($&quot;&#123;code&#125;&quot;);        AppendLine(&quot;&#123;&quot;);        BeginBlank();    &#125;    /// &lt;summary&gt;    /// 结束字段    /// &lt;/summary&gt;    public void EndField()    &#123;        EndBlank();        AppendLine(&quot;&#125;;&quot;);    &#125;    /// &lt;summary&gt;    /// 开始Region    /// &lt;/summary&gt;    /// &lt;param name=&quot;name&quot;&gt;Region的名字&lt;/param&gt;    public void BeginRegion(string name)    &#123;        AppendLine($&quot;#region &#123;name&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 结束Region    /// &lt;/summary&gt;    public void EndRegion()    &#123;        AppendLine(&quot;#endregion&quot;);    &#125;    /// &lt;summary&gt;    /// 转成字符串    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public override string ToString()    &#123;        return m_Builder.ToString();    &#125;&#125;</code></pre><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>上述方法就是辅助的脚本，下面是举例调用方法作为参考  </p><pre><code>// 获取类脚本的路径var scriptPath = AssetDatabase.GUIDToAssetPath(kGUID);var sb = new ScriptBuilder();sb.BeginNamespace(typeof(StorageKeyConst).Namespace);sb.BeginClass(&quot;static&quot;, &quot;StorageKeyConst&quot;);if (DataStorageEditorTools.Instance.DataStorageEditorDataRootList.Count &gt; 0)&#123;    sb.BeginRegion(&quot;RootKeys&quot;);    sb.AppendLine(string.Empty);    AddListScripts(sb, DataStorageEditorTools.Instance.DataStorageEditorDataRootList);    sb.AppendLine(string.Empty);    sb.EndRegion();    sb.AppendLine(string.Empty);&#125;if (DataStorageEditorTools.Instance.DataStorageEditorDataList.Count &gt; 0)&#123;    sb.BeginRegion(&quot;Keys&quot;);    sb.AppendLine(string.Empty);    AddListScripts(sb, DataStorageEditorTools.Instance.DataStorageEditorDataList);    sb.AppendLine(string.Empty);    sb.EndRegion();&#125;sb.EndClass();sb.EndNamespace();File.WriteAllText(scriptPath, sb.ToString(), Encoding.UTF8);AssetDatabase.SaveAssets();AssetDatabase.Refresh();</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——阿拉伯数字转罗马数字</title>
      <link href="/2022/12/29/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
      <url>/2022/12/29/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在游戏开发中，美术人员有时需要将一些数字转换为罗马数字。本文介绍了一种将阿拉伯数字转换为罗马数字的方法，可以帮助美术人员快速完成转换。如果您是游戏开发人员或对数字转换感兴趣，本文也会对您有所帮助。 </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>/// &lt;summary&gt;/// 数字转罗马数字/// &lt;/summary&gt;/// &lt;param name=&quot;num&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string IntToRoman(int num)&#123;    var res = string.Empty;    var val = new List&lt;int&gt; &#123; 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 &#125;;    var str = new List&lt;string&gt; &#123; &quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot; &#125;;    for(var i = 0;i &lt; val.Count; ++i)    &#123;        while(num &gt;= val[i])        &#123;            num -= val[i];            res += str[i];        &#125;    &#125;    return res;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——编辑器Foldout右键菜单</title>
      <link href="/2022/12/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E5%99%A8Foldout%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/"/>
      <url>/2022/12/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E5%99%A8Foldout%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在用编辑器开发工具的时候，我们经常会用到折叠的Foldout，这里就不对Foldout做详细的介绍了，本文主要分享如何对Foldout做一个扩展，笔者在开发中常常需要的一个右键菜单的功能，这样我们就可以添加很多功能而不需要增加按钮，右键选择对应的菜单就行了。  </p><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/FoldoutRightClick-2022-12-2811:17:09.gif"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>var rect = GUILayoutUtility.GetRect(EditorGUIUtility.fieldWidth, EditorGUIUtility.fieldWidth, 18f, 18f,    EditorStyles.foldout);m_IsFoldout = EditorGUI.Foldout(rect, m_IsFoldout, &quot;标题&quot;);CreateNewGenericMenu(rect, new List&lt;string&gt; &#123; &quot;方法一&quot;, &quot;方法二&quot;, &quot;方法三&quot; &#125;, new List&lt;Action&gt;&#123;    (() =&gt; &#123;Debug.LogError(&quot;1&quot;);&#125;),    (() =&gt; &#123;Debug.LogError(&quot;2&quot;);&#125;),    (() =&gt; &#123;Debug.LogError(&quot;3&quot;);&#125;),&#125;);/// &lt;summary&gt;/// 绘制右键菜单/// &lt;/summary&gt;/// &lt;param name=&quot;btnRect&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;menuName&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;menuIsOn&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;menuCallBack&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public GenericMenu CreateNewGenericMenu(Rect btnRect, List&lt;string&gt; menuName, List&lt;Action&gt; menuCallBack,    List&lt;bool&gt; menuIsOn = null)&#123;    var menu = new GenericMenu();    var index = 0;    foreach (var action in menuCallBack)    &#123;        menu.AddItem(new GUIContent(menuName[index]), menuIsOn != null &amp;&amp; menuIsOn[index],            () =&gt; &#123; action?.Invoke(); &#125;);        index++;    &#125;    if (Event.current.button == 1 &amp;&amp; Event.current.type == EventType.MouseDown &amp;&amp;        btnRect.Contains(Event.current.mousePosition))    &#123;        menu.ShowAsContext();    &#125;    return menu;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——UI点击穿透</title>
      <link href="/2022/12/17/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UI%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F/"/>
      <url>/2022/12/17/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UI%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>当UI打开一个小的提示tip的时候，常见的需求是点击其他任意地方就关闭tip，这个功能很常见，空白出响应点击，监听到就关闭tip，这里会发现一个问题，我们并不能响应tip面板底下的其他按钮，这样玩家在操作的时候就需要先关掉tip，然后再点一下按钮，这往往不是策划想要的，所以我们需要在点击空白处关闭的时候同时响应底下的按钮，这个时候就需要点击穿透事件。  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>using System.Collections.Generic;using UnityEngine;using UnityEngine.EventSystems;namespace ZHEngine.UI&#123;    public sealed class UTouchPass : MonoBehaviour, IPointerClickHandler,    IMoveHandler,IPointerDownHandler, IPointerUpHandler,IPointerEnterHandler,ISelectHandler, IDeselectHandler    , ISubmitHandler, IInitializePotentialDragHandler, IBeginDragHandler, IEndDragHandler, IDragHandler, IScrollHandler    &#123;        private GameObject CacheGameObject;        private readonly List&lt;RaycastResult&gt; result = new List&lt;RaycastResult&gt;();        public void OnPointerClick(PointerEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.pointerClickHandler);        &#125;        public void OnPointerDown(PointerEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.pointerDownHandler);            if (Input.GetButtonDown(&quot;Submit&quot;))               ExecuteEvents.Execute(eventData.pointerCurrentRaycast.gameObject, eventData, ExecuteEvents.submitHandler);        &#125;        public void OnPointerUp(PointerEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.pointerUpHandler);        &#125;        public void OnPointerEnter(PointerEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.pointerEnterHandler);        &#125;        public void OnSelect(BaseEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.selectHandler);        &#125;        public void OnDeselect(BaseEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.deselectHandler);        &#125;        public void OnSubmit(BaseEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.submitHandler);        &#125;        public void OnMove(AxisEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.moveHandler);        &#125;        public void OnInitializePotentialDrag(PointerEventData eventData)        &#123;            CacheGameObject = PassEvent(eventData, ExecuteEvents.initializePotentialDrag);        &#125;        public void OnBeginDrag(PointerEventData eventData)        &#123;             PassEvent(eventData, ExecuteEvents.beginDragHandler);        &#125;        public void OnDrag(PointerEventData eventData)        &#123;            ExecuteEvents.Execute(CacheGameObject, eventData, ExecuteEvents.dragHandler);        &#125;        public void OnEndDrag(PointerEventData eventData)        &#123;            ExecuteEvents.Execute(CacheGameObject, eventData, ExecuteEvents.endDragHandler);            CacheGameObject = null;        &#125;        public void OnScroll(PointerEventData eventData)        &#123;            ExecuteEvents.Execute(CacheGameObject, eventData, ExecuteEvents.scrollHandler);        &#125;        private GameObject PassEvent&lt;T&gt;(BaseEventData data, ExecuteEvents.EventFunction&lt;T&gt; function) where T : IEventSystemHandler        &#123;            if (data is PointerEventData eventData)            &#123;                var pointerGo = eventData.pointerCurrentRaycast.gameObject                    ? eventData.pointerCurrentRaycast.gameObject                    : eventData.pointerDrag;                EventSystem.current.RaycastAll(eventData, result);                foreach (var item in result)                &#123;                    var go = item.gameObject;                    if (go != null &amp;&amp; go != pointerGo)                    &#123;                        var executeGo = ExecuteEvents.GetEventHandler&lt;T&gt;(go);                        if (executeGo)                        &#123;                            if (executeGo.TryGetComponent&lt;UTouchPass&gt;(out var __))                                return null;                            ExecuteEvents.Execute(executeGo, data, function);                            return executeGo;                        &#125;                        else                        &#123;                            if(go.TryGetComponent&lt;UnityEngine.UI.Graphic&gt;(out var com))                            &#123;                                if (com.raycastTarget) return null;                            &#125;                        &#125;                    &#125;                &#125;            &#125;            return null;        &#125;    &#125;&#125;</code></pre><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.xuanyusong.com/archives/4773">Unity3D研究院之UI完整透下事件（一百二十二）——雨松MOMO</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——编辑器下拉多选菜单</title>
      <link href="/2022/09/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8B%E6%8B%89%E5%A4%9A%E9%80%89%E8%8F%9C%E5%8D%95/"/>
      <url>/2022/09/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8B%E6%8B%89%E5%A4%9A%E9%80%89%E8%8F%9C%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>游戏编辑器工具开发中会经常遇到下拉菜单的需求，笔者也遇到了一种特殊的下拉菜单，是下拉后可以多选的菜单，于是笔者便记录下这种特殊菜单的开发脚本。</p><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/20220928_003131-2022-9-2800:34:48.gif">  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><pre><code>public enum DropdownMultiType&#123;    [InspectorName(&quot;无&quot;)] None = 0,    Everything = ~0,    [InspectorName(&quot;类型一&quot;)] Type1 = 1 &lt;&lt; 1,    [InspectorName(&quot;类型二&quot;)] Type2 = 1 &lt;&lt;2,    [InspectorName(&quot;类型三&quot;)] Type3 = 1&lt;&lt;3&#125;</code></pre><h2 id="调用脚本"><a href="#调用脚本" class="headerlink" title="调用脚本"></a>调用脚本</h2><pre><code>m_DropdownMultiType = (DropdownMultiType)EditorGUILayout.EnumFlagsField(m_DropdownMultiType, GUILayout.Width(120))；EditorGUILayout.LabelField($&quot;Type1：&#123;m_DropdownMultiType.HasFlag(DropdownMultiType.Type1)&#125;&quot;);EditorGUILayout.LabelField($&quot;Type2：&#123;m_DropdownMultiType.HasFlag(DropdownMultiType.Type2)&#125;&quot;);EditorGUILayout.LabelField($&quot;Type3：&#123;m_DropdownMultiType.HasFlag(DropdownMultiType.Type3)&#125;&quot;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用Python文件处理脚本</title>
      <link href="/2022/09/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%B8%B8%E7%94%A8Python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/"/>
      <url>/2022/09/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%B8%B8%E7%94%A8Python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Unity打包经常会用一些文件的复制粘贴到一些文件到自己指定的SDK目录，一开始我们使用的是bat脚本，但是笔者发现这个脚本没办法在打包机（MAC）上使用，于是笔者便想到了python脚本来实现。  </p><h1 id="引用的库"><a href="#引用的库" class="headerlink" title="引用的库"></a>引用的库</h1><pre><code>import sysimport osimport jsonimport shutil</code></pre><h1 id="利用json配置需要控制的文件或者文件夹"><a href="#利用json配置需要控制的文件或者文件夹" class="headerlink" title="利用json配置需要控制的文件或者文件夹"></a>利用json配置需要控制的文件或者文件夹</h1><pre><code>&#123;    &quot;remdir&quot;:[        &quot;data/libs/&quot;,        &quot;data/src/main/assets/&quot;        ],    &quot;copydir&quot;:[        &quot;../xarchive/android/unityLibrary/libs/&quot;,        &quot;../xarchive/android/unityLibrary/    ]&#125;</code></pre><h1 id="参数读取"><a href="#参数读取" class="headerlink" title="参数读取"></a>参数读取</h1><pre><code>if (len(sys.argv) &gt; 1):    isPAD = sys.argv[1]if(isPAD == &quot;0&quot;)    ...</code></pre><p>命令执行python脚本的时候通过读取<strong>sys.argv</strong>便可以读取到自己传入的参数，这里需要注意的是读取的都是字符串，所以笔者在读数字0的时候需要用到**”0”**。  </p><h1 id="读取Config配置文件（json）"><a href="#读取Config配置文件（json）" class="headerlink" title="读取Config配置文件（json）"></a>读取Config配置文件（json）</h1><pre><code>configFilePath = &quot;config.json&quot;;with open(configFilePath,&#39;r&#39;) as load_f:    load_dict = json.load(load_f)</code></pre><h1 id="删除目录文件或者文件夹"><a href="#删除目录文件或者文件夹" class="headerlink" title="删除目录文件或者文件夹"></a>删除目录文件或者文件夹</h1><pre><code>def path_remove(removepath):    for remdirPath in removepath:        try:            if os.path.exists(remdirPath):                if os.path.isdir(remdirPath):                    shutil.rmtree(remdirPath)                else:                    os.remove(remdirPath)                print(&quot;Remove Success: &quot;+remdirPath)        except OSError as e:            print(&quot;Error: %s : %s&quot; % (remdirPath, e.strerror))</code></pre><h1 id="复制文件或者文件夹到指定目录"><a href="#复制文件或者文件夹到指定目录" class="headerlink" title="复制文件或者文件夹到指定目录"></a>复制文件或者文件夹到指定目录</h1><pre><code>def proc_copy(old_path, new_path):    if os.path.exists(old_path):        if os.path.isdir(old_path):            shutil.copytree(old_path, new_path)        elif os.path.isfile(old_path):            shutil.copyfile(old_path, new_path)        print(&quot;Copy Success: &quot; + old_path)    else:        print(&quot;NOT FOUND: &#123;&#125;&quot;.format(old_path))def path_copy(copydir, pastedir):    for index in range(len(copydir)):        if os.path.exists(pastedir[index]):            if os.path.isdir(pastedir[index]):                shutil.rmtree(pastedir[index])        proc_copy(copydir[index],pastedir[index])</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——Android设备唯一标识</title>
      <link href="/2022/09/02/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Android%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86/"/>
      <url>/2022/09/02/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Android%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>获取设备唯一标识的方法。</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>引用库的github地址：<a href="https://github.com/gzu-liyujiang/Android_CN_OAID/tree/master"><font color="steelblue" size="5">Android_CN_OAID</font></a><br>在Android最外层的bundel.gradle里添加下面依赖  </p><pre><code>allprojects &#123;    repositories &#123;        &#39;&#39;&#39;        maven &#123; url &#39;https://www.jitpack.io&#39; &#125;        ...    &#125;&#125;</code></pre><p>在app或者library的bundel.gradle添加下面依赖  </p><pre><code>dependencies &#123;implementation &#39;com.github.gzu-liyujiang:Android_CN_OAID:&lt;version&gt;&#39;&#125;</code></pre><p><version>这里换成自己需要的版本</version></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="引用的库的初始化"><a href="#引用的库的初始化" class="headerlink" title="引用的库的初始化"></a>引用的库的初始化</h2><p>在Application或者Active的onCreate里添加下面代码：  </p><pre><code>@Overridepublic void onCreate() &#123;    super.onCreate();    if (privacyPolicyAgreed) &#123;        ...        DeviceIdentifier.register(&lt;Application&gt;);        ...    &#125;&#125;</code></pre><p><Application>这里替换成自己程序的application</Application></p><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>需要的变量： </p><pre><code>//设备唯一标识private static String deviceId;//设备唯一标识文件名字private static String deviceIdFileName = &quot;all_in_sdk&quot;;//设备唯一标识缓存关键字keyprivate static String deviceIdKey = &quot;DeviceId&quot;;//设备唯一标识正则private static final Pattern ANDROID_ID_PATTERN = Pattern.compile(&quot;^[0-9a-fA-F]&#123;16&#125;$&quot;);</code></pre><p>获取的方法：</p><pre><code>//获取设备的唯一标识public static String GetDeviceID() &#123;    if(m_Activity == null)&#123;        m_Activity = UnityPlayer.currentActivity;    &#125;    Application application = m_Activity.getApplication();    if (application == null)        return &quot;&quot;;    if (deviceId != null)        return deviceId;    deviceId = getSPValue((Context)application, deviceIdKey);    if (!TextUtils.isEmpty(deviceId))        return deviceId;    deviceId = getAndroidIdAsDeviceId((Context)application);    if (!TextUtils.isEmpty(deviceId)) &#123;        saveSPValue((Context)application, deviceIdKey, deviceId);        return deviceId;    &#125;    deviceId = generateSoftDeviceId();    if (!TextUtils.isEmpty(deviceId)) &#123;        saveSPValue((Context)application, deviceIdKey, deviceId);        return deviceId;    &#125;    return deviceId;&#125;private static String getSPValue(Context paramContext, String paramString) &#123;    SharedPreferences sharedPreferences = paramContext.getSharedPreferences(deviceIdFileName, 0);    return sharedPreferences.getString(paramString, null);&#125;private static String getAndroidIdAsDeviceId(Context paramContext) &#123;    String str;    if(DeviceID.supportedOAID(m_Activity))    &#123;        str = DeviceIdentifier.getOAID(m_Activity);        if (isLegalAndroidId(str, true))            return str;    &#125;    str = DeviceIdentifier.getAndroidID(m_Activity);    if (isLegalAndroidId(str, true))        return str;    str = DeviceIdentifier.getIMEI(m_Activity);    if (isLegalAndroidId(str, true))        return str;    str = DeviceIdentifier.getWidevineID();    if (isLegalAndroidId(str, true))        return str;    str = DeviceIdentifier.getPseudoID();    if (isLegalAndroidId(str, true))        return str;    str = DeviceIdentifier.getGUID(m_Activity);    if (isLegalAndroidId(str, true))        return str;    return null;&#125;private static String generateSoftDeviceId() &#123;    String str1 = Build.SERIAL;    String str2 = !TextUtils.isEmpty(str1) ? str1 : &quot;NA&quot;;    try &#123;        long l1 = 1152921504606846976L;        long l2 = randomLong(Long.MAX_VALUE - l1) + l1;        return String.format(&quot;%1$s_%2$s&quot;, new Object[] &#123; Long.toHexString(l2), str2 &#125;);    &#125; catch (Throwable throwable) &#123;        return String.format(&quot;%1$s_%2$s&quot;, new Object[] &#123; &quot;NA&quot; + Long.toHexString(System.currentTimeMillis()), str2 &#125;);    &#125;&#125;private static void saveSPValue(Context paramContext, String paramString1, String paramString2) &#123;    SharedPreferences sharedPreferences = paramContext.getSharedPreferences(deviceIdFileName, 0);    sharedPreferences.edit().putString(paramString1, paramString2).apply();&#125;private static long randomLong(long paramLong) &#123;    if (Build.VERSION.SDK_INT &gt;= 21)        return ThreadLocalRandom.current().nextLong(paramLong);    return (long)((new Random()).nextDouble() * (paramLong - 1L));&#125;private static boolean isLegalAndroidId(String paramString, boolean paramBoolean) &#123;    if (paramBoolean)        return (!TextUtils.isEmpty(paramString) &amp;&amp; ANDROID_ID_PATTERN                .matcher(paramString).find());    return (!TextUtils.isEmpty(paramString) &amp;&amp; ANDROID_ID_PATTERN            .matcher(paramString).find());&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——UI父节点随子节点自适应</title>
      <link href="/2022/08/24/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UI%E7%88%B6%E8%8A%82%E7%82%B9%E9%9A%8F%E5%AD%90%E8%8A%82%E7%82%B9%E8%87%AA%E9%80%82%E5%BA%94/"/>
      <url>/2022/08/24/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UI%E7%88%B6%E8%8A%82%E7%82%B9%E9%9A%8F%E5%AD%90%E8%8A%82%E7%82%B9%E8%87%AA%E9%80%82%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在UI的开发过程中，经常会遇到Image随子节点的文字变化自动缩放，就是拿Image当背景。笔者遇到这种问题每次都是利用Layout+Content Size Fitter来完成的，笔者想了想每次都要加两个组件，并且Layout只用到了随自己点自适应的功能，于是笔者便想办法把两个功能合成一个脚本来实现需求，于是便有了下面的脚本。  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>代码如下： </p><pre><code>using System;using UnityEngine;using UnityEngine.EventSystems;using UnityEngine.UI;/// &lt;summary&gt;/// 未完成，暂时别用/// &lt;/summary&gt;[AddComponentMenu(&quot;Layout/Rect Transform Fitter&quot;, 142)][ExecuteAlways][RequireComponent(typeof(RectTransform))]public class RectTransformFit : UIBehaviour, ILayoutGroup&#123;    [SerializeField] protected RectTransform m_RectChildren;    [SerializeField] protected RectOffset m_Padding = new RectOffset();    [SerializeField] protected TextAnchor m_ChildAlignment = TextAnchor.UpperLeft;    [SerializeField] protected bool m_ChildControlWidth = false;    [SerializeField] protected bool m_ChildControlHeight = false;    [SerializeField] protected ContentSizeFitter.FitMode m_HorizontalFit = ContentSizeFitter.FitMode.Unconstrained;    [SerializeField] protected ContentSizeFitter.FitMode m_VerticalFit = ContentSizeFitter.FitMode.Unconstrained;    public RectOffset padding    &#123;        get =&gt; m_Padding;        set =&gt; SetProperty(ref m_Padding, value);    &#125;    public TextAnchor childAlignment &#123; get =&gt; m_ChildAlignment;        set =&gt; SetProperty(ref m_ChildAlignment, value);    &#125;    public bool childControlWidth    &#123;        get =&gt; m_ChildControlWidth;        set =&gt; SetProperty(ref m_ChildControlWidth, value);    &#125;    public bool childControlHeight    &#123;        get =&gt; m_ChildControlHeight;        set =&gt; SetProperty(ref m_ChildControlHeight, value);    &#125;    public ContentSizeFitter.FitMode horizontalFit    &#123;        get =&gt; m_HorizontalFit;        set        &#123;            if (SetPropertyUtility.SetStruct(ref m_HorizontalFit, value)) SetDirty();        &#125;    &#125;    public ContentSizeFitter.FitMode verticalFit    &#123;        get =&gt; m_VerticalFit;        set        &#123;            if (SetPropertyUtility.SetStruct(ref m_VerticalFit, value)) SetDirty();        &#125;    &#125;    [NonSerialized] private RectTransform m_Rect;    protected RectTransform rectTransform    &#123;        get        &#123;            if (m_Rect == null)                m_Rect = GetComponent&lt;RectTransform&gt;();            return m_Rect;        &#125;    &#125;#pragma warning disable 649    private DrivenRectTransformTracker m_Tracker;#pragma warning restore 649    private void OnEnable()    &#123;        m_Rect ??= GetComponent&lt;RectTransform&gt;();        SetDirty();    &#125;    protected override void OnRectTransformDimensionsChange()    &#123;        SetDirty();    &#125;    protected override void OnDisable()    &#123;        m_Tracker.Clear();        base.OnDisable();    &#125;    /// &lt;summary&gt;    /// Calculate and apply the horizontal component of the size to the RectTransform    /// &lt;/summary&gt;    public void SetLayoutHorizontal()    &#123;        m_Tracker.Clear();        if (m_RectChildren == null || !m_ChildControlWidth)        &#123;            SetDirty();            return;        &#125;        HandleSelfFittingAlongAxis(0, m_RectChildren);    &#125;    /// &lt;summary&gt;    /// Calculate and apply the vertical component of the size to the RectTransform    /// &lt;/summary&gt;    public void SetLayoutVertical()    &#123;        if (m_RectChildren == null || !m_ChildControlHeight)        &#123;            SetDirty();            return;        &#125;        HandleSelfFittingAlongAxis(1, m_RectChildren);    &#125;    private void HandleSelfFittingAlongAxis(int axis, RectTransform rectChild)    &#123;        if (rectChild == null) return;        var fitting = (axis == 0 ? horizontalFit : verticalFit);        if (fitting == ContentSizeFitter.FitMode.Unconstrained)        &#123;            // Keep a reference to the tracked transform, but don&#39;t control its properties:            m_Tracker.Add(this, rectChild, DrivenTransformProperties.None);            return;        &#125;        m_Tracker.Add(this, rectChild,            (axis == 0 ? DrivenTransformProperties.SizeDeltaX : DrivenTransformProperties.SizeDeltaY));        // Set size to min or preferred size        rectChild.SetSizeWithCurrentAnchors((RectTransform.Axis)axis,            fitting == ContentSizeFitter.FitMode.MinSize                ? LayoutUtility.GetMinSize(rectChild, axis)                : LayoutUtility.GetPreferredSize(rectChild, axis));        SetDirty();    &#125;    /// &lt;summary&gt;    /// Helper method used to set a given property if it has changed.    /// &lt;/summary&gt;    /// &lt;param name=&quot;currentValue&quot;&gt;A reference to the member value.&lt;/param&gt;    /// &lt;param name=&quot;newValue&quot;&gt;The new value.&lt;/param&gt;    protected void SetProperty&lt;T&gt;(ref T currentValue, T newValue)    &#123;        if ((currentValue == null &amp;&amp; newValue == null) || (currentValue != null &amp;&amp; currentValue.Equals(newValue)))            return;        currentValue = newValue;        SetDirty();    &#125;    protected void SetDirty()    &#123;        if (!IsActive())            return;        RefreshRect();        LayoutRebuilder.MarkLayoutForRebuild(m_RectChildren);        LayoutRebuilder.MarkLayoutForRebuild(m_Rect);    &#125;    public void RefreshRect()    &#123;        if (m_RectChildren == null) return;        Vector2 anchoredPos;        var childSize = m_RectChildren.sizeDelta;        var width = childSize.x + padding.left + padding.right;        var height = childSize.y + padding.top + padding.bottom;        var rectSize = rectTransform.sizeDelta;        if (horizontalFit != ContentSizeFitter.FitMode.Unconstrained &amp;&amp;            verticalFit != ContentSizeFitter.FitMode.Unconstrained)        &#123;            rectTransform.sizeDelta = new Vector2(width, height);        &#125;        else if (horizontalFit != ContentSizeFitter.FitMode.Unconstrained)        &#123;            rectTransform.sizeDelta = new Vector2(width, rectSize.y);        &#125;        else if (verticalFit != ContentSizeFitter.FitMode.Unconstrained)        &#123;            rectTransform.sizeDelta = new Vector2(rectSize.x, height);        &#125;        rectSize = rectTransform.sizeDelta;        var oldPos = rectTransform.anchoredPosition;        var oldPivot = rectTransform.pivot;        switch (m_ChildAlignment)        &#123;            case TextAnchor.UpperLeft:                rectTransform.pivot = new Vector2(0, 1);                anchoredPos = new Vector2(padding.left, -padding.top);                break;            case TextAnchor.UpperCenter:                rectTransform.pivot = new Vector2(0.5f, 1);                anchoredPos = new Vector2(0, -padding.top);                break;            case TextAnchor.UpperRight:                rectTransform.pivot = new Vector2(1, 1);                anchoredPos = new Vector2(-padding.right, -padding.top);                break;            case TextAnchor.MiddleLeft:                rectTransform.pivot = new Vector2(0, 0.5f);                anchoredPos = new Vector2(padding.left, 0);                break;            case TextAnchor.MiddleCenter:                rectTransform.pivot = new Vector2(0.5f, 0);                anchoredPos = new Vector2(0, 0);                break;            case TextAnchor.MiddleRight:                rectTransform.pivot = new Vector2(1, 0);                anchoredPos = new Vector2(-padding.right, 0);                break;            case TextAnchor.LowerLeft:                rectTransform.pivot = new Vector2(0, 0);                anchoredPos = new Vector2(padding.left, padding.bottom);                break;            case TextAnchor.LowerCenter:                rectTransform.pivot = new Vector2(0.5f, 0);                anchoredPos = new Vector2(0, padding.bottom);                break;            case TextAnchor.LowerRight:                rectTransform.pivot = new Vector2(1, 0);                anchoredPos = new Vector2(-padding.right, padding.bottom);                break;            default:                throw new ArgumentOutOfRangeException();        &#125;        var pivot = rectTransform.pivot;        rectTransform.anchoredPosition = new Vector2(oldPos.x + rectSize.x * (pivot.x - oldPivot.x),            oldPos.y + rectSize.y * (pivot.y - oldPivot.y));        m_RectChildren.anchorMax = pivot;        m_RectChildren.anchorMin = pivot;        m_RectChildren.pivot = pivot;        m_RectChildren.anchoredPosition = anchoredPos;    &#125;#if UNITY_EDITOR    protected override void OnValidate()    &#123;        SetDirty();    &#125;#endif&#125;</code></pre><h1 id="需要支持的脚本（源码抄来的SetPropertyUtility）"><a href="#需要支持的脚本（源码抄来的SetPropertyUtility）" class="headerlink" title="需要支持的脚本（源码抄来的SetPropertyUtility）"></a>需要支持的脚本（源码抄来的SetPropertyUtility）</h1><pre><code>using System;using System.Collections.Generic;using UnityEngine;internal static class SetPropertyUtility&#123;    private const float Tolerance = 0.000001f;                 //通过此值判断值是否发生变化    public static bool SetColor(ref Color currentValue, Color newValue)    &#123;        if (Math.Abs(currentValue.r - newValue.r) &lt; Tolerance &amp;&amp;            Math.Abs(currentValue.g - newValue.g) &lt; Tolerance &amp;&amp;            Math.Abs(currentValue.b - newValue.b) &lt; Tolerance &amp;&amp;            Math.Abs(currentValue.a - newValue.a) &lt; Tolerance)            return false;        currentValue = newValue;        return true;    &#125;    public static bool SetStruct&lt;T&gt;(ref T currentValue, T newValue) where T : struct    &#123;        if (EqualityComparer&lt;T&gt;.Default.Equals(currentValue, newValue))            return false;        currentValue = newValue;        return true;    &#125;    public static bool SetClass&lt;T&gt;(ref T currentValue, T newValue) where T : class    &#123;        if ((currentValue == null &amp;&amp; newValue == null) || (currentValue != null &amp;&amp; currentValue.Equals(newValue)))            return false;        currentValue = newValue;        return true;    &#125;&#125;</code></pre><h1 id="编辑器显示Editor代码"><a href="#编辑器显示Editor代码" class="headerlink" title="编辑器显示Editor代码"></a>编辑器显示Editor代码</h1><p>代码如下： </p><pre><code>using System;using UnityEditor;using UnityEditor.UI;using UnityEngine;[CustomEditor(typeof(RectTransformFit))]public class RectTransformFitEditor : SelfControllerEditor&#123;    SerializedProperty m_Padding;    SerializedProperty m_ChildAlignment;    SerializedProperty m_RectChildren;    SerializedProperty m_HorizontalFit;    SerializedProperty m_VerticalFit;    SerializedProperty m_ChildControlWidth;    SerializedProperty m_ChildControlHeight;    protected void OnEnable()    &#123;        m_Padding = serializedObject.FindProperty(&quot;m_Padding&quot;);        m_ChildAlignment = serializedObject.FindProperty(&quot;m_ChildAlignment&quot;);        m_RectChildren = serializedObject.FindProperty(&quot;m_RectChildren&quot;);        m_ChildControlWidth = serializedObject.FindProperty(&quot;m_ChildControlWidth&quot;);        m_ChildControlHeight = serializedObject.FindProperty(&quot;m_ChildControlHeight&quot;);        m_HorizontalFit = serializedObject.FindProperty(&quot;m_HorizontalFit&quot;);        m_VerticalFit = serializedObject.FindProperty(&quot;m_VerticalFit&quot;);    &#125;    public override void OnInspectorGUI()    &#123;        serializedObject.Update();        EditorGUILayout.PropertyField(m_Padding, true);        EditorGUILayout.PropertyField(m_ChildAlignment, true);        EditorGUILayout.PropertyField(m_RectChildren, true);        Rect rect = EditorGUILayout.GetControlRect();        rect = EditorGUI.PrefixLabel(rect, -1, EditorGUIUtility.TrTextContent(&quot;Control Child Size&quot;));        rect.width = Mathf.Max(50, (rect.width - 4) / 3);        EditorGUIUtility.labelWidth = 50;        ToggleLeft(rect, m_ChildControlWidth, EditorGUIUtility.TrTextContent(&quot;Width&quot;));        rect.x += rect.width + 2;        ToggleLeft(rect, m_ChildControlHeight, EditorGUIUtility.TrTextContent(&quot;Height&quot;));        EditorGUIUtility.labelWidth = 0;        EditorGUILayout.PropertyField(m_HorizontalFit, true);        EditorGUILayout.PropertyField(m_VerticalFit, true);        serializedObject.ApplyModifiedProperties();    &#125;    void ToggleLeft(Rect position, SerializedProperty property, GUIContent label)    &#123;        bool toggle = property.boolValue;        EditorGUI.showMixedValue = property.hasMultipleDifferentValues;        EditorGUI.BeginChangeCheck();        int oldIndent = EditorGUI.indentLevel;        EditorGUI.indentLevel = 0;        toggle = EditorGUI.ToggleLeft(position, label, toggle);        EditorGUI.indentLevel = oldIndent;        if (EditorGUI.EndChangeCheck())        &#123;            property.boolValue = property.hasMultipleDifferentValues || !property.boolValue;        &#125;        EditorGUI.showMixedValue = false;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo图床图片无法显示</title>
      <link href="/2022/08/20/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/hexo%E5%9B%BE%E5%BA%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/"/>
      <url>/2022/08/20/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/hexo%E5%9B%BE%E5%BA%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>今天更新自己博客的时候发现新博客的图片都无法显示，这个听说只存在于没有域名的博客中，笔者因为没有域名，所以不清除是不是。  </p><blockquote><p>图床：gitee<br>博客：github+hexo<br>原因猜测：gitee开始对图床进行限制，没有域名的博客也访问不到图床的图片  </p></blockquote><p>#解决方法 </p><h2 id="方法一（不推荐）"><a href="#方法一（不推荐）" class="headerlink" title="方法一（不推荐）"></a>方法一（不推荐）</h2><p>最快捷的解决方案就是再自己博客的文章开头加上下面代码   </p><pre><code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</code></pre><p>看下面举例  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1660990253369-2022-8-2018:10:54.png"></p><h2 id="方法二（推荐）"><a href="#方法二（推荐）" class="headerlink" title="方法二（推荐）"></a>方法二（推荐）</h2><p>在自己播放的主题文件加里直接加上就不需要了，具体路径：<br>拿3-hexo主题举例：<br>在**…\themes\3-hexo\layout_partial\header.ejs**文件里加入刚才的代码，如下：  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1660990452909-2022-8-2018:14:13.png">  </p><p>其他主题文件在类似位置：<strong>hexo\themes...\layout_partial\head.ejs</strong><br>其他主题的文件名字应该叫：<strong>head.ejs</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——Unity的Animation无法播放</title>
      <link href="/2022/08/20/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Unity%E7%9A%84Animation%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE/"/>
      <url>/2022/08/20/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Unity%E7%9A%84Animation%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>笔者再开发过程中，有个功能需求是在游戏中移动Camera，笔者采用了两种方式，第一种是K动画用动画播放，另一种是用曲线表示运动节奏直线运动。第二种方式和本文无关，主要阐述第一种方式在播放Animation的时候无法播放的问题。  </p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者采用的是Animation的方式播放动画，笔者并未采用Animator，是在游戏中进行动态添加Animation组件，然后根据资源名字动态加载动画资源进行播放，下面是案例代码：  </p><pre><code>public float LookAtAnim(string animName)&#123;    if (!m_Transfrom.TryGetComponent(out Animation animation))    &#123;        animation = m_Transfrom.gameObject.AddComponent&lt;Animation&gt;();    &#125;    var clip = animation.GetClip(animName);    if (clip == null)    &#123;        clip = ResManager.LoadAsset&lt;AnimationClip&gt;(animName);        animation.AddClip(clip, animName);    &#125;    animation.clip = clip;    animation.Play(animName);    return clip.length;&#125;</code></pre><p>但是笔者在运行过程中发现编辑器并不能正常播放动画，通过断点调试，笔者发现在添加动画clip的时候并不能添加到Animation的clip列表里，于是笔者通过各种百度，谷歌等搜索发现需要打开Animation的legacy，修改后的代码如下：</p><pre><code>public float LookAtAnim(string animName)&#123;    ...    if (clip == null)    &#123;        clip = ResManager.LoadAsset&lt;AnimationClip&gt;(animName);        clip.legacy = true;        animation.AddClip(clip, animName);    &#125;    ...&#125;</code></pre><p>这时候动画播放正常了，但是笔者打包成apk后，在模拟器上依旧无法正常播放，笔者打印日志发现动画都正常添加了，于是笔者便尝试解决问题。  </p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>笔者思考**clip.legacy &#x3D; true;**这行代码的作用，于是笔者发现有可能是动画的问题，首先打开inspector的debug模式   </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1660979445735-2022-8-2015:10:46.png"><br>然后发现有些动画的Legacy是打开的，有些是关闭的，于是笔者都手动打开了  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1660979791351-2022-8-2015:16:31.png"><br>发现模拟器依旧没办法播放，最后发现真机上只需要把这个关闭就可以了。<br>笔者最终抛弃了Animation的方法，因为还需要手动加载资源，笔者采用了Animator的方式进行播放。代码如下：  </p><pre><code>/// &lt;summary&gt;/// 播放相机动画/// &lt;/summary&gt;/// &lt;param name=&quot;animName&quot;&gt;动画名字&lt;/param&gt;public float LookAtAnim(string animName)&#123;    SetAnimatorVisible(true);    m_Animator.Play(animName);    return (from animationClip in m_Animator.runtimeAnimatorController.animationClips        where animationClip.name == animName        select animationClip.length).FirstOrDefault();&#125;public void SetAnimatorVisible(bool visible)&#123;    if (m_Animator != null &amp;&amp; m_Animator.enabled == visible) return;    if(visible)    &#123;        if(m_Animator == null)        &#123;            m_Animator = m_Transfrom.gameObject.AddComponent&lt;Animator&gt;();            m_Animator.runtimeAnimatorController =                ResManager.LoadAsset&lt;RuntimeAnimatorController&gt;(TableGlobal.CameraController);        &#125;        else        &#123;            m_Animator.enabled = true;        &#125;    &#125;    else if (m_Animator != null)    &#123;        m_Animator.DOKill();        m_Animator.enabled = false;    &#125;&#125;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>切记要把动画资源的Legacy关闭，否则Animator也无法播放动画片段</strong></p>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Animation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——根据条件禁用编辑器菜单</title>
      <link href="/2022/03/24/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E7%A6%81%E7%94%A8%E7%BC%96%E8%BE%91%E5%99%A8%E8%8F%9C%E5%8D%95/"/>
      <url>/2022/03/24/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E7%A6%81%E7%94%A8%E7%BC%96%E8%BE%91%E5%99%A8%E8%8F%9C%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>unity编辑器扩展菜单功能是我们开发中经常使用的，笔者在开发过程中想在特定条件下在启用指定的菜单，不满足条件的时候就禁用菜单，于是笔者找到了解决的办法。  </p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><pre><code>[MenuItem(&quot;Assets/MyMenuTest&quot;, false, 81)]public static void MyMenuTest()&#123;    //菜单执行事件&#125;[MenuItem(&quot;Assets/MyMenuTest&quot;, true)]public static bool IsShowMyMenu()&#123;    //获取自己的条件并return条件即可    return false;&#125;</code></pre><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1648103657696-2022-3-2414:34:18.png">  </p><p>只需要保证MenuItem的菜单路径一样的，把第二个参数改为true代表的是否是控制一个验证函数，根据自己的条件进行返回即可控制。   </p><p>下面是官网给的参数设置<br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1648103567771-2022-3-2414:32:48.png"></p>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——自动创建asset资源文件</title>
      <link href="/2022/03/21/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BAasset%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/"/>
      <url>/2022/03/21/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BAasset%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Unity保存数据的方式有很多，比如我们经常用的json，xml和Txt，笔者今天讲到的是另外一种保存方式，asset文件，这个是unity提供的一种新的保存数据的方式，笔者也是刚使用没多久，这里就不详细进行介绍了，笔者今天主要是介绍一键自动创建对应的asset文件。  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code> public class CreateAssetEditor&#123;    [MenuItem(&quot;Assets/Create/CreateAsset&quot;,false,81)]    public static void OnCreateAsset()    &#123;        foreach (var guid in Selection.assetGUIDs)        &#123;            var path = AssetDatabase.GUIDToAssetPath(guid);            var pathSplit = path.Split(&#39;/&#39;);            var className = pathSplit[pathSplit.Length - 1].Replace(&quot;.cs&quot;, &quot;&quot;);            var classType = GetClassByClassName(className);            var assetPath = path.Replace(&quot;.cs&quot;, &quot;.asset&quot;);            if (File.Exists(assetPath))            &#123;                LBLogWrapper.Error(&quot;创建失败，资源已经存在&quot;);            &#125;            else if (classType != null)             &#123;                var classInst = ScriptableObject.CreateInstance(classType);                AssetDatabase.CreateAsset(classInst,assetPath);            &#125;            else            &#123;                LBLogWrapper.Error(&quot;创建失败，脚本不可创建&quot;);            &#125;        &#125;    &#125;        [MenuItem(&quot;Assets/Create/CreateAsset&quot;,true)]    private static bool IsValidateFun()    &#123;        return (from guid in Selection.assetGUIDs            select AssetDatabase.GUIDToAssetPath(guid)            into path            select path.Split(&#39;/&#39;)            into pathSplit            select pathSplit[pathSplit.Length - 1]).Any(className =&gt; className.Contains(&quot;.cs&quot;));    &#125;    /// &lt;summary&gt;    /// 通过类名获取对应的类    /// &lt;/summary&gt;    /// &lt;param name=&quot;className&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    private static Type GetClassByClassName(string className)    &#123;        var allAssemblies = AppDomain.CurrentDomain.GetAssemblies();        return allAssemblies.SelectMany(assembly =&gt; assembly.GetTypes()).FirstOrDefault(type =&gt;            type.Name == className &amp;&amp; type.IsSubclassOf(typeof(ScriptableObject)));    &#125;&#125;</code></pre><p>脚本的原理很简单，就是获取当前选择的脚本，判断是否可以创建asset文件，如果可以就是通过类名获取对应的类对象和，这里需要注意的是，<font color="red">文件名字必须等于类名</font>，然后通过类名获取对应的类型，就可以生成对应的asset文件了。</p>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> asset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——通过类名获取对应的Type</title>
      <link href="/2022/03/11/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E7%B1%BB%E5%90%8D%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E7%9A%84Type/"/>
      <url>/2022/03/11/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E7%B1%BB%E5%90%8D%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E7%9A%84Type/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者在编辑器开发过程中遇到一个问题，笔者想通过一个类的名字获取对应的类的Type然后再做一系列的操作，但是笔者发现无法直接获取，于是笔者通过不断的尝试通过下面的方法获取到了，如果有更好的方法欢迎告诉笔者。  </p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>话不多说，先上代码：  </p><pre><code>[MenuItem(&quot;Assets/GetType&quot;,false,81)]public static void GetClassTypeByClassTypeName()&#123;    const string className = &quot;TestScripts&quot;;    //方法一（在同一程序集内并且非自身Class才能获取到）    var type = Type.GetType(className);    Debug.LogError(type);        var allAssemblies = AppDomain.CurrentDomain.GetAssemblies();        //方法二（有特殊情况会获取不到，笔者没找到获取不到的原因）    type = allAssemblies.Select(assembly =&gt; assembly.GetType(className)).FirstOrDefault(assembly =&gt; assembly != null);    Debug.LogError(type);        //方法三（如果存在类重名的情况有概率获取错误，可以通过路径做限制）    type = allAssemblies.SelectMany(assembly =&gt; assembly.GetTypes()).FirstOrDefault(type1 =&gt; type1.Name == className);    Debug.LogError(type);&#125;</code></pre><p>运行结果如下  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1646985481130-2022-3-1115:58:02.png">  </p><p>方法一和方法二的获取条件都有限制，因此笔者建议使用方法三进行获取。  </p><h1 id="获取方式讲解"><a href="#获取方式讲解" class="headerlink" title="获取方式讲解"></a>获取方式讲解</h1><p>方法一是直接在当前程序集进行获取的。<br>方法二是通过遍历当前程序的所有程序集，然后通过程序集直接GetType进行获取<br>方法三是类似于方法二，得到所有的程序集再遍历程序集中的Type，判断名字是否相同来得到对应的Type</p>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——按行删除字符串</title>
      <link href="/2022/03/10/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/03/10/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>笔者在项目开发过程中需要做一个聊天的假数据显示，是用于demo的，于是笔者就直接用string字符串来模拟显示的数据，但是当聊天内容过多的时候就需要删除历史的聊天内容，于是笔者就想按照行数删除字符串，发现string并不包含这种接口，于是写下了下面的代码。  </p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><pre><code>private static string DeleteStrLine(string text, int startLine, int lineCount)&#123;    var curIndex = 0;    int? remStartIndex = null;    var sum = 1;    while (sum &lt; startLine + lineCount)     &#123;        if (sum == startLine) remStartIndex = curIndex;                curIndex = text.IndexOf(&quot;\n&quot;, curIndex, StringComparison.Ordinal);        if (curIndex &lt; 0)        &#123;            curIndex = text.Length;            break;        &#125;        curIndex++;        sum++;    &#125;    if (remStartIndex == null)    &#123;        return text;    &#125;    text = text.Remove(remStartIndex.Value, curIndex - remStartIndex.Value);    return text;&#125;</code></pre><p>上述代码是笔者的解决方案，原理很简单，遍历查找字符串的换行字符**”\n”**,然后记录下索引，根据传入的需要删除的行数找到对应的索引，最后使用Remove函数按照开始和结束的索引进行删除。  </p>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>StarUML使用笔记</title>
      <link href="/2022/03/04/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/StarUML%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/04/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/StarUML%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="图操作菜单"><a href="#图操作菜单" class="headerlink" title="图操作菜单"></a>图操作菜单</h1><h2 id="Add-Diagram"><a href="#Add-Diagram" class="headerlink" title="Add Diagram"></a>Add Diagram</h2><pre><code>Class Diagram                   类图Package Diagram                 包图Object Diagram                  对象图Composite Structure Diagram     复合结构图Component Diagram               组件图Deployment Diagram              展开图Use Case Diagram                用例图Sequence Diagram                时序图Communication Diagram           交流图Statechart Diagram              状态图Activity Diagram                活动图Profile DiagramER Diagram                      E-R图Flowchart Diagram               流程图Data Flow Diagram               数据流程图</code></pre><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><pre><code>Tempalate Parameter     模板参数Attribute               属性Port                    端口Operation               操作Reception               接待Class                   类Interface               接口Signal                  信号DataType                数据类型PrimitiveType           原始类型Enumeration             枚举Artifact                工件Component               组件Node                    节点UseCaseActorInformationItemCollaborationInteraction             交互State Machine           状态机Activity                活动Opaque Behavior         不透明树Constraint              约束Requirement             要求Block                   块Value Type              数值类型Interface Block         接口块Constraint Block        约束快Tag                     标签</code></pre><h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1646381948452-2022-3-416:19:09.png">   </p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——String按行删除</title>
      <link href="/2022/03/03/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94string%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4/"/>
      <url>/2022/03/03/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94string%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在unity开发过程中，如果一个string字符串有多行，如果我们想删除前面一行或者多行应该如何操作？  </p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><pre><code>private static string DeleteStrLine(string text, int startLine, int lineCount)&#123;    var curIndex = 0;    int? remStartIndex = null;    var sum = 1;    while (sum &lt; startLine + lineCount)     &#123;        if (sum == startLine) remStartIndex = curIndex;                curIndex = text.IndexOf(&quot;\n&quot;, curIndex, StringComparison.Ordinal);        if (curIndex &lt; 0)        &#123;            curIndex = text.Length;            break;        &#125;        curIndex++;        sum++;    &#125;    if (remStartIndex == null)    &#123;        return text;    &#125;    text = text.Remove(remStartIndex.Value, curIndex - remStartIndex.Value);    return text;&#125;</code></pre><p>思路就是通过<strong>IndexOf</strong>函数遍历找到需要删除的行对应的”\n”(换行)的索引，然后再通过<strong>Remove</strong>函数对开始和结束的索引进行删除。</p>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity笔记</title>
      <link href="/2022/03/03/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Unity%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/03/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Unity%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p><strong>[Conditional(“XXX”)]</strong>: 指定XXX宏下进行编译<br><strong>[RuntimeInitializeOnLoadMethod]</strong>:游戏运行是就执行的方法</p>]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——扩展Inspector面板(二)</title>
      <link href="/2022/02/23/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95Inspector%E9%9D%A2%E6%9D%BF(%E4%BA%8C)/"/>
      <url>/2022/02/23/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95Inspector%E9%9D%A2%E6%9D%BF(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>上次笔者讲解了如何自定义Inspector面板的显示，但是这里还有一个问题，就是对于支持的字段我们可以绘制对应的属性，但是有些字段我们并不支持绘制，比如一些类定义的变量，我们又改如何绘制？下面笔者介绍一下如何绘制一些本身不支持的字段。  </p><h1 id="自定义绘制Inspector"><a href="#自定义绘制Inspector" class="headerlink" title="自定义绘制Inspector"></a>自定义绘制Inspector</h1><p>笔者依旧拿笔者写的动画编辑器作为案例来进行讲解。  </p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>存放文件的目录如下  </p><blockquote><p>—Asset<br>——Scripts<br>———Editor<br>————UIAnimManagerEditor.cs<br>————<font color="#00FF00">UIAnimTransformInfoEditor.cs</font><br>———Engine<br>————UIAnimManager.cs<br>————<font color="#00FF00">UIAnimInfoBase.cs</font><br>————<font color="#00FF00">UIAnimTransformInfo.cs</font>  </p></blockquote><h2 id="创建一个Transform的信息的类（UIAnimTransformInfo）"><a href="#创建一个Transform的信息的类（UIAnimTransformInfo）" class="headerlink" title="创建一个Transform的信息的类（UIAnimTransformInfo）"></a>创建一个Transform的信息的类（UIAnimTransformInfo）</h2><p>为了方便我们可以绘制动画信息在Inspector面板上，我们需要在信息类上加上**[Serializable]**标签方便我们序列化</p><pre><code>[Serializable]public class UIAnimTransformInfo&#123;        public Transform m_Transform;&#125;</code></pre><p>然后我们在UIAnimManager上添加我们的信息就可以了</p><pre><code>public class UIAnimManager : MonoBehaviour&#123;    public float m_SumTime;                                                     //总时间    public bool m_IsDefReversed;                                                //默认的是否倒放    public bool m_IsDefLoop;                                                    //默认的是否循环    public bool m_IsDefAutoPlay;                                                //默认的是否自动播放    public UIAnimTransformInfo m_UIAnimTransformInfo;                           //Transform动画信息        [NonSerialized]    public float m_CurTime;                                                     //当前时间    [NonSerialized]    public UIAnimPlayState m_UIAnimPlayState = UIAnimPlayState.Stop;            //当前状态    &#125;</code></pre><h2 id="默认绘制类中类对象的Inspector面板"><a href="#默认绘制类中类对象的Inspector面板" class="headerlink" title="默认绘制类中类对象的Inspector面板"></a>默认绘制类中类对象的Inspector面板</h2><p>我们可以通过绘制属性的方式直接绘制我们的变量，代码如下：  </p><pre><code>EditorGUILayout.PropertyField(m_UIAnimTransformInfo);</code></pre><p>效果如下：  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1645698365713-2022-2-2418:26:06.png">  </p><p>这个绘制是unity默认的绘制。  </p><h2 id="自定义绘制类中类对象的Inspector面板"><a href="#自定义绘制类中类对象的Inspector面板" class="headerlink" title="自定义绘制类中类对象的Inspector面板"></a>自定义绘制类中类对象的Inspector面板</h2><p>如果我们类中的对象不想使用自定义的绘制，我们可以采用CustomPropertyDrawer这个属性标签来绑定我们类的绘制编辑器类。<br>代码如下  </p><pre><code>[CustomPropertyDrawer(typeof(UIAnimTransformInfo))]public class UIAnimTransformInfoEditor : PropertyDrawer&#123;    /// &lt;summary&gt;    /// 获取属性绘制的高度    /// &lt;/summary&gt;    /// &lt;param name=&quot;property&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;label&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public override float GetPropertyHeight(SerializedProperty property, GUIContent label)    &#123;        return EditorGUI.GetPropertyHeight(property);    &#125;    /// &lt;summary&gt;    /// 绘制自定义的面板    /// &lt;/summary&gt;    /// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;property&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;label&quot;&gt;&lt;/param&gt;    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)    &#123;            &#125;&#125;</code></pre><p>上述代码中，GetPropertyHeight函数是用来设置绘制面板的高度的，然后OnGUI的函数是写自定义的绘制的。  </p><font size="5" color="FF0000">提示：   在GetPropertyHeight函数离，如果类比较复杂，通过EditorGUI.GetPropertyHeight(property)获取的高度会出错，最好把属性里的需要绘制的字段分别获取高度再加一起返回。  在OnGUI函数里绘制的时候不能采用GUILayout和EditorGuiLayout的绘制方式，因为这个是给Rect进行绘制的，每次绘制的时候只需要计算宽度，然后绘制后坐标再自己移动绘制下一个。举例代码如下：</font>  <pre><code>/// &lt;summary&gt;/// 绘制单个可滑动的列表/// &lt;/summary&gt;/// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;property&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;uiReorderableList&quot;&gt;&lt;/param&gt;public static void OnReorderableListPropertyItemGUI(ref Rect position, SerializedProperty property,ReorderableList uiReorderableList)&#123;    position.height = GetReorderableListHeight(property);    uiReorderableList.DoList(position);    position.y += position.height;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——扩展Inspector面板(一)</title>
      <link href="/2022/02/18/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95Inspector%E9%9D%A2%E6%9D%BF(%E4%B8%80)/"/>
      <url>/2022/02/18/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95Inspector%E9%9D%A2%E6%9D%BF(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在使用unity的时候我们会经常使用到inspector面板来查看我们选中对象的信息，也会经常修改一些信息，但是，untiy默认的指挥显示我们组件上序列化的信息，也并不是所有的序列化的信息都显示，我们只需要添加**[HideInInspector]**标签就可以隐藏信息。但是这些并不能满足我们修改信息的需求，unity也为我们提供了自动绘制面板，这样我们不仅仅有修改字段的功能，还可以添加更多的功能了。  </p><h1 id="自定义绘制Inspector"><a href="#自定义绘制Inspector" class="headerlink" title="自定义绘制Inspector"></a>自定义绘制Inspector</h1><p>笔者是以自己写的一个UI的动画控制器为例来讲解的。  </p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>存放文件的目录如下  </p><blockquote><p>—Asset<br>——Scripts<br>———Editor<br>————UIAnimManagerEditor.cs<br>———Engine<br>————UIAnimManager.cs  </p></blockquote><h2 id="组件脚本"><a href="#组件脚本" class="headerlink" title="组件脚本"></a>组件脚本</h2><p>首先我们先创建一个需要绘制的脚本：  </p><pre><code>/// &lt;summary&gt;/// 动画播放状态/// &lt;/summary&gt;public enum UIAnimPlayState&#123;    Stop,                   //停止    Playing,                //播放中    Pause,                  //暂停    Finish,                 //完成&#125;/// &lt;summary&gt;/// 动画播放控制器/// &lt;/summary&gt;public class UIAnimManager : MonoBehaviour&#123;    public float m_SumTime;                                                     //总时间    public bool m_IsDefReversed;                                                //默认的是否倒放    public bool m_IsDefLoop;                                                    //默认的是否循环    public bool m_IsDefAutoPlay;                                                //默认的是否自动播放        [NonSerialized]    public float m_CurTime;                                                     //当前时间    [NonSerialized]    public UIAnimPlayState m_UIAnimPlayState = UIAnimPlayState.Stop;            //当前状态&#125;</code></pre><p>下面我们来看看默认的inspector的面板显示：  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1645165132213-2022-2-1814:18:53.png"></p><p>不仅仅**[HideInInspector]<strong>标签会隐藏字段，</strong>[NonSerialized]**标记没有序列化的字段也不会显示出来。  </p><h2 id="绘制Inspector面板脚本-CustomEditor"><a href="#绘制Inspector面板脚本-CustomEditor" class="headerlink" title="绘制Inspector面板脚本(CustomEditor)"></a>绘制Inspector面板脚本(CustomEditor)</h2><pre><code>[CustomEditor(typeof(UIAnimManager))]public class UIAnimManagerEditor : UnityEditor.Editor&#123;    #region 字段    private UIAnimManager m_UIAnimManager;                                      //面板的脚本        private SerializedProperty m_IsDefReversed;                                 //是否倒放    private SerializedProperty m_IsDefLoop;                                     //是否循环    private SerializedProperty m_IsDefAutoPlay;                                 //是否自动播放    #endregion        #region 继承方法    private void OnEnable()    &#123;        m_UIAnimManager = (UIAnimManager) target;                               //获取绑定的脚本                m_IsDefReversed = serializedObject.FindProperty(&quot;m_IsDefReversed&quot;);     //获取m_IsDefReversed字段        m_IsDefLoop = serializedObject.FindProperty(&quot;m_IsDefLoop&quot;);             //获取m_IsDefLoop字段        m_IsDefAutoPlay = serializedObject.FindProperty(&quot;m_IsDefAutoPlay&quot;);     //获取m_IsDefAutoPlay字段    &#125;    /// &lt;summary&gt;    /// 自定义绘制Inspector面板    /// &lt;/summary&gt;    public override void OnInspectorGUI()    &#123;        OnPropertyFieldGUI();    &#125;    #endregion        #region 自定义方法    /// &lt;summary&gt;    /// 绘制属性字段    /// &lt;/summary&gt;    private void OnPropertyFieldGUI()    &#123;        EditorGUI.BeginChangeCheck();                                       //监听面板是否发生变化        &#123;            EditorGUILayout.PropertyField(m_IsDefReversed);                 //绘制m_IsDefReversed属性            EditorGUILayout.PropertyField(m_IsDefLoop);                     //绘制m_IsDefLoop属性            EditorGUILayout.PropertyField(m_IsDefAutoPlay);                    //绘制m_IsAutoPlay属性        &#125;        if (EditorGUI.EndChangeCheck())                                     //如果发生变化为true        &#123;            EditorUtility.SetDirty(target);                                 //标记用于触发保存            serializedObject.ApplyModifiedProperties();                     //更新序列化的数据        &#125;    &#125;    #endregion&#125;</code></pre><p>如上述代码，编写脚本只需要类上面打上**[CustomEditor(typeof(UIAnimManager))]<strong>即可，中间的UIAnimManager换成需要绑定的类即可，然后在代码中继承</strong>OnInspectorGUI**方法，在这个方法里绘制自己想绘制的面板。<br>绘制样子如下：  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1645168657839-2022-2-1815:17:38.png">  </p><h2 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h2><p>首先开<strong>OnEnable</strong>函数里：  </p><blockquote><p>m_UIAnimManager &#x3D; (UIAnimManager) target;获取当前绑定的脚本对象<br>serializedObject.FindProperty是获取脚本上的属性，是拿这些属性绘制的  </p></blockquote><p><strong>OnInspectorGUI</strong>函数就是我们编写绘制Inspector面板的函数，在代码里我们可以编写untiy提供的编辑器代码，笔者这里只是通过EditorGUILayout.PropertyField来绘制属性，也可以使用其他unity的编辑器绘制代码，这里就不举例了。  </p>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Hexo博客提交Warning</title>
      <link href="/2022/01/29/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E8%A7%A3%E5%86%B3Hexo%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4Warning/"/>
      <url>/2022/01/29/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E8%A7%A3%E5%86%B3Hexo%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4Warning/</url>
      
        <content type="html"><![CDATA[<h1 id="Warning-Accessing-non-existent-property-‘XXX’-of-module-exports-inside-circular-dependency"><a href="#Warning-Accessing-non-existent-property-‘XXX’-of-module-exports-inside-circular-dependency" class="headerlink" title="Warning: Accessing non-existent property ‘XXX’ of module exports inside circular dependency"></a>Warning: Accessing non-existent property ‘XXX’ of module exports inside circular dependency</h1><p>笔者在更新本地npm和node后，提交hexo博客的时候遇到了这个问题。原因在于本地node的版本太高导致的。  </p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>降低node的版本，选择一个低版本的node，node的12版本应该就可以。  </p><p><a href="https://nodejs.org/download/release/"><font color="steelblue" size="5">node各版本下载</font></a>  </p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>笔者并不想更新node版本，于是笔者找到了第二种解决方案，在博客目录下：  </p><pre><code>myBlog\node_modules\nib\node_modules\stylus\lib\nodes\index.jsmyBlog\node_modules\stylus\lib\nodes\index.js.</code></pre><p>上面两个路径下的<strong>index.js</strong>文件的前面分别添加下面代码即可。(两个文件都需要添加)  </p><pre><code>exports.lineno = null;exports.column = null;exports.filename = null;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客Warning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnityECS入门(三)——写一个简单的ECS</title>
      <link href="/2022/01/29/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%B8%89)%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84ECS/"/>
      <url>/2022/01/29/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%B8%89)%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84ECS/</url>
      
        <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><pre><code>unity: 2020.3.18f1Entities: 0.17.0Jobs: 0.8.0</code></pre><h1 id="SimpleECS"><a href="#SimpleECS" class="headerlink" title="SimpleECS"></a>SimpleECS</h1><p>一个简单的ECS应该包括Entity、Component和System，接下来笔者就带着大家写一个简单的ECS。  </p><h2 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h2><p>unity的<strong>Entity是已经封装好的，不需要自己创建</strong>。笔者一开始也没有理解，每个实例不一样，为啥不是自己制作Entity，笔者目前的理解是Entity就像一个没有任何属性的GameObject，我们是通过给这个空的GameObject添加Component来组成我们理解的实体对象。<br>下面我们来分析一下Entity，源码如下：  </p><pre><code>using System;namespace Unity.Entities&#123;        public struct Entity : IEquatable&lt;Entity&gt;, IComparable&lt;Entity&gt;    &#123;                public int Index;        public int Version;        public static bool operator==(Entity lhs, Entity rhs)        &#123;            return lhs.Index == rhs.Index &amp;&amp; lhs.Version == rhs.Version;        &#125;        public static bool operator!=(Entity lhs, Entity rhs)        &#123;            return !(lhs == rhs);        &#125;        public int CompareTo(Entity other)        &#123;            return Index - other.Index;        &#125;        public override bool Equals(object compare)        &#123;            return this == (Entity)compare;        public override int GetHashCode()        &#123;            return Index;        &#125;        public static Entity Null =&gt; new Entity();        public bool Equals(Entity entity)        &#123;            return entity.Index == Index &amp;&amp; entity.Version == Version;        &#125;        public override string ToString()        &#123;            return Equals(Entity.Null) ? &quot;Entity.Null&quot; : $&quot;Entity(&#123;Index&#125;:&#123;Version&#125;)&quot;;        &#125;    &#125;&#125;</code></pre><p>上面的代码重要部分是两个字段，<strong>Index</strong>和<strong>Version</strong>。<br>Index其实不难理解，笔者在上一篇文章提起过，Entity绑定的component是统一放在一个Chunk上的，为了提高访问的速度，当我们想要操作一个Entity的Component的时候，我们是通过Index在EntityDataManager中查找所在的Chunk和IndexInChunk。<br>Version是一个类似于版本号的东西，就像版本号会递增一样，Entity每次被回收的时候这个值会+1。用途的话，笔者猜测可能是当我们回调一个实例的时候，可以判断实例是否已经被回收了或者改变了。  </p><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><pre><code>[GenerateAuthoringComponent]public struct SimpleEcsComp : IComponentData&#123;    public float m_MoveSpeed;&#125;</code></pre><p>Component可以理解为Entity具有的属性或者组件，一个Entity是可以绑定多个Component的，就像一个GameObject上挂很多组件一样。<br>Component一般定义成struct，并且继承IComponentData或者ISharedComponentData这两个接口。   </p><h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>在以前的UnityECS版本里存在ComponentSystem和JobSystem两种System，但是目前已经被Unity弃用，这里就不介绍了，在新的ECS版本里，System采用的是<strong>SystemBase</strong>。  </p><pre><code>public class SimpleEcsSystem : SystemBase&#123;    protected override void OnUpdate()    &#123;        var deltaTime = Time.DeltaTime;        Entities.ForEach((ref Translation translation, ref SimpleEcsComp simpleEcsComp) =&gt;        &#123;            translation.Value.y += simpleEcsComp.m_MoveSpeed * deltaTime;            if (translation.Value.y &gt; 5f)            &#123;                simpleEcsComp.m_MoveSpeed = -math.abs(simpleEcsComp.m_MoveSpeed);            &#125;            else if (translation.Value.y &lt; -5f)            &#123;                simpleEcsComp.m_MoveSpeed = math.abs(simpleEcsComp.m_MoveSpeed);            &#125;        &#125;).ScheduleParallel();    &#125;&#125;</code></pre><p>如上述代码，在System的中，在进行Entities.ForEach的时候，最后需要执行一下<strong>ScheduleParallel</strong>这个方法，这里是一种扩展方法，这里常用的不仅仅是ScheduleParallel，还有Run和Schedul两个方法。下面介绍一下方法的用途：  </p><blockquote><p>Run() : evaluates the entity query and invokes the lambda function for each selected entity immediately on the main thread. Calling Run() completes the system Dependency JobHandle before running, blocking the main thread, if necessary, while it waits for those jobs to finish.<br>Schedul(): schedules the work to be done in a single job (no matter how many entities are selected).<br>ScheduleParallel() – schedules the work to be done in parallel using the C# Job system. Each parallel job instance processes at least one chunk of entities at a time. In other words, if all the selected entities are in the same chunk, then only one job instance is spawned.   </p></blockquote><h2 id="运行结果如下"><a href="#运行结果如下" class="headerlink" title="运行结果如下"></a>运行结果如下</h2><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1645079644114-2022-2-1714:34:04.png"></p>]]></content>
      
      
      <categories>
          
          <category> UnityECS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给hexo博客添加访问密码</title>
      <link href="/2022/01/28/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E7%BB%99hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E5%AF%86%E7%A0%81/"/>
      <url>/2022/01/28/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E7%BB%99hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔者记忆力比较差，于是笔者想有个空间能记录笔者一些私人的内容，于是笔者想起来比较经常会遇到一些加密的博客，笔者便想如果自己如果有一个博客能记录自己的私人内容，然后把博客进行加密即可，这样自己想要查看内容的额时候只需要访问隐私博客，然后输入密码就可以看到了。  </p><h1 id="安装Hexo-Blog-Encrypt"><a href="#安装Hexo-Blog-Encrypt" class="headerlink" title="安装Hexo-Blog-Encrypt"></a>安装Hexo-Blog-Encrypt</h1><p>hexo的博客添加密码其实只需要安装一个插件就可以了。<br>通过npm在hexo博客目录安装Hexo-Blog-Encrypt  </p><pre><code>npm install --save hexo-blog-encrypt</code></pre><h1 id="博客使用密码"><a href="#博客使用密码" class="headerlink" title="博客使用密码"></a>博客使用密码</h1><p>只需要在博客的开头使用  </p><pre><code>---title: Hello Worlddate: 2022-01-28 15:31:45password: 密码---</code></pre><p>还可以添加一些描述的标签  </p><pre><code>---title: Hello Worldtags:- 加密文章的tagdate: 2022-01-28 15:31:45password: 密码abstract: 这里有东西被加密了，需要输入密码查看哦。message: 您好，这里需要密码。wrong_pass_message: 抱歉，这个密码看着不太对，请再试试。wrong_hash_message: 抱歉，这个文章不能被纠正，不过您还是能看看解密后的内容。---</code></pre><h1 id="根目录添加配置文件"><a href="#根目录添加配置文件" class="headerlink" title="根目录添加配置文件"></a>根目录添加配置文件</h1><pre><code># 安全encrypt: # hexo-blog-encrypt  abstract: 这里有东西被加密了，需要输入密码查看哦。  message: 您好, 这里需要密码.  tags:  - &#123;name: tagName, password: 密码A&#125;  - &#123;name: tagName, password: 密码B&#125;  #密码主题 https://github.com/D0n9X1n/hexo-blog-encrypt#encrypt-theme  theme: wave  wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.  wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.</code></pre>]]></content>
      
      
      <categories>
          
          <category> 搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnityECS入门(二)——简单讲解一下ECS</title>
      <link href="/2022/01/28/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%BA%8C)%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3%E4%B8%80%E4%B8%8BECS/"/>
      <url>/2022/01/28/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%BA%8C)%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3%E4%B8%80%E4%B8%8BECS/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇我们已经成功的配置好本地的环境了，接下来我们来简单的讲解一下ECS。(笔者也是初学者，如果有错误欢迎大家指出)  </p><h1 id="ECS简介"><a href="#ECS简介" class="headerlink" title="ECS简介"></a>ECS简介</h1><p>在写ECS之前我们先了解一下什么是ECS？  </p><h2 id="ECS是什么？"><a href="#ECS是什么？" class="headerlink" title="ECS是什么？"></a>ECS是什么？</h2><p>ECS的缩写就是Entity Component System。对应的就是实例、组件和系统。笔者认为这是和MVC框架类似，虽然作用不是一样的，但是都代表了一种思想。ECS的思想打破了我们面向对象的思想，让我们直接面向数据变成。以往的Unity提供给使用者的都是GameObject，让我们来面向对象思想，但是ECS则是把GameObject拆成了Entity和Component，然后由System再进行同意管理。  </p><h2 id="为什么使用ECS？"><a href="#为什么使用ECS？" class="headerlink" title="为什么使用ECS？"></a>为什么使用ECS？</h2><h3 id="在编写思想上"><a href="#在编写思想上" class="headerlink" title="在编写思想上"></a>在编写思想上</h3><p>笔者认为，现在的大部分游戏其实都是数据驱动的游戏，游戏的界面对象其实是给使用者提供的。一个好的程序猿应该做到真正的数据和显示分离，这样不管显示是什么样，数据都可以去应对，但其实这是理想化的，因为显示是很难统一的。  </p><h3 id="在编写代码上"><a href="#在编写代码上" class="headerlink" title="在编写代码上"></a>在编写代码上</h3><p>ECS为我们提供了面向数据编程的结构、强迫使我们数据和显示进行分离，这样虽然编写复杂了一些，但是我们的扩展性和适应性会有很大的提高。<br>Unity的MonoBehavior的class其实是非常笨重的，里面包含了大量的信息，我们在平时开发中其实用不到那么多信息，在ECS上我们只需要添加上我们需要用到的组件即可。  </p><h3 id="在内存管里方面"><a href="#在内存管里方面" class="headerlink" title="在内存管里方面"></a>在内存管里方面</h3><p>ECS引入了Archetype和Chuck两个概念，Archetype对应的是我们的Component，就是存放我们Entity需要的所有组件，然后多个Archetype会被封装成一个个的Archetype Chuck，然后在内存里按照顺序进行存放，如果一个Chuck存放满了，会在后面内存里创建新的Chuck，这样Component就是在一起的，每次查找Component的时候速度会大大提升。<br>下面我们来看一看内存结构图：  </p><p><img src="https://i0.hdslb.com/bfs/article/6cb305d158f9daf75ef880b035a26afdea2961af.png" alt="在这里插入图片描述"></p><p><img src="https://i0.hdslb.com/bfs/article/363335a8d53167863db8a0c040e29e37d2f9b269.png" alt="在这里插入图片描述">  </p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>Unity使用的是单线程，虽然里面会有携程一些，但其根本原理都是单线程，所以并不能完全发挥CPU，ECS引入了多线程的Job system，并且Job System会把Entities分发到CPU的线程上，这样就提高了CPU的利用率。  </p><h1 id="怎么使用ECS"><a href="#怎么使用ECS" class="headerlink" title="怎么使用ECS"></a>怎么使用ECS</h1><p>ECS主要提升的是CPU的性能，并不是所有的项目都适合使用ECS，因为ECS是新的思想，团队开发成本也是有一定提高的，笔者业主要是为了学习了解，拓展一下自己的思路。<br>接下来笔者会继续学习如何使用ECS。  </p>]]></content>
      
      
      <categories>
          
          <category> UnityECS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnityECS入门(一)——安装Unity官方的ECS</title>
      <link href="/2022/01/27/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%B8%80)%E2%80%94%E2%80%94%E5%AE%89%E8%A3%85Unity%E5%AE%98%E6%96%B9%E7%9A%84ECS/"/>
      <url>/2022/01/27/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%B8%80)%E2%80%94%E2%80%94%E5%AE%89%E8%A3%85Unity%E5%AE%98%E6%96%B9%E7%9A%84ECS/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>笔者最近准备学习Unity官方的ECS，笔者才刚开始学习，这里就先不卖弄了，笔者写这篇博客的主要目的是为了分享如何安装官方ECS。  </p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><pre><code>Unity 2020.3.18f1c1</code></pre><h1 id="安装Entitie-com-unity-entities"><a href="#安装Entitie-com-unity-entities" class="headerlink" title="安装Entitie(com.unity.entities)"></a>安装Entitie(com.unity.entities)</h1><p>unity的版本低于2020.1的可以直接在Package Manager里搜索Entitie就可以了。<br>在unity2020.1版本的时候，官方对unity的Package Manager做了一些整改，默认不再显示Preview Package了。<br>首先笔者先介绍如何打开显示Preview Package。<br><img src="https://img-blog.csdnimg.cn/a6e1dd43a96d4951834981e78c8054e2.png" alt="在这里插入图片描述">  </p><p><img src="https://img-blog.csdnimg.cn/74d2605b303549cbbcc895a4013b83e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IS455m9,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">  </p><p>虽然打开了Preview Package但是依旧会搜不到部分Preview Package的库，这是因为处于早期开发阶段和开发不活跃的包无法直接搜索到。<br>笔者这里便介绍另外一种方式，通过url的方式导入需要的库。笔者在文章后面也会放入一些无法搜到的库。<br><strong>通过URL安装需要本地安装git来进行下载</strong><br>Entitie的url是： <strong>com.unity.entities</strong><br>导入步骤如下：<br><img src="https://img-blog.csdnimg.cn/b093196413e44d178d9a5656aee4ed7e.png" alt="在这里插入图片描述">  </p><p><img src="https://img-blog.csdnimg.cn/126370bd43ae4f8ca103be329245adde.png" alt="在这里插入图片描述">  </p><h1 id="安装Jobs-com-unity-jobs"><a href="#安装Jobs-com-unity-jobs" class="headerlink" title="安装Jobs(com.unity.jobs)"></a>安装Jobs(com.unity.jobs)</h1><p>通过git url的方式输入com.unity.jobs即可安装，笔者安装entities的时候会自动安装jobs，如果没有安装可以使用这种方式安装。  </p><h1 id="安装HyBrid-Renderer-com-unity-rendering-hybrid"><a href="#安装HyBrid-Renderer-com-unity-rendering-hybrid" class="headerlink" title="安装HyBrid Renderer(com.unity.rendering.hybrid)"></a>安装HyBrid Renderer(com.unity.rendering.hybrid)</h1><p>学习ECS过程中还有可能用到HyBrid Renderer这个package，这里也提供一下对应的URL  </p><p><strong>com.unity.rendering.hybrid</strong>  </p><h1 id="安装Burst-com-unity-barracuda-burst"><a href="#安装Burst-com-unity-barracuda-burst" class="headerlink" title="安装Burst(com.unity.barracuda.burst)"></a>安装Burst(com.unity.barracuda.burst)</h1><p>直接在package manager里搜索Burst是可以搜到的</p><h1 id="安装Mathematics-com-unity-mathematics"><a href="#安装Mathematics-com-unity-mathematics" class="headerlink" title="安装Mathematics(com.unity.mathematics)"></a>安装Mathematics(com.unity.mathematics)</h1><p>直接在package manager里搜索Mathematics是可以搜到的，这里也放一下url </p><p><strong>com.unity.mathematics</strong></p><h1 id="无法搜到的Preview-Package的URL"><a href="#无法搜到的Preview-Package的URL" class="headerlink" title="无法搜到的Preview Package的URL"></a>无法搜到的Preview Package的URL</h1><p>com.ptc.vuforia.engine<br>com.unity.2d.entities<br>com.unity.ai.planner<br>com.unity.aovrecorder<br>com.unity.assetbundlebrowser<br>com.unity.assetgraph<br>com.unity.barracuda<br>com.unity.barracuda.burst<br>com.unity.build-report-inspector<br>com.unity.cloud.userreporting<br>com.unity.collections<br>com.unity.connect.share<br>com.unity.dots.editor<br>com.unity.entities<br>com.unity.film-tv.toolbox<br>com.unity.google.resonance.audio<br>com.unity.immediate-window<br>com.unity.mathematics<br>com.unity.meshsync<br>com.unity.multiplayer-hlapi<br>com.unity.package-manager-doctools<br>com.unity.package-manager-ui<br>com.unity.package-validation-suite<br>com.unity.physics<br>com.unity.platforms<br>com.unity.platforms.android<br>com.unity.platforms.linux<br>com.unity.platforms.macos<br>com.unity.platforms.web<br>com.unity.platforms.windows<br>com.unity.playablegraph-visualizer<br>com.unity.render-pipelines.lightweight<br>com.unity.rendering.hybrid<br>com.unity.renderstreaming<br>com.unity.scene-template<br>com.unity.simulation.client<br>com.unity.simulation.core<br>com.unity.simulation.capture<br>com.unity.simulation.games<br>com.unity.standardevents<br>com.unity.streaming-image-sequence<br>com.unity.test-framework.performance<br>com.unity.tiny.all<br>com.unity.transport<br>com.unity.upm.develop<br>com.unity.vectorgraphics<br>com.unity.webrtc<br>com.unity.xr.googlevr.android<br>com.unity.xr.googlevr.ios<br>com.unity.xr.legacyinputhelpers<br>com.unity.xr.oculus.android<br>com.unity.xr.oculus.standalone<br>com.unity.xr.openvr.standalone<br>com.unity.xr.arsubsystems<br>com.unity.xr.interactionsubsystems<br>com.unity.xr.windowsmr.metro  </p>]]></content>
      
      
      <categories>
          
          <category> UnityECS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——序列化AnimationCurve</title>
      <link href="/2022/01/25/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%BA%8F%E5%88%97%E5%8C%96AnimationCurve/"/>
      <url>/2022/01/25/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%BA%8F%E5%88%97%E5%8C%96AnimationCurve/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在开发地图编辑器时，需要配置摄像机的移动速度，策划提出了通过设置曲线的方式来设置摄像机的移动。笔者想到了使用Unity编辑器自带的AnimationCurve来获得运动曲线。但是，由于需要将配置保存下来，笔者选择了使用JSON格式进行保存。然而，JSON序列化无法序列化AnimationCurve对象。在这种情况下，我们可以考虑将AnimationCurve对象转换为可序列化的数据类型，例如数组或自定义类，然后再进行JSON序列化。这样就可以保存配置信息并在需要时重新加载。  </p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>如果您需要序列化AnimationCurve，但是无法直接序列化，可以通过保存Keyframe数组来实现。在保存时，只需要将Keyframe数组保存下来，然后在加载时，通过添加保存的Keyframe来生成所需的AnimationCurve。<br>然而，Keyframe的字段都是私有的，无法直接序列化。为了解决这个问题，我们可以自定义一个新的Keyframe类，然后通过自己的Keyframe来生成需要的Keyframe。<br>以下是一个示例代码，演示如何自定义Keyframe类并使用它来生成AnimationCurve：<br>通过查看keyframe的源码，我们可以摘取我们需要的数据，然后自定义类即可。（这里定义struct，打包的时候序列化会出错，具体原因还未查明）  </p><pre><code>public class LBSerializeAnimCurveKeyFrame&#123;    #region 字段    public float m_Time;    public float m_Value;    public float m_InTangent;    public float m_OutTangent;    public int m_TangentMode;    public int m_WeightedMode;    public float m_InWeight;    public float m_OutWeight;    #endregion        #region 属性        #endregion        #region 方法        public LBSerializeAnimCurveKeyFrame(        float time,        float value,        float inTangent,        float outTangent,        float inWeight,        float outWeight)    &#123;        this.m_Time = time;        this.m_Value = value;        this.m_InTangent = inTangent;        this.m_OutTangent = outTangent;        this.m_WeightedMode = 3;        this.m_InWeight = inWeight;        this.m_OutWeight = outWeight;        this.m_TangentMode = 0;    &#125;    public static implicit operator LBSerializeAnimCurveKeyFrame(Keyframe keyframe)    &#123;        return new LBSerializeAnimCurveKeyFrame(keyframe);    &#125;        public static implicit operator Keyframe(LBSerializeAnimCurveKeyFrame keyframe)    &#123;        return new Keyframe(keyframe.m_Time, keyframe.m_Value, keyframe.m_InTangent, keyframe.m_OutTangent,            keyframe.m_InWeight, keyframe.m_OutWeight);    &#125;        #endregion&#125;</code></pre><p>上面就是笔者自己定义的keyframe，然后我们只需要在我们需要序列化的类添加上即可，示例如下：<br>首先查看我们需要序列化的数据应该怎么设计：  </p><pre><code>public class SerializeAnimationCurveData&#123;    #region 字段        public List&lt;LBSerializeAnimCurveKeyFrame&gt; m_AnimCurveKeyFrameList;        [IgnoreDataMember]    public AnimationCurve AnimCurve    &#123;        get        &#123;            Keyframe[] keyframeArray;            if (m_AnimCurveKeyFrameList != null)            &#123;                keyframeArray = new Keyframe[m_AnimCurveKeyFrameList.Count];                for (int i = 0; i &lt; m_AnimCurveKeyFrameList.Count; i++)                &#123;                    keyframeArray[i] = m_AnimCurveKeyFrameList[i];                &#125;            &#125;            else            &#123;                keyframeArray = AnimationCurve.Linear(0f, 0f, 1f, 1f).keys;            &#125;            return new AnimationCurve(keyframeArray);        &#125;        set        &#123;            m_AnimCurveKeyFrameList.Clear();            foreach (var keyframe in value.keys)            &#123;                m_AnimCurveKeyFrameList.Add(keyframe);            &#125;        &#125;    &#125;    #endregion    #region 方法    public SerializeAnimationCurveData()    &#123;        AnimCurve = AnimationCurve.Linear(0, 0, 1, 1);        m_AnimCurveKeyFrameList = new List&lt;LBSerializeAnimCurveKeyFrame&gt;();        foreach (var keyframe in AnimCurve.keys)        &#123;            m_AnimCurveKeyFrameList.Add(keyframe);        &#125;    &#125;    #endregion&#125;</code></pre><p>接着我们看一下如何编辑器上设置，笔者是在自定义的窗口上绘制的，其他面板也是类似：  </p><pre><code>private SerializeAnimationCurveData m_SerAnimCurveData;private void Awake()&#123;    m_SerAnimCurveData = new SerializeAnimationCurveData();&#125;private void OnGUI()&#123;    EditorGUILayout.BeginVertical(GUILayout.Width(400f));    &#123;        m_SerAnimCurveData.AnimCurve =            EditorGUILayout.CurveField(LBEditorLNG.SerAnimCurveTitle, m_SerAnimCurveData.AnimCurve);    &#125;    EditorGUILayout.EndVertical();&#125;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当我们想序列化一个字段的时候，如果字段不可以序列化，我们可以通过保留组成的数据，然后在反序列化的时候通过保留下来的数据重新组成我们需要的字段。如果字段也是封装好的私有字段，我们只需要自己重新设计一个类，用来保留这些字段。当我们需要一个成品的时候，如果我们没有办法保留成品，我们可以拆分这些，这样使用的时候重新组成就行了。</p>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——基于UGUI的UI拖拽监听</title>
      <link href="/2022/01/13/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EUGUI%E7%9A%84UI%E6%8B%96%E6%8B%BD%E7%9B%91%E5%90%AC/"/>
      <url>/2022/01/13/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EUGUI%E7%9A%84UI%E6%8B%96%E6%8B%BD%E7%9B%91%E5%90%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果一个UI的面板想监听拖拽事件通常会有两种方式：  </p><blockquote><ol><li>继承IBeginDragHandler，IDragHandler，IEndDragHandler接口，然后实现自己需要的逻辑。（此方法需要脚本继承MonoBehaviour）  </li><li>监听Input的输入，通过判断按下和按住来实现自己拖拽的逻辑。</li></ol></blockquote><p>已经有写好的放发笔者为什么还要写这边文章呢，是因为笔者目前参与的项目中的UI框架，面板的脚本都不是继承MonoBeehaviour的，都是通过统一管理的，这样的方式的好处就是UI的初始化和Update的一些都可以自己控制。面板的View都是通过绑定的方式进行操作的，了解框架的应该都知道，这样的好处有很多，这里就不过多介绍了。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>如果一个UI面板是通过绑定的方式进行的，没有继承MonoBehaviour，有不想在Update里写大量的逻辑，我们想见监听一个UI的拖拽应该怎么操作呢。  </p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>我们只需要自己写一个继承MonoBehaviour的脚本，然后脚本继承这些接口，在脚本里添加拖拽需要的一些参数，然后脚本里添加我们需要注册的委托就可以了，我们的面板脚本可以绑定面板的UI，我们只需要通过UI物体获取我们需要的拖拽脚本组件，然后注册我们需要的一些委托就可以了。脚本如下：  </p><pre><code>using System;using UnityEngine;using UnityEngine.EventSystems;public class UDragEvent : MonoBehaviour,IBeginDragHandler,IDragHandler,IEndDragHandler&#123;    private bool m_IsDraging;    public bool IsDraging    &#123;        get =&gt; m_IsDraging;        private set =&gt; m_IsDraging = value;    &#125;    public Action&lt;PointerEventData&gt; OnBeginDragEvent;    public Action&lt;PointerEventData&gt; OnDragEvent;    public Action&lt;PointerEventData&gt; OnEndDragEvent;    public void OnBeginDrag(PointerEventData eventData)    &#123;        OnBeginDragEvent?.Invoke(eventData);        m_IsDraging = true;    &#125;    public void OnDrag(PointerEventData eventData)    &#123;        OnDragEvent?.Invoke(eventData);    &#125;    public void OnEndDrag(PointerEventData eventData)    &#123;        OnEndDragEvent?.Invoke(eventData);        m_IsDraging = false;    &#125;&#125;</code></pre><p>上述脚本非常简单，只是把一些接口转换成了委托，然后在需要监听拖拽的组件上放上挂上这个脚本，在面板的控制脚本里获取这个脚本，然后绑定上对应的委托就可以使用了。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当我们使用一个接口或者方法的时候，如果我们没有办法直接调用，我们不仅仅只考虑找和它相同功能的方法替换掉，我们还可以通过转换的方式，间接的使用我们需要的。笔者就是通过委托的方式简介的使用了拖拽的接口。不仅仅是拖拽，很多接口我们都可以这样间接使用。也不仅仅是接口，很多开发者遇到的阻挡，我们不应该考虑换路，我们也要考虑能不能跨过阻挡或者绕过阻挡。  </p>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——自定义创建模板脚本</title>
      <link href="/2022/01/13/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%9B%E5%BB%BA%E6%A8%A1%E6%9D%BF%E8%84%9A%E6%9C%AC/"/>
      <url>/2022/01/13/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%9B%E5%BB%BA%E6%A8%A1%E6%9D%BF%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>相信大多数Unity开发人员在创建脚本的时候，经常会修改自从生成的脚本内容，比如去掉继承的MonoBehavior,添加命名空间，或者继承固定的接口、类等。这样重复的工作看似花费不了多少时间，但是如果每次创建都需要修改，还是有点麻烦的，所以如果我们能按照我们自定一的模板脚本去创建脚本就可以了。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者在团队开发中发现，每次创建UI的脚本的时候都需要固定修改继承，和添加一些标签等，这些重复性的工作笔者想了想可不可按照自定义的模板创建脚本。笔者发现unity自带的在unity安装目录下创建模板脚本有很大的缺点，只能创建C#脚本，并且只可以自己使用，并不可以上传到项目的库进行团队使用，于是笔者参考网上的一些文章写了下面的解决方案。  </p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>首先我们在创建一个Editor Default Resources目录，这个目录是提供为编辑器模式使用的资源路径，加载此目录的资源文件代码如下：<br><strong>EditorGUIUtility.Load(filePath)</strong><br>加载后通过as转换成需要的类型就可以了<br>笔者模板文件存放的目录如下：<br>—Assets<br>——Editor Default Resources<br>———CustomScriptTemplate<br>————C# Script-NewNoMonoBehaviourScript.text  </p><p>模板文件的内容如下：  </p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;namespace #NAMESPACE#&#123;    public class #SCRIPTNAME#    &#123;        #region 字段                #endregion                #region 属性                #endregion                #region 方法                                #endregion    &#125;&#125;</code></pre><h2 id="在选中的目录里创建模板脚本"><a href="#在选中的目录里创建模板脚本" class="headerlink" title="在选中的目录里创建模板脚本"></a>在选中的目录里创建模板脚本</h2><p>制作的原理就是通过读取模板文件的内容，然后将内容写入新的脚本中，监听编辑结束后替换新模板中的固定字符串就可以了。<br>直接上代码：  </p><pre><code>using System.Text;using System.Text.RegularExpressions;using UnityEditor;using UnityEditor.Compilation;using UnityEditor.ProjectWindowCallback;using UnityEngine;public static class CreatNewCShapScript&#123;        /// &lt;summary&gt;        /// 创建不继承MonoBehaviour脚本        /// &lt;/summary&gt;        [MenuItem(&quot;Assets/Create/C# Scripts Menu/C# NoMonoBehaviourScript&quot;, false,81)]        public static void CreatNoMonoBehaviourScript()        &#123;            //参数为传递给CreateEventCSScriptAsset类action方法的参数            ProjectWindowUtil.StartNameEditingIfProjectWindowExists(0,                ScriptableObject.CreateInstance&lt;CreateNewCShapScriptAsset&gt;(),                GetSelectPathOrFallback() + &quot;/NewNoMonoBehaviourScript.cs&quot;, null,                &quot;CustomScriptTemplate/C# Script-NewNoMonoBehaviourScript.txt&quot;);        &#125;        /// &lt;summary&gt;        /// 取得要创建文件的路径        /// &lt;/summary&gt;        /// &lt;returns&gt;&lt;/returns&gt;        public static string GetSelectPathOrFallback()        &#123;            string path = &quot;Assets&quot;;            //遍历选中的资源以获得路径            //Selection.GetFiltered是过滤选择文件或文件夹下的物体，assets表示只返回选择对象本身            foreach (UnityEngine.Object obj in Selection.GetFiltered(typeof(UnityEngine.Object), SelectionMode.Assets))            &#123;                path = AssetDatabase.GetAssetPath(obj);                if (!string.IsNullOrEmpty(path) &amp;&amp; File.Exists(path))                &#123;                    path = Path.GetDirectoryName(path);                    break;                &#125;            &#125;            return path;        &#125;        /// &lt;summary&gt;        /// 创建脚本文件的委托类        /// &lt;/summary&gt;        class CreateNewCShapScriptAsset : EndNameEditAction        &#123;            public override void Action(int instanceId, string pathName, string resourceFile)            &#123;                UnityEngine.Object obj = CreateScriptAssetFromTemplate(pathName, resourceFile);                         //创建资源                ProjectWindowUtil.ShowCreatedAsset(obj);                                                                //高亮显示资源            &#125;                        internal static UnityEngine.Object CreateScriptAssetFromTemplate(string pathName, string resourceFile)            &#123;                string fullPath = Path.GetFullPath(pathName);                                                           //获取要创建资源的绝对路径                string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(pathName);                           //获取文件名，不含扩展名                var textAsset = EditorGUIUtility.Load(resourceFile) as TextAsset;                string resourceFileText = textAsset.text;                resourceFileText = Regex.Replace(resourceFileText, &quot;#NAMESPACE#&quot;,                    CompilationPipeline.GetAssemblyRootNamespaceFromScriptPath(pathName));                resourceFileText = Regex.Replace(resourceFileText, &quot;#SCRIPTNAME#&quot;, fileNameWithoutExtension);              //将模板类中的类名替换成你创建的文件名                bool encoderShouldEmitUTF8Identifier = true;                                                            //参数指定是否提供 Unicode 字节顺序标记                bool throwOnInvalidBytes = false;                                                                       //是否在检测到无效的编码时引发异常                UTF8Encoding encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier, throwOnInvalidBytes);                bool append = false;                StreamWriter streamWriter = new StreamWriter(fullPath, append, encoding);                               //写入文件                streamWriter.Write(resourceFileText);                streamWriter.Close();                AssetDatabase.ImportAsset(pathName);                                                                    //刷新资源管理器                AssetDatabase.Refresh();                return AssetDatabase.LoadAssetAtPath(pathName, typeof(UnityEngine.Object));            &#125;        &#125;&#125;</code></pre><p>此代码有一个比较重要的一点就是获取文件所在的程序集的命名空间名字，因为要自动添加命名空间，最后找到了对应的API，通过**CompilationPipeline.GetAssemblyRootNamespaceFromScriptPath(pathName)**获取地址路径下的命名空间名字，然后动态替换就可以了。  </p>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity游戏开发知识点整理</title>
      <link href="/2022/01/12/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
      <url>/2022/01/12/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="94147dc6af44e8a35c45f6506e4e214b03d18cfeeda183817a31068f42fd5f73">2521a7807bde158c25736a82631336cef69c8023285301a3fbc36dfb98f6e317c9ac81c4d12edc8947dcaf8a0861a8948c1801f937c078349c26b44a4a8fc585f88e9b911e5ffe98e4c7f9fdd9db222ae42632ebcf17f27ad48bcdbcc168d62b44e4aa373d5c24a839a3c0b319a63a5c182a88b811178548b0323f67228629e8c978bed10d73398b17c41064f9b6c6b9c4a8e92bbf93b54102424c20a36908de17235eddb55912cd10dbe5b4f4fc656c45f4c077f0f23f660968530007a6c6fbfbcdff10375bdffd4321b5b82773bcd088f7a1c51e06d244212df83f4e2fa546ff493f5e44d4c75888c14742d5570e8e4277ef8915d02f74abcd84e16acfc24822e91881090fce77477bea1fa43493eb058c5de05e45e54d89275c297d3633bbda9813e4cb1ec72e59ec04b79a4bd604967ff4f5d7c92efa492f4bf5cc5c15e20b15ea904d22c5f083f3cc59fa46268420092fb77ce4ee7bba66bcc83a746b6c804ee413d84d822db9a22facd3538179d30a4ffeec47b94ea4cfe3f7eba065c685e4f98b48ea411e84e289d0f8dd28511bfbcd46566226414f81c1ec5a225a1e3d95853103a6e958a587ba5a9326fa27a1e38bae31fc14deab24639cbce5d3f369b444aa55927f2969ec552de62824cf0caef81e11f8266bbd9d60846fe5e17aaeb3c4cbdcef4939661409abff0658a92cbaa0261f835790653d8d88fcff6e95cfff50df65694559fee34c94a5ac2d1f4167f77a829dbf7e26d227e00f6b5acaaa64ed8d27e281ed718f75b49ee1e3ade9fa64b2ed6dbfcb867a3e924e897438c221380e732232bc85e1600d771725f919c13b71132b96838f8cedcda8613760af5bcedf047bf052d2cfb212014f7ab112811f0dc04d2bdd718710aa8923e4b7d095d85ffa6b4ac60477ec26f99ad8eae42f6f684252f59b780d870f2c9e5e8132b4fe401c75d88a549d6a268727784eb4ecb729c03b057df4c68a73c89681edcd0ecbc1e5c483365dc361958efb0175a4b916b4434038c606c50d40e3798f53b72a0f90a1e58a4c88edf7832064ed063b6331de873ec5d591ef1dd933b2a3a08a44433ce5d8a5619d5b38d892b8a7dfd4ddb526bfc60a61d2c673e130ebcc49b37f8dc014bd6efd66b05aa1220201178c80ace74f0d2913ccf28455ff63b918c97ff2ec632d957490912e08ae29ca1b741cc34a75b52ad655ce1ef31d7400271feb69eb538ad782a1dbb7272737adf16bc3c706f05e2d8c680c1199f1a1d770d73967959ad696232cf1cd685b90f8f07b94ec3f0e2cc1fb0865806f1a5e05817fc480b6832ccbff394d5615f194d36e81610cdf417b6e3cfba49555e41fae7b1220df3bc191c6e6347f6131049a8acf811a6d94cfaa8f4b3e9dab1b8d1fabf2b85bd1c3ae8e37454da6bf6dea061f65aa330877dfacad126910b286833835ebd759e77b1dfbbb3f9354af910187c2672ad8e211dc9fa17d2bb3ebfe94114154eb2370488235637dd9892f3a924cf6370be836d34b11d5c28a30aa616fddca438a208980bdcdbcf225ca13b76c1405a175914c770efb31a0b31c5e2852fed7cc8778fc0e10ff0c26e66057fc41b82820f69f391488047b969f377689d2feb04c4d1e32a46eeb93a660a1ee4988ef1917864e7a150d90f6435129ea313801c9d25f842a3f75aa8e2a3c7b4a02bc25f9b280347c1badee42de2d3614b801395112e6b100cd4dc0e6805a831b946794c4c13a65ae41d4a3166a1c75edf9880cd9957987a21c2d63906bb2e68adf66916b82b2ad13065a4d536623bfcbf05de8027c344aca1e907ba6df1f8773098346e00971cc55f5c05ecab515c377adee4dd3c74d07746c983c115daa1c5114fedfe9f9d777b2b26e4f32e0f288f6ee2fabaee3862901c0bcc5fbdec349872b2a002c99bc49ffbce6bde484b50e95d5cf8b803f358021e2ee1649f87abcb7b059a99581871e6a77c913b70e6da146d2e15cd90bc8c7ae1c3d80dcb07338e116e5097600d63c9a9c64a0360ed5f0a3c6ed97c1589050eea8fd4d20d4b50aee246682e08d049764355b3e85dd4ddaae425664c76826bd726eb99537fe3f8e968895f69613faa68a837eeb4153792974a6be68993f8ef2b14b7a904d66bedfbb6aaf09e443e9d339cfa7bf289585b3e5b10d37056d1525233b7212024b1e94a58a9cef49bce875f4b6e70121106065047ad895eba32a0807fc52205fab52ec0e419f5416874255c99163620874aba27764c2f27b50fceed97bf7d5486cd88ed2e8dcadd9fc35bd00e7be5276e70be83479e1246911f386779ab8e7868b37c140fe86d9f74380dbe35b4e32b88016f3338603b5c45fdec8c82f634bf5f09c8b63631e37bb7fc54a9fbb162b9083d7b9decda441cf19ab76b27a87a17a913a513b19c3e7d664e145c12ab6fe80aad77054acd6d3f4507969017819b9e541cc67d3674bf33a2378b958b5df6efbfa8664d33bd35d082d0f982ac4026cf064d848a5d6b1c09a3890c9ecb2e4a069aaad60a82709305d84cebd882874920cc622333188f6717f30d5e853774b464a8367475507ed313eefd896e2f716dba67437c608928f29eedb79303aab811442920950ff496040cfa94c39bd44f9e491841b19fd48e6610fceed602840bcbed884ef88389b752be74dc41cf1ca44544dc1e0283fc143235b9dababb6e873dee6c991d59c032c6ac1b39b139bce2f75ab36dfe6894ee4e26092f8ba0ca3a1f9de21c9501aed5c37ce89c9d2bddd865af03c39694810de43be6476be3665af392bab514e6ec1ec346a8cad1dad8f80d3e0bda1b9c1fec09dcf5c15b49a993a1c4eea5af61d05fc192b805ba2a17495703470f3cbce5001ff72be3d3a8da9a4e06758ce15e544eb7b202631a769ea7a3479440d515acb2e559dd8b6829b4d4a13128db01d0ac20fc85b48083781f1fb2429693bc4830497462277832bb67176a5f204fb2831308ca19e33c6a9fcb66cb50aa177fcf5b1191b11b4a85b5e0a1051a313e623aa631bc4d84e4a61088ac22b1b97fc2d1e120767b06f7c378edf48184d6f3db86eb3aa308c1f2790463ef05f3b457b444c0513034aa50bc2417cd04d2c50494a35cdfd7ddee0d4c4ea4bb962738ac045064eb69398b599e6887bad6e0be05484946a08ddcce5b8c321b91b6740306390ba31e5320a6357fe4b11a0925cf3e25fd4858096dde022ed8e272ceeb8056ce4b11d43694ea662feda4eaf2a065af25b9ac8d6905cd4003fc8a90ed71827ad09032338f6db4f97baea0c1c8f0484900002f3711efe6d41b82146f394e088539568d688bdf7cb9943b33d60eaba0e4327ea6a963680689ebfb637ab3920ffe4c6efbe951ec942973d0476f7fbb478535dba26bd9a160121902dc13b8943ac4a74ba0d87d3847c4da51cbfd4f920abff67809ac95e3b508bf48c83ea6d92f2f53ff39f04147d81b10a9799ab34c0db240e9a4dc22982dc9945a1b3ebd54c24b8f74d7566ceecbe4a61c95994173995bf0c897e04f623919c0c7fc0518fa6cbcd890a6178ac1caab7c9860d0c6772e7259bd07fbcaa3776d8a81ce8719c08b1d40c9b3425c24b08cf3e3c2aaf8285492152b6726f4020f1f12aaffcc86c83dd2082a4e814fca48b9dcc5c6a9d9e6d4ce5116770d983b2e215d5e58af90c00dd396a12322200cc605a6be094c25e04fb372a1a9b18a403bb002cb1a60d7b4d03ae37c03a0987990d29754da584a72d15b08f49133045563bfb98cad3f15e5e40b31d264f01f153790f3e196edf5d72fa337d071dbd4ad39b391887d5530e84fae569f1ff0280691c63f9d2628c26d186b535e50a09446c32b702fa99422223ae68bd7d23baa1e1c3a17969b0f24b4afe71eaaf836f34feddc46858f3e206494efc839a7f9b63e9956a795b30165d393abd08b1f7f8b19f6d581bcee0be10f3fb9cf9eece2261057e2c9776a161cc7278ce0af5f3a99152d0e9303288d27a633552d2e94a0628a5e456391b65848c8be1b9ed3294506de3ff8404c1223489c4b79bb1c3af87d08e4f0eeb7d6f77023f4bb2db565e7a3ec6592abc84ca830ad894810a05b92d352ca77828ca2e2769c0ed808675a92d8c53f56de21476e0a1402fb49ac7e32f4797f1f2bd00fb82cf66e46727ccbd111442ca2ccdcd63466be02c6eb2226f5a8f35a35d60b595deaff752f1d5e0d5e546ee1924c97524b06ee05a1d0c2ab6255276c963e74b4d15018344f8cfd3b47497490e694e0c2b62e1153b4d54b19c8fdbff8727f70363f5c462be4316f7da63ed1b5340df398054a54a544c7476d6b65ad9ba53844e248eeaa8b7fe6d65d019a492b0843c5fce8bac2109237809b72fb536598b67e73aa9576ef734ff9ba63a1331a0689df52116394cf2054e6eeed079868c08f9b6fe0a5b7b8a69d0cf363478396d717a6074470d7e59d872317cb6560b44b19746f18bb47233b9c403690c7856d1cb94a3d09bdccbc37ac7d4e15f7900c7acda6d620066afe81116ae08a0d8fb944c776aba9dab8c397d4850586ea45528a409e1491c17bf9f998707ed0a33b91c9f4127720132a293163bc3565aa099138395b04ac478ca72acc1e05dc0510c126e6ac6148c9bf567779b4ec25637e688996cc50bb0167ef24b39138c363f37df12884169a7e0ad7d44bdd2479336cf1406a232d9aaa4bf76d6515792f04f4c4fdd635fc2dd0320cae38532590fd2db02cd4185eea8b9fa7e8bacc2e3a0e2851a9dfaa8dd4e31c5eaaaf359cfb8b1e5ed870a725a0d702af3c552b127843dce15a1cb4abf643eedd6b4f91a1f1236ed3d8f3beabc99f86dc901c5dd4fa473a8f430871bc7e64f26379ccbe38f38df069ab51fb272cf1e3044bb7344fff335d86477f5aa3c40a22fa83803617601478509ee6ca85d20ef255b8e9433ac44181bcff0c85f69def5420e34b92d0c5ea7b6ffc2705489d58b8950c3742908de74b8798de3d97893dd1283c562ece11c68f3100c50aab21338df5686600bde4578d7dc40397a9ea28d65269dac2f9ec8a7b204aa8018edbbd8d0ae89faa77f5cf15aa5f4144296746f00b68f9a1ce61fcef412745408de7f2bdb7a6101ff678c3dfd72ad4fb69f25d3be34e58cd709da643d804b64597cc1a629ab37347408fdd68fc024ae0c3c2c9dbdb36b1c32be593589c432f7479cbf61f331746568a97ab376ddd7997924fe736972814eb6ec8405bf0683ebc2573ea0bc32ebb5574e4a01fc1775e9a5bb811451a9a9404458985ec9bc4e6b07b1cfbb349f9b30a8f778a144d8a8951c3829dce7843b56d613223675d449ce3d91d27510d6d5cdcffa185afa247ef371a1c74e0677c75fe2f7cc23eff86c350f36158eca8d173769d3b2dc7bcd430f92c0ebf4fa34027809528bcf93a8dac983607238e2c284abd4172493e6cf80f9c67fc93fdd1c701e5f7900638a723d04b89744634641998569bc1db16bb14556f9e6505f44e9d61af7da6cdbd1567c1c6828d0d148744097df1842242eabca3221050643699033f28237509bd4e423b8ccf1b1af1fd98202fa51d4749e036df3c5099f3fcfd04eda811bf21751b6b04c05801ab9c2de38600193df101c3bc065ae23f6651ee40db975d7bb47c6d6337d033ebf0d7e3d7263fc4461d8119826ce68054b08904d2e4d7eece08d8a1f2a5be39e88d5df2424e23bd4df22758cc291743cbbdf03e1151167c93e86e292edbe8c937f2155bc14d649b7e1e1b796e9a8c82e3e5e9b9553fa208301fafe1b207b923600df582d0d858e8d1bb85a7b0efdf2d9b9543d7a062c9795ad06e5c30218318b93c7a7016eca6d84dd34faabc2960a12b79b9a5be6649ee43ceca2ca030d1f7bb03cf8236af8bde8f48835965806629d61743c0cc47ae1e387841b6d3da97bc017e2b892a978f86908c2d83b689fbc59d85995650ccd8500d35672835de8cbdb2195b86b1a336a90d386d4126f5f3da5f3ce738c34e0538870dd1c7ce1f26ca9e05718bd7cf283dcfb0816b2f90e07a1186e1db1827bb84c147711446019fe0658456fe17ffc664086d98fba0a3ddb96d8c98987c692fe5456f94b8db36874ad17ba3b15158d96500f2abc30a477d31e20146183f5ebd5456b964f586e1cd4eedc4906010c0b2f441b9be1e892db4356cfc50800710043a8169574d4558072e6402e1ddd92e068266774cacb6335c3bf60a666a71cd958a4aaa16eeb494acf1cf20440526aeb0a6dbc493d57fbb5b13a227ec9618036689aeffec67424163e5a3694243fd75e83c77f5a4d6e01df44dea7c68b9801746217190bf5a2f4a50fe52995fb303900f38c8e29c91736b56635b7bbf8060dc77769bfe42ea4eac78fd9c2b8841090af351f629feca75c48214f3cfeb64732b417706de62d23fdc098d96d03a55436afd282a581fa6282f844158c94fb9f23417853ec11f963a969436cdad3e05f12da2923c7a6919024bc8c3448e24fa062e469c3a0a35c21bc44c80d4d4254777f041a73e58100dbe84373f8cedaa147f1bc31ff8033f2b86d04780d3e1e95123836508d70d03013f93aa436230ab8c8fee8b7364e6f3f6c2c7e660d13f81aaab4e81b4ea35eebfdac0a2c9a6cf4612700452706adfb58890519d26edf9c3d5a19a3ae4893f5b88ba11acdfac59ca19e74b8d1dcfaa9184703abbd29c06df12f3f2663c1c0d270c41e7bb891854a285596a709bbd2ce58ff38e70467c753b550f8be7073e21a2dbdd97a95e5fbd585109729f313aeab3a82a638a5b9f08db8d1ea39268ac31763ca938997ee006e8f450455bfef1d5b3175807f4e095c064f7c77afe06505305f22acc3e4c5b36bed644c1d9150ea81ef1c7d53ff162cb77a8beeed71f3a0652fce2fc116643fe434e52673e16b40fd6774ab4143f3ad33fc6e4f8d892de9e5660d2a499dad542f17c0843ca258bf993694e5a6f0b6e7d46f0f74362fc1ea65d9d44e453cd13ab6d24fc92126182994d5fe9f48274e7f9cce842f46823b389e113d8c12259248f069ed8f7b82a016e14418a12350e71b792948750306449be386818a9bc6965c1cba3af9b60f3a688e2fedc918c770eae51b185bcc7ccc06c2ee3e6a0e9d47281d8bccb94ee35eee75d6d37a270fd22bedcd8d3ff80961f7f41ccb00240792af142f891993ddbe73b069e85cbd38e78e4e14cea968806af90806038e62c704caf7dfb0ff2c780d75b9c59b70c916acb92968bd167e06d2ae6997a49f4c4d2836bca77e812a9aa30d3cc0e30531124a582ac322f385b84222badf29af51eec887e9e43a517e13e8ee6fb9884c7b2735b179639f35d6d4ec7096b6f670b77c469b5970f6ba9002633d2fcae9906725994d542a7e29cb84d0e2fe96b7204ac36988e005f1608621f16ba8601357a9c33ede5b5bd486f8e680d8f694a42e89933d71603dd7cfe57d572c8d047e91484a2998b387dc9423535e63fd2f76b3b01506befc1e13d23e3003fd14c9861b3f33a40282746e9a4a7dbb06a228e310ca74a0a51c8ea619094988d470ab6be381bca7fba2bc2abf049d14d50153a19d3b889c38210abaa539a47a2e4cef5126dcc98b53b17e4ca9bad43ada2f25c551c146fabb353b6ef0275574f173112b49ffaac9bd28ba437ece1bfdea4974ac9024a56e33bebf9c8a977ed2892b373277dfd4fdb8f146f5be826ce7a22d9ab3181f033caee343540e149754ef2eb16867b3a7860e52c0af3de2c301a7b799d679d89c753239e6aefbae82ef9aad4bb8b339535903d9f5ee460255327fee24cbc0fc8c563ab001dc2f56c81e59ff8b8c1325876be6415cb733a08eb02bc73f970761cabf1ed4bb31b9113572792852b6ed18e2d1a1006a08b682b3487129acd2366f9453dc8d11ebe1434dbcec3378e97e3be50c63d010930d97e8523270b33e9012c560f91d63b8578f35e856e13a1596a3e85cf3cfd721f24536ad9b1f536855f27caaec73eef5a3d04935199ace4b5c86f8472c98bed74b44754b3acc7e616e8fe919c2816e2f38e407a6a65bb86d3ff4212f99bf872f2e14fe002faa6085a5bef82494384a40616cf5fa646471f07ed496e4dec8745b50211bd85279e5971f68febd7047877f564a5365bd5081c53ab240739a913d4c1a25f0c6d3f98ed4f0a7231e0814f652ebee2342be785ffc061a3b6acca2b35d50e4f651a0bf42e1fd7e0ae7414ce976435456564f34b13220d72c89083eb89552333912289f164d189feda7d0698ce073e39205eda0937a8c28ccac3948aa7947d1c21cf3b407fbbf55deef8d4e04286e98116321ed050098103a4982890e26ee3cc26045c02b44152a2d658e68a3c108a84f8250815d1452d9ed82cbe756e04a7f5c4bdda54da48532aa9c603ca6830b291dacceb1f311848c846a8f20914509298197189a17cd334609259a2081cda5c1b2d0905f4d0656df84fe5f1f392dff8cfc368aeb55585544d8eb016631d4dc33c42375c5abeb079e056701057942fff1ef6f1c5f0308e9f38924310f9ba82d114a2ba61f24c319e2c1a661097e7a9c21c03dac1e3e0b93ff5e40c221c976ac40ebc8fe2deb79a9c88f3fe6556098f51d34d058af8975013e29404d1baf7d194628789af6bb2a10fac196b2426a61b64681ef7b50c867ab52fe098a9ea214134201dc96cecef801454cfb831254278519e2d2ab07e1fd37d0c51a753672adff1ef25669d36a5244056d25b84edbfa64cc6831d27777c7243db4915010568807c11f56d258a78327df4177d37fa16e2545627e0fa41c08447e3623a582235b8970a55d0d16816fc99542641c0787c1b999b12c58bdf2a1aa5fdcb6771784a5378643c4556f83d34f81d6aebd7d54ea6eddd3a8c0f37be1b4ee63a3f61bad327d34726ba56263735422dd6773c3f618c0eaf586d42cfb392d8dd11a29ee0a671b91f92b40268a3b309f5d964912a8e0bda2325f199db95107f8524aa2d7290bf958b4ad556a33e201393bf6715734510c15e61e98725f332f488beb836d34e47e29af2a99c10f1e13e85cc30366a0edb926cd16c76ced43846f4cf43f359745014353a0e6a98ea77526608ae428e9b72e345fc7e0146179ab1e84d0cf7c13f12ca0d335c399b674acc66752cef5e4525f654d75f4e28f44b4bf33d301580947267c58dfbb6628ee8fd2aa58e591df3028ec2923d27dd34c70b6a785d54210012db2c65a2ff85e169f147bcc32cfa53120b123dddb09add5171389cccdfee4d6704f3571ee2f66b5e323463c5023f9ec25113801a9658b38b764149dd3a813fbb78f4d5a4c1aac55b37d58d996df0e712f8c65c465b02cbd5fd0fa4270d79ce9db475a138ef3624794e13cfabbe9b00181314920a753dd0e39381ee574ea04a1f7e6e170bf349ab7765e5022f9270ae112ae20416e784ec39030033612f9016457614d533c8266b1062d36a4294f98a6f1f11bd3732a83dd505c1676b63d64d520544f260eafb9c5263babd294c5bf6273dda1be6bde4ee1adb4511b348d20d0ccfb4b050b5da0e8</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 个人笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unity知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——扩展变量增加OnValueChange功能</title>
      <link href="/2022/01/07/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95%E5%8F%98%E9%87%8F%E5%A2%9E%E5%8A%A0OnValueChange%E5%8A%9F%E8%83%BD/"/>
      <url>/2022/01/07/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95%E5%8F%98%E9%87%8F%E5%A2%9E%E5%8A%A0OnValueChange%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔者参与的项目的UI框架并没有采用MVC结构，而是把MVC中的C去掉了，只使用了MV，把C的逻辑拆分了一下，分别分为M里的C和V里的C，分别写在了对应的M或者V里面，V是根据M里的数据变化从而进行变化的。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>C#自带的属性并没有数据变化响应的事件或者委托，笔者的UI结构是需要根据数据变化进行更新的，所以笔者希望属性能有一个类似于OnValueChange的功能。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="方法一（使用委托）"><a href="#方法一（使用委托）" class="headerlink" title="方法一（使用委托）"></a>方法一（使用委托）</h2><p>这种方式是自己增加一个变量的委托事，然后在属性的set方法里进行响应对应的委托，每次需要监听数据变化的时候注册一下对应的委托就可以了。<br>缺点：变量需要定义成委托，并且每个需要监听变化的变量都需要增加一个委托的变量。<br>代码如下：  </p><pre><code>public class ExtendProperty&#123;    private int m_Value;    public Action&lt;int, int&gt; OnValueChange;    public int Value    &#123;        get =&gt; m_Value;        set        &#123;            OnValueChange?.Invoke(m_Value, value);            m_Value = value;        &#125;    &#125;&#125;</code></pre><p>根据代码可以看出，如果是属性使用只需要两个变量，但是如果是字段使用就需要三个变量了。<br>使用方法如下：  </p><pre><code> void Start()&#123;    ExtendProperty property = new ExtendProperty();    property.Value = 10;    property.OnValueChange += OnValueChange;    property.Value = 20;&#125;private void OnValueChange(int arg1, int arg2)&#123;    Debug.Log(string.Format(&quot;&#123;0&#125;-&#123;1&#125;&quot;, arg1, arg2));&#125;</code></pre><h2 id="方法二（推荐）"><a href="#方法二（推荐）" class="headerlink" title="方法二（推荐）"></a>方法二（推荐）</h2><p>方法一的缺点很明显，如果是少数变量使用还可以，但是如果大量的变量都需要监听会比较麻烦，于是笔者就找到了另外的解决办法，笔者自定义一个类，然后变量都使用这个类定义，在类里面进行变量监听就可以了。<br>代码如下：  </p><pre><code>public class ExtendProperty&lt;T&gt;&#123;    private T m_Value;    public Action&lt;T, T&gt; OnValueChange;    public T Value    &#123;        get =&gt; m_Value;        set        &#123;            OnValueChange?.Invoke(m_Value, value);            m_Value = value;        &#125;    &#125;    public ExtendProperty(T value)    &#123;        m_Value = value;    &#125;        public ExtendProperty()    &#123;        m_Value = default;    &#125;        public static implicit operator T(ExtendProperty&lt;T&gt; vl)    &#123;        return vl.Value;    &#125;&#125;</code></pre><p>缺点：定义普通变量的时候都需要初始化，不会默认赋值，并且每次使用变量的时候都不是直接赋值，而是采用property.Value &#x3D; value的方式赋值。<br>使用案例如下：  </p><pre><code>ExtendProperty&lt;int&gt; property = new ExtendProperty&lt;int&gt;(10);property.OnValueChange += OnValueChange;property.Value = 20;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>采用OnValue的方式是一种简单的响应式框架，类似于UniRx，笔者在使用方法二的时候一直在想办法解决如何让使用者使用的时候像普通变量一样赋值而不是采用.Value的方式赋值，奈何一直找不到能拿到赋值的左值的方法。第二种方式更像是把第一种方式整合成一个对象，从而减少代码量。</p>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#-Property </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——解决Unity修改Prefab的参数不生效，无法保存</title>
      <link href="/2021/12/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3Unity%E4%BF%AE%E6%94%B9Prefab%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%8D%E7%94%9F%E6%95%88%EF%BC%8C%E6%97%A0%E6%B3%95%E4%BF%9D%E5%AD%98/"/>
      <url>/2021/12/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3Unity%E4%BF%AE%E6%94%B9Prefab%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%8D%E7%94%9F%E6%95%88%EF%BC%8C%E6%97%A0%E6%B3%95%E4%BF%9D%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔者刚入职一家公司，团队的项目在UI方面处理和外面大部分框架都差不多，都是采用绑定的方式处理UI面板，笔者在开发UI面板的时候发现，笔者修改绑定的脚本的数据的时候，发现无法触发prefab的保存，所以不管从场景还是资源中修改参数，在重新打开的时候都没有生效。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者经过一系列的搜索，最后发现是因为笔者所在团队的框架，修改prefab上绑定面板的脚本是通过这个脚本的编辑器扩展脚本中的OnInspectorGUI方法中进行赋值的，但是在这个方法中通过代码赋值的数据都无法触发Prefab的修改，所以无法进行保存，因此下次再打开prefab的时候依旧不生效。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="方法一（不建议使用）"><a href="#方法一（不建议使用）" class="headerlink" title="方法一（不建议使用）"></a>方法一（不建议使用）</h2><p>这个方法是笔者同事用的方法，采用的方式是通过其他方式触发Prefab的修改，从而进行Apply或者Save，这个时候进行保存就会把修改进行保存。笔者同事是Prefab拖到场景中，通过设置Prefab的显示隐藏，触发修改，然后保存。笔者在测试过程中是通过增加节点再删除触发的。这个方法并不推荐使用，因为每次修改都需要想办法触发保存。  </p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>这个方法是在OnInspectorGUI函数中，在调用参数修改的地方，通过**Undo.RecordObject(object,”value change”)**的方法,然后在修改的时候发现就可以触发了，这个方法笔者是从度娘那里学到的方法，笔者并没有采用成功是因为笔者框架的Object是System.Object,但是接口要求的是UnityEngine.Object，因此笔者如果修改会修改大量代码。并且据说这个方法不是百分百生效。  </p><h2 id="方法三（推荐）"><a href="#方法三（推荐）" class="headerlink" title="方法三（推荐）"></a>方法三（推荐）</h2><p>这个方法是在OnInspectorGUI函数中，在调用参数修改的地方，通过**EditorUtility.SetDirty(obj);**的方法监听赋的值就可以了，这是笔者采用的发放，这样修改就可以直接保存了。不过此方法有个确定，就是修改后无法使用ctrl+z进行回退，本身修改也是无法回退，据说方法二是可以支持回退的。  </p><pre><code>[CustomEditor(typeof(XXX))]public class XXXEditor : Editor&#123;    public override void OnInspectorGUI()    &#123;        ...        XXX xxx = value as XXX;        if (#change#)//数据发生变化        &#123;            xxx.Value = object;            EditorUtility.SetDirty(object);        &#125;        ...    &#125;&#125;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>笔者的方法依旧存在无法回退的方法，如果那位大佬有好的方法可以联系笔者。</p>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Prefab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——海外开发踩坑笔记</title>
      <link href="/2021/07/09/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%B5%B7%E5%A4%96%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/07/09/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%B5%B7%E5%A4%96%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><h2 id="Gradle版本问题"><a href="#Gradle版本问题" class="headerlink" title="Gradle版本问题"></a>Gradle版本问题</h2><p>本地打包的大部分错误都是因为这个问题，这是因为笔者接入的SDK自定义了gradle的插件版本，这个再unity本身其实已经定义过了，但是自己是可以通过修改build.gradle进行修改的。查看unity本身gradel的插件版本的路径是：Editor\Data\PlaybackEngines\AndroidPlayer\Tools\GradleTemplates\baseProjectTemplate.gradle,以2019.4.28版本为例，里面代码为：  </p><pre><code>// GENERATED BY UNITY. REMOVE THIS COMMENT TO PREVENT OVERWRITING WHEN EXPORTING AGAINallprojects &#123;    buildscript &#123;        ***        dependencies &#123;            ***            classpath &#39;com.android.tools.build:gradle:3.4.0&#39;            **BUILD_SCRIPT_DEPS**        &#125;    &#125;    ***&#125;***</code></pre><p>如上图，可以看到插件版本为3.4.0，如果unity里本身修改了baseProjectTemplate.gradle就按照修改后的来，这个文件夹内所有的gradle和properties都是默认的，如果程序里修改就按照程序里的来。修改的方法在Editor–&gt;ProjectSettings–&gt;Player–&gt;Publishing Settings，如下图所示：  </p><p>  <img src="https://file.liangxiegame.com/f69ca480-57fe-4313-8391-4318b1cead9a.png" alt="image.png">   </p><p>如上图，其实就是对应编辑器文件夹下的gradle文件，如果打勾就会在pluging&#x2F;Android文件夹下生成对应的文件，就可以直接修改，不再按照unity默认的来，就可以修改配置了。</p><p>经过上面的介绍已经知道如何查看并修改unity的gradle插件版本，下面就是修改对应的gradle版本。首先打开Editor–&gt;Preference–&gt;External Tools就可以看到Android的打包环境配置。  </p><p><img src="https://file.liangxiegame.com/13b80d7b-6dd0-4fdd-8199-82222a81d8e2.png" alt="image.png">   </p><p>2020版本以后的Unity是默认路径下就自己配置好环境，选择默认就可以，但是依旧可能会存在环境不存在或者版本不对，所以可以自己配置，这样修改也方便。这里有需要特别关注的一点也是大部分打包失败的原因，就是gradle的版本和对应的插件版本是有对照关系的，必须对照上才能正常打包。对应关系如下图：  </p><p><img src="https://file.liangxiegame.com/10319033-5e95-4d83-a544-060a7ff6cac3.png" alt="image.png">   </p><p>只要配置好对应的关系就行了。  </p><h2 id="NDK版本问题"><a href="#NDK版本问题" class="headerlink" title="NDK版本问题"></a>NDK版本问题</h2><p>在打包的时候也遇到了NDK版本不对无法打包的问题，打包失败会提示打包需要的版本，下载对应的版本即可，笔者打包的时候需要的是版本19，但是下载19版本依旧无法打包，这是因为版本的小版本依旧对不上，这里可以不用找对应的小版本，只要对应的大版本一样，在自己ndk安装目录下，找到source.properties文件，编辑文件，如下，修改对应的<strong>Pkg.Revision</strong>即可。  </p><pre><code>Pkg.Desc = Android NDKPkg.Revision = 19.0.5232133</code></pre><h2 id="maven仓库下载问题"><a href="#maven仓库下载问题" class="headerlink" title="maven仓库下载问题"></a>maven仓库下载问题</h2><p>这个问题是打包的时候并没有找到对应的maven仓库，笔者接入的SDK需要的maven都写在了launcherTemplate文件里，但是打包的时候并没有找到仓库，这是因为maven的仓库应该写在mainTemplate文件里，在launcherTemplate文件里可能会存在没有下载到的情况。  </p><h2 id="API版本问题API"><a href="#API版本问题API" class="headerlink" title="API版本问题API"></a>API版本问题API</h2><p>这里牵扯到两个API的版本，分别是minSdkVersion和targetSdkVersion，打包的时候会报错版本问题，这里只需要在Editor–&gt;ProjectSettings–&gt;Player–&gt;Other Settings里修改对应的Minimum API Level和Target API Level，修改到要求的版本或者更高的版本即可。  </p><p><img src="https://file.liangxiegame.com/8f76046e-d068-4e4a-a7f0-09db7505453d.png" alt="image.png">   </p><h2 id="APK-obb分包无法运行问题"><a href="#APK-obb分包无法运行问题" class="headerlink" title="APK+obb分包无法运行问题"></a>APK+obb分包无法运行问题</h2><p>因为Google商店对上传的apk有内存限制，要求是100M以内，这里推荐使用的是APk+OBB进行分包，根据最新的要求是要求使用AAB包，这里先介绍APK+OBB的分包遇到的问题。  </p><p>分开打包的方法是Editor–&gt;ProjectSettings–&gt;Player–&gt;Publishing Settings里，勾选上最下面的Split Application Binary。 </p><p><img src="https://file.liangxiegame.com/1ce243b5-e799-4710-a446-0e141fc2a4c1.png" alt="image.png">    </p><p>这个是可以代码控制的：  </p><pre><code>PlayerSettings.Android.useAPKExpansionFiles = true;</code></pre><p>分包后如何在手机上运行呢，这里只需要安装分包后的APK，然后在手机上运行，发现第一次运行不成功，这是因为资源都在OBB中，所以无法正常运行，这里只需要吧自己的OBB改好名字放在对应的文件夹就行了。然后再运行就可以了。   </p><p>文件夹地址：手机目录\Android\obb&quot;APP的包名”<br>OBB文件的名字: main.安卓内部版本号.APP包名.obb (举例：main.102.com.XXX.XXX.XXX.obb)</p><h2 id="打包AAB报错-FileNotFoundException-Temp-launcher-aab-does-not-exist"><a href="#打包AAB报错-FileNotFoundException-Temp-launcher-aab-does-not-exist" class="headerlink" title="打包AAB报错:FileNotFoundException: Temp...\launcher.aab does not exist"></a>打包AAB报错:FileNotFoundException: Temp...\launcher.aab does not exist</h2><p>打包aab的方法就是打开File–&gt;Build Settings的面板，然后勾选上Build AppBundle(Google Play)再进行打包就可以了。  </p><p><img src="https://file.liangxiegame.com/09a6726f-1fd1-4805-be17-d0bbb3ad5481.png" alt="image.png">   </p><p>这个报错网上查了一下原因，说的是因为gradle版本过高，导致unity内部逻辑出错的问题。笔者的gradle的版本确实比unity自带的版本过高，于是利用网上给的解决方案解决了。解决方法是在launcher的gradle的defaultConfig里添加下面代码，笔者不导出安卓工程于是就在launcherTemplate的defaultConfig里添加了下列的代码。  </p><pre><code>defaultConfig &#123;    ***    //打包abb的话需要这个    tasks.whenTaskAdded &#123;        task -&gt;        if (task.name.startsWith(&quot;bundle&quot;)) &#123;                   def renameTaskName = &quot;rename$&#123;task.name.capitalize()&#125;Aab&quot;            def flavor = task.name.substring(&quot;bundle&quot;.length()).uncapitalize()            tasks.create(renameTaskName, Copy) &#123;                       def path = &quot;$&#123;buildDir&#125;/outputs/bundle/$&#123;flavor&#125;/&quot;                from(path)                include &quot;launcher-release.aab&quot;                destinationDir file(&quot;$&#123;buildDir&#125;/outputs/bundle/$&#123;flavor&#125;/&quot;)                rename &quot;launcher-release.aab&quot;, &quot;launcher.aab&quot;            &#125;                 task.finalizedBy(renameTaskName)        &#125;    &#125;&#125;</code></pre><h2 id="AAB格式手机安装方法"><a href="#AAB格式手机安装方法" class="headerlink" title="AAB格式手机安装方法"></a>AAB格式手机安装方法</h2><p>首先需要把aab格式的安装包解析成apks格式的安装包，在解析的时候需要一个jar的包，这个jar包是bundletool-all-1.6.1，版本不要求一定是1.6.1，解析的方法是下面CMD的命令：  </p><pre><code>java -jar &lt;bundletool.jar的路径&gt; build-apks --bundle=&lt;.aab文件的路径&gt; --output=&lt;输出.apks的路径&gt; --ks=&lt;打包.aab文件时的秘钥文件路径，如果.aab文件时没有使用秘钥则可以省去秘钥环节的配置&gt; --ks-pass=pass:&lt;秘钥密码&gt; --ks-key-alias=&lt;秘钥别名&gt; --key-pass=pass:&lt;秘钥别名密码&gt; --device-spec=&lt;要输出的目标sdkVersion的APK的json配置文件路径&gt;</code></pre><p>举例：  </p><pre><code>java -jar C:\Users\XX\Desktop\bundletool-all-1.0.0.jar build-apks --bundle=C:\Users\XX\Desktop\test23.aab --output=C:\Users\XX\Desktop\test23.apks --ks=G:\Client\Trunk\key\user.keystore --ks-pass=pass:abcdef --ks-key-alias=yunzhong --key-pass=pass:abcdef --device-spec=C:\Users\XX\Desktop\config.json</code></pre><p>然后手机链接电脑，打开调试模式，接着调用CMD的安装命令：  </p><pre><code>java -jar C:\Users\XX\Desktop\bundletool-all-1.6.1.jar install-apks --apks=C:\Users\XX\Desktop\test23.apks  </code></pre><p>安装结束后手机上就存在自己需要的安装包了。  </p><h2 id="报错Illegal-usage-of-unity-detected-shutdown-unity"><a href="#报错Illegal-usage-of-unity-detected-shutdown-unity" class="headerlink" title="报错Illegal usage of unity detected, shutdown unity"></a>报错Illegal usage of unity detected, shutdown unity</h2><p>分包之后笔者运行发现APP直接闪退，看了半天日志最后发现了一句报错是Illegal usage of unity detected, shutdown unity。笔者使用的是unity2019.4.26f1c1(中国版，以后的中国版本后面都会有个c)。通过百度发现Unity中国版2019.4版本再分割obb编译的时候会导致这个错误，其他版本还没试过，不知道会不会有这个问题。发现只需要使用国际版本即可。  </p><h2 id="报错DSL-element-‘useProguard’-is-obsolete-and-will-be-removed-soon-Use-‘android-enableR8’-in-gradle-pro"><a href="#报错DSL-element-‘useProguard’-is-obsolete-and-will-be-removed-soon-Use-‘android-enableR8’-in-gradle-pro" class="headerlink" title="报错DSL element ‘useProguard’ is obsolete and will be removed soon. Use ‘android.enableR8’ in gradle.pro"></a>报错DSL element ‘useProguard’ is obsolete and will be removed soon. Use ‘android.enableR8’ in gradle.pro</h2><p>出现这个警告是因为build.gradle里配置了 ‘useProguard’属性，而这个属性将很快被移除，使用‘android.enableR8’来代替。这里只需要在gradleTemplate.properties文件后面添加下面一句话就可以了： </p><pre><code>android.enableR8 = true</code></pre><h2 id="报错自己定义的Application丢失"><a href="#报错自己定义的Application丢失" class="headerlink" title="报错自己定义的Application丢失"></a>报错自己定义的Application丢失</h2><p>打包后出现自己写的Application脚本丢失，这个大部分是因为AndroidManifest没有配置自己的Application，配置方法这里就不多做介绍，网上很多介绍。笔者这里遇到的并不是因为没有配置，是因为笔者接入的SDK是继承的MultiDexApplication，这里需要注意的是如果您的 minSdkVersion 设为 21 或更高版本，系统会默认启用 MultiDex，并且您不需要 MultiDex 库。<br>不过，如果您的 minSdkVersion 设为 20 或更低版本，您必须使用 MultiDex 库并对应用项目进行以下修改：</p><pre><code>android &#123;    defaultConfig &#123;        ...        multiDexEnabled true    &#125;    ...&#125;dependencies &#123;    implementation &quot;androidx.multidex:multidex:2.0.1&quot;&#125;</code></pre><p>此时重新编译打包后发现果然打包出多个dex文件，在安卓6.0上测试完美运行，并且用360加固以后5.0以上都能正常运行。<br>但是坑来了 ：在5.0，5.1系统上一运行就奔溃！<br>后来知道在高版本系统上使用art支持多dex，而低版本dalvik默认先加载主dex，如果启动时需要的类不在主dex内就会报错ClassNotFoundException。 解压apk发现里面有上百个dex文件，一般不会拆分如此多，百度查阅后得知：<br>对于dex 的–multi-dex 选项设置与预编译的library工程有冲突,如果你的应用中包含引用的lirary工程,需要将预编译设置为false:<br>在 build.gradle中添加  </p><pre><code>dexOptions&#123;    preDexLibraries = false&#125;</code></pre><h1 id="SDK遇到问题"><a href="#SDK遇到问题" class="headerlink" title="SDK遇到问题"></a>SDK遇到问题</h1><h2 id="华为手机出现水滴屏无法适配的问题"><a href="#华为手机出现水滴屏无法适配的问题" class="headerlink" title="华为手机出现水滴屏无法适配的问题"></a>华为手机出现水滴屏无法适配的问题</h2><p>笔者的项目要求手机在遇到水滴屏或者刘海屏的时候，上面显示黑条不进行渲染就可以，笔者查了一下unity的设置方法，发现只需要不勾选Editor–&gt;ProjectSettings–&gt;Resolution and Presentation里的Render outside safe area即可。  </p><p><img src="https://file.liangxiegame.com/45f3375d-4006-40a8-a599-3efb2978e578.png" alt="image.png">   </p><p>但是笔者发现APP在某个测试的华为手机上依旧渲染了，最后发现是接入的SDK里设置了华为手机的屏幕渲染。在华为手机Android8.0的适配方案是在AndroidManfiest里面添加下面的话即可，笔者发现接入的SDK设置了这个，于是去掉就没有问题了。  </p><pre><code>&lt;meta-data android:name=&quot;android.notch_support&quot; android:value=&quot;true&quot;/&gt; </code></pre><p>这里列举一下小米手机的适配方案是：  </p><pre><code>&lt;meta-data android:name=&quot;notch.config&quot; android:value=&quot;portrait|landscape&quot;/&gt;</code></pre><h2 id="如何修改build-gradle"><a href="#如何修改build-gradle" class="headerlink" title="如何修改build.gradle"></a>如何修改build.gradle</h2><p>关于对Android的gradle的脚本进行修改，其实上面已经介绍了。Pluging&#x2F;Android文件夹下的XXXTemplate对应的其实就是导出android工程下的build.gradle，修改对应的Template就是修改对应的build.gradle。  </p><h2 id="如何添加Android需要的java脚本"><a href="#如何添加Android需要的java脚本" class="headerlink" title="如何添加Android需要的java脚本"></a>如何添加Android需要的java脚本</h2><p>首先导出一个安卓工程，然后用AndroidStudio打开导出的Android工程，然后直接在安卓工程里写对应的脚本，脚本完成后直接复制到unity工程中pluging下Android文件夹下面。这里因为每次都要复制文件，所以笔者写了一个脚本直接一键复制所有的bat脚本。脚本内容如下：  </p><pre><code>@echo offset filePath=unityLibrary\src\main\java\com\ksset targetFilePath=..\..\project\Assets\Plugins\Androidfor /R %filePath% %%i in (*.java) do (    xcopy /y /c /h /r %%i %targetFilePath%    echo %%i)pause</code></pre><p>后来发现每次改好脚本后，还需要找到这个bat文件执行，于是笔者简化了这个步骤，笔者添加了一个unity的编辑器脚本，用于执行这个bat文件。脚本内容如下：  </p><pre><code>public static void SyncAndroidJava2()&#123;    var filepath = FileEditorTools.FormatPath(Application.dataPath + &quot;/../../android/AndroidBDSDK_R/&quot;);    RunBat(&quot;CopyJavaScripts.bat&quot;, &quot;&quot;, filepath);&#125;//cmd是执行的脚本的名字args是参数，可以直接设置为“”workingDir是执行bat文件所在文件夹路径public static System.Diagnostics.Process CreateShellExProcess(string cmd, string args, string workingDir = &quot;&quot;)&#123;    var pStartInfo = new System.Diagnostics.ProcessStartInfo(cmd);    pStartInfo.Arguments = args;    pStartInfo.CreateNoWindow = false;    pStartInfo.UseShellExecute = true;    pStartInfo.RedirectStandardError = false;    pStartInfo.RedirectStandardInput = false;    pStartInfo.RedirectStandardOutput = false;    if (!string.IsNullOrEmpty(workingDir))        pStartInfo.WorkingDirectory = workingDir;    return System.Diagnostics.Process.Start(pStartInfo);&#125;public static void RunBat(string batfile, string args, string workingDir = &quot;&quot;)&#123;    var p = CreateShellExProcess(batfile, args, workingDir);    p.Close();&#125;</code></pre><p>在执行bat脚本的时候笔者发现，自己完全可以写一个复制用的脚本，就不需要再依靠bat脚本进行执行。脚本如下：<br>    public static void SyncAndroidJava()<br>    {<br>        var filepath &#x3D; FileEditorTools.FormatPath(Application.dataPath + “&#x2F;..&#x2F;..&#x2F;android&#x2F;AndroidBDSDK_R&#x2F;unityLibrary&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;ks&#x2F;“);&#x2F;&#x2F;需要复制的java文件所在的文件夹<br>        var folderpath &#x3D; Application.dataPath + “&#x2F;Plugins&#x2F;Android&#x2F;“;&#x2F;&#x2F;复制到的文件位置<br>        var filelist &#x3D; FileEditorTools.GetallFile(filepath, “.java”);</p><pre><code>    var curcount = 0;    var sumcount = filelist.Count;        EditorUtility.DisplayProgressBar(&quot;同步Android的Java脚本&quot;, &quot;开始复制文字...&quot;, 0);    foreach (var javafile in filelist)    &#123;        EditorUtility.DisplayProgressBar(&quot;复制文件&quot;, javafile.FullName, (float)curcount / sumcount);        // 判断目标目录是否存在如果不存在则新建        try        &#123;            FileEditorTools.CopyFileToFolder(javafile,folderpath);        &#125;        catch (Exception e)        &#123;            Debug.LogError(e);            EditorUtility.ClearProgressBar();            return;        &#125;        Debug.Log(javafile.FullName);        curcount++;    &#125;    EditorUtility.ClearProgressBar();&#125;public class FileEditorTools&#123;    // 文件列表    private static List&lt;FileInfo&gt; _FileList = new List&lt;FileInfo&gt;();        #region   公有方法    /// &lt;summary&gt;    /// 获得目录下所有文件或指定文件类型文件(包含所有子文件夹)    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件夹路径&lt;/param&gt;    /// &lt;param name=&quot;extName&quot;&gt;扩展名可以多个 例如[.mp4] [.mp3] [.wma] 等&lt;/param&gt;    /// &lt;returns&gt;List&lt;FileInfo&gt;&lt;/returns&gt;    public static List&lt;FileInfo&gt; GetallFile(string path, string extName)    &#123;        //检查目录是否存在        if (!string.IsNullOrWhiteSpace(path))        &#123;            if (Directory.Exists(path))            &#123;                GetallfilesOfDir(path, extName);            &#125;            else            &#123;                Directory.CreateDirectory(path);            &#125;        &#125;        else        &#123;            //注意这里的EverydayLog.Write()是我自定义的日志文件，可以根据需要保留或删除            Debug.LogError(&quot;GetAllFileOfFolder/GetallFile()/存储视频文件的路径为空，请检查！！！&quot; );        &#125;        return _FileList;    &#125;    public static void CopyFileToFolder(FileInfo fileinfo,string fildername)    &#123;        var destfilename = FormatPath(fildername+fileinfo.Name);        File.Copy(fileinfo.FullName, destfilename, true);    &#125;        public static string FormatPath(string path)    &#123;        path = path.Replace(&quot;/&quot;, &quot;\\&quot;);        if (Application.platform == RuntimePlatform.OSXEditor)            path = path.Replace(&quot;\\&quot;, &quot;/&quot;);        return path;    &#125;    #endregion        #region   私有方法    /// &lt;summary&gt;    /// 递归获取指定类型文件,包含子文件夹    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;指定文件夹的路径&lt;/param&gt;    /// &lt;param name=&quot;extName&quot;&gt;文件拓展名&lt;/param&gt;    private static void GetallfilesOfDir(string path, string extName)    &#123;        try        &#123;            string[] dir = Directory.GetDirectories(path); //文件夹列表               DirectoryInfo fdir = new DirectoryInfo(path);            FileInfo[] file = fdir.GetFiles();            if (file.Length != 0 || dir.Length != 0) //当前目录文件或文件夹不为空                               &#123;                foreach (FileInfo f in file) //显示当前目录所有文件                   &#123;                    if (extName.ToLower().IndexOf(f.Extension.ToLower()) &gt;= 0)                    &#123;                        _FileList.Add(f);                    &#125;                &#125;                foreach (string d in dir)                &#123;                    GetallfilesOfDir(d, extName);//递归                   &#125;            &#125;        &#125;        catch (Exception ex)        &#123;            //注意这里的EverydayLog.Write()是我自定义的日志文件，可以根据需要保留或删除            Debug.LogError(&quot;/GetAllFileOfFolder()/GetallfilesOfDir()/获取指定路径：&quot;+path+&quot;   下的文件失败！！！，错误信息=&quot;+ex.Message);        &#125;    &#125;    #endregion    &#125;</code></pre><h2 id="设备唯一标识"><a href="#设备唯一标识" class="headerlink" title="设备唯一标识"></a>设备唯一标识</h2><p>这里的设备唯一标识一开始笔者用的是设备的OAID，后来发现有些设备并不能获取到设别的OAID，并且换位的手机如果打开了”关闭广告追踪“，那么获取的OAID所以这个并不能作为设别的唯一标识，网上有很多进行多数据拼接的方法，于是笔者从自己公司的SDK摘取了或者设备唯一标识的方法，这是一个比较简单的方法，就是先获取设备的androidID，如果获取不到就会自己保存一个数据到文件里，然后每次从文件里读取就行了。  </p><pre><code>private static String deviceId;public String GetDeviceID() &#123;    Application yourApplicatoin = this;//这里只是举个例子，这里需要大家获取一下自己的Application    if (yourApplicatoin.getApplicationContext() == null) //这里是获取Application的实例，如果没有就可以直接返回空        return &quot;&quot;;    else &#123;        String var1;        if ((var1 = deviceId) != null)//先判断deviceID是否已经赋值过了，如果已经赋值就直接返回就行了            return var1;        else &#123;            deviceId = getSPValue(yourApplicatoin, &quot;DeviceId&quot;);//如果没有就先从文件里获取一下            if (!TextUtils.isEmpty(deviceId)) &#123;//如果获取到了就直接返回                return deviceId;            &#125; else &#123;                deviceId = getAndroidIdAsDeviceId(yourApplicatoin);//如果文件里没有就先尝试获取一下androidID作为设备唯一标识                if (!TextUtils.isEmpty(deviceId)) &#123;//获取到了就进行保存并返回这个标识                    saveSPValue(yourApplicatoin, &quot;DeviceId&quot;, deviceId);                    return deviceId;                &#125; else &#123;                    deviceId = generateSoftDeviceId();//如果没有获取到就通过自己的混合加密方式进行缓存                    if (!TextUtils.isEmpty(deviceId)) &#123;//如果不为空就保存然后返回标识                        saveSPValue(yourApplicatoin, &quot;DeviceId&quot;, deviceId);                        return deviceId;                    &#125; else &#123;//如果都没获取到就是特殊情况，直接返回                        return deviceId;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="保存DeviceID到文件里"><a href="#保存DeviceID到文件里" class="headerlink" title="保存DeviceID到文件里"></a>保存DeviceID到文件里</h2><p>通过getSharedPreferences方法将deviceid保存到文件里。</p><pre><code>private static void saveSPValue(Context mycontext, String datakey, String datavalue) &#123;    mycontext.getSharedPreferences(&quot;myappsdkdeviceid&quot;, 0).edit().putString(&quot;datakey&quot;, datavalue).apply();&#125;</code></pre><p>myappsdkdeviceid是文件名字，datakey是保存的关键字名字，然后datavalue是储存的值，就是我们要储存的deviceid。  </p><h2 id="从文件里获取DeviceID"><a href="#从文件里获取DeviceID" class="headerlink" title="从文件里获取DeviceID"></a>从文件里获取DeviceID</h2><pre><code>private static String getSPValue(Context mycontext, String datakey) &#123;    return var0.getSharedPreferences(&quot;myappsdkdeviceid&quot;, 0).getString(datakey, (String)null);&#125;</code></pre><p>myappsdkdeviceid是文件名字，datakey是保存的关键字名字。 </p><h2 id="获取设备的AndroidID"><a href="#获取设备的AndroidID" class="headerlink" title="获取设备的AndroidID"></a>获取设备的AndroidID</h2><pre><code>private static String getAndroidIdAsDeviceId(Context mycontext) &#123;    String andid = Settings.Secure.getString(mycontext.getContentResolver(), &quot;android_id&quot;);//获取设备的AndroidID    return isLegalAndroidId(andid) ? &quot;ANDROID_&quot; + andid : null;//如果符合条件就添加前缀，不符合就返回空&#125;private static final Pattern ANDROID_ID_PATTERN = Pattern.compile(&quot;^[0-9a-fA-F]&#123;16&#125;$&quot;);private static boolean isLegalAndroidId(String andid) &#123;        return !TextUtils.isEmpty(andid) &amp;&amp; ANDROID_ID_PATTERN.matcher(andid).find();&#125;</code></pre><p>第二个函数是判断获得到的android是否不为空并且符合正则表达式的规则  </p><h2 id="自定义的设备唯一标识"><a href="#自定义的设备唯一标识" class="headerlink" title="自定义的设备唯一标识"></a>自定义的设备唯一标识</h2><pre><code>private static long randomLong(long var0) &#123;    return Build.VERSION.SDK_INT &gt;= 21 ? ThreadLocalRandom.current().nextLong(var0) : (long)((new Random()).nextDouble() * (double)(var0 - 1L));&#125;private static String generateSoftDeviceId() &#123;    String arg0  = Build.SERIAL;//首先获取序列号    if (TextUtils.isEmpty(arg0)) &#123;//如果没有获取到序列化就赋值为&quot;NA&quot;        arg0 = &quot;NA&quot;;    &#125;    long arg1 = 2564562216496361285L;//设置两个随机的long型的数据    long arg2 = 8545649582269949258L;    arg2 = randomLong(arg2);//获取一个随机数，获取失败就调回去重新获取    arg1 += arg2;    String var8 = &quot;ANDROID_%1$s_%2$s&quot;;//设置一下格式    Object[] arg3 = new Object[2];    arg3[0] = Long.toHexString(arg1);//设置第一个参数    try &#123;        arg3[1] = arg0;//设置第二个参数        return String.format(var8, arg3);    &#125; catch (Throwable var3) &#123;    &#125;    Object[] arg4;//如果上述存在问题就根据时间设置一个随机数    Object[] arg5 = arg4 = new Object[2];    arg5[0] = &quot;NA&quot; + Long.toHexString(System.currentTimeMillis());    arg5[1] = arg0;    return String.format(&quot;ANDROID_%1$s_%2$s&quot;, arg4);&#125;</code></pre><h1 id="AWS-亚马逊-的CDN上传"><a href="#AWS-亚马逊-的CDN上传" class="headerlink" title="AWS(亚马逊)的CDN上传"></a>AWS(亚马逊)的CDN上传</h1><h2 id="网页上传"><a href="#网页上传" class="headerlink" title="网页上传"></a>网页上传</h2><p>这种上传方式就是访问网页，然后按照需求把自己需要上传的文件上传到对应网页的进行上传。  </p><h2 id="自动上传"><a href="#自动上传" class="headerlink" title="自动上传"></a>自动上传</h2><p>笔者采用的是利用python环境然后写的bat脚本进行上传。  </p><h2 id="Python环境配置"><a href="#Python环境配置" class="headerlink" title="Python环境配置"></a>Python环境配置</h2><p>首先需要在Python虚拟环境中安装 AWS CLI  </p><pre><code>$ pip install awscli</code></pre><p>这里介绍一个python比较好的版本管理工具，可以管理本地多版本的python。<a href="https://www.jianshu.com/p/d66fce9a7bdc"><font color="steelblue" size="3">pyenv</font></a>   </p><h2 id="aws版本查看"><a href="#aws版本查看" class="headerlink" title="aws版本查看"></a>aws版本查看</h2><pre><code>$ aws --version</code></pre><p><img src="https://file.liangxiegame.com/12c0d1cf-5a76-4322-bbb6-55654310b33d.png" alt="image.png">   </p><h2 id="更新aws"><a href="#更新aws" class="headerlink" title="更新aws"></a>更新aws</h2><pre><code>$ aws install awscli --upgrade</code></pre><h2 id="卸载aws"><a href="#卸载aws" class="headerlink" title="卸载aws"></a>卸载aws</h2><pre><code>$ pip uninstall awscli  </code></pre><h2 id="配置AWS-CLI"><a href="#配置AWS-CLI" class="headerlink" title="配置AWS CLI"></a>配置AWS CLI</h2><pre><code>$ aws configureAWS Access Key ID [None]: *******AWS Secret Access Key [None]: *******Default region name [None]: us-east-2Default output format [None]: json</code></pre><p>这里分辨需要填上对应的参数，上面的ID和Key就是自己页面申请aws给提供的。下面的json也只输出的格式，这里最关键的其实是<strong>Default region name</strong>，这里并不是随便填的，而是填上aws终端节点对应的区域代码。  </p><p><img src="https://file.liangxiegame.com/63176da0-0361-49ed-8413-00163af95287.png" alt="image.png">   </p><p>这里其实会再打开终端的目录生成一个.aws文件夹，里面会有config和credentials两个文件就是我们的配置文件了。  </p><h2 id="aws与s3配合使用"><a href="#aws与s3配合使用" class="headerlink" title="aws与s3配合使用"></a>aws与s3配合使用</h2><p>想要使用aws cli上传文件需要与s3配合使用。  </p><h3 id="列举自己的库"><a href="#列举自己的库" class="headerlink" title="列举自己的库"></a>列举自己的库</h3><pre><code>$ aws s3 ls  </code></pre><h3 id="列举库中文件夹内容"><a href="#列举库中文件夹内容" class="headerlink" title="列举库中文件夹内容"></a>列举库中文件夹内容</h3><pre><code>$ aws s3 ls s3://my-bucket  </code></pre><h3 id="上传文件到s3的库"><a href="#上传文件到s3的库" class="headerlink" title="上传文件到s3的库"></a>上传文件到s3的库</h3><pre><code>$aws s3 cp my-file s3://my-bucket/my-folder</code></pre><p>如果每次都使用上面的命令传输文件还是比较麻烦的，所以笔者自己写了一个简单的bat脚本，可以更方便的上传文件  </p><pre><code>@echo offset filePath=..\resource\cdnfileroot\resource\packres\default-pack\android-defaultset cdnPath=s3://cyber-era-cdn/resource/packres/default-pack/android-defaultcall cd %filePath%for %%i in (*.zip) do (    call aws s3 cp %%i %cdnPath%/%%i    echo %%i)pause</code></pre><h1 id="海外文本替换"><a href="#海外文本替换" class="headerlink" title="海外文本替换"></a>海外文本替换</h1><h2 id="提取Prefab中文字到表里"><a href="#提取Prefab中文字到表里" class="headerlink" title="提取Prefab中文字到表里"></a>提取Prefab中文字到表里</h2><p>这里是把prefab上的文字全部提取到一个自定定义的Language表里。首先需要读取自定义的Language表里的数据，这是为了去重用的。然后加载本地所有的prefab，再遍历prefab所有的节点，然后判断是否包含Text的组件，如果包含文字就把文字记录在自己的字典中。在放进字典中是需要排重的。<br>加载Prefab的代码  </p><pre><code>private static void doLoadPrefab(bool clearText,bool onlyFindText = false)//两个参数分别是是否清除Text组件和是否之查找文本，下面会有详细介绍&#123;    ...    if (string.IsNullOrEmpty(ExportExcel.excelFolder))//接下来是查找自己的需要导入的表，不存在就创建一个新的表    &#123;        excelPath = EditorUtility.OpenFilePanel(&quot;选择SVN中的ProgramLanguage表&quot;,&quot;&quot;,&quot;&quot;);    &#125;    else    &#123;        excelPath = ExportExcel.excelFolder + &quot;/ProgramLanguage.xlsx&quot;;    &#125;    if (!string.IsNullOrEmpty(excelPath))    &#123;        ReadExcel();//进行读取加载表格        LoadAllPrefabText(clearText,onlyFindText);//进行加载所有prefab的文本内容        if (clearText)//如果是清除文本组件的就只是需要清除字典        &#123;            textDesAddDic.Clear();        &#125;        else//如果不是清除的就把读取内容写入到表格中        &#123;            WroadExcel();        &#125;    &#125;&#125;</code></pre><p>读取Language代码如下:  </p><pre><code>private static int exKey;private static string exValue;public static void ReadExcel()&#123;    var attrArr = File.GetAttributes(excelPath);//这个是获取表格的属性，因为有些表格可能是只读属性，需要修改    File.SetAttributes(excelPath, FileAttributes.Normal);//把表格的属性设置成普通属性，这样就一定能写入了，之所以不是去掉只读属性是因为只是单独修改可读属性不知道为何还是不能写入，就先设置为普通的属性了    textDesDic.Clear();//清空自己的字典    excelFile = new FileInfo(excelPath);//接着就是获取表格文件    using (ExcelPackage excelPackage = new ExcelPackage(excelFile))//下面就是循环读取表格内容然后写入到字典中    &#123;        var worksheet = excelPackage.Workbook.Worksheets[1];        for (int i = startRow; i &lt;= worksheet.Dimension.End.Row; i++)        &#123;            exKey = worksheet.Cells[i, keyColumn].GetValue&lt;int&gt;();            exValue = worksheet.Cells[i, valueVolumn].GetValue&lt;string&gt;();            startTextIndex = Mathf.Max(exKey, startTextIndex);            textDesDic.Add(exKey, exValue);        &#125;    &#125;    textDesAddDic.Clear();//接着就是把第二个增加的字典清空，是为了记录新增的文字    File.SetAttributes(excelPath, attrArr);//然后就是把文件属性设置为原来的属性&#125;</code></pre><p>写入Language和读取类似，只是把原来的遍历读取变成遍历新增字典，然后一行一行写入。代码如下:  </p><pre><code>public static void WroadExcel()&#123;    var attrArr = File.GetAttributes(excelPath);    File.SetAttributes(excelPath, FileAttributes.Normal);    excelFile = new FileInfo(excelPath);    using (ExcelPackage excelPackage = new ExcelPackage(excelFile))    &#123;        var worksheet = excelPackage.Workbook.Worksheets[1];        var curRow = worksheet.Dimension.End.Row;        foreach (var textdespair in textDesAddDic)        &#123;            worksheet.Cells[++curRow, keyColumn].Value = textdespair.Key;            worksheet.Cells[curRow, valueVolumn].Value = textdespair.Value;        &#125;                excelPackage.Save();//保存表    &#125;        File.SetAttributes(excelPath, attrArr);        textDesAddDic.Clear();&#125;</code></pre><p>加载prefab中的Text文本，代码如下:  </p><pre><code>static StringBuilder newTexts = new StringBuilder();public static void LoadAllPrefabText(bool isClearText,bool onlyFindTxt = false)&#123;    newTexts.Clear();//清空字符串    textDesAddDic.Clear();//清空新增的字典    var sdirs =GetAllPrefabFiles();//获取Prefab的存在文件夹    EditorUtility.DisplayProgressBar(&quot;Progress&quot;, &quot;LoadPrefabTxtDes...&quot;, 0);//打开一个进度掉，为了方便查看加载进度使用    var asstIds = AssetDatabase.FindAssets(&quot;t:Prefab&quot;, sdirs);//得到所有Prefab的资源    int count = 0;//初始化加载的进度    for (int i = 0; i &lt; asstIds.Length; i++)//循环遍历一下自己加载出来的prefab    &#123;        string path = AssetDatabase.GUIDToAssetPath(asstIds[i]);//得到prefab资源的路径        //Debug.LogError(&quot;try deal with path &quot;+path);        var pfb = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(path);//根据路径加载对应的prefab        var texts = pfb.GetComponentsInChildren&lt;Text&gt;(true);//得到prefab上所有节点的Text组件        if (texts == null || texts.Length &lt;= 0)//如果不存在就跳过，遍历到下一个prefab        &#123;            //Debug.LogError(&quot;asset no texts: &quot;+path);            continue;        &#125;        foreach (var item in texts)//遍历prefab中的Text组件        &#123;            textDes = item.text;//获取组件上的文字            if (textDes.IsNullOrWhitespace())//如果文字为空就跳过到下一个                continue;                        var langTextComp = item.gameObject.GetComponent&lt;MutiLangText&gt;();//获取Text文本上的脚本，自己写的替换文本的脚本            if (langTextComp &amp;&amp; onlyFindTxt)//如果存在脚本并且只是查找文本，说明已经添加过就可以直接跳过了            &#123;                continue;                //Debug.LogError(&quot;has Added MutiText: &quot;+item.name);            &#125;            bool addComP = false;//标记是否增加组件为false            if (isClearText)//判断是否需要清除自己的替换语言脚本            &#123;                if (!textDesDic.ContainsValue(textDes))//判断表里是否已经存在文本                &#123;                    item.text = &quot;&quot;;//如果不存在就先清除文字                    if (langTextComp)//如果不存在自己的脚本就一并删除                    &#123;                        //TODO  remove  comp                        DestroyImmediate(langTextComp);                    &#125;                &#125;                else//如果表里存在就从字典里获取到表里的ID                &#123;                    curDesId = textDesDic.Where(q =&gt; q.Value == textDes).Select(q =&gt; q.Key).ToArray()[0];                    addComP = true;//标记需要增加组件                &#125;            &#125;            else//如果不是清除文本            &#123;                if (onlyFindTxt)//如果只是查找文本                &#123;                    if (!textDesDic.ContainsValue(textDes))//如果字典中不存在就记录下来                    &#123;                        newTexts.AppendLine(textDes);                    &#125;                    continue;                &#125;                if (!textDesDic.ContainsValue(textDes))//如果字典中不存在，就往字典中添加，并且在新增字典中增加                &#123;                    textDesDic.Add(++startTextIndex, textDes);                    textDesAddDic.Add(startTextIndex,textDes);                    curDesId = startTextIndex;                &#125;                else//如果存在就记录下来文本对应的ID                &#123;                    curDesId = textDesDic.Where(q =&gt; q.Value == textDes).Select(q =&gt; q.Key).ToArray()[0];                &#125;                                if(!langTextComp)//如果并没有增加切换语言脚本就标记需要增加脚本                &#123;                    addComP = true;                &#125;            &#125;            if (addComP &amp;&amp; !langTextComp)//如果需要增加并且组件不存在，就增加一下自己的脚本            &#123;                langTextComp = item.gameObject.AddComponent&lt;MutiLangText&gt;();                langTextComp.baseText = item;            &#125;                        if (langTextComp)//如果存在组件就更新一下ID                langTextComp.languageID = curDesId;        &#125;        PrefabUtility.SavePrefabAsset(pfb, out bool success);//修改完毕保存prefab就可以了        if (success)//记录加载进度，然后更新进度条        &#123;            count++;        &#125;        EditorUtility.DisplayProgressBar(&quot;LoadPrefabTxtDes Progress&quot;, pfb.name, count / (float)asstIds.Length);    &#125;    if (newTexts.Length &gt; 0)//如果有新增的文字就记录下来    &#123;        Debug.LogError(&quot;write new text: &quot;+newTexts.Length);        File.WriteAllText(ExportExcel.excelFolder + &quot;/newText.txt&quot;,newTexts.ToString());    &#125;    EditorUtility.ClearProgressBar();//结束之后清除加载进度条&#125;</code></pre><p>获取Prefab文件路径的代码：  </p><pre><code>private static string[] GetAllPrefabFiles()&#123;    string sdir = &quot;Assets/XXX/XXX&quot;;    List&lt;string&gt; sdirlist = new List&lt;string&gt;();    sdirlist.Add(sdir);    sdirlist.Add(&quot;Assets/Resources/RootPrefab&quot;);       return sdirlist.ToArray();    &#125;</code></pre><h2 id="查找代码中的中文"><a href="#查找代码中的中文" class="headerlink" title="查找代码中的中文"></a>查找代码中的中文</h2><p>因为一开始没有考虑到会做海外，并且写的代码不规范，所以存在一部分中文是在代码里。这部分中文代码是不好查找的，所以写了一个小脚本，可以快速标记到中文代码的位置，这个脚本可以解决大部分，但是仍旧是存在找不到的问题的。下面来看代码:  </p><p>首先会打开一个面板用来选择代码脚本所在的文件路径</p><pre><code>[MenuItem(&quot;Tools/ReplaceText/FindScriptsLanguage&quot;)]public static void Pack()&#123;    Rect wr = new Rect(300, 400, 400, 100);    FindChineseWindow window = (FindChineseWindow)EditorWindow.GetWindowWithRect(typeof(FindChineseWindow), wr, true, &quot;查找项目中的中文字符&quot;);    window.Show();&#125;public class FindChineseWindow : EditorWindow&#123;    private ArrayList csList = new ArrayList();    private int eachFrameFind = 4;    private int currentIndex = 0;    private bool isBeginUpdate = false;    private string outputText;    public string filePath = &quot;/Scripts&quot;;    private string strForShader = &quot;&quot;;    //这个是需要忽略检测的文件夹    private List&lt;string&gt; ingoreFileInfoDirNameList = new List&lt;string&gt; &#123;&quot;GMConsole&quot;, &quot;LogicWorld&quot;, &quot;NetWork&quot;, &quot;SDK&quot;&#125;;    //这个是需要忽略的代码文件名    private List&lt;string&gt; ingoreFileInfoNameList = new List&lt;string&gt; &#123;&quot;LocalLanguage&quot;&#125;;    //这个是需要忽略的代码包含的字符串    private List&lt;string&gt; ingoreScriptesDesList = new List&lt;string&gt; &#123;&quot;Debug&quot;, &quot;LogWrapper&quot;, &quot;Tooltip&quot;, &quot;throw new&quot;&#125;;    //获取需要检测的文件    private void GetAllFile(DirectoryInfo dir)    &#123;        FileInfo[] allFile = dir.GetFiles();        foreach (FileInfo fi in allFile)        &#123;            if (ingoreFileInfoDirNameList.Where(str =&gt; fi.DirectoryName.Contains(str)).Count() &gt; 0)                 continue;            if (ingoreFileInfoNameList.Where(str =&gt; fi.Name.Contains(str)).Count() &gt; 0)                 continue;            if (fi.FullName.IndexOf(&quot;.meta&quot;) == -1 &amp;&amp; fi.FullName.IndexOf(&quot;.cs&quot;) != -1)            &#123;                csList.Add(fi.DirectoryName + &quot;/&quot; + fi.Name);            &#125;        &#125;        DirectoryInfo[] allDir = dir.GetDirectories();        foreach (DirectoryInfo d in allDir)//遍历子文件夹        &#123;            GetAllFile(d);        &#125;    &#125;    public void OnGUI()//面板显示的代码    &#123;        filePath = EditorGUILayout.TextField(&quot;路径：&quot;, filePath);//输入路径        EditorGUILayout.Space();        EditorGUILayout.Space();        if (GUILayout.Button(&quot;开始遍历目录&quot;))//显示的按钮        &#123;            csList.Clear();            DirectoryInfo d = new DirectoryInfo(Application.dataPath + filePath);//从绝对路径读取文件            GetAllFile(d);//获取所有的文件            //GetAllFile(d);            outputText = &quot;游戏内代码文件的数量：&quot; + csList.Count;            isBeginUpdate = true;            outputText = &quot;开始遍历项目&quot;;        &#125;        GUILayout.Label(outputText, EditorStyles.boldLabel);    &#125;    private bool HasChinese(string str)//这是个判断是否是中文的方法    &#123;        return Regex.IsMatch(str, @&quot;[\u4e00-\u9fa5]&quot;);    &#125;    private Regex regex = new Regex(&quot;\&quot;[^\&quot;]*\&quot;&quot;);    private void printChinese(string path)//开始输出中文文字所在位置    &#123;        if (File.Exists(path))        &#123;            string[] fileContents = File.ReadAllLines(path, Encoding.Default);            int count = fileContents.Length;            for (int i = 0; i &lt; count; i++)            &#123;                string printStr = fileContents[i].Trim();                if (printStr.IndexOf(&quot;//&quot;) == 0) //说明是注释                    continue;                if (ingoreScriptesDesList.Where(str =&gt; printStr.Contains(str)).Count() &gt; 0) //说明是需要排除的代码                    continue;                MatchCollection matches = regex.Matches(printStr);                foreach (Match match in matches)                &#123;                    if (HasChinese(match.Value))                    &#123;                        string[] fullPath = path.Split(&#39;/&#39;);                        path = fullPath[fullPath.Length - 1];                        Debug.Log(&quot;路径:&quot; + path + &quot; 行数:&quot; + i + &quot; 内容:&quot; + printStr);                        break;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 海外Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——基于UGUI实现性能更好的圆形Image</title>
      <link href="/2021/04/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EUGUI%E5%AE%9E%E7%8E%B0%E6%80%A7%E8%83%BD%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%9C%86%E5%BD%A2Image/"/>
      <url>/2021/04/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EUGUI%E5%AE%9E%E7%8E%B0%E6%80%A7%E8%83%BD%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%9C%86%E5%BD%A2Image/</url>
      
        <content type="html"><![CDATA[<p>参考博客地址：<a href="https://www.cnblogs.com/leoin2012/p/6425089.html">https://www.cnblogs.com/leoin2012/p/6425089.html</a>  </p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在我们开发游戏过程中，会经常使用Mask来进行图片的裁剪，但是笔者在使用Mask进行裁剪的时候发现锯齿特别严重，因此笔者选择了利用shader进行图形遮罩，详情请看<a href="https://lianbai.github.io/2021/04/20/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UGUI%E5%9F%BA%E4%BA%8E%E5%9B%BE%E9%9B%86%E7%9A%84shader%E9%81%AE%E7%BD%A9/">Unity杂文——UGUI基于图集的shader遮罩</a>。<br>笔者虽然已经利用shader做好了遮罩并应用项目中的，但是在笔者在学习UGUI优化的时候发现Mask不仅有锯齿，也会增加两个DrawCall，因为Mask会把自己和子节点都和外面分开，不会进行合批，这样mask越多，DrawCall就会比较严重，笔者利用Shader进行遮罩虽然也会多一个DrawCall，但是相同的材质会进行合批，<br>裁剪随然已经改好了，但是笔者发现了不会增加DrawCall的方法。  </p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>我们在屏幕上看到的图形是GPU渲染出来的，而GPU渲染的最小单位是三角面片，我们从Unity的Scence场景中，切换视图方式为WireFrame或者Shader Wireframe都可以明显看到图片是三角形组成的，而我们要制作出圆形的Image可以利用多个等腰三角形，这样就可以拼接成看似圆形的Image，三角形数量越多就越像圆形。如下图：  </p><p><img src="https://file.liangxiegame.com/fc913a59-b938-4129-8c69-fc299a3ba79b.png" alt="image.png">   </p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>首先我们需要自己重写Image，我们要自己实现画图，我们首先查看Image的原码：  </p><pre><code>public class Image : MaskableGraphic, ISerializationCallbackReceiver, ILayoutElement, ICanvasRaycastFilter</code></pre><p>我们可以看到Image继承了MaskableGraphic，并且实现了ISerializationCallbackReceiver、ILayoutElement、ICanvasRaycastFilter的接口。最关键的其实是MaskableGraphic类，因为这个类主要是负责画图的，我们可以很简单的看到MaskableGraphic类其实继承了Graphic类，在这个类里面有个OnPopulateMesh函数，这个函数就是我们需要重写的函数。<br>当UI元素生成顶点数据时就会调用OnPopulateMesh函数，我们只需要继承这个函数并且将原来的顶带你数据清除，改写成我们自己设置的圆形的顶带你数据，这样我们就可以画我们需要的圆形了。<br>由于在Unity中，继承UnityEngine基类的派生类并不能在Inspector面板里显示参数，笔者在制作圆形的Image的时候肯定要设置一些可调节的参数，这样可以应用到更多的场景中，因为笔者就像参考博客一样新建一个BaseImage类去继承Image类，然后自己再写一个CircleImage类去继承BaseImage类，这样我们把可调节的变量放在CircleImage类中，这样就可以通过面板调节参数了。<font color="red">(原Image源码有近千行代码，BaseImage对其进行了部分精简，只支持Simple Image Type，并去掉了eventAlphaThreshold的相关代码。经过删减，得到一个百行代码的BaseImage类，精简版Image就完成了。)</font>  </p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>完整代码在最后面，因为内容过多，笔者就先写代码分析，您可以先复制最后的完整代码到工程里，然后自己对着代码一步一步进行。  </p><h3 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h3><p>笔者首先介绍一下笔者设置的允许调节的参数，参数描述都在代码中，代码如下：  </p><pre><code>[Tooltip(&quot;圆形的半径&quot;)][Range(0, 1)]public float fillRadius = 1f;[Tooltip(&quot;UV缩放比例&quot;)][Range(0, 1)]public float UVScale = 1f;[Tooltip(&quot;圆形的中心点&quot;)]public Vector2 fillCenter = new Vector2(0.5f, 0.5f);[Tooltip(&quot;圆形或扇形填充比例&quot;)][Range(0, 1)]public float fillPercent = 1f;[Tooltip(&quot;是否填充圆形&quot;)]public bool fill = true;[Tooltip(&quot;圆环宽度&quot;)]public float thickness = 5;[Tooltip(&quot;圆形&quot;)][Range(3, 100)]public int segements = 20;//填充三角形数量</code></pre><p>在OnPopulateMesh函数中，函数的参数VertexHelper就是原来图片的顶带你信息，因为我们要重写这些顶点信息，所以我们要清空vh。在我们设置自己的顶点的信息之前，我们需要获得UV信息，获取方法就是DataUtility.GetOuterUV(overrideSprite)。  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    Vector4 uv = overrideSprite != null ? DataUtility.GetOuterUV(overrideSprite) : Vector4.zero;    float uvCenterX = (uv.x + uv.z) * (0.5f + (fillCenter.x - 0.5f) * (uv.z - uv.x));    float uvCenterY = (uv.y + uv.w) * (0.5f + (fillCenter.y - 0.5f) * (uv.w - uv.y));    float uvScaleX = (uv.z - uv.x) / tw  * fillRadius * UVScale;    float uvScaleY = (uv.w - uv.y) / th  * fillRadius * UVScale;    ...&#125;</code></pre><p>在设置的属性中我们有一个变量segements就是我们需要的三角形数量，正如原理将的，三角形数量越多，越像圆形，但是顶点数据就越多，影响性能，所以我们设置这个参数可以根据需求设置数量，然后我们知道数量后就可以算出顶点的夹角，然后面片数segements与填充比例fillPercent相乘，就知道要用多少个面片来显示圆形&#x2F;扇形  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    //算出每个面片的顶点夹角，面片数segements与填充比例fillPercent相乘，就知道要用多少个面片来显示圆形/扇形    float degreeDelta = (float)(2 * Mathf.PI / segements);    int curSegements = (int)(segements * fillPercent);    ...&#125;</code></pre><p>我们可以通过RectTransform获取原图矩形的宽高，笔者这里也添加了一个可以调整的参数圆形半径个圆环宽度，圆环宽度是用来做圆环形状显示的，圆形半径其实就是原图的宽高乘以圆的半径就行了，这里圆的半径其实是一个比例，把原图的比作为1。  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    //通过RectTransform获取矩形宽高，计算出半径    float tw = rectTransform.rect.width * fillRadius;    float th = rectTransform.rect.height * fillRadius;    float outerRadius = rectTransform.pivot.x * tw;    float innerRadius = rectTransform.pivot.x * tw - thickness;    ...&#125;</code></pre><p>已经有了半径，夹角信息，根据圆形点坐标公式(radius * cosA,radius * sinA)可以算出顶点坐标，每次迭代新建UIVertex，将求出的坐标，color，uv等参数传入，再将UIVertex传给VertexHelper。重复迭代n次，VertexHelper就获得了多边形顶点及圆心点信息了。  这里笔者也设置了参数，UV的缩放和圆的中心点，也是为了适应更多的场景</p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    float uvCenterX = (uv.x + uv.z) * (0.5f + (fillCenter.x - 0.5f) * (uv.z - uv.x));    float uvCenterY = (uv.y + uv.w) * (0.5f + (fillCenter.y - 0.5f) * (uv.w - uv.y));    float uvScaleX = (uv.z - uv.x) / tw  * fillRadius * UVScale;    float uvScaleY = (uv.w - uv.y) / th  * fillRadius * UVScale;    float curDegree = 0;    UIVertex uiVertex;    int verticeCount;    int triangleCount;    Vector2 curVertice;    curVertice = Vector2.zero;    verticeCount = curSegements + 1;    uiVertex = new UIVertex();    uiVertex.color = color;    uiVertex.position = curVertice;    uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);    vh.AddVert(uiVertex);    for (int i = 1; i &lt; verticeCount; i++)    &#123;        float cosA = Mathf.Cos(curDegree);        float sinA = Mathf.Sin(curDegree);        curVertice = new Vector2(cosA * outerRadius, sinA * outerRadius);        curDegree += degreeDelta;        uiVertex = new UIVertex();        uiVertex.color = color;        uiVertex.position = curVertice;        uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);        vh.AddVert(uiVertex);        outterVertices.Add(curVertice);    &#125;    ...&#125;</code></pre><p>虽然已经传入了所有的顶带你信息，但是GPU还不知道顶点信息之间的关系，不知道顶带你分成了多少个三角形片面，所以还需要把三角形的信息告诉GPU,这里有一个VertexHelper的接口就是**AddTriangle(int idx0, int idx1, int idx2)**来接受三角形信息。<br>接口的传入参数并不是UIVertex类型，而是int类型的索引值。哪来的索引？还记得之前往VertexHelper传入了一堆顶点吗？按照传入顺序，第一个顶点，索引记为0，依次类推。每次传入三个顶点的索引，就记录下了一个三角形。  </p><blockquote><p>需要注意，GPU 默认是做backface culling(背面剔除)的，GPU只渲染正对屏幕的三角面片，当GPU认为某个三角面片是背对屏幕时，直接丢弃该三角面片，不做渲染。那么GPU怎么判断我们传入的某个三角形是正对屏幕，还是背对屏幕？答案是通过三个顶点的时针顺序，当三个顶点是呈顺时针时，判定为正对屏幕；呈逆时针时，判定为背对屏幕。</p></blockquote><p><img src="https://file.liangxiegame.com/f83adeb0-049d-413a-b538-e8a2cab10a6c.png" alt="image.png"></p><p>VertexHelper收到的第一个顶点是圆心，且算法是按逆时针方向，迭代计算出的多边形顶点，并依次传给VertexHelper。因此按(i, 0, i+1)(i&gt;&#x3D;1)的规律取索引，就可以保证顶点顺序是顺时针的。  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    triangleCount = curSegements*3;    for (int i = 0, vIdx = 1; i &lt; triangleCount - 3; i += 3, vIdx++)    &#123;        vh.AddTriangle(vIdx, 0, vIdx+1);    &#125;    if (fillPercent == 1)    &#123;        //首尾顶点相连        vh.AddTriangle(verticeCount - 1, 0, 1);    &#125;    ...&#125;</code></pre><p>到此我们的圆形算是绘制完成了，但是观测我们的变量可以看出，笔者还支持了圆环的绘制  </p><h3 id="圆环"><a href="#圆环" class="headerlink" title="圆环"></a>圆环</h3><p>圆环的情况稍微复杂：顶点集没有圆心顶点了，只有内环、外环顶点；三角形集也不是简单的切饼式分割，采用一种比较直观的三角形划分，让内外环相邻的顶点类似一根鞋带那样互相连接，来划分三角形。  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    float uvCenterX = (uv.x + uv.z) * (0.5f + (fillCenter.x - 0.5f) * (uv.z - uv.x));    float uvCenterY = (uv.y + uv.w) * (0.5f + (fillCenter.y - 0.5f) * (uv.w - uv.y));    float uvScaleX = (uv.z - uv.x) / tw  * fillRadius * UVScale;    float uvScaleY = (uv.w - uv.y) / th  * fillRadius * UVScale;    float curDegree = 0;    UIVertex uiVertex;    int verticeCount;    int triangleCount;    Vector2 curVertice;    curVertice = Vector2.zero;    verticeCount = curSegements + 1;    uiVertex = new UIVertex();    uiVertex.color = color;    uiVertex.position = curVertice;    uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);    vh.AddVert(uiVertex);     verticeCount = curSegements*2;    for (int i = 0; i &lt; verticeCount; i += 2)    &#123;        float cosA = Mathf.Cos(curDegree);        float sinA = Mathf.Sin(curDegree);        curDegree += degreeDelta;        curVertice = new Vector3(cosA * innerRadius, sinA * innerRadius);        uiVertex = new UIVertex();        uiVertex.color = color;        uiVertex.position = curVertice;        uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);        vh.AddVert(uiVertex);        innerVertices.Add(curVertice);        curVertice = new Vector3(cosA * outerRadius, sinA * outerRadius);        uiVertex = new UIVertex();        uiVertex.color = color;        uiVertex.position = curVertice;        uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);        vh.AddVert(uiVertex);        outterVertices.Add(curVertice);    &#125;    ...&#125;</code></pre><h3 id="点击判断"><a href="#点击判断" class="headerlink" title="点击判断"></a>点击判断</h3><p>传统的UGUI的Image的点击判断是只要在矩形内点击，不管是不是透明，都认定为点击到了，笔者从网上学习了一套更好的判断点击的方法，利用的是<strong>Ray-Crossing算法</strong>。Ray-Crossing算法大概思路是从指定点p发出一条射线，与多边形相交，假若交点个数是奇数，说明点p落在多边形内，交点个数为偶数说明点p在多边形外。<br>射线选取哪个方向并没有限制，但为了实现起来方便，考虑屏幕点击点为点p，向水平方向右侧发出射线的情况，那么顶点v1,v2组成的线段与射线若有交点q，则点q必定满足两个条件：</p><blockquote><p>v2.y &lt; q.y &#x3D; p.y &gt; v1.y<br>p.x &lt; q.x  </p></blockquote><p>我们根据这两个条件，逐一跟多边形线段求交点，并统计交点个数，最后判断奇偶即可得知点击点是否在圆形内。  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    public override bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)    &#123;        Sprite sprite = overrideSprite;        if (sprite == null)            return true;        Vector2 local;        RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, screenPoint, eventCamera, out local);        return Contains(local, outterVertices, innerVertices);    &#125;        private bool Contains(Vector2 p, List&lt;Vector3&gt; outterVertices, List&lt;Vector3&gt; innerVertices)    &#123;        var crossNumber = 0;        if(!fill)            RayCrossing(p, innerVertices, ref crossNumber);//检测内环        RayCrossing(p, outterVertices, ref crossNumber);//检测外环        return (crossNumber &amp; 1) == 1;    &#125;        /// &lt;summary&gt;    /// 使用RayCrossing算法判断点击点是否在封闭多边形里    /// &lt;/summary&gt;    /// &lt;param name=&quot;p&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;vertices&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;crossNumber&quot;&gt;&lt;/param&gt;    private void RayCrossing(Vector2 p, List&lt;Vector3&gt; vertices, ref int crossNumber)    &#123;        for (int i = 0, count = vertices.Count; i &lt; count; i++)        &#123;            var v1 = vertices[i];            var v2 = vertices[(i + 1) % count];            //点击点水平线必须与两顶点线段相交            if (((v1.y &lt;= p.y) &amp;&amp; (v2.y &gt; p.y))                || ((v1.y &gt; p.y) &amp;&amp; (v2.y &lt;= p.y)))            &#123;                //只考虑点击点右侧方向，点击点水平线与线段相交，且交点x &gt; 点击点x，则crossNumber+1                if (p.x &lt; v1.x + (p.y - v1.y) / (v2.y - v1.y) * (v2.x - v1.x))                &#123;                    crossNumber += 1;                &#125;            &#125;        &#125;    &#125;    ...&#125;</code></pre><p>###SetNativeSize<br>SetNativeSize的实现比较简单，只要把宽高设置图片的高度就行了。</p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    public override void SetNativeSize()    &#123;        if (activeSprite != null)        &#123;            float w = activeSprite.rect.width / pixelsPerUnit;            float h = activeSprite.rect.height / pixelsPerUnit;            rectTransform.anchorMax = rectTransform.anchorMin;            rectTransform.sizeDelta = new Vector2(w, h);            SetAllDirty();        &#125;    &#125;    ...&#125;</code></pre><p>在这里笔者遇到了一个问题，就是我们怎么能像Image那样调用这个方法呢，笔者参考了Image的原码，Imnage是有一个专门的Editor脚本设置面板显示的，于是笔者就写了一个CircleImageEditor的脚本来控制。只需要脚本继承GraphicEditor，然后通过[CustomEditor(typeof(CircleImage))]标签就可以实现脚本的控制了。  </p><pre><code>[CustomEditor(typeof(CircleImage))]public class CircleImageEditor : GraphicEditor&#123;    public override void OnInspectorGUI() &#123;        DrawDefaultInspector();                CircleImage myScript = (CircleImage)target;        EditorGUILayout.BeginHorizontal();        &#123;            GUILayout.Space(EditorGUIUtility.labelWidth);            if (GUILayout.Button(&quot;Set Native Size&quot;, EditorStyles.miniButtonRight))            &#123;                myScript.SetNativeSize();            &#125;        &#125;        EditorGUILayout.EndHorizontal();    &#125;&#125;</code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>笔者在制作BaseImage的时候并没有继承MaskableGraphic而是自己复制了一份到BaseMaskableGraphic类中，这是因为笔者不喜欢脚本在Inspector面面板中显示m_OnCullStateChanged这个事件，因此笔者复制了一份，只是把这个变量变成了私有，就不在面板显示，如果不介意面板的了可以继续继承MaskableGraphic。</p><h3 id="BaseImage"><a href="#BaseImage" class="headerlink" title="BaseImage"></a>BaseImage</h3><pre><code>public class BaseImage : BaseMaskableGraphic,ISerializationCallbackReceiver, ILayoutElement, ICanvasRaycastFilter&#123;    [FormerlySerializedAs(&quot;m_Frame&quot;)]    [SerializeField]    private Sprite m_Sprite;        //私有的sorite，内部调用，防止外部修改    //对外公开的sprite属性    public Sprite sprite    &#123;        get &#123; return m_Sprite; &#125;        set&#123;if (SetPropertyUtilityExt.SetClass(ref m_Sprite, value)) SetAllDirty();&#125;    &#125;    [NonSerialized]    private Sprite m_OverrideSprite;        protected BaseImage()    &#123;        useLegacyMeshGeneration = false;    &#125;    public Sprite overrideSprite    &#123;        get &#123; return m_OverrideSprite == null ? sprite : m_OverrideSprite; &#125;        set        &#123;            if (SetPropertyUtilityExt.SetClass(ref m_OverrideSprite, value)) SetAllDirty();        &#125;    &#125;    /// &lt;summary&gt;    /// Image&#39;s texture comes from the UnityEngine.Image.    /// &lt;/summary&gt;    public override Texture mainTexture    &#123;        get        &#123;            return overrideSprite == null ? s_WhiteTexture : overrideSprite.texture;        &#125;    &#125;    public Sprite activeSprite &#123; get &#123; return overrideSprite != null ? overrideSprite : sprite; &#125; &#125;            public float pixelsPerUnit    &#123;        get        &#123;            float spritePixelsPerUnit = 100;            if (sprite)                spritePixelsPerUnit = sprite.pixelsPerUnit;            float referencePixelsPerUnit = 100;            if (canvas)                referencePixelsPerUnit = canvas.referencePixelsPerUnit;            return spritePixelsPerUnit / referencePixelsPerUnit;        &#125;    &#125;            /// &lt;summary&gt;    /// 子类需要重写该方法来自定义Image形状    /// &lt;/summary&gt;    /// &lt;param name=&quot;vh&quot;&gt;&lt;/param&gt;    protected override void OnPopulateMesh(VertexHelper vh)    &#123;        base.OnPopulateMesh(vh);    &#125;    #region ISerializationCallbackReceiver        public void OnBeforeSerialize()    &#123;    &#125;    public void OnAfterDeserialize()    &#123;    &#125;        #endregion    #region ILayoutElement    public virtual void CalculateLayoutInputHorizontal() &#123; &#125;    public virtual void CalculateLayoutInputVertical() &#123; &#125;    public virtual float minWidth &#123; get &#123; return 0; &#125; &#125;    public virtual float preferredWidth    &#123;        get        &#123;            if (overrideSprite == null)                return 0;            return overrideSprite.rect.size.x / pixelsPerUnit;        &#125;    &#125;    public virtual float flexibleWidth &#123; get &#123; return -1; &#125; &#125;    public virtual float minHeight &#123; get &#123; return 0; &#125; &#125;    public virtual float preferredHeight    &#123;        get        &#123;            if (overrideSprite == null)                return 0;            return overrideSprite.rect.size.y / pixelsPerUnit;        &#125;    &#125;    public virtual float flexibleHeight &#123; get &#123; return -1; &#125; &#125;    public virtual int layoutPriority &#123; get &#123; return 0; &#125; &#125;    #endregion        #region ICanvasRaycastFilter    public virtual bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)    &#123;        return true;    &#125;    #endregion&#125;</code></pre><h3 id="CircleImage"><a href="#CircleImage" class="headerlink" title="CircleImage"></a>CircleImage</h3><pre><code>[AddComponentMenu(&quot;UI/Circle Image&quot;)]public class CircleImage : BaseImage&#123;    [Tooltip(&quot;圆形的半径&quot;)]    [Range(0, 1)]    public float fillRadius = 1f;    [Tooltip(&quot;UV缩放比例&quot;)]    [Range(0, 1)]    public float UVScale = 1f;    [Tooltip(&quot;圆形的中心点&quot;)]    public Vector2 fillCenter = new Vector2(0.5f, 0.5f);    [Tooltip(&quot;圆形或扇形填充比例&quot;)]    [Range(0, 1)]    public float fillPercent = 1f;    [Tooltip(&quot;是否填充圆形&quot;)]    public bool fill = true;    [Tooltip(&quot;圆环宽度&quot;)]    public float thickness = 5;    [Tooltip(&quot;圆形&quot;)]    [Range(3, 100)]    public int segements = 20;    private List&lt;Vector3&gt; innerVertices;    private List&lt;Vector3&gt; outterVertices;    void Awake()    &#123;        innerVertices = new List&lt;Vector3&gt;();        outterVertices = new List&lt;Vector3&gt;();    &#125;        // Update is called once per frame    void Update () &#123;        if(!fill)            this.thickness = (float)Mathf.Clamp(this.thickness, 0, rectTransform.rect.width / 2);    &#125;    protected override void OnPopulateMesh(VertexHelper vh)    &#123;        vh.Clear();        innerVertices.Clear();        outterVertices.Clear();        //算出每个面片的顶点夹角，面片数segements与填充比例fillPercent相乘，就知道要用多少个面片来显示圆形/扇形        float degreeDelta = (float)(2 * Mathf.PI / segements);        int curSegements = (int)(segements * fillPercent);        //通过RectTransform获取矩形宽高，计算出半径        float tw = rectTransform.rect.width * fillRadius;        float th = rectTransform.rect.height * fillRadius;        float outerRadius = rectTransform.pivot.x * tw;        float innerRadius = rectTransform.pivot.x * tw - thickness;        Vector4 uv = overrideSprite != null ? DataUtility.GetOuterUV(overrideSprite) : Vector4.zero;        float uvCenterX = (uv.x + uv.z) * (0.5f + (fillCenter.x - 0.5f) * (uv.z - uv.x));        float uvCenterY = (uv.y + uv.w) * (0.5f + (fillCenter.y - 0.5f) * (uv.w - uv.y));        float uvScaleX = (uv.z - uv.x) / tw  * fillRadius * UVScale;        float uvScaleY = (uv.w - uv.y) / th  * fillRadius * UVScale;        float curDegree = 0;        UIVertex uiVertex;        int verticeCount;        int triangleCount;        Vector2 curVertice;        if (fill) //圆形        &#123;            curVertice = Vector2.zero;            verticeCount = curSegements + 1;            uiVertex = new UIVertex();            uiVertex.color = color;            uiVertex.position = curVertice;            uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);            vh.AddVert(uiVertex);            for (int i = 1; i &lt; verticeCount; i++)            &#123;                float cosA = Mathf.Cos(curDegree);                float sinA = Mathf.Sin(curDegree);                curVertice = new Vector2(cosA * outerRadius, sinA * outerRadius);                curDegree += degreeDelta;                uiVertex = new UIVertex();                uiVertex.color = color;                uiVertex.position = curVertice;                uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);                vh.AddVert(uiVertex);                outterVertices.Add(curVertice);            &#125;            triangleCount = curSegements*3;            for (int i = 0, vIdx = 1; i &lt; triangleCount - 3; i += 3, vIdx++)            &#123;                vh.AddTriangle(vIdx, 0, vIdx+1);            &#125;            if (fillPercent == 1)            &#123;                //首尾顶点相连                vh.AddTriangle(verticeCount - 1, 0, 1);            &#125;        &#125;        else//圆环        &#123;            verticeCount = curSegements*2;            for (int i = 0; i &lt; verticeCount; i += 2)            &#123;                float cosA = Mathf.Cos(curDegree);                float sinA = Mathf.Sin(curDegree);                curDegree += degreeDelta;                curVertice = new Vector3(cosA * innerRadius, sinA * innerRadius);                uiVertex = new UIVertex();                uiVertex.color = color;                uiVertex.position = curVertice;                uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);                vh.AddVert(uiVertex);                innerVertices.Add(curVertice);                curVertice = new Vector3(cosA * outerRadius, sinA * outerRadius);                uiVertex = new UIVertex();                uiVertex.color = color;                uiVertex.position = curVertice;                uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);                vh.AddVert(uiVertex);                outterVertices.Add(curVertice);            &#125;            triangleCount = curSegements*3*2;            for (int i = 0, vIdx = 0; i &lt; triangleCount - 6; i += 6, vIdx += 2)            &#123;                vh.AddTriangle(vIdx+1, vIdx, vIdx+3);                vh.AddTriangle(vIdx, vIdx + 2, vIdx + 3);            &#125;            if (fillPercent == 1)            &#123;                //首尾顶点相连                vh.AddTriangle(verticeCount - 1, verticeCount - 2, 1);                vh.AddTriangle(verticeCount - 2, 0, 1);            &#125;        &#125;    &#125;        public override bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)    &#123;        Sprite sprite = overrideSprite;        if (sprite == null)            return true;        Vector2 local;        RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, screenPoint, eventCamera, out local);        return Contains(local, outterVertices, innerVertices);    &#125;        private bool Contains(Vector2 p, List&lt;Vector3&gt; outterVertices, List&lt;Vector3&gt; innerVertices)    &#123;        var crossNumber = 0;        if(!fill)            RayCrossing(p, innerVertices, ref crossNumber);//检测内环        RayCrossing(p, outterVertices, ref crossNumber);//检测外环        return (crossNumber &amp; 1) == 1;    &#125;        /// &lt;summary&gt;    /// 使用RayCrossing算法判断点击点是否在封闭多边形里    /// &lt;/summary&gt;    /// &lt;param name=&quot;p&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;vertices&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;crossNumber&quot;&gt;&lt;/param&gt;    private void RayCrossing(Vector2 p, List&lt;Vector3&gt; vertices, ref int crossNumber)    &#123;        for (int i = 0, count = vertices.Count; i &lt; count; i++)        &#123;            var v1 = vertices[i];            var v2 = vertices[(i + 1) % count];            //点击点水平线必须与两顶点线段相交            if (((v1.y &lt;= p.y) &amp;&amp; (v2.y &gt; p.y))                || ((v1.y &gt; p.y) &amp;&amp; (v2.y &lt;= p.y)))            &#123;                //只考虑点击点右侧方向，点击点水平线与线段相交，且交点x &gt; 点击点x，则crossNumber+1                if (p.x &lt; v1.x + (p.y - v1.y) / (v2.y - v1.y) * (v2.x - v1.x))                &#123;                    crossNumber += 1;                &#125;            &#125;        &#125;    &#125;            /// &lt;summary&gt;    /// Adjusts the image size to make it pixel-perfect.    /// &lt;/summary&gt;    /// &lt;remarks&gt;    /// This means setting the Images RectTransform.sizeDelta to be equal to the Sprite dimensions.    /// &lt;/remarks&gt;    public override void SetNativeSize()    &#123;        if (activeSprite != null)        &#123;            float w = activeSprite.rect.width / pixelsPerUnit;            float h = activeSprite.rect.height / pixelsPerUnit;            rectTransform.anchorMax = rectTransform.anchorMin;            rectTransform.sizeDelta = new Vector2(w, h);            SetAllDirty();        &#125;    &#125;&#125;</code></pre><h3 id="CircleImageEditor"><a href="#CircleImageEditor" class="headerlink" title="CircleImageEditor"></a>CircleImageEditor</h3><pre><code>[CustomEditor(typeof(CircleImage))]public class CircleImageEditor : GraphicEditor&#123;    public override void OnInspectorGUI() &#123;        DrawDefaultInspector();                CircleImage myScript = (CircleImage)target;        EditorGUILayout.BeginHorizontal();        &#123;            GUILayout.Space(EditorGUIUtility.labelWidth);            if (GUILayout.Button(&quot;Set Native Size&quot;, EditorStyles.miniButtonRight))            &#123;                myScript.SetNativeSize();            &#125;        &#125;        EditorGUILayout.EndHorizontal();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——UGUI基于图集的shader遮罩</title>
      <link href="/2021/04/20/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UGUI%E5%9F%BA%E4%BA%8E%E5%9B%BE%E9%9B%86%E7%9A%84shader%E9%81%AE%E7%BD%A9/"/>
      <url>/2021/04/20/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UGUI%E5%9F%BA%E4%BA%8E%E5%9B%BE%E9%9B%86%E7%9A%84shader%E9%81%AE%E7%BD%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Unity开发过程中，为了节省图，经常会做一些图形的遮罩，笔者开发UI使用的是UGUI遮罩，用过UGUI的Mask做遮罩的应该都知道，UGUI的mask做遮罩有很明显的锯齿，于是笔者就从网上学习一套shader做的遮罩，但是仅仅是shader做的遮罩虽然效果很好，但是在正式开发中，为了优化性能，大部分图片都是会打成图集的，这时候shader中的UV就不是我们想要的UV了，这时候就需要做一些修改了。所以本文是基于图集的shader遮罩。</p><h1 id="普通的shader遮罩"><a href="#普通的shader遮罩" class="headerlink" title="普通的shader遮罩"></a>普通的shader遮罩</h1><p><img src="https://file.liangxiegame.com/e2f8acff-6e17-45c0-8bd1-ec8027772385.png" alt="image.png"> </p><p>上图左边是普通的UGUI的正常mask，右边是shader写的遮罩，边缘锯齿比较很明显。</p><h2 id="shader代码"><a href="#shader代码" class="headerlink" title="shader代码"></a>shader代码</h2><pre><code>Shader &quot;ImageMask01&quot;&#123;    Properties    &#123;        [PerRendererData] _MainTex (&quot;Sprite Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Mask (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;     _Color (&quot;Tint&quot;, Color) = (1,1,1,1)        _StencilComp(&quot;Stencil Comparison&quot;, Float) = 8        _Stencil(&quot;Stencil ID&quot;, Float) = 0        _StencilOp(&quot;Stencil Operation&quot;, Float) = 0        _StencilWriteMask(&quot;Stencil Write Mask&quot;, Float) = 255        _StencilReadMask(&quot;Stencil Read Mask&quot;, Float) = 255        _ColorMask(&quot;Color Mask&quot;, Float) = 15    &#125;    SubShader    &#123;        Tags        &#123;            &quot;Queue&quot;=&quot;Transparent&quot;            &quot;IgnoreProjector&quot;=&quot;True&quot;            &quot;RenderType&quot;=&quot;Transparent&quot;            &quot;PreviewType&quot;=&quot;Plane&quot;            &quot;CanUseSpriteAtlas&quot;=&quot;True&quot;        &#125;        Stencil        &#123;            Ref [_Stencil]            Comp [_StencilComp]            Pass [_StencilOp]            ReadMask [_StencilReadMask]            WriteMask [_StencilWriteMask]        &#125;        Cull Off        Lighting Off        ZWrite Off        ZTest [unity_GUIZTestMode]        Blend SrcAlpha OneMinusSrcAlpha        ColorMask [_ColorMask]        Pass        &#123;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #pragma target 2.0            #include &quot;UnityCG.cginc&quot;            #include &quot;UnityUI.cginc&quot;            #pragma multi_compile_local _ UNITY_UI_CLIP_RECT            #pragma multi_compile_local _ UNITY_UI_ALPHACLIP            struct appdata_t            &#123;            fixed2 uv : TEXCOORD0;                float4 vertex   : POSITION;                float4 color    : COLOR;            &#125;;            struct v2f            &#123;            fixed2 uv : TEXCOORD0;                float4 vertex   : SV_POSITION;                fixed4 color    : COLOR;            &#125;;            sampler2D _MainTex;            fixed4 _Color;            sampler2D _Mask;            v2f vert(appdata_t IN)            &#123;                v2f OUT;                OUT.vertex = UnityObjectToClipPos(IN.vertex);                OUT.uv = IN.uv;                OUT.color = IN.color * _Color;#ifdef PIXELSNAP_ON                OUT.vertex = UnityPixelSnap(OUT.vertex);#endif                return OUT;            &#125;            fixed4 frag(v2f IN) : SV_Target            &#123;                fixed4 color = tex2D(_MainTex, IN.uv) * IN.color;                fixed4 mask = tex2D(_Mask, IN.uv);                color.a *= mask.a;                return color;            &#125;        ENDCG        &#125;    &#125;&#125;</code></pre><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>上述代码虽然多，但是大部分都是通用的固定写法，包含一些shader支持UGUI的mask的写法，这里就不要进行讲解了，我们来看看我们shader做mask的关键代码。</p><pre><code>Properties&#123;    ...    _Mask (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;     ...&#125;</code></pre><p>在Properties主要是把我们需要遮罩的形状放进去，这里需要注意的是需要遮罩的部分图片必须不透明，因为在做遮罩的时候是读取这个图片的透明度来判断是否需要进行遮罩的。也就是下面的代码：</p><pre><code>fixed4 frag(v2f IN) : SV_Target&#123;    fixed4 color = tex2D(_MainTex, IN.uv) * IN.color;    fixed4 mask = tex2D(_Mask, IN.uv);    color.a *= mask.a;    return color;&#125;</code></pre><p>逐片源操作的时候来进行读取来遮罩显示。</p><h1 id="基于图集的遮罩"><a href="#基于图集的遮罩" class="headerlink" title="基于图集的遮罩"></a>基于图集的遮罩</h1><p>虽然上述已经实现了遮罩，但是在假如我们需要遮罩的图片是在图集上，会发现我们的遮罩会出现错误，不遮罩或者遮罩的不对，这是因为shader在读取图片的UV坐标的时候读取的并不是0<del>1而是图片在图集中的坐标，所以根据坐标进行遮罩是不行的。<br>解决方案就是需要把遮罩的坐标转成0</del>1的坐标，这样就可以判断是否需要遮罩了。<br>虽然我们有了解决方案，但是我们如何在shader中获取图片在图集的坐标呢，笔者的解决方案是利用一个C#的脚本，把图片坐标传递给shader。</p><h2 id="Shader新的代码"><a href="#Shader新的代码" class="headerlink" title="Shader新的代码"></a>Shader新的代码</h2><pre><code>Properties&#123;    ...    _Mask (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;     _UvRect (&quot;UvRect&quot;, Vector) = (0, 0, 1, 1)    ...&#125;</code></pre><p>上述是Properties中的代码，可以看出和普通的相比多了一个_UvRect参数，是用来保存图片在图集中的坐标的。  </p><pre><code>fixed4 frag(v2f IN) : SV_Target&#123;    fixed4 color = tex2D(_MainTex, IN.uv) * IN.color;    float2 temuv = float2((IN.uv.x - _UvRect.x)/(_UvRect.z - _UvRect.x),(IN.uv.y - _UvRect.y)/(_UvRect.w - _UvRect.y));    fixed4 mask = tex2D(_Mask, temuv);    color.a *= mask.a;    return color;&#125;</code></pre><p>在判断是否遮罩的时候，可以看到笔者关键性的代码，就是teamuv的赋值，算法很简单，知道图片四个角在图集的UV坐标，就是_UvRect参数，然后**(IN.uv.x - _UvRect.x)<strong>和</strong>(IN.uv.y - _UvRect.y)**就为了计算图片距离图片原点坐标的差值，也就是坐标系的坐标，他们在分别除以他们坐在的长度就转换成新的UV坐标了，其实就是图片本身的UV坐标了，然后就可以和普通的shader一样计算了。  </p><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C#代码"></a>C#代码</h2><pre><code>public class RefreshUVRect : MonoBehaviour&#123;    private Material material;    private Image img;    // Start is called before the first frame update    void Start()    &#123;        img = GetComponent&lt;Image&gt;();        material = img.material;        Refresh();    &#125;    public void Refresh()    &#123;        if (img)        &#123;            Vector4 uvRect = UnityEngine.Sprites.DataUtility.GetOuterUV(img.overrideSprite);            material.SetVector(&quot;_UvRect&quot;, uvRect);        &#125;    &#125;&#125;</code></pre><p>C#的代码比较简单，就是获取一下材质，然后把图片四个角的UV坐标传递给材质，<strong>UnityEngine.Sprites.DataUtility.GetOuterUV</strong>这个方法就是获取UV的边界坐标。<br><font color="red" size="4">特别提醒一下，遮罩后编辑器模式下是错误的，因为获取的还是图片坐标，运行状态下观看就是正确的了</font></p>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——UGUI中粒子的遮罩与裁剪</title>
      <link href="/2021/04/19/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UGUI%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E9%81%AE%E7%BD%A9%E4%B8%8E%E8%A3%81%E5%89%AA/"/>
      <url>/2021/04/19/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UGUI%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E9%81%AE%E7%BD%A9%E4%B8%8E%E8%A3%81%E5%89%AA/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Unity开发中，在使用UGUI的mask的时候，如果子节点存在粒子特效，发现mask并不能裁剪粒子，比如笔者在开发中，有一个滑动列表，列表中的button上面存在按钮特效，在滑动的时候滑动的mask并不能裁剪粒子，因此笔者从网上找到了一些解决方案，并应用了一下，用着还可以。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>粒子的裁剪是用shader制作的，但是仅仅用shader是并不能满足需求的，因为特效有可能是会动的，这样剪裁区域就会发生变化，所以需要一个脚本把裁剪的区域传递给shader，然后shader在进行裁剪处理。  </p><h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C#代码"></a>C#代码</h1><pre><code>public class TailorParticle : MonoBehaviour&#123;    private Material material;    private Mask mask;    private RectMask2D rectmask2d;    public void Start()    &#123;        material = GetComponentInChildren&lt;ParticleSystem&gt;().GetComponent&lt;Renderer&gt;().material;        mask = GetComponentInParent&lt;Mask&gt;();        rectmask2d = GetComponentInParent&lt;RectMask2D&gt;();        SetClip();        //如果运行时裁剪区域不会发生改变，可以注释掉下面这句代码        var scrollrecct = GetComponentInParent&lt;ScrollRect&gt;();        if (scrollrecct)        &#123;            scrollrecct.onValueChanged.AddListener(v =&gt; &#123; SetClip(); &#125;);        &#125;    &#125;    private bool isMask;    private Vector3[] corners = new Vector3[4];    private Vector3[] cornerstemp = new Vector3[4];    public void SetClip()    &#123;        //获取到需要裁剪的区域        isMask = false;        if (mask)         &#123;            mask.GetComponent&lt;RectTransform&gt;().GetWorldCorners(corners);            isMask = true;        &#125;        if(rectmask2d)        &#123;            rectmask2d.GetComponent&lt;RectTransform&gt;().GetWorldCorners(cornerstemp);            if (isMask)            &#123;                corners[0].x = Mathf.Min(corners[0].x, cornerstemp[0].x);                corners[0].y = Mathf.Min(corners[0].y, cornerstemp[0].y);                corners[2].x = Mathf.Max(corners[2].x, cornerstemp[2].x);                corners[2].y = Mathf.Max(corners[2].y, cornerstemp[2].y);            &#125;            else            &#123;                isMask = true;            &#125;        &#125;        if (material &amp;&amp; isMask)        &#123;            //将裁剪区域传入到Shader中            material.SetFloat(&quot;_MinX&quot;, corners[0].x);            material.SetFloat(&quot;_MinY&quot;, corners[0].y);            material.SetFloat(&quot;_MaxX&quot;, corners[2].x);            material.SetFloat(&quot;_MaxY&quot;, corners[2].y);        &#125;    &#125;&#125;</code></pre><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><pre><code>material = GetComponentInChildren&lt;ParticleSystem&gt;().GetComponent&lt;Renderer&gt;().material;mask = GetComponentInParent&lt;Mask&gt;();rectmask2d = GetComponentInParent&lt;RectMask2D&gt;();SetClip();//如果运行时裁剪区域不会发生改变，可以注释掉下面这句代码var scrollrecct = GetComponentInParent&lt;ScrollRect&gt;();if (scrollrecct)&#123;    scrollrecct.onValueChanged.AddListener(v =&gt; &#123; SetClip(); &#125;);&#125;</code></pre><p>首先我们先看Start函数中，material是获取子节点的粒子特效的材质(如果粒子多了可以自己扩展成组)，mask是获取父节点的Mask遮罩，rectmask2d和mask一样是获取父节点的RectMask2D组件，笔者之所以获取RectMask2D这个组件是因为笔者有些裁剪是用这个做的。接着就是进行裁剪函数，这里后面介绍。正常的裁剪到这里就结束了，但是我们如果想裁剪区域进行动态变化，那我们就要进行动态刷新shader，笔者这里只是简单的用ScrollRect进行举例，大家可以根据自己的项目进行监听。只要当变化的时候刷新一下裁剪就行了。  </p><pre><code>isMask = false;if (mask) &#123;    mask.GetComponent&lt;RectTransform&gt;().GetWorldCorners(corners);    isMask = true;&#125;if(rectmask2d)&#123;    rectmask2d.GetComponent&lt;RectTransform&gt;().GetWorldCorners(cornerstemp);    if (isMask)    &#123;        corners[0].x = Mathf.Min(corners[0].x, cornerstemp[0].x);        corners[0].y = Mathf.Min(corners[0].y, cornerstemp[0].y);        corners[2].x = Mathf.Max(corners[2].x, cornerstemp[2].x);        corners[2].y = Mathf.Max(corners[2].y, cornerstemp[2].y);    &#125;    else    &#123;        isMask = true;    &#125;&#125;</code></pre><p>接着我们来看一下裁剪的代码，首先是标记不需要裁剪，只有当父节点存在Mask的时候才进行裁剪，然后就是获取父节点的剪裁区域，笔者这里是把两个Mask进行融合，获取最小的范围，这里可以根据自己的需求进行变化，然后就是关键性的代码  </p><pre><code>if (material &amp;&amp; isMask)&#123;    //将裁剪区域传入到Shader中    material.SetFloat(&quot;_MinX&quot;, corners[0].x);    material.SetFloat(&quot;_MinY&quot;, corners[0].y);    material.SetFloat(&quot;_MaxX&quot;, corners[2].x);    material.SetFloat(&quot;_MaxY&quot;, corners[2].y);&#125;</code></pre><p>这里就是将剪裁区域传递给次材质的shader，然后shader进行裁剪。</p><h1 id="Shader关键代码"><a href="#Shader关键代码" class="headerlink" title="Shader关键代码"></a>Shader关键代码</h1><pre><code>Properties &#123;        ...    _MinX (&quot;Min X&quot;, Float) = -10    _MaxX (&quot;Max X&quot;, Float) = 10    _MinY (&quot;Min Y&quot;, Float) = -10    _MaxY (&quot;Max Y&quot;, Float) = 10&#125;SubShader &#123;    Pass &#123;        ...        float _MinX;        float _MaxX;        float _MinY;        float _MaxY;                ...        float4 frag(VertexOutput i) : COLOR &#123;                        ...                    c.a *= (i.vpos.x &gt;= _MinX );           c.a *= (i.vpos.x &lt;= _MaxX);            c.a *= (i.vpos.y &gt;= _MinY);            c.a *= (i.vpos.y &lt;= _MaxY);            c.rgb *= c.a;            return c;        &#125;        ...    &#125;&#125;</code></pre><p>shader的代码也比较简单，就是将传过来的区域进行判断，如果在区域内据显示，如果超出区域就将颜色的透明度设置为0，也就看不见了。</p>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习笔记</title>
      <link href="/2019/11/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/11/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><ol><li><p>初始化仓库，可以将本地目录变成git可以管理的本地仓库  </p><pre><code> git init</code></pre></li><li><p>关联远程仓库，可以将本地仓库与远程仓库关联，切记是<strong>本地仓库</strong>，不是本地目录，可以先利用<strong>git init</strong>将本地目录编程本地仓库后再进行关联。  </p><pre><code> git remote add origin 仓库地址</code></pre></li><li><p>取消关联地址</p><pre><code> git remote rm origin</code></pre></li><li><p>将远程仓库与本地仓库同步合并，下列命令是合并master分支</p><pre><code> git pull --rebase origin master</code></pre></li><li><p>查看远程分支命令和查看本地分支</p><pre><code> git branch -a//查看远程分支 git branch//查看本地分支</code></pre></li><li><p>切换分支命令</p><pre><code> git checkout 分支名字</code></pre></li><li><p>查看仓库状态</p><pre><code> git status</code></pre></li><li><p>将工作区内容添加到缓存区</p><pre><code> git add .//所有内容添加 git add//选择内容添加</code></pre></li><li><p>缓存区内容提交到本地仓库区</p><pre><code> git commit -m &quot;提交注释&quot;</code></pre></li><li><p>把本地仓库代码内容推送到远程仓库  </p><p>   git push -u origin master</p></li><li><p>查看日志(历史版本)</p><pre><code>git loggit reflog</code></pre></li><li><p>撤销修改<br>— 撤销文件在工作区的修改:  </p><pre><code>git checkout -- 文件名git checkout</code></pre></li></ol><p>— 撤销文件在缓存区的修改:  </p><pre><code>    git reset 文件名          # 撤销指定文件的git add操作，即在缓存区的修改    git reset                # 撤销之前所有的git add操作，即在缓存区的修改</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bat学习笔记</title>
      <link href="/2019/11/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/bat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/11/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/bat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="bat文件执行多条命令"><a href="#bat文件执行多条命令" class="headerlink" title=".bat文件执行多条命令"></a>.bat文件执行多条命令</h2><p>笔者博客利用的是hexo+github搭建的，每次提交都会重复输入多条命令，于是笔者想到用一个bat脚本来代替这些重复的命令，但是，笔者发现bat在执行多条命令的情况下，不会等第一条命令执行完再去执行下一条命令，第一条命令执行的时候下一条命令还会继续执行，所以就会导致只执行第一条命令，笔者查了许多资料，最后了以下两种方法：  </p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><pre><code>命令1 &amp; 命令2 &amp; 命令3 ... (无论前面命令是否故障,照样执行后面)   命令1 &amp;&amp; 命令2 &amp;&amp; 命令3....(仅当前面命令成功时,才执行后面)   命令1 || 命令2 || 命令3.... (仅当前面命令失败时.才执行后面)</code></pre><p>下面来看看示例代码：</p><pre><code>call git add .&amp;&amp;git status&amp;&amp;git commit -m &quot;backups&quot;&amp;&amp;git pull --rebase origin master&amp;&amp;git push</code></pre><p>这条执行会一步一步执行命令，如果一条命令失败，就会停止。  </p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>此类方法并不是作者从网上查到了，是笔者一步一步试验出来的，如果存在问题，欢迎联系作者讨论。  </p><pre><code>call 命令1call 命令2call 命令3...</code></pre><p>笔者发现，每次在命令前加上call，就会等上一个命令结束后执行(不管错与对，只要上面结束就会停止)。<br>下面来看看笔者完成后的完整代码：  </p><pre><code>@echo off call cd D:/blogcall hexo cleancall hexo g -dcall pausecall git add .&amp;&amp;git status&amp;&amp;git commit -m &quot;backups&quot;&amp;&amp;git pull --rebase origin master&amp;&amp;git pushcall pause</code></pre><h2 id="bat变量的输入和赋值"><a href="#bat变量的输入和赋值" class="headerlink" title=".bat变量的输入和赋值"></a>.bat变量的输入和赋值</h2><p>在上文中，我们还可以改进一下，就是博客文件地址，其实可以用变量代替，因为代码有点短，而且很少更改，所以这一点就不用改进了，换地址直接换一行就行了，笔者在每次创建博客的时候，也会重复输入“hexo new post ‘’”,这种重复命令，虽然不多，但是，当你写一些专栏的时候，你会发现名字有很多重复的地方，这时候就会体现出变量的作用。<br>示例代码：</p><pre><code>@echo off call cd D:/blogset/p name=please input name:call hexo new post &quot;%name%&quot;call pause</code></pre><p>从代码中可以看书，输入变量的命令就是：**set&#x2F;p 变量名 &#x3D; 输入描述(可以为空)**，这里要切记，set&#x2F;p中间不要加空格，笔者在这里也被坑了，加上空格后，有些变量赋值就会出现问题，至于原因，笔者还在研究，大家先记住就好了，下面来看看写专栏重复名字的时候，应该如何优化吧。<br>代码如下：  </p><pre><code>@echo off call cd D:/blogset/p number=please input UniRx number:set/p name=please input UniRx name:call hexo new post &quot;UniRx精讲(%number%)——%name%&quot;call pause</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——AssetDatabase资源数据库</title>
      <link href="/2019/09/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94AssetDatabase%E8%B5%84%E6%BA%90%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/09/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94AssetDatabase%E8%B5%84%E6%BA%90%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>unity中有个类，叫做AssetDatabase，这是一个在编辑器(Editor)下使用的一个类，是一个允许您访问工程中资源的API。这个类包含了查找、加载、创建、删除和修改资源等。这个类仅适用于编辑器状态下。</p><h1 id="导入资源"><a href="#导入资源" class="headerlink" title="导入资源"></a>导入资源</h1><p>unity不仅仅可以通过拖拽导入资源，还可以通过脚本导入资源，代码如下：  </p><pre><code>sing UnityEngine;using UnityEditor; public class ImportAsset &#123;    [MenuItem (&quot;AssetDatabase/ImportExample&quot;)]    static void ImportExample ()    &#123;        AssetDatabase.ImportAsset(&quot;资源路径+资源名字&quot;, ImportAssetOptions.Default);    &#125;&#125;</code></pre><h1 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h1><p>加载资源有很多API，大家可以参考API手册进行操作，加载API包含：</p><pre><code>AssetDatabase.LoadAssetAtPathAssetDatabase.LoadMainAssetAtPathAssetDatabase.LoadAllAssetRepresentationsAtPathAssetDatabase.LoadAllAssetsAtPath</code></pre><p>参考下面案例进行使用：</p><pre><code>using UnityEngine;using UnityEditor;public class ImportAsset &#123;    [MenuItem (&quot;AssetDatabase/LoadAssetExample&quot;)]    static void ImportExample ()    &#123;        Texture2D t = AssetDatabase.LoadAssetAtPath(&quot;Assets/Textures/texture.jpg&quot;, typeof(Texture2D)) as Texture2D;    &#125;&#125;</code></pre><h1 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h1><h2 id="更改提交至数据库"><a href="#更改提交至数据库" class="headerlink" title="更改提交至数据库"></a>更改提交至数据库</h2><p>这里提前声明一下，修改完资源后应该调用AssetDatabase.Refresh 将更改提交至数据库，并使其显示在工程中。</p><h2 id="创建资源"><a href="#创建资源" class="headerlink" title="创建资源"></a>创建资源</h2><p>创建文件的API是：<strong>CreateAsset</strong>  </p><pre><code>Material material = new Material (Shader.Find(“Specular”));AssetDatabase.CreateAsset(material, “Assets/MyMaterial.mat”);if(AssetDatabase.Contains(material))//判断是否包含这个资源    Debug.Log(“Material asset created”);</code></pre><p>##创建文件夹<br>创建文件夹：<strong>CreateFolder</strong>  </p><pre><code>ret = AssetDatabase.CreateFolder(&quot;Assets&quot;, &quot;NewFolder&quot;);if(AssetDatabase.GUIDToAssetPath(ret) != &quot;&quot;)    Debug.Log(&quot;Folder asset created&quot;);else    Debug.Log(&quot;Couldn‘t find the GUID for the path&quot;);</code></pre><h2 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h2><p>给文件夹重新命名：<strong>RenameAsset</strong>  </p><pre><code>ret = AssetDatabase.RenameAsset(“Assets/MyMaterial.mat”, “MyMaterialNew”);if(ret == “”)    Debug.Log(“Material asset renamed to MyMaterialNew”);else    Debug.Log(ret);</code></pre><h2 id="移动资源位置"><a href="#移动资源位置" class="headerlink" title="移动资源位置"></a>移动资源位置</h2><p>移动资源所在的位置：<strong>MoveAsset</strong><br>得到资源所在路径：GetAssetPath</p><pre><code>ret = AssetDatabase.MoveAsset(AssetDatabase.GetAssetPath(material), &quot;Assets/NewFolder/MyMaterialNew.mat&quot;);if(ret == &quot;&quot;)    Debug.Log(&quot;Material asset moved to NewFolder/MyMaterialNew.mat&quot;);else    Debug.Log(ret);</code></pre><h2 id="复制资源"><a href="#复制资源" class="headerlink" title="复制资源"></a>复制资源</h2><p>复制一个资源：<strong>CopyAsset</strong></p><pre><code>if(AssetDatabase.CopyAsset(AssetDatabase.GetAssetPath(material), &quot;Assets/MyMaterialNew.mat&quot;))    Debug.Log(&quot;Material asset copied as Assets/MyMaterialNew.mat&quot;);else    Debug.Log(&quot;Couldn‘t copy the material&quot;);</code></pre><h2 id="移动到回收站"><a href="#移动到回收站" class="headerlink" title="移动到回收站"></a>移动到回收站</h2><p>把资源移动到回收站：<strong>MoveAssetToTrash</strong></p><pre><code>if(AssetDatabase.MoveAssetToTrash(AssetDatabase.GetAssetPath(MaterialCopy)))    Debug.Log(&quot;MaterialCopy asset moved to trash&quot;);</code></pre><h2 id="删除资源"><a href="#删除资源" class="headerlink" title="删除资源"></a>删除资源</h2><p>删除一个资源或文件夹：DeleteAsset</p><pre><code>if(AssetDatabase.DeleteAsset(AssetDatabase.GetAssetPath(material)))    Debug.Log(&quot;Material asset deleted&quot;);if(AssetDatabase.DeleteAsset(&quot;Assets/NewFolder&quot;))    Debug.Log(&quot;NewFolder deleted&quot;);</code></pre><p>官方API网址：<a href="https://docs.unity3d.com/ScriptReference/AssetDatabase.html"><font color="steelblue" size="3"><strong>https://docs.unity3d.com/ScriptReference/AssetDatabase.html</strong></font></a>  </p>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity编辑器扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——JSON数据转化为Excel表格</title>
      <link href="/2019/09/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94JSON%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8C%96%E4%B8%BAExcel%E8%A1%A8%E6%A0%BC/"/>
      <url>/2019/09/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94JSON%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8C%96%E4%B8%BAExcel%E8%A1%A8%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作者今天接到一个工作，需要把一个从其他地方接收过来的json数据观察规律，因为数据比较多，不可能一个一个观察记录，作者想的是把接收过来的数据全部保存到表格中，因为表格处理数据还是比较方便观察的，很省事。废话不多说了，直接上代码。  </p><h1 id="准备资源"><a href="#准备资源" class="headerlink" title="准备资源"></a>准备资源</h1><p>需要一个dll，这里提供下载链接：<br><a href="https://pan.baidu.com/s/1Z8YZJgezbAeQGDO2pGiFrA"><font color="steelblue" size="3">org.in2bits.MyXls.Dll</font></a><br><strong>解压密码：fuck</strong></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>首先把dll导入到自己的项目中，这里就不用做过多的解释了。<br>接着直接放代码：  </p><pre><code>using org.in2bits.MyXls;using QF.Extensions;using UnityEngine;namespace QFramework.MFO&#123;    public class JsonToExcelSystem    &#123;        //保留当前创建的xls文档        private XlsDocument newXls;        //保留当前操作的对应的sheet中的单元格        private Cells newCells;        //当前sheet所添加的行        private int nowRow;        /// &lt;summary&gt;        /// 创建新的Xls文件        /// &lt;/summary&gt;        public void CreateExcelFile(string filePath,string fileName,            string author = &quot;LianBai&quot;,string subject = &quot;Test&quot;)        &#123;              XlsDocument xls = new XlsDocument();    //创建一个新的xls文档            xls.FileName = filePath+fileName;                //设置文件名字(路径+名字)            xls.SummaryInformation.Author = author; //设置xls文件作者信息            xls.SummaryInformation.Subject = subject;   //设置xls文件主题信息            newXls = xls;            //Worksheet sheet = xls.Workbook.Worksheets.AddNamed(sheetName);  //添加一个sheet页面        &#125;        /// &lt;summary&gt;        /// 添加一个新的sheet,并赋予开头        /// &lt;/summary&gt;        public void AddNewSheet(string sheetName, params string[] param)        &#123;            if (newXls == null)            &#123;                Debug.LogError(&quot;LianBai:Please create new xls&quot;);            &#125;            else            &#123;                Worksheet sheet = newXls.Workbook.Worksheets.AddNamed(sheetName);   //添加一个新的sheet                newCells = sheet.Cells; //修改当前操作的单元格                int index = 1;                      param.ForEach(tipName =&gt;        //遍历添加标头                &#123;                    newCells.Add(1, index, tipName);                    index++;                &#125;);                nowRow = 2;     //初始化从第二行添加数据            &#125;        &#125;        /// &lt;summary&gt;        /// 往创建的sheet里添加数据        /// &lt;/summary&gt;        public void AddData(params object[] param)        &#123;            if (newXls == null || newCells == null)     //判断文件是否被创建            &#123;                Debug.LogError(&quot;LianBai:Please create new xls or sheet&quot;);            &#125;            else            &#123;                int index = 1;                param.ForEach(data =&gt;           //遍历添加数据                &#123;                    newCells.Add(nowRow, index, data);                    index++;                &#125;);                nowRow++;                   //添加一行后往下添加            &#125;        &#125;        /// &lt;summary&gt;        /// 保存成文件        /// &lt;/summary&gt;        public void SaveXls()        &#123;            newXls.Save();        &#125;            &#125;&#125;</code></pre><p>上述代码都有注释，也就不做过多的解释了。</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>下面来看看作者自己写的一个案例：<br>先看看json数据：  </p><pre><code>[  &#123;    &quot;playerid&quot;: 2,    &quot;playericoname&quot;: &quot;PlayerIcon_2&quot;,    &quot;playerprefabname&quot;: &quot;Player_2&quot;  &#125;,  &#123;    &quot;playerid&quot;: 3,    &quot;playericoname&quot;: &quot;PlayerIcon_3&quot;,    &quot;playerprefabname&quot;: &quot;Player_3&quot;  &#125;,  &#123;    &quot;playerid&quot;: 4,    &quot;playericoname&quot;: &quot;PlayerIcon_4&quot;,    &quot;playerprefabname&quot;: &quot;Player_4&quot;  &#125;,  &#123;    &quot;playerid&quot;: 5,    &quot;playericoname&quot;: &quot;PlayerIcon_5&quot;,    &quot;playerprefabname&quot;: &quot;Player_5&quot;  &#125;]</code></pre><p>接着看作者写的案例代码，其中josn读取利用的是QF框架中的，QF是一个非常强大的框架：<br>代码如下：  </p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;namespace QFramework.MFO&#123;    public class MyJsonToExcelExample : MonoBehaviour    &#123;        private JsonToExcelSystem myJsonToExcelSystem = new JsonToExcelSystem();        private string path;        private string fileName = &quot;LianBai&quot;;                      //文件名字        private List&lt;PlayerData&gt; posData = new List&lt;PlayerData&gt;(); //用来保存json数据        // Start is called before the first frame update        void Start()        &#123;            path = Application.dataPath + &quot;/Prints/&quot;;    //文件保存路径            var jsonText = ResLoadManage.Instance.mResLoader.LoadSync&lt;TextAsset&gt;(&quot;playeritem&quot;).text;    //读取本地的json文件            posData = jsonText.FromJson&lt;List&lt;PlayerData&gt;&gt;();    //保存json数据            myJsonToExcelSystem.CreateExcelFile(path,fileName); //创建文件            myJsonToExcelSystem.AddNewSheet(&quot;lianbai&quot;,&quot;ID&quot;,&quot;IocName&quot;,&quot;PrefabName&quot;); //创建sheet并且赋值表头            posData.ForEach(data =&gt;         //遍历数据            &#123;                myJsonToExcelSystem.AddData(data.playerid,data.playericoname,data.playerprefabname);    //把数据写入到表格中            &#125;);            myJsonToExcelSystem.SaveXls();  //保存文件        &#125;    &#125;&#125;</code></pre><p>运行后的结果如下：<br><img src="http://file.liangxiegame.com/df26006d-9f6f-4bd3-8e6c-5243301474aa.png"></p>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——2D游戏开发常用插件集合</title>
      <link href="/2019/09/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%942D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E9%9B%86%E5%90%88/"/>
      <url>/2019/09/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%942D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Unity以开发3D游戏见长，早期版本的Unity在开发2D游戏时不慎方便，因此Asset Store出现了很多2D游戏开发引擎。现在Unity对2D游戏的支持越来越好，而这些开发2D游戏的Unity插件也得到了更多开发者的喜爱。</p><h1 id="Rex-Engine-Classic-2D-Platformer-Engine"><a href="#Rex-Engine-Classic-2D-Platformer-Engine" class="headerlink" title="Rex Engine: Classic 2D Platformer Engine"></a>Rex Engine: Classic 2D Platformer Engine</h1><p>下载地址：<a href="https://assetstore.unity.com/packages/templates/systems/rex-engine-classic-2d-platformer-engine-92333?aid=1101l4bPZ&utm_source=aff"><font color="steelblue" size="3">点击这里</font></a><br>Rex Engine: Classic 2D Platformer Engine是一款在Unity内部专门制作2D平台游戏的游戏引擎。<br><img src="http://file.liangxiegame.com/06051a4e-9428-4cc7-86aa-62b2782950d4.png">   </p><h1 id="TopDown-Engine"><a href="#TopDown-Engine" class="headerlink" title="TopDown Engine"></a>TopDown Engine</h1><p>下载地址：<a href="https://assetstore.unity.com/packages/templates/systems/topdown-engine-89636?aid=1101l4bPZ&utm_source=aff"><font color="steelblue" size="3">点击这里</font></a><br>TopDown Engine和Corgi Engine来自同一开发者，是制作2D&#x2F;3D动作类游戏的最佳引擎。<br><img src="http://file.liangxiegame.com/d55f87c3-4c73-442e-bccb-d5cd18aba35e.png">  </p><h1 id="Platformer-PRO-2"><a href="#Platformer-PRO-2" class="headerlink" title="Platformer PRO 2"></a>Platformer PRO 2</h1><p>下载地址：<a href="https://assetstore.unity.com/packages/templates/systems/platformer-pro-2-140510?aid=1101l4bPZ&utm_source=aff"><font color="steelblue" size="3">点击这里</font></a><br>Platformer PRO 2是一款制作2D&#x2F;2.5D的平台游戏引擎，内部集成了大量功能，包括跳跃等运动系统。<br><img src="http://file.liangxiegame.com/47cecac4-2f43-47b0-94d1-fae9ce3da5bd.png">  </p><h1 id="Corgi-Engine-–-2D-2-5D-Platformer"><a href="#Corgi-Engine-–-2D-2-5D-Platformer" class="headerlink" title="Corgi Engine – 2D + 2.5D Platformer"></a>Corgi Engine – 2D + 2.5D Platformer</h1><p>下载地址：<a href="https://assetstore.unity.com/packages/templates/systems/corgi-engine-2d-2-5d-platformer-26617?aid=1101l4bPZ&utm_source=aff"><font color="steelblue" size="3">点击这里</font></a><br>Corgi Engine是一款制作2D&#x2F;2.5D的平台游戏引擎，内部集成了若干有趣的游戏，Corgi Engine弥补了Unity制作2D游戏的短板。<br><img src="http://file.liangxiegame.com/753b12fa-cb85-4897-9d28-21ebba9730be.png">  </p><h1 id="DoozyUI-Complete-UI-Management-System"><a href="#DoozyUI-Complete-UI-Management-System" class="headerlink" title="DoozyUI: Complete UI Management System"></a>DoozyUI: Complete UI Management System</h1><p>下载地址：<a href="https://assetstore.unity.com/packages/tools/gui/doozyui-complete-ui-management-system-138361?aid=1101l4bPZ&utm_source=aff"><font color="steelblue" size="3">点击这里</font></a><br>DoozyUI是Unity内部的一个UI管理插件。<br><img src="http://file.liangxiegame.com/df376645-503b-4471-a8b3-36ba8fdf4c66.png">  </p><h1 id="Fingers-–-Touch-Gestures-for-Unity"><a href="#Fingers-–-Touch-Gestures-for-Unity" class="headerlink" title="Fingers – Touch Gestures for Unity"></a>Fingers – Touch Gestures for Unity</h1><p>下载地址：<a href="https://assetstore.unity.com/packages/tools/input-management/fingers-touch-gestures-for-unity-41076?aid=1101l4bPZ&utm_source=aff"><font color="steelblue" size="3">点击这里</font></a><br>Fingers Touch Gestures是一款处理处理手势输入的插件，对手机游戏制作很有必要。<br><img src="http://file.liangxiegame.com/b9e85b2f-5cbd-4482-9745-77ff7998ead1.png">   </p><h1 id="RPG-Map-Editor"><a href="#RPG-Map-Editor" class="headerlink" title="RPG Map Editor"></a>RPG Map Editor</h1><p>下载地址：<a href="https://assetstore.unity.com/packages/templates/systems/rpg-map-editor-25657"><font color="steelblue" size="3">点击这里</font></a><br>制作RPG游戏地图的插件，简单易用非常推荐。<br><img src="http://file.liangxiegame.com/0982f53c-449a-4aea-b1f2-2a51d25b796b.png">  </p><h1 id="Super-Tilemap-Editor"><a href="#Super-Tilemap-Editor" class="headerlink" title="Super Tilemap Editor"></a>Super Tilemap Editor</h1><p>下载地址：<a href="https://assetstore.unity.com/packages/tools/level-design/super-tilemap-editor-56339"><font color="steelblue" size="3">点击这里</font></a><br>Super Tilemap Editor是一款制作Tilemap的插件，功能强大而且使用方便。<br><img src="http://file.liangxiegame.com/8a82f6d6-0e3d-48a9-8f9d-6e91121296f0.png"><br>Unity优质的插件和资源电子书:<br>链接: <a href="https://pan.baidu.com/s/14gF7nlWU65V-YJFexSczDQ">https://pan.baidu.com/s/14gF7nlWU65V-YJFexSczDQ</a><br>提取码: fuck<br>nity插件和素材资源按照分类做了汇总网站：<a href="http://gamedevplugins.com/"><font color="steelblue" size="3">游戏开发插件之家</font></a>   </p><pre><code>参考博客：https://www.jianshu.com/p/6659944272a3</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——IOS后台推送</title>
      <link href="/2019/09/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94IOS%E5%90%8E%E5%8F%B0%E6%8E%A8%E9%80%81/"/>
      <url>/2019/09/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94IOS%E5%90%8E%E5%8F%B0%E6%8E%A8%E9%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="IOS本地消息通知"><a href="#IOS本地消息通知" class="headerlink" title="IOS本地消息通知"></a>IOS本地消息通知</h1><p>相信用过IOS的都会知道，IOS的软件在关闭后也会收到通知消息，软件上面有红点并且还会接到通知消息。<br>先带大家看看效果：  </p><h2 id="红点"><a href="#红点" class="headerlink" title="红点"></a>红点</h2><p><img src="http://file.liangxiegame.com/d1844fda-c9d3-4190-851c-f59908891ebb.png">   </p><h2 id="消息通知"><a href="#消息通知" class="headerlink" title="消息通知"></a>消息通知</h2><p><img src="http://file.liangxiegame.com/c25f8f72-e202-4964-b128-e7686c3f4275.png">  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>好了，大家来看看代码：  </p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;using System.Runtime.InteropServices;using System;using UnityEngine.iOS; //引入命名空间public class UnityToIOSManager : MonoBehaviour&#123;    static UnityToIOSManager mInstance;    static long lastTime;    int PushIndex;//推送    string PushText; //推送信息    private void Awake()    &#123;        Screen.sleepTimeout = SleepTimeout.NeverSleep;//游戏运行时禁止休眠，游戏在前台时可以保持屏幕长亮        if (mInstance == null)            mInstance = this;        //先清空本地消息，然后注册        UnityEngine.iOS.NotificationServices.RegisterForNotifications(NotificationType.Badge | NotificationType.Alert | NotificationType.Sound);        CleanNotification();        DontDestroyOnLoad(this);    &#125;//当有多条推送时，每次进入游戏时更换推送消息    private void Push()    &#123;        #region 推送条目记录        PushIndex = PlayerPrefs.GetInt(&quot;Push&quot;);        PushIndex++;        if (PushIndex &gt; 4)            PushIndex = 1;        PlayerPrefs.SetInt(&quot;Push&quot;, PushIndex);        PlayerPrefs.Save();        PushText = LanguageMananger.GetPushText(PushIndex);        #endregion    &#125;    //后台消息通知    //本地推送    public static void NotificationMessage(string message, int hour, bool isRepeatDay)    &#123;        int year = System.DateTime.Now.Year;        int month = System.DateTime.Now.Month;        int day = System.DateTime.Now.Day;        System.DateTime newDate = new System.DateTime(year, month, day, hour, 0, 0);        NotificationMessage(message, newDate, isRepeatDay);    &#125;    //本地推送 你可以传入一个固定的推送时间    public static void NotificationMessage(string message, System.DateTime newDate, bool isRepeatDay)    &#123;        if (isRepeatDay &amp;&amp; newDate &lt;= System.DateTime.Now)        &#123;            newDate = newDate.AddDays(1);        &#125;        //推送时间需要大于当前时间        if (newDate &gt; System.DateTime.Now)        &#123;            UnityEngine.iOS.LocalNotification localNotification = new UnityEngine.iOS.LocalNotification();            localNotification.fireDate = newDate;            localNotification.alertBody = message;            localNotification.applicationIconBadgeNumber = 1;            localNotification.hasAction = true;            if (isRepeatDay)            &#123;                //是否每天定期循环                localNotification.repeatCalendar = UnityEngine.iOS.CalendarIdentifier.ChineseCalendar;                localNotification.repeatInterval = UnityEngine.iOS.CalendarUnit.Day;            &#125;            localNotification.soundName = UnityEngine.iOS.LocalNotification.defaultSoundName;            UnityEngine.iOS.NotificationServices.ScheduleLocalNotification(localNotification);        &#125;    &#125;    void OnApplicationPause(bool paused)    &#123;        //程序进入后台时        if (paused)        &#123;            Push();            //每天中午12点推送            NotificationMessage(PushText, 19, true);            //10s后发送            NotificationMessage(&quot;10秒后发送&quot;,System.DateTime.Now.AddSeconds(10),false);            //时间戳            TimeSpan ts = DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, 0);            lastTime = Convert.ToInt64(ts.TotalSeconds);        &#125;        else        &#123;            //程序从后台进入前台时            CleanNotification();            TimeSpan ts = DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, 0);            long nowTime = Convert.ToInt64(ts.TotalSeconds);            if(nowTime - lastTime &gt; 180)            &#123;                //这个是判断程序退出到后台超出多久之后                //然后进行其他操作，播放广告，或是提醒什么的            &#125;        &#125;    &#125;    //清空所有本地消息    void CleanNotification()    &#123;        UnityEngine.iOS.LocalNotification l = new UnityEngine.iOS.LocalNotification();        l.applicationIconBadgeNumber = -1;        UnityEngine.iOS.NotificationServices.PresentLocalNotificationNow(l);        Invoke(&quot;WaitOneFrameClear&quot;,0);    &#125;    //延迟一帧执行，不然没法清理    void WaitOneFrameClear()    &#123;        UnityEngine.iOS.NotificationServices.CancelAllLocalNotifications();        UnityEngine.iOS.NotificationServices.ClearLocalNotifications();    &#125;&#125;</code></pre><hr><pre><code>参考文章：http://www.xuanyusong.com/archives/2632?replytocom=591072         https://blog.csdn.net/shuangkui5355/article/details/79064241</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity4IOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity杂文——AssetBundle自动标记</title>
      <link href="/2019/09/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94AssetBundle%E8%87%AA%E5%8A%A8%E6%A0%87%E8%AE%B0/"/>
      <url>/2019/09/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94AssetBundle%E8%87%AA%E5%8A%A8%E6%A0%87%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>当我们想把资源打包成AB的时候，需要把资源一个一个标记AB名字，其实大多数名字都是资源名字，如果资源一旦很多，就需要花费大量的时间，为了提高开发效率，我们肯定希望能把需要热更的资源一键标记资源名字。  </p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>自动打标记无非就是给我一个资源路径，我通过这个路径将里面的所有的资源文件遍历一遍，然后通过 AssetImporter 这个 API 设置每个文件的 assetbundleName 和 assetBundleVariant 属性，当然在设置属性的时候提前分好类，决定将哪些资源放到一个 AssetBundle 包内。然后记录一下要打多少个 AssetBundle 包，以及该包所在的目录，方便以后查找加载。<br>废话不多说，直接上代码：  </p><pre><code> # region 自动做标记[MenuItem(&quot;AssetBundle/Set AssetBundle Lables&quot; ,false , 100)]public static void SetAssetBundleLables()&#123;    //移除掉所有没有使用的标记    AssetDatabase.RemoveUnusedAssetBundleNames();    string assetDirectory = &quot;Assets/Res&quot;;    DirectoryInfo directoryInfo = new DirectoryInfo(assetDirectory);    DirectoryInfo[] scenesDirectories = directoryInfo.GetDirectories();    foreach (var tempDir in scenesDirectories)    &#123;        string sceneDirectory = assetDirectory + &quot;/&quot; + tempDir.Name;        DirectoryInfo sceneDirectoryInfo = new DirectoryInfo(sceneDirectory);        if (sceneDirectoryInfo == null)        &#123;            Debug.Log(sceneDirectoryInfo + &quot;不存在&quot;);            return;        &#125;        else        &#123;            Dictionary&lt;string , string&gt; namePathDictionary = new Dictionary&lt;string, string&gt;();            int index = sceneDirectory.LastIndexOf(&quot;/&quot;);            string sceneName = sceneDirectory.Substring(index + 1);            OnSceneFileSystemInfo(sceneDirectoryInfo , sceneName , namePathDictionary);            OnWriteConfig(sceneName , namePathDictionary);        &#125;    &#125;    AssetDatabase.Refresh();    Debug.Log(&quot;设置标记成功...&quot;);&#125;/// &lt;summary&gt;/// 记录配置文件/// &lt;/summary&gt;/// &lt;param name=&quot;sceneDirectory&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;namePathDictionary&quot;&gt;&lt;/param&gt;private static void OnWriteConfig(string sceneName , Dictionary&lt;string , string&gt; namePathDictionary)&#123;    string path = Application.dataPath + &quot;/AssetBundles/&quot; + sceneName ;    if (!Directory.Exists(path)) Directory.CreateDirectory(path);    Debug.Log(path);    using (FileStream fs = new FileStream(path + &quot;/Record.txt&quot;, FileMode.OpenOrCreate , FileAccess.Write))    &#123;        using (StreamWriter sw = new StreamWriter(fs))        &#123;            sw.WriteLine(namePathDictionary.Count);            foreach (KeyValuePair&lt;string , string&gt; kv in namePathDictionary)            &#123;                Debug.Log(kv.Value);                sw.WriteLine(kv.Key+&quot;/&quot;+kv.Value);            &#125;        &#125;    &#125;&#125;private static void OnSceneFileSystemInfo(FileSystemInfo fileSystemInfo , string sceneNama , Dictionary&lt;string, string&gt; namePathDictionary)&#123;    if (!fileSystemInfo.Exists)    &#123;        Debug.Log(fileSystemInfo + &quot;不存在&quot;);        return;    &#125;    DirectoryInfo directoryInfo = fileSystemInfo as DirectoryInfo;    FileSystemInfo[] fileSystemInfos = directoryInfo.GetFileSystemInfos();    foreach (var systemInfo in fileSystemInfos)    &#123;        FileInfo fileInfo = systemInfo as FileInfo;        if (fileInfo == null)        &#123;            OnSceneFileSystemInfo(systemInfo, sceneNama , namePathDictionary);        &#125;        else        &#123;            SetLables(fileInfo, sceneNama , namePathDictionary);        &#125;    &#125;&#125;/// &lt;summary&gt;/// 修改资源 assetbundle lables/// &lt;/summary&gt;private static void SetLables(FileInfo fileInfo , string sceneName , Dictionary&lt;string, string&gt; namePathDictionary)&#123;    if(fileInfo.Extension == &quot;.meta&quot;)return;    string bundleName = GetBundleName(fileInfo , sceneName);    int index = fileInfo.FullName.IndexOf(&quot;Assets&quot;);    string assetPath = fileInfo.FullName.Substring(index);    AssetImporter assetImporter = AssetImporter.GetAtPath(assetPath);    assetImporter.assetBundleName = bundleName;    if (fileInfo.Extension == &quot;.unity&quot;)        assetImporter.assetBundleVariant = &quot;u3d&quot;;    else        assetImporter.assetBundleVariant = &quot;assetbundle&quot;;    string folderName;    if (bundleName.Contains(&quot;/&quot;))        folderName = bundleName.Split(&#39;/&#39;)[1];    else        folderName = bundleName;    string bundlePath = assetImporter.assetBundleName + &quot;.&quot; + assetImporter.assetBundleVariant;    if (!namePathDictionary.ContainsKey(folderName))        namePathDictionary.Add(folderName, bundlePath);&#125;private static string GetBundleName(FileInfo fileInfo, string sceneName)&#123;    string path = fileInfo.FullName;    int index = path.IndexOf(sceneName) + sceneName.Length;    string bundlePath = path.Substring(index + 1);    bundlePath = bundlePath.Replace(@&quot;\&quot;, &quot;/&quot;);    if (bundlePath.Contains(&quot;/&quot;))    &#123;        string[] tmp = bundlePath.Split(&#39;/&#39;);        return sceneName + &quot;/&quot; + tmp[0];    &#125;    return sceneName;&#125;#endregion</code></pre><h1 id="一键打包"><a href="#一键打包" class="headerlink" title="一键打包"></a>一键打包</h1><p>一键打包<br>根据刚才我们设置好的标记，Unity 就可以识别到我们想要打包的资源，官方有个打包 AssetBundle 的插件（ AssetBundle Browser ），你可以用那款插件打包。<br>作自己也写了一个但是不是很好，这个东西可以用官方的代替。也可以根据自己的需求改一下。我这里选择的压缩方式是不压缩（ BuildAssetBundleOptions.None 这个选项）。  </p><pre><code>#region 打包static void BuildAssetBundles(string outPath , BuildTarget target)&#123;    if (!Directory.Exists(outPath)) Directory.CreateDirectory(outPath);    BuildPipeline.BuildAssetBundles(outPath, BuildAssetBundleOptions.None, target);&#125;[MenuItem(&quot;AssetBundle/CreateAndroidAssetBundles&quot;, false, 200)]public static void BuildAndroidAssetBundles()&#123;    string outPath = &quot;Assets/AssetBundles/Android&quot;;    BuildAssetBundles(outPath , BuildTarget.Android);&#125;[MenuItem(&quot;AssetBundle/CreateIOSAssetBundles&quot;, false, 201)]public static void BuildIOSAssetBundles()&#123;    string outPath = &quot;Assets/AssetBundles/IOS&quot;;    BuildAssetBundles(outPath, BuildTarget.iOS);&#125;[MenuItem(&quot;AssetBundle/CreateStandaloneWindows64AssetBundles&quot;, false, 202)]public static void BuildStandaloneWindows64AssetBundles()&#123;    string outPath = &quot;Assets/AssetBundles/StandaloneWindows64&quot;;    BuildAssetBundles(outPath, BuildTarget.StandaloneWindows64);&#125;#endregion</code></pre><h1 id="一键删除"><a href="#一键删除" class="headerlink" title="一键删除"></a>一键删除</h1><p>把目标路径删除掉就 OK 了。  </p><pre><code>#region 一键删除[MenuItem(&quot;AssetBundle/Delete All&quot;)]static void DeletAssetBundles()&#123;    string outPuth = &quot;Assets/AssetBundles&quot;;    Directory .Delete(outPuth , true);    File.Delete(outPuth+ &quot;.meta&quot;);    AssetDatabase.Refresh();&#125;#endregion参考文章：https://zhuanlan.zhihu.com/p/39994056</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AssetBundle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC入门</title>
      <link href="/2019/09/27/Unity/IOC%E5%85%A5%E9%97%A8/"/>
      <url>/2019/09/27/Unity/IOC%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="IOC简介"><a href="#IOC简介" class="headerlink" title="IOC简介"></a>IOC简介</h2><p>IOC全称为Invertuon Of Control，也就是控制反转。<br>控制反转是一种设计思想。而不是具体的技术。<br>IOC这种设计思想有很多方式实现，最常见的实现方式就是DI。  </p><h2 id="DI简介"><a href="#DI简介" class="headerlink" title="DI简介"></a>DI简介</h2><p>DI的全称是Dependency Injection，也就是依赖注入，是IOC思想的一种实现。  </p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>什么是依赖？看下面这段代码：  </p><pre><code>public class A&#123;  public B b = new B();&#125;</code></pre><p>上述代码中就是A依赖B。<br>我再这里理解为，A对象里面持有B对象，如果B对象不存在，那么A就无法成立，所以是A对象依赖B。  </p><h3 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h3><p>什么是注入呢？看下面这段代码：  </p><pre><code>public class A&#123;  public B b = null;&#125;public class B &#123;&#125;void Main()&#123;  var a = new A();  var b = new B();  a.b = b;&#125;</code></pre><p>从上面可以看出总共有两个对象，分别是a和b。可以看出现在的A对象是依赖B对象的。<br>**a.b&#x3D;b;**这句代码就是将b对象注入到a对象的b成员中。<br>有时候可以把注入就理解成设置值。<br>依赖注入也就是吧某个对象依赖的对象进行赋值。  </p><h1 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h1><h2 id="QF中的IOC"><a href="#QF中的IOC" class="headerlink" title="QF中的IOC"></a>QF中的IOC</h2><p>QF是一种框架，是作者最近正在学习的一种框架，这个框架不要求会，我们就拿QF中的DI来进行详细的了解一下DI。<br>我们在使用DI方案的时候一般都离不开DI容器这个概念。育德时候DI容易也叫做IOC容器。就是：DIContainer 和 IOCContainer。<br>下面我们来看看QF中是如何使用IOC的。  </p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;namespace QF.Master.Example&#123;        public class ServiceA    &#123;        public void Say()        &#123;            Debug.Log(&quot;I am ServiceA:&quot; + this.GetHashCode());        &#125;    &#125;    public class IOCExample : MonoBehaviour     &#123;        // 声明为需要注入的对象        [Inject]         public ServiceA A &#123;get;set;&#125;        void Start ()         &#123;            // 创建实例容器            var container = new QFrameworkContainer();            // 注册类型            container.Register&lt;ServiceA&gt;();            // 注入对象（会自动查找 Inject Atrributet的对象)            container.Inject(this);            // 注入之后，就可以直接使用 A 对象了            A.Say();                &#125;    &#125;&#125;</code></pre><p>上面是完整的案例，我们只要仔细看下面的代码：  </p><pre><code>// 创建实例容器var container = new QFrameworkContainer();// 注册类型container.Register&lt;ServiceA&gt;();// 注入对象（会自动查找 Inject Atrributet的对象)container.Inject(this);// 注入之后，就可以直接使用 A 对象了A.Say();</code></pre><p>首先我们创建了一个容器，并且在容器里注册了一个ServiceA对象。这些其实都是可以自己写一个脚本进行封装的。<br>接下来我们来看注入：**container.Inject(this);**这句就是注入对象，注入的就是刚才注册的对象。<br>接下来我们就可以使用this对象里的ServiceA对象了，为啥注入到A对象了，这里是框架给设计好了，只要在对应的对象上面添加[Inject]就代表是需要注入的对象。注入的时候就会对其进行赋值。<br>我们可以看下面的图进行理解：<br><img src="http://file.liangxiegame.com/b4cd45e1-29c7-402a-852e-7d30fe0705ef.png"><br>这是QF框架中的使用方法，我们不用会这种方法，因为只是针对QF框架的，我们学习的是IOC的这种思想。  </p><h2 id="DI容器的强大之处"><a href="#DI容器的强大之处" class="headerlink" title="DI容器的强大之处"></a>DI容器的强大之处</h2><h3 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h3><p>一般情况下DI容器会提供如下的API：  </p><pre><code>注册类型：Register&lt;TSource,TTarget&gt;注入:Inject(object obj)解析:Resolve&lt;T&gt;()</code></pre><p>注册和注入在刚才代码中已经有体现了。<br>在 DI Container 中，Resolve 实际上是根据类型返回实例。<br>DI容器的职责很简单，就是管理依赖和注入依赖。<br>DI容器中的容器代表的就是存储依赖的容器，容器里面装的就是依赖。<br>一般的DI容器利用的其实就是Dictonary&lt;Type,object&gt;来作为核心数据结构。<br>根据Type就可以得到依赖的对象，然后通过Inject注入到对象中。  </p><h3 id="强大之处"><a href="#强大之处" class="headerlink" title="强大之处"></a>强大之处</h3><p>有了单例这个工具，当我们需要写一个独立模块的时候，很容易用单例就实现了。而且通过单例（或静态类）实现的独立模块，与其他模块之间的交互会变得非常容易。<br>这种结构好于直接撸的结构，毕竟它有一定的扩展性（只需实现单例），维护性上也还可以（模块独立），但是它很容易达到瓶颈，尤其是当单例的数量逐渐随着项目变多的时候。<br>因为单例的获取是没有限制的，任何层级的代码都可以获取到任何层级的单例，如下图示：<br><img src="http://file.liangxiegame.com/2056ec16-a56a-40de-b9fa-76536a162082.png"><br>虽然我们在预定上分了很多层，但是当我们的模块数量超过一定数量时，约定就很难遵循，因为我们访问模块的时候就需要去看一遍层级的示意图：<br><img src="http://file.liangxiegame.com/0ed6d9fd-8478-402c-8c1e-236e4f973d8d.png"><br>这就造成项目达到一定规模，约定就变成了限制，让我们很难遵循。<br>从约定上，来说，我们怎么约定都可以，而约定的图示，就是上边的图。那些分层都是一些抽象的概念，比如游戏流程、主逻辑层、业务模块、框架层、底层，这些都是约定的结构。一般都是存在于文档上，并不会通过技术手段表达。<br>而从技术限制这个角度来说，单例的访问是没有限制的，就算是用最佳实践，也是没有限制的。而且单例难以表达约定上的分层的那些概念，因为只要一个模块变成单例了，那么这个模块就在技术上失去了层次关系。<br>如下图：<br><img src="http://file.liangxiegame.com/3e9c0a55-66d1-481c-a531-8704e1127da7.png"><br>如图所示，在使用单例的时候蓝牙和商店模块就在同一层级了，就失去了层级的约定。<br>使用单例时，项目结构的设计非常依赖于约定（文档等等）。<br>在项目规模比较少的时候，是没问题的，因为模块数量也比较少，但是一旦项目规模变大，模块数量变多，那么约定就会越来越难以遵循，就会非常容易导致项目结构的崩溃。<br>这个时候，有一种很简单的解决方式，就是最顶层模块都用单例，然后一些底层的模块，作为顶层的成员变量，从而达到逻辑层无法直接访问底层模块，而是必须通过顶层模块间接地使用底层模块服务。<br>如下图：<br><img src="http://file.liangxiegame.com/fd7000a1-4223-4972-8998-c8934d0d4fbf.png"><br>这样就解决了单例结构无法表达层级的问题，但是同时也失去了单例带来的种种好处，比如易扩展，维护性（模块独立）。<br>现在不容易扩展模块了，因为要扩展模块需要考虑依赖关系，也不容易维护了，因为模块不独立了。<br>而这里不容易维护指的是各个模块不容易单独维护了，但是整体项目会更容易维护。<br>接下来就体现DI Container 的作用了，它的出现可以让各个模块容易维护，也容易扩展，同时让整个项目也同样容易维护，而且可以通过技术限制来分担一部分约定。  </p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>从上面解决单例问题的图我们可以看到，有大量的依赖关系，这个依赖关系我们可以理解成对象的持有或者变量。<br>就是因为这些依赖关系，造成了此结构的维护性和扩展性降低了。因为模块本身也是对象，对象就有声明周期，那么对象和是去new就很重要。<br>我们来看看下面的代码：  </p><pre><code>public  class ModuleA&#123;  public ModuleB ModuleB;&#125;public class ModuleB&#123;&#125;</code></pre><p>从代码中我们可以知道ModuleA是依赖ModuleB，这样我们在使用ModuleA的时候要考虑A中ModuleB是不是有值。<br>创建ModuleB我们可以考虑在ModuleA内部创建和外部创建两种情况：  </p><h3 id="在ModuleA内部创建"><a href="#在ModuleA内部创建" class="headerlink" title="在ModuleA内部创建"></a>在ModuleA内部创建</h3><p>看下列代码：</p><pre><code>public  class ModuleA&#123;  public ModuleB ModuleB = new ModuleB();&#125;</code></pre><p>这种方式也很简单，创建ModuleA的时候ModuleB一定被创建了，但是此时的ModuleB是比较难共用的。  </p><h3 id="在ModuleA外部创建"><a href="#在ModuleA外部创建" class="headerlink" title="在ModuleA外部创建"></a>在ModuleA外部创建</h3><p>看下列代码：</p><pre><code>void main()&#123;  var moduleA = new ModuleA();  moduleA.ModuleB = new ModuleB();&#125;</code></pre><p>这样看起来没问题，因为在外部创建过程中，我们非常清晰地知道，moduleA.ModuleB 是有实例的。 但是我们看下在 ModuleA 内部使用 ModuleB 时的情况，代码如下:  </p><pre><code>public class ModuleA&#123;  public ModuleB ModuleB;  ...  void XXX()  &#123;    ModuleB. // 在这里会想 ModuleB 到底有没有值？在哪里设置的值？  &#125;&#125;</code></pre><p>接下来我们看看单例的解决方案：</p><pre><code>public class ModuleA&#123;  void XXX()  &#123;    ModuleB.Instance.DoSomething();  &#125;&#125;</code></pre><p>这样就不用考虑ModuleB的创建过程。<br>现在这种结构就是有大量的依赖，不易维护不易扩展也都出现在这个依赖上，因为依赖要考虑依赖对象的创建过程。  </p><h3 id="使用-DI-Container-管理依赖"><a href="#使用-DI-Container-管理依赖" class="headerlink" title="使用 DI Container 管理依赖"></a>使用 DI Container 管理依赖</h3><p>利用DI代码就变成下面的方式了：  </p><pre><code>public class ModuleA&#123;  [Inject]  public ModuleB ModuleB &#123;get;set;&#125;  void XXX()  &#123;    ModuleB.DoSomeThing(); // 放心用，因为不用考虑依赖的创建过程。  &#125;&#125;</code></pre><p>我们只需要在启动程序的时候进行注册：  </p><pre><code>public static QFrameworkContainer Container &#123;get;private set;&#125;void Main()&#123;  Container = new Contaner();  Container.Register&lt;ModuleB&gt;();&#125;</code></pre><p>但是我们在创建ModuleA的时候需要注入对象：</p><pre><code>void MethodA()&#123;  App.Container.Inject(new ModuleA());&#125;</code></pre><p>使用 DIContainer之后我们的结构就变成了下图所示：<br><img src="http://file.liangxiegame.com/000d5697-89dd-417c-93cc-8cfa1fc50d18.png"><br>我们只需要，在模块内部声明模块作为变量，而不需要考虑创建过程，这样就导致每个模块都是可独立测试的（易维护），而扩展一个模块，不需要用单例实现，而是注册到类型容器即可，扩展性比单例还容易。这就是 DI Container 的最核心的优势。  </p><h1 id="域"><a href="#域" class="headerlink" title="域"></a>域</h1><p>我们来了解DIContainer 的一个基础知识：域</p><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>域这个概念我们在学习C#的时候接触过，域的俗称就是代码块：  </p><pre><code>public class A// 类范围内的域&#123;  public void Main()  // 方法范围内的域  &#123;  &#125;&#125;</code></pre><p>从上面代码的注释就可以看出，代码块其实就是域<br>C# 的域的特性就是内部的域中的代码可以调用外部域中的变量。  </p><h2 id="DIContainer中的域"><a href="#DIContainer中的域" class="headerlink" title="DIContainer中的域"></a>DIContainer中的域</h2><p>首先我们要考虑一个问题，每次DIContainer在注入实例的时候，注入的是新的还是返回的同一个实例呢？<br>而这个问题所描述的行为指的是 DIContainer 的域。<br>我们来看看QF中是如何注入：  </p><pre><code>当注册依赖时，使用 Register&lt;Type&gt;() 方法时，每次注入都会创建新的实例。当注册依赖时，使用 RegisterInstance(object obj) 方法时，每次注入都会使用 obj 实例。</code></pre><p>我们来看看演示的代码：</p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;namespace QF.Master.Example&#123;    public class SomeService     &#123;        public void Description()        &#123;            Debug.Log(&quot;SomeService:&quot; + this.GetHashCode());        &#125;    &#125;    public class SomeObject    &#123;        public void Description()        &#123;            Debug.Log(&quot;SomeObject:&quot; + this.GetHashCode());        &#125;    &#125;    public class IOCScopeExample : MonoBehaviour &#123;        [Inject]        public SomeObject ObjA &#123;get;set;&#125;        [Inject]        public SomeObject ObjB &#123;get;set;&#125;        [Inject]        public SomeObject ObjC &#123;get;set;&#125;        [Inject]        public SomeService ServiceA &#123;get;set;&#125;        [Inject]        public SomeService ServiceB &#123;get;set;&#125;        void Start ()         &#123;            var container = new QFrameworkContainer();            // 每次注入都创建新的实例            container.Register&lt;SomeObject&gt;();            // 每次注入都使用同一个实例            container.RegisterInstance(new SomeService());            // 注入            container.Inject(this);            ObjA.Description();            ObjB.Description();            ObjC.Description();            ServiceA.Description();            ServiceB.Description();        &#125;    &#125;&#125;</code></pre><p>接下来我们看看运行的结果：<br><img src="http://file.liangxiegame.com/848bb7c8-aa25-4bcc-9924-1d7b74a69314.png"><br>我们不难看到过 Register<T>() 注册的依赖，每次注入时创建新的实例，而通过 RegisterInstance(object obj) 注册的依赖，每次注入都返回同一个 obj 实例。<br>总结如下：</T></p><pre><code>Register&lt;T&gt;，每次注入时创建新的实例。RegisterInstance(object obj)，每次注入时，返回同一个 obj 对象。</code></pre><h1 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h1><p>依赖倒置原则，即：Dependency Inversion Principle，很多时候缩写成 DIP。<br>这个原则包含了两个主题：  </p><pre><code>高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念。抽象接口不应该依赖于实现，而实现依赖于抽象接口</code></pre><h2 id="高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念"><a href="#高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念" class="headerlink" title="高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念"></a>高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念</h2><p>我们来拿一个司机开车的例子，代码如下：  </p><pre><code>public class Driver&#123;  // 司机的职责是开车  public void Drive(Benz benz)  &#123;    benz.Run();  &#125;&#125;public class Benz&#123;  public void Run()  &#123;    Debug.Log(&quot;奔驰汽车开始运行&quot;)  &#125;&#125;void Main()&#123;  var lucas = new Driver();  var benz = new Benz();  lucas.Drive(benz);&#125;</code></pre><p>目前A同学负责开发Driver类，B同学负责开发Benz类。这时候突然多了一个需求，那就是有一个同学的车换成了宝马，那我们需要重新创建一个BMW类。<br>然而因为A同学和B同学开发的类耦合性太强了，所以都需要重新改一下代码，这时候看看这句话：高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念。这样我们把车和司机都依赖于抽象，更改后的代码是：  </p><pre><code>public class Driver&#123;  // 司机的职责是开车  public void Drive(ICar car)  &#123;    car.Run();  &#125;&#125;public interface ICar&#123;  void Run();&#125;//public class Benz : ICar//&#123;//  public void Run()//  &#123;//    Debug.Log(&quot;奔驰汽车开始运行&quot;)//  &#125;//&#125;public class BMW : ICar&#123;  public void Run()  &#123;    Debug.Log(&quot;宝马汽车开始运行&quot;)  &#125;&#125;void Main()&#123;  var lucas = new Driver();  var bmw = new BMW();  lucas.Drive(bmw);&#125;</code></pre><p>从上面代码可以看出，当更换车的时候，不需要修改高层的代码，只需要把车的类更换掉就行了。<br>实际上，要完全实现”高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念“这一个主题的话，Driver 类也应该抽象出来一个 IDriver，不过对于目前的结构来说没有必要。  </p><h2 id="抽象接口不应该依赖于实现，而实现依赖于抽象接口"><a href="#抽象接口不应该依赖于实现，而实现依赖于抽象接口" class="headerlink" title="抽象接口不应该依赖于实现，而实现依赖于抽象接口"></a>抽象接口不应该依赖于实现，而实现依赖于抽象接口</h2><p>我们直接上代码：</p><pre><code>var lucas = new Driver();ICar car = new BMW();lucas.Drive(car);</code></pre><p>其中的 ICar car &#x3D; new BMW() 就实现了“实现依赖于抽象接口”这一主题。<br>依赖这个概念需要再次更新了，上文中说到司机需要车才能当好司机，所以司机依赖车，那么现在 BMW 需要实现 ICar 接口，才能正常使用，那么 BMW 类依赖 ICar 接口，（实现依赖抽象接口)。<br>实际上依赖倒置原则的两个主题都在说一件事情，两个类之间的交互通过抽象（接口、抽象类）来完成。<br>而通过一个抽象，可以将两个类的变化隔离。即 A 类修改或扩展甚至是替换都不影响 B，反过来也是如此。<br>通过依赖倒置原则可以提高整个系统的灵活性和扩展性还有维护性。  </p><h1 id="通过DIContainer实现DIP"><a href="#通过DIContainer实现DIP" class="headerlink" title="通过DIContainer实现DIP"></a>通过DIContainer实现DIP</h1><p>我们这时候来想想，其实依赖也就等于需求了。<br>而 QF 中的 DIContainer 支持前两种依赖管理，而市面上有个 IOC 容器，叫做 Zenject，支持以上全部的依赖关系。  </p><h2 id="DIContainer-中的接口依赖管理（QF）"><a href="#DIContainer-中的接口依赖管理（QF）" class="headerlink" title="DIContainer 中的接口依赖管理（QF）"></a>DIContainer 中的接口依赖管理（QF）</h2><p>在上文中，我们说过QF中的依赖注入的时候DIContainer提供了两个API，分别是Register 与 RegisterInstance，分别是注入的时候是新的还是说同一个。<br>实际上这两者都有一些重载，即支持接口依赖的注册。<br>多说无用，放出来代码大家来体会一下：  </p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;namespace QF.Master.Example&#123;    public interface ILoginService    &#123;        void Login();    &#125;    public class LoginService : ILoginService    &#123;        public void Login()        &#123;            Debug.Log(&quot;登录成功&quot;);        &#125;    &#125;    public class IOCInterfaceExample : MonoBehaviour     &#123;        [Inject]        public ILoginService LoginService &#123;get;set;&#125;        void Start ()         &#123;            var container = new QFrameworkContainer();            container.RegisterInstance&lt;ILoginService&gt;(new LoginService());            // Register 也支持注册接口依赖            //container.Register&lt;ILoginService,LoginService&gt;();            container.Inject(this);            LoginService.Login();        &#125;    &#125;&#125;</code></pre><p>代码很简单，代码中可以根据接口注入具体的实例，使脚本可以依赖 ILoginService 接口而不依赖于 LoginService 类。  </p><h1 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h1><p>在上文我们已经了解了依赖倒置原则和依赖注入的方案。了解了上面两个概念。这样会让我们更容易了解控制反转。  </p><h2 id="控制正转"><a href="#控制正转" class="headerlink" title="控制正转"></a>控制正转</h2><p>有反转就有正转，我们先来看看正转的代码：  </p><pre><code>public class ModuleA&#123;  public ModuleB B = new ModuleB();&#125;public class ModuleB&#123;&#125;</code></pre><p>这个就是正转，就是依赖的对象在内部进行创建，其实这不叫正转，这是正常的控制过程。<br>控制的意思其实就是依赖的对象创建的过程。也就是上述代码中的B的创建控制过程。<br>正转的过程就是被依赖对象B的创建是由依赖对象A控制，谁依赖谁创建。<br>控制反转就好理解了，就是被依赖对象B的创建是由外部控制了，就不需要依赖对象A进行控制创建了。<br>控制反转代码如下：  </p><pre><code>public class ModuleA&#123;  public ModuleB B;&#125;public class ModuleB&#123;&#125;void Main()&#123;  var moduleA = new ModuleA();  // 对象创建过程由外部控制  moduleA.B = new ModuleB();&#125;</code></pre><p><strong>控制反转意思是类依赖对象创建的过程由外部控制，而不是在类内部控制。</strong>  </p><h1 id="依赖注入与控制反转"><a href="#依赖注入与控制反转" class="headerlink" title="依赖注入与控制反转"></a>依赖注入与控制反转</h1><pre><code>控制反转：依赖对象的创建过程交给外部控制。 依赖注入：依赖对象在外部进行设置。</code></pre><p>控制反转是设计原则，或者说是设计模式，而依赖注入是控制反转的具体实现。<br>控制反转的具体实现除了有常用的依赖注入还有一种方案叫依赖查找，这里我们不介绍。<br>控制反转和依赖注入有一些细微的差别，控制反转的重点在于依赖对象创建过程的控制，而依赖注入的重点在于依赖对象如何设置，实际上这两个概念都在说，依赖对象的创建和设置都在外边搞，不要在类内部搞。  </p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI</title>
      <link href="/2019/09/23/Unity/UGUI/"/>
      <url>/2019/09/23/Unity/UGUI/</url>
      
        <content type="html"><![CDATA[<h1 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h1><h2 id="Render-Mode"><a href="#Render-Mode" class="headerlink" title="Render Mode"></a>Render Mode</h2><p>Screen Space – overlay:不需要UI相机，UI永远显示最前面。<br>Screen Space- Camera：需要提供一个UICamera,如果UI前面需要加特效，只要深度大于UICamera就行了。<br>World Space：适用于3D的UI。  </p><h2 id="Pixel-Perfect"><a href="#Pixel-Perfect" class="headerlink" title="Pixel Perfect"></a>Pixel Perfect</h2><p>启用可以使元素看起来清晰并防止模糊。</p><h2 id="Sort-Order"><a href="#Sort-Order" class="headerlink" title="Sort Order"></a>Sort Order</h2><p>Canvas的深度，数值越大，优先级越高；优先级高的遮挡优先级低的。  </p><h2 id="Terget-Display"><a href="#Terget-Display" class="headerlink" title="Terget Display"></a>Terget Display</h2><p>使Canvas渲染到指定的显示中。支持的辅助显示器最大数量为8。</p><h2 id="Additional-Shader-Channels"><a href="#Additional-Shader-Channels" class="headerlink" title="Additional Shader Channels"></a>Additional Shader Channels</h2><p>提供给Shader使用的参数。</p><h2 id="Render-Camera"><a href="#Render-Camera" class="headerlink" title="Render Camera"></a>Render Camera</h2><p>指定Canvas渲染在哪一个摄像机上。</p><h2 id="Plane-Distance"><a href="#Plane-Distance" class="headerlink" title="Plane Distance"></a>Plane Distance</h2><p>当Camera的Projection为Orthograhic时，值得变化仅仅改变Canvas的Pos Z；<br>当Camera的Projection为Perspective时，值得变化不仅仅改变Canvas的Pos Z,还会改变Scale;<br>当Plane Distance等于Camera的Clipping Planes的Near时，相当于Render Mode是Screen Space-Overlay的效果，当Plane Distance等于Camera的Clipping Planes的Far时，Canvas在所有物体的后面。  </p><h2 id="Sorting-Layer"><a href="#Sorting-Layer" class="headerlink" title="Sorting Layer"></a>Sorting Layer</h2><p>可为UGUI设置画布深度，在下拉菜单中点击“Add Sorting Layer”进入标签和层的设置界面，点击+或者-即可添加和删除，画布所使用的Sorting Layer越往下，显示的优先级越高。   </p><h2 id="Order-in-Layer"><a href="#Order-in-Layer" class="headerlink" title="Order in Layer"></a>Order in Layer</h2><p>在相同深度的Layer中区别显示层级关系的设定，相同的Layer中Order in Layer越高，显示的优先级也就越高。  </p><h2 id="Event-Camera"><a href="#Event-Camera" class="headerlink" title="Event Camera"></a>Event Camera</h2><p>在World Space模式下，Event Camera为空也可以执行按钮点击事件  </p><h1 id="Canvas-Scaler"><a href="#Canvas-Scaler" class="headerlink" title="Canvas Scaler"></a>Canvas Scaler</h1><h2 id="UI-Scale-Mode-——-Constant-Pixel-Size"><a href="#UI-Scale-Mode-——-Constant-Pixel-Size" class="headerlink" title="UI Scale Mode —— Constant Pixel Size"></a>UI Scale Mode —— Constant Pixel Size</h2><p>不管屏幕Size如何变化，都会保持UI像素Size不变。<br>Scale Factor:设置UI的缩放比例，值为1表示不缩放。<br>Reference Pixels Per Unit:UI元素每个单元需要Sprite途中的多少像素填充。  </p><h2 id="UI-Scale-Mode-——-Scale-With-Screen-Size"><a href="#UI-Scale-Mode-——-Scale-With-Screen-Size" class="headerlink" title="UI Scale Mode —— Scale With Screen Size"></a>UI Scale Mode —— Scale With Screen Size</h2><p>UI根据屏幕的size来调整自己的size。<br>Reference Resolution:默认参考的分辨率，一般设置为当下市场中主流设备的分辨率，它是参考标准，其他的分辨率的，会根据它来进行缩放。<br>Screen Match Mode:如果当前屏幕的分辨率与参考标准值不符时，应选择一种适应匹配模式来缩放Canvas。   </p><pre><code>1.Match Width Or Height当Match的值为0时，指UI大小只取决于屏幕的宽度，如果当前屏幕的宽度是参考标准宽度的n倍，则UI整体缩放为参考标准的n倍，当Match的值为1时，指UI大小只取决于屏幕的高度；当Match的值在0~1之间时，通过上述两个比例权重加成来进行计算。  2.Expand这种模式比较适合屏幕实际的Size大于参考标准时，需要将UI扩充到大屏幕中，为尽可能保证显示效果，该模式会选择变化较小的一个方向，作为放大Canvas的标准，儿另外一个方向的变化则在整体缩放后进行补偿性的变化。3.Shrink与Expand恰好相反，这种模式比较适合屏幕的实际Size大小参考标准时，需要将UI压缩到小屏幕中，原理与Expand类似。</code></pre><h2 id="UI-Scale-Mode-——-Constant-Physical-Size"><a href="#UI-Scale-Mode-——-Constant-Physical-Size" class="headerlink" title="UI Scale Mode —— Constant Physical Size"></a>UI Scale Mode —— Constant Physical Size</h2><p>不管屏幕的Size还是分辨率如何，都会保持UI的物理Size不变<br>Physical Unit：设置物理尺寸单位<br>Fallback Screen DPI:当前屏幕分辨率不明确时而采用的分辨率；<br>Default Sprite DPI：精灵图片每英寸的默认像素</p><h1 id="Graphic-Raycaster"><a href="#Graphic-Raycaster" class="headerlink" title="Graphic Raycaster"></a>Graphic Raycaster</h1><p>用于检测头像Canvas的射线。<br>Ignore Reversed Graphics:忽略颠倒的图形的射线检测，即旋转180°后的图片不会与射线发生交互<br>Blocked Objects：会阻挡图形射线的对象类型，需要有collider组件。<br>Blocked Mask：会阻挡图形射线的Layer。</p><h1 id="LayoutGroup"><a href="#LayoutGroup" class="headerlink" title="LayoutGroup"></a>LayoutGroup</h1><h2 id="Grid-Layout-Group"><a href="#Grid-Layout-Group" class="headerlink" title="Grid Layout Group"></a>Grid Layout Group</h2><p>Padding:间隔<br>CellSize:子物体大小<br>Spacing：子物体之间的间隔<br>Start Corner:子物体排列的角度<br>Start Axis:子物体排列方向<br>Child Alignment:子物体整体位于什么方位<br>Constraint: </p><pre><code>Flexible:灵活的，按照父物体长宽自动横竖行Fixed Column Count:指定列数Fixed Row Count:指定行数</code></pre><h2 id="Horizontak-Vertical-Layout-Group"><a href="#Horizontak-Vertical-Layout-Group" class="headerlink" title="Horizontak(Vertical) Layout Group"></a>Horizontak(Vertical) Layout Group</h2><p>child force expand：是否强制拉伸长宽到父物体大小。单独使用很难实现理想效果，所以要配合Content Size Fitter组件配合使用。<br>Content Size Fitter:</p><pre><code>Horizontal Fit:子物体横向适配Vertical Fit:子物体竖向适配</code></pre><p>Layout Element:</p><pre><code>Min Width:最小宽度Min Height:最小高度Preferred Width:首选宽度Flexible Width:灵活的宽度Flexible Height:灵活的高度</code></pre><h2 id="Content-Size-Fitter"><a href="#Content-Size-Fitter" class="headerlink" title="Content Size Fitter"></a>Content Size Fitter</h2><p>一般和Layout Group配合使用</p><h2 id="Aspect-Ratio-Fitter"><a href="#Aspect-Ratio-Fitter" class="headerlink" title="Aspect Ratio Fitter"></a>Aspect Ratio Fitter</h2><p>Aspect Mode:宽高比模式（宽控制高，高不可修改）<br>Height Controls Width:高控制宽<br>Fitln Parent:宽或高和父物体一样，另一个小于父物体<br>Envelope Parent：宽或高和父物体一样，另一个包围父物体<br>Aspect Ratio:宽高比例  </p><h1 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h1><h2 id="Source-Image"><a href="#Source-Image" class="headerlink" title="Source Image"></a>Source Image</h2><p>指定要系那是的目标图片资源，只支持Sprite类型的图片。</p><h2 id="Color"><a href="#Color" class="headerlink" title="Color"></a>Color</h2><p>设置Color属性值，会改变图片显示的色调。</p><h2 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h2><p>设定用于渲染图片的材质</p><h2 id="RaycastTarget"><a href="#RaycastTarget" class="headerlink" title="RaycastTarget"></a>RaycastTarget</h2><p>决定是否接收射线碰撞检测</p><h2 id="Image-Type"><a href="#Image-Type" class="headerlink" title="Image Type"></a>Image Type</h2><p>用于设定图片显示的类型，如Simple&#x2F;Sliced&#x2F;Tiled&#x2F;Filled。  </p><h3 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h3><p>图片根据Image的比例按照原来比例进行伸缩改变。</p><h3 id="Sliced"><a href="#Sliced" class="headerlink" title="Sliced"></a>Sliced</h3><p>九宫格，经过九宫格处理的图片，在九宫格的4个角落不进行改变，并且4个边只进行单向的伸缩。<br>在属性面板中点击Sprite Editor按钮即可进行图片的九宫格编辑。<br>Fill Center选项如果取消勾选，Image的显示就不会完成，只会显示切片的边缘图片。  </p><h3 id="Tiled"><a href="#Tiled" class="headerlink" title="Tiled"></a>Tiled</h3><p>此模式下Sprite本身大小会保持不变，但是sprite会像铺地板一样填充整个Image。  </p><h3 id="Filled"><a href="#Filled" class="headerlink" title="Filled"></a>Filled</h3><p>此模式一般用作“CD”效果的技能按钮等，让Image以一定的展现方式显示部分。<br>Fill Method:指定呈现方式（Horizontal水平、Vertical垂直、Radial90(1&#x2F;4圆呈现)，半圆，整圆）<br>Fill Origin:指定填充显现操作的起点。<br>Fill Amount:指定填充的进度<br>Clock Wise:针对圆类型的填充显示方式，取消与勾选该项，会“翻转”填充显示“方向”<br>Preserve Aspect:根据Sprite宽高比，缩放Image  </p><h1 id="Canvas-Group"><a href="#Canvas-Group" class="headerlink" title="Canvas Group"></a>Canvas Group</h1><h2 id="Alpha"><a href="#Alpha" class="headerlink" title="Alpha"></a>Alpha</h2><p>该组件UI元素的透明度。需要注意，每个UI最终的透明度是由此值和自身的alpha数值相乘得到。  </p><h2 id="Interactable"><a href="#Interactable" class="headerlink" title="Interactable"></a>Interactable</h2><p>是否需要交互，通知作用于该组全部UI元素  </p><h2 id="BlockRaycasts"><a href="#BlockRaycasts" class="headerlink" title="BlockRaycasts"></a>BlockRaycasts</h2><p>如果需要图形射线检测，勾选后，可将此组件作为一个射线碰撞盒。注意不适用于Physics.Raycast  </p><h2 id="Ignore-Parent-Groups"><a href="#Ignore-Parent-Groups" class="headerlink" title="Ignore Parent Groups"></a>Ignore Parent Groups</h2><p>是否需要忽略父级对象中的Canvas Group的设置（勾选则忽略）  </p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UniRx入门</title>
      <link href="/2019/09/23/Unity/UniRx%E5%85%A5%E9%97%A8/"/>
      <url>/2019/09/23/Unity/UniRx%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<pre><code>UniRx - Unity响应式编程插件  插件作者Yoshifumi Kawai(neuecc) 本篇参照博客：1.凉鞋小班博客            2.https://blog.csdn.net/zhenghongzhi6/article/details/79229585</code></pre><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="UniRx简介"><a href="#UniRx简介" class="headerlink" title="UniRx简介"></a>UniRx简介</h2><p>UniRx 是 Unity Reactive Extensions 的缩写，意思是 Unity 的响应式扩展集。重写了.Net的响应式扩展。<br>.Net官方的Rx很棒，但是在Unity中无法使用，并且与IOS的IL2CPP有兼容性问题。这个库这些问题并且添加了一些Unity专属的工具类。<br>支持的平台有：PC&#x2F;Mac&#x2F;Android&#x2F;iOS&#x2F;WP8&#x2F;WindowsStore&#x2F;等等，并且支持Unity4.6之后的所有版本。  </p><p><strong>UniRx 在 Unity Asset Store 的地址(免费)：<a href="http://u3d.as/content/neuecc/uni-rx-reactive-extensions-for-unity/7tT">http://u3d.as/content/neuecc/uni-rx-reactive-extensions-for-unity/7tT</a></strong>  </p><h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p>响应式是什么意思：一旦A做了事情，B就得到了通知。<br>为什么unirx是响应式：因为UniRx通过观察者模式实现了这种响应。  </p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>在C#语法中对静态this关键字进行了扩展，类似于Linq的关键字扩展。<br>例：<br>    Observable.EveryUpdate() &#x2F;&#x2F; 每一帧发送一次通知<br>      .Where(<em>&#x3D;&gt;Timer.frameCount % 5 &#x3D;&#x3D; 0) &#x2F;&#x2F; Linq Where 关键字，每 5 帧发送一次通知<br>      .Subscribe(</em>&#x3D;&gt;Debug.Log(“Every 5 Frame”)) &#x2F;&#x2F; 订阅 输出</p><h2 id="为什么用Rx"><a href="#为什么用Rx" class="headerlink" title="为什么用Rx"></a>为什么用Rx</h2><p>拿网络操作进行举例：<br>网络操作需要用到WWW和Coroutine。但是使用Coroutine会遇到下面列问题<br>  1.协程不能有返回值，因为返回类型必须是IEnumerator<br>  2.协程不能处理异常，因为 yield return 语句没办法被 try-catch<br>这样就会造成代码大面试的强耦合。<br>游戏循环 (every Update, OnCollisionEnter, etc), 传感器数据 (Kinect, Leap Motion, VR Input, etc.) 都是事件。Rx将事件转化为响应式的序列，通过LINQ操作可以很简单地组合起来，还支持时间操作。  </p><p>Unity通常是单线程，但是UniRx可以让多线程更容易。</p><p>UniRx 可以简化 uGUI 的编程，所有的UI事件 (clicked, valuechanged, etc) 可以转化为 UniRx 的事件流。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Reactive Extensions 指的就是： 观察者模式 + Linq。</p><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>代码如下：</p><pre><code>using UnityEngine;using UniRx;namespace QF.Master.Example&#123;    public class UniRxBasicUsage : MonoBehaviour    &#123;        void Start()        &#123;            Observable.EveryUpdate()                .Where(_ =&gt; Time.frameCount % 5 == 0)                .Subscribe(_=&gt; Debug.Log(&quot;hello&quot;));        &#125;    &#125;&#125;</code></pre><p>运行结果：<br><img src="http://file.liangxiegame.com/7d00ea36-8058-4b6d-87d6-d2e27d2e6cb2.png">  </p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>主要代码：</p><pre><code>Observable.EveryUpdate()  .Where(_ =&gt; Time.frameCount % 5 == 0)  .Subscribe(_=&gt; Debug.Log(&quot;hello&quot;));</code></pre><p>代码分为三部分，分别是:</p><pre><code>Observable：Observable.EveryUpdate()Linq 操作符：Where(_ =&gt; Time.frameCount % 5 == 0)订阅、注册事件的处理：Subscribe(_=&gt; Debug.Log(&quot;Hello&quot;))</code></pre><p>以上是一个 UniRx 的基本使用格式，每个 UniRx 的完整使用，都会包含以上三个部分。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式分别有:观察者（Observer）、主题（Subject）、通知（Notify）、订阅（Subscribe）。<br>Observable 中文的意思是可观察者的，是一个形容词。<br>主题（Subject）就是可观察的主体。<br>对比下列代码</p><pre><code>Observable.EveryUpdate()// Observable  .Where(_ =&gt; Time.frameCount % 5 == 0)//可以不写，代表没有限制条件  .Subscribe(_=&gt; Debug.Log(&quot;hello&quot;));// Subscribe</code></pre><p>代码中的 EveryUpdate 意思是：每次执行 Update 时，发送一次通知（Notify）。<br>发送的通知由 Subscribe 中的 lambda 表达式接收。  </p><h3 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h3><pre><code>Where(_ =&gt; Time.frameCount % 5 == 0)</code></pre><p>Where 是相当于一个条件过滤，意思是，当 Where 方法中的 lambda 表达式返回 true 时，则保留，否则丢弃。<br>Where 是一个 Linq 操作符。<br>举例：</p><pre><code>var ages = new int[] &#123; 1,2,3&#125;;var ageList = ages.Where(age=&gt;age &gt;= 2).ToList();// 此时 ageList 为 [2,3]</code></pre><h2 id="UniRx-中的-Linq-操作符"><a href="#UniRx-中的-Linq-操作符" class="headerlink" title="UniRx 中的 Linq 操作符"></a>UniRx 中的 Linq 操作符</h2><p>Linq 有大量的类似 Where 这样的操作符，而 UniRx 也同样支持了大量的操作符，不过 UniRx 是在自己的库中实现的，与 C# 的 Linq 操作符并不是完全一致的。<br>我们知道 C# 中的 Linq 操作符是查询内存数据用的，这里的内存数据指的是各种可枚举集合（IEnumrable），比如 Array,Queue,Stack,Dictionary 等所有实现 IEnumrable 接口的类。<br>而 UniRx 中的 Linq 操作符是用来查询各种事件源的 (IObservable)，比如 Observable.EveryUpdate() 返回的对象就是一个 IObservable 对象。<br>C# 中的 Where 操作符是过滤一个一个数据。<br>而 UniRx 中的 Where 操作符是过滤一个一个通知（事件）  </p><h2 id="Subscribe"><a href="#Subscribe" class="headerlink" title="Subscribe"></a>Subscribe</h2><pre><code>.Subscribe(_=&gt; Debug.Log(&quot;hello&quot;));</code></pre><p>Subscribe就是订阅的意思，在代码中其实是被订阅的意思，意思就是被<strong>观察者</strong>订阅。<br>代码结构目前是：</p><pre><code>Observable.Linq.Subcribe(callback)</code></pre><p>讲到这里，观察者模式中，我们看到了<strong>主题（Observable）、订阅（Subscribe）、通知（Notify）</strong>，但是还没有**观察者(Observer)**。<br>我们来看看Subscribe的底层是如何定义的  </p><pre><code>public static XXXYYYZZZ Subscribe(IObserver observer)&#123;  ...&#125;</code></pre><p>Subscribe 的参数实际上就是一个观察者，而在最上层的 API 中，UniRx 将 Observer 简化为了一个委托。<br><img src="http://file.liangxiegame.com/a682675e-98a6-4c60-af78-5d5801f066f1.png">  </p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>UniRx 的最核心的三个概念分别是：<br>Observable（可观察的）<br>Linq 操作符<br>Subscribe（Observer）<br>这是UniRx最基础的三个概念，只要熟练掌握这三个概念就可以运用UniRx的所有API了。<br>niRx 有大量的 Observable 和 Linq 操作符，我们学习的 EveryUpdate 只是其中一个 Observable。  </p><h1 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h1><h2 id="TimeSpan-延迟功能"><a href="#TimeSpan-延迟功能" class="headerlink" title="TimeSpan(延迟功能)"></a>TimeSpan(延迟功能)</h2><p>代码如下：</p><pre><code>using UnityEngine;using UniRx;using System;public class UniRxTimerExample : MonoBehaviour &#123;    void Start ()     &#123;        Debug.Log(&quot;此时:&quot; + DateTime.Now);        Observable.Timer(TimeSpan.FromSeconds(2.0f))             .Subscribe(_=&gt;Debug.Log(&quot;此时:&quot; + DateTime.Now));    &#125;&#125;</code></pre><h2 id="AddTo-MonoBehaviour"><a href="#AddTo-MonoBehaviour" class="headerlink" title="AddTo(MonoBehaviour)"></a>AddTo(MonoBehaviour)</h2><p>上述延迟有个问题，就是如果延迟期间gameobject被销毁，就会访问到NULL数据<br>UniRx 提供了一个方案：生命周期绑定<br>当 GameObject 销毁时，自动销毁延时任务：AddoTo(MonoBehaviour)  </p><pre><code>using UnityEngine;using UniRx;using System;public class UniRxTimerExample : MonoBehaviour &#123;    void Start ()     &#123;        Debug.Log(&quot;此时:&quot; + DateTime.Now);        Observable.Timer(TimeSpan.FromSeconds(2.0f))            .Subscribe(_=&gt; Debug.Log(&quot;此时:&quot;  + DateTime.Now))            .AddTo(this);        Observable.Timer(TimeSpan.FromSeconds(0.5f))            .Subscribe(_=&gt; Destroy(gameObject));    &#125;&#125;</code></pre><p>运行的结果:(2s后就没有输出了)<br><img src="http://file.liangxiegame.com/64db9c51-30fa-458c-bc64-366bfa4d6b3a.png"></p><h2 id="IDisposable"><a href="#IDisposable" class="headerlink" title="IDisposable"></a>IDisposable</h2><p>而 AddTo 实际上是 UniRx 对 IDisposable(.NET中用于释放对象资源的接口) 的一个静态扩展，也就是说所有的实现 IDisposable 接口的对象都可以使用 AddTo 将销毁绑定到 MonoBehaviour 或 GameObject 上。<br>而 Observbale.Timer 在 Subscribe 之后能够调用 AddTo 是因为 Subscribe 方法返回了一个 IDisposable 对象。  </p><pre><code>public static IDisposable Subscribe&lt;T&gt;(this IObservable&lt;T&gt; source, Action&lt;T&gt; onNext)&#123;    ...&#125;</code></pre><p>使用 IDisposable 和 AddTo 这对组合我们可以在做模块或库设计的时候非常容易实现生命周期绑定的功能，IDisposable 实际上可以充当一个卸载过程。 </p><h1 id="Subject使用"><a href="#Subject使用" class="headerlink" title="Subject使用"></a>Subject使用</h1><h2 id="Subject-Observable"><a href="#Subject-Observable" class="headerlink" title="Subject Observable"></a>Subject Observable</h2><p>Subject 即主题，UniRx 是提供了具体的 Subject 这个概念的。<br>举例代码如下：  </p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;using UniRx;public class UniRxSubjectExample : MonoBehaviour &#123;    void Start ()     &#123;        var subject = new Subject&lt;int&gt;();        subject.Subscribe(number =&gt; &#123;            Debug.Log(number);        &#125;);        subject.OnNext(1);        subject.OnNext(2);        subject.OnNext(3);    &#125;&#125;</code></pre><p>Subject是一个Observable，是一个事件源，是可以被订阅的(Subscribe).<br>而 Subject 是一个泛型类，可以制定要发送通知的类型。<br>代码中指定了发送类型为int。  </p><pre><code>var subject = new Subject&lt;int&gt;();</code></pre><p>而指定什么类型，那么在订阅的时候就会接收到什么类型的数据  </p><pre><code>subject.Subscribe(number =&gt; &#123;  Debug.Log(number);&#125;);</code></pre><p>一个 subject 光是创建对象和被订阅是没什么用的，要让 subject 发送数据，代码如下:</p><pre><code>subject.OnNext(1);subject.OnNext(2);subject.OnNext(3);</code></pre><p>运行结果如下：<br><img src="http://file.liangxiegame.com/42e52357-4f57-4b0e-820a-d5c32d4628d8.png">  </p><h2 id="Subjecrt是什么？"><a href="#Subjecrt是什么？" class="headerlink" title="Subjecrt是什么？"></a>Subjecrt是什么？</h2><p>在 UniRx 中 Subject 是一个 Observable（事件源），它可以让我们通过做少的代码实现观察者模式。  </p><h2 id="Subject-与委托相比有什么不同？"><a href="#Subject-与委托相比有什么不同？" class="headerlink" title="Subject 与委托相比有什么不同？"></a>Subject 与委托相比有什么不同？</h2><p>在使用上，Subject 与委托的使用方式差不多，两者之间共同的地方有：</p><blockquote><p>需要声明，定义参数类型<br>需要注册、订阅<br>委托需要调用，而 Subject 需要通过 OnNext 发送数据。<br>委托给人的感觉是一根线，而 Subject 给人感觉是一个管道。<br>委托不同的地方有：<br>可以定义多个接收参数<br>接收数据之后比较难以再组织整理  </p></blockquote><p>Subject 不同的地方有：  </p><blockquote><p>只能定一个一个参数类型<br>接收数据之后可以使用 Linq 对数据进行再组织整理   </p></blockquote><h1 id="OnNext-与-IObserver"><a href="#OnNext-与-IObserver" class="headerlink" title="OnNext 与 IObserver"></a>OnNext 与 IObserver</h1><h2 id="OnNext简介"><a href="#OnNext简介" class="headerlink" title="OnNext简介"></a>OnNext简介</h2><p>从前面内容可以推测出Subject 继承了 Observable。<br>真实情况底层代码<strong>Subject</strong>实现了一个<strong>IObservable</strong>接口  </p><pre><code>namespace UniRx&#123;    public interface IObservable&lt;T&gt;    &#123;        IDisposable Subscribe(IObserver&lt;T&gt; observer);    &#125;&#125;</code></pre><p>从代码中可以看出**IObservable.Subscribe(IObserver)**结构<br>OnNext 没有在 IObservable 中定义，但是在 IObserver 中定义了，IObserver 代码如下：</p><pre><code>using System;namespace UniRx&#123;    public interface IObserver&lt;T&gt;    &#123;        void OnCompleted();        void OnError(Exception error);        void OnNext(T value);    &#125;&#125;</code></pre><p>Subject 既是 Observable 也是 Observer。它同时实现了 IObservable 和 IObserver 两个接口。</p><p>这样 Subject 就能做到，既可以被订阅（Subscribe），又可以让我们通过其 OnNext 方法传输数据。</p><p>到此，大家可能会比较乱，IObservable 和 IObserver 分不清楚。</p><p>没关系，IObservable 和 IObserver 在接下来的文章中会着重介绍，因为它俩是 UniRx 的两个核心接口。</p><h2 id="OnNext-是什么？"><a href="#OnNext-是什么？" class="headerlink" title="OnNext 是什么？"></a>OnNext 是什么？</h2><p>OnNext 是 IObserver 定义的 API，在 UniRx 内部，OnNext 是被 IObservable 调用的。当 IObservable 每次发送事件时，都是通过 OnNext 向 IObserver 发送事件了，如下图所示：<br><img src="http://file.liangxiegame.com/e881f6d8-991f-4cda-83c7-d8664526f928.png"><br>而 Subject 既是 IObservable 又是 IObserver 所以既可以通过 OnNext 传输数据，又可以被 Subscribe。<br>Subject 就是这样的一个特殊的存在。 </p><h1 id="IObserver"><a href="#IObserver" class="headerlink" title="IObserver"></a>IObserver</h1><p>底层代码：  </p><pre><code>using System;namespace UniRx&#123;    public interface IObserver&lt;T&gt;    &#123;        void OnCompleted();        void OnError(Exception error);        void OnNext(T value);    &#125;&#125;</code></pre><h2 id="OnComplete"><a href="#OnComplete" class="headerlink" title="OnComplete"></a>OnComplete</h2><p>OnCompleted意思是，当完成时，也就是说当 Observable 发送完事件时会调用 IObserver 的 OnCompleted 的方法。<br>Observable.EveryUpdate 没有完成的时刻,所以是不会接收Oncomplete事件。<br>在<strong>UniRx</strong>中我们就知道有两种 Observable 了，即<strong>可结束的（比如 Observable.Timer）</strong>和不可结束的<strong>（Observable.EveryUpdate）</strong>。<br>OnCompleted 是在Subscribe 的第二个参数中使用。<br>我们知道 Subscribe 可以传入一个委托，次委托实际上是对应的是 OnNext 事件，那么第二个<strong>无参委托</strong>则是对应的是 OnCompleted 事件。  </p><pre><code>using UnityEngine;using UniRx;using System;public class UniRxOnCompletedExample : MonoBehaviour &#123;    void Start ()     &#123;            Observable.Timer(TimeSpan.FromSeconds(3.0f))            .Subscribe(_ =&gt; Debug.Log(&quot;Delayed 3 seconds&quot;),()=&gt;Debug.Log(&quot;completed&quot;));    &#125;&#125;</code></pre><h2 id="OnNext"><a href="#OnNext" class="headerlink" title="OnNext"></a>OnNext</h2><p>Subscribe 的第一个有参委托就是接收的是 OnNext 事件，这里就不多说了。</p><h2 id="OnError"><a href="#OnError" class="headerlink" title="OnError"></a>OnError</h2><p>Observable（事件源）会发送一些异常或错误，这个时候错误和异常就会发送到 IObserver 的 OnError 中，而 OnError 的使用也非常简单，即：Subscribe 的第二个<strong>有参委托</strong>接收的就是 OnError 事件  </p><h1 id="ReactiveProperty"><a href="#ReactiveProperty" class="headerlink" title="ReactiveProperty"></a>ReactiveProperty</h1><p>ReactiveProperty 即响应式属性，它是一个 Property(属性)，同时也是响应式的，说明它是一个可以被 Subscribe 的 Property。  </p><h2 id="C-中的Property"><a href="#C-中的Property" class="headerlink" title="C#中的Property"></a>C#中的Property</h2><pre><code>public class SomeClass&#123;  public int Age &#123;get;set;&#125;&#125;</code></pre><p>SomeClass 中的 Age 是一个 Property（属性）  </p><h2 id="UniRx中的Property"><a href="#UniRx中的Property" class="headerlink" title="UniRx中的Property"></a>UniRx中的Property</h2><pre><code>public class SomeClass&#123;  public ReactiveProperty&lt;int&gt; Age = new ReactiveProperty&lt;int&gt;();&#125;</code></pre><p>ReactiveProperty 的作用与 C# 的 Property 作用是一致的，就是可以设置值和获取值。<br>得到值的方法是：<strong>属性名.Value</strong><br>测试代码：</p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;using UniRx;public class UniRxReactiveProperty : MonoBehaviour &#123;    ReactiveProperty&lt;int&gt; mAge = new ReactiveProperty&lt;int&gt;();    void Start () &#123;        mAge.Subscribe(age=&gt;Debug.Log(age));        mAge.Value = 10;        mAge.Value = 10;        mAge.Value = 10;        mAge.Value = 11;    &#125;&#125;</code></pre><p>得到结果：<br><img src="http://file.liangxiegame.com/5f57e47e-695e-4490-8b6e-45753ce51715.png"><br>这里多输出了一个 0，这是因为，ReactiveProperty 会把初始默认值当做第一次值改变发送给 Subscribe 的委托。<br>解决方法Skip(1)：</p><pre><code> mAge.Skip(1)     .Subscribe(age=&gt;Debug.Log(age));</code></pre><p>这里我们要注意一下，ReactiveProperty 把初始值当做值改变事件发送是合理的，因为有的时候我们是需要得到初始值的，那么至于大家在使用时需不需要初始值，大家可以自行决定，而屏蔽掉初始值的方式就是通过 Skip 操作符。  </p><h2 id="Skip"><a href="#Skip" class="headerlink" title="Skip"></a>Skip</h2><p>skip 是 Linq 的操作符，意思是忽略，而 Skip 的参数是 Count，就是说可以通过 Count 来决定忽略多少个数据、事件。<br>在 ReactiveProperty 的用例代码中，Skip 的 Count 参数为 1，意思是忽略 1 个数据、事件。  </p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>ReactiveProperty 是一个事件源（Observable），而 Skip 是一个 Linq 操作符。<br>ReactiveProperty 是经常使用的设计工具，笔者常用它来写 Model 层的代码。  </p><h1 id="ReactiveCollection"><a href="#ReactiveCollection" class="headerlink" title="ReactiveCollection"></a>ReactiveCollection</h1><p>这是一种List形式的属性，用法和ReactiveProperty差不多：  </p><pre><code>public ReactiveCollection&lt;PlayerData&gt; mPlayerDataList = new ReactiveCollection&lt;PlayerData&gt;();</code></pre><p>是支持类似于List的Add一类的函数的。这里先不用做过多的详解   </p><h1 id="基于UniRx的事件系统"><a href="#基于UniRx的事件系统" class="headerlink" title="基于UniRx的事件系统"></a>基于UniRx的事件系统</h1><h2 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h2><p>代码：  </p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;using System;using UniRx;public class UniRxTypeEventSystem &#123;    /// &lt;summary&gt;    /// 接口 只负责存储在字典中    /// &lt;/summary&gt;    interface IRegisterations    &#123;    &#125;    /// &lt;summary&gt;    /// 多个注册    /// &lt;/summary&gt;    class Registerations&lt;T&gt; : IRegisterations    &#123;        /// &lt;summary&gt;        /// 不需要 List&lt;Action&lt;T&gt;&gt; 了        /// 因为委托本身就可以一对多注册        /// &lt;/summary&gt;        public Subject&lt;T&gt; Subject = new Subject&lt;T&gt;();    &#125;    /// &lt;summary&gt;    ///     /// &lt;/summary&gt;    private static Dictionary&lt;Type, IRegisterations&gt; mTypeEventDict = new Dictionary&lt;Type, IRegisterations&gt;();    /// &lt;summary&gt;    /// 注册事件    /// &lt;/summary&gt;    /// &lt;param name=&quot;onReceive&quot;&gt;&lt;/param&gt;    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;    public static Subject&lt;T&gt; GetEvent&lt;T&gt;()    &#123;        var type = typeof(T);        IRegisterations registerations = null;        if (mTypeEventDict.TryGetValue(type, out registerations))        &#123;            var reg = registerations as Registerations&lt;T&gt;;            return reg.Subject;        &#125;        else        &#123;            var reg = new Registerations&lt;T&gt;();            mTypeEventDict.Add(type, reg);            return reg.Subject;        &#125;    &#125;    /// &lt;summary&gt;    /// 发送事件    /// &lt;/summary&gt;    /// &lt;param name=&quot;t&quot;&gt;&lt;/param&gt;    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;    public static void Send&lt;T&gt;(T t)    &#123;        var type = typeof(T);        IRegisterations registerations = null;        if (mTypeEventDict.TryGetValue(type, out registerations))        &#123;            var reg = registerations as Registerations&lt;T&gt;;            reg.Subject.OnNext(t);        &#125;    &#125;&#125;</code></pre><p>调用方法：</p><pre><code>using System.Collections;using System.Collections.Generic;using System;using UnityEngine;using UniRx;public class UniRxTypeEventSystemTest : MonoBehaviour&#123;    class A    &#123;    &#125;    class B    &#123;        public int    Age;        public string Name;    &#125;    IDisposable mEventADisposable;    private void Start()    &#123;        mEventADisposable = UniRxTypeEventSystem.GetEvent&lt;A&gt;()            .Subscribe(ReceiveA); // 可以获取 IDisposable 对象        UniRxTypeEventSystem.GetEvent&lt;B&gt;()            .Subscribe(ReceiveB)            .AddTo(this); // 可以绑定    &#125;    void ReceiveA(A a)    &#123;        Debug.Log(&quot;received A&quot;);    &#125;    void ReceiveB(B b)    &#123;        Debug.LogFormat(&quot;received B:&#123;0&#125; &#123;1&#125;&quot;, b.Name, b.Age);    &#125;    private void Update()    &#123;        if (Input.GetMouseButtonDown(0))        &#123;            UniRxTypeEventSystem.Send(new A());        &#125;        if (Input.GetMouseButtonDown(1))        &#123;            UniRxTypeEventSystem.Send(new B()            &#123;                Age = 10,                Name = &quot;凉鞋&quot;            &#125;);        &#125;        if (Input.GetKeyDown(KeyCode.U))        &#123;            mEventADisposable.Dispose();        &#125;    &#125;&#125;</code></pre><h2 id="案例二（自写）"><a href="#案例二（自写）" class="headerlink" title="案例二（自写）"></a>案例二（自写）</h2><pre><code>using System;using System.Collections;using System.Collections.Generic;using QF;using UniRx;using UnityEngine;/// &lt;summary&gt;/// 接口 只负责存储在字典中/// &lt;/summary&gt;interface IRegisterations&#123;&#125;/// &lt;summary&gt;/// 多个注册/// &lt;/summary&gt;class Registerations : IRegisterations&#123;    /// &lt;summary&gt;    /// 委托本身就可以一对多注册    /// &lt;/summary&gt;    public Subject&lt;object[]&gt; Subject = new Subject&lt;object[]&gt;();&#125;public class MyEventSystem&#123;    /// &lt;summary&gt;    /// 存储已经注册的事件    /// &lt;/summary&gt;    private static Dictionary&lt;MyEventType, IRegisterations&gt; mTypeEventDict         = new Dictionary&lt;MyEventType, IRegisterations&gt;();    /// &lt;summary&gt;    /// 注册事件    /// &lt;/summary&gt;    public static Subject&lt;object[]&gt; GetEvent(MyEventType type)    &#123;        IRegisterations registerations = null;        if (mTypeEventDict.TryGetValue(type, out registerations))        &#123;            var reg = registerations as Registerations;            return reg.Subject;        &#125;        else        &#123;            var reg = new Registerations();            mTypeEventDict.Add(type, reg);            return reg.Subject;        &#125;    &#125;    /// &lt;summary&gt;    /// 发送事件    /// &lt;/summary&gt;    public static void Send(MyEventType type, params object[] param)    &#123;        IRegisterations registerations = null;        if (mTypeEventDict.TryGetValue(type, out registerations))        &#123;            var reg = registerations as Registerations;            reg.Subject.OnNext(param);        &#125;    &#125;    &#125;</code></pre><p>调用方法：</p><pre><code>MyEventSystem.Send(MyEventType.SelectNewPlayer, date);MyEventSystem.GetEvent(MyEventType.SelectNewPlayer)            .Subscribe(ChangePlayerShow)            .AddTo(this);</code></pre><h1 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h1><p>使用 ObservableWWW 进行异步网络操作。它的 Get&#x2F;Post 方法返回可订阅(Subscribe)的 IObservables:  </p><pre><code>ObservableWWW.Get(&quot;http://google.co.jp/&quot;)             .Subscribe(                 x =&gt; Debug.Log(x.Substring(0, 100)), // onSuccess                 ex =&gt; Debug.LogException(ex)); // onError</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UniRx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NUnit单元测试</title>
      <link href="/2019/09/23/Unity/NUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/09/23/Unity/NUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><p><font size="4"><strong>单元测试环境： NSubstitute</strong></font><br><font size="4"><strong>编写脚本环境： rider 2020.1.4</strong></font><br><font size="4"><strong>Unity环境: unity2019.4.3f1(LTS)</strong></font>    </p><p>首先下载<a href="https://github.com/nsubstitute/nsubstitute/downloads"><font color="steelblue" size="3">NSubstitute</font></a>插件。<br>然后把下载的文件中的NSubstitute.dll放进需要单元测试的项目中。  </p><h1 id="配置项目中的程序集"><a href="#配置项目中的程序集" class="headerlink" title="配置项目中的程序集"></a>配置项目中的程序集</h1><p>导入需要的dll文件后，点击Unity菜单中的<strong>Window&#x2F;General&#x2F;Test Runner</strong>,会弹出创建界面。<br><img src="http://file.liangxiegame.com/068a79ae-72a7-49bf-904c-2e20e67a921e.png"><br>在TestRunner界面中的右上角三个点的菜单上点击选择<strong>Enable playmode  tests…</strong>,然后打开PlayMode界面就可以了。<br><img src="http://file.liangxiegame.com/c24e5014-2852-492c-8476-e15006ccc222.png">  </p><h1 id="单元测试Assert类主要静态成员"><a href="#单元测试Assert类主要静态成员" class="headerlink" title="单元测试Assert类主要静态成员"></a>单元测试Assert类主要静态成员</h1><pre><code>AreEqual：方法被重载了N多次，主要功能是判断两个值是否相等；如果两个值不相等，则测试失败。AreNotEqual：方法被重载了N多次，主要功能是判断两个值是否不相等；如果两个值相等，则测试失败。AreNotSame：引用的对象是否不相同；如果两个输入内容引用相同的对象，则测试失败.AreSame：引用的对象是否相同；如果两个输入内容引用不相同的对象，则测试失败Fail：断言失败。 Inconclusive：表示无法证明为 true 或 false 的测试结果IsFalse：指定的条件是否为 false；如果该条件为 true，则测试失败。IsTrue：指定的条件是否为 true；如果该条件为 false，则测试失败IsInstanceofType：测试指定的对象是否为所需类型的实例；如果所需的实例不在该对象的继承层次结构中，则测试失 IsNotInstanceofType: 测试指定的对象是否为所需类型的实例；如果所需的实例在该对象的继承层次结构中，则测试失败IsNull：测试指定的对象是否为非空IsNotNull：测试指定的对象是否为非空</code></pre><h1 id="单元测试脚本"><a href="#单元测试脚本" class="headerlink" title="单元测试脚本"></a>单元测试脚本</h1><h2 id="创建第一个测试脚本"><a href="#创建第一个测试脚本" class="headerlink" title="创建第一个测试脚本"></a>创建第一个测试脚本</h2><pre><code>    public interface ICalculator      &#123;        int Add(int a, int b);        string Mode &#123; get; set; &#125;        event EventHandler PoweringUp;    &#125;    [Test]    public void Test_GetSubstitute()    //NSubstitute创建类型实例    &#123;        ICalculator calculator = Substitute.For&lt;ICalculator&gt;();    //创建实例    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NUnit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github+hexo博客搭建</title>
      <link href="/2019/09/21/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/github-hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/09/21/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/github-hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作者(脸白)搭建的博客网址：<a href="https://lianbai.github.io/">https://lianbai.github.io/</a><br>本篇博客参照博客网址：<a href="https://www.cnblogs.com/fengxiongZz/p/7707219.html">https://www.cnblogs.com/fengxiongZz/p/7707219.html</a><br>电脑系统：window 10专业版 64位</p><h1 id="准备步骤"><a href="#准备步骤" class="headerlink" title="准备步骤"></a>准备步骤</h1><p>1.首先电脑安装好Node.js和npm并配置好Node.js环境(不会安装的可以百度安装教程)，打开cmd命令行可以检测是否安装成功<br><img src="http://file.liangxiegame.com/84b0744f-b0dc-4d66-b715-e633e01a273d.png"><br>2.电脑安装git并配置好git的环境，并检测在电脑界面右键是否出现下图两个选择<br><img src="http://file.liangxiegame.com/8458cd48-c166-4b66-8f46-c950cab88ad8.png"><br>注:因为出于安全考虑所有的git的命令都在git bash here进行git的命令操作，如果想在cmd中进行git的相关命令操作，就需要在电脑中配置环境变量或者安装的时候选择 use Git from the Windows Command Prompt。在这里不做详细的说明。<br>检测git是否安装成功如下图在cmd命令下执行git –version<br><img src="http://file.liangxiegame.com/c0940441-c53a-4ca8-80cc-69b4cd9cbb02.png">  </p><h1 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h1><h2 id="创建github项目"><a href="#创建github项目" class="headerlink" title="创建github项目"></a>创建github项目</h2><p>1.注册一个github账户并且创建一个新的项目(<strong>github页面左上角有个‘+’,点击即可看到new repository</strong>)，项目的名字必须是严格遵守：账户名.github.io,并且需要勾选并且需要勾选Initialize this repository with a README<br><img src="http://file.liangxiegame.com/4326e22d-ef9e-4b53-aa45-c809f528174c.png"><br>2.创建好的项目在上面菜单的右侧会看到一个settings，打开它，页面一直往下拉，这时候会看到一个一个GitHub Pages,在上面有个网址，访问这个网址，发现已经可以访问了，并且外网也可以通过这个网址进行访问。<br><img src="http://file.liangxiegame.com/0db9aba0-1843-4a97-bf65-43ae14e184ab.png">  </p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>1.在自己认为合适的地方创建一个文件夹，用来存放博客配置，我这里就在D盘创建了一个文件夹名字叫blog，然后在cmd命令行里进入刚才创建的文件夹里<br><img src="http://file.liangxiegame.com/36a9d697-5dd4-43d8-a6c2-18a8d9d8c214.png"><br>2.在刚才创建的<strong>文件夹里</strong>利用npm安装hexo<br><img src="http://file.liangxiegame.com/ac6128be-50e1-401f-98d1-bccc96efe0a2.png"><br>3.检测hexo是否安装成功，命令是：hexo -v<br><img src="http://file.liangxiegame.com/d5fd5269-5a55-48fa-bd47-2e33cb7df82f.png"><br>4.初始化文件夹中的hexo(时间有点长)，命令是：hexo init<br><img src="http://file.liangxiegame.com/ce905082-9353-4755-8e2c-40e14b66b2cc.png"><br>5.当看到Start blogging with Hexo！的时候代表初始化成功了<br><img src="http://file.liangxiegame.com/36c0fc90-5246-464f-9686-ec5ad3d6c338.png"><br>6.在目录里安装所需要的组件，命令是：npm install<br><img src="http://file.liangxiegame.com/c15c696f-8134-4952-8e5c-e21914de299d.png">  </p><h2 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h2><p>1.首次提交配置，命令是：hexo g<br><img src="http://file.liangxiegame.com/446d8646-e0bb-41bf-b48f-7205e187bfa6.png"><br>2.开启博客的服务器，访问网址，开始体验hexo，命令是：hexo s<br><img src="http://file.liangxiegame.com/729756f3-ceb1-4fca-9ff5-872b4a66c1cd.png"><br><strong>注:有的电脑会自动跳转到链接，进行访问，如果没有跳转，可以手动复制链接进行访问，如果链接不能访问，有可能是端口被占用了，接下来可以改动服务的端口</strong><br>3.改动服务端口，命令是：hexo server -p 端口号<br><img src="http://file.liangxiegame.com/9bcc0944-11b8-470b-9cbf-ca3dd1fdbe52.png">  </p><h1 id="Hexo关联Github"><a href="#Hexo关联Github" class="headerlink" title="Hexo关联Github"></a>Hexo关联Github</h1><h2 id="配置Hexo信息"><a href="#配置Hexo信息" class="headerlink" title="配置Hexo信息"></a>配置Hexo信息</h2><p>1.在hexo里面设置git的名字和邮箱，在刚才创建的文件夹目录下右键，点击调用git命令的<strong>git bash here</strong>,然后添加名字和邮箱，命令是：  </p><pre><code>git config --global user.name &quot;github名字&quot;git config --global user.email &quot;github使用的邮箱&quot;  </code></pre><p><strong>名字和邮箱都用自己github的邮箱和名字</strong><br><img src="http://file.liangxiegame.com/be89b79e-65b8-4a88-8403-5cb30df0aadd.png"><br>2.检查是否有.ssh文件夹，命令是:</p><pre><code>cd ~/.ssh:跳转到.ssh目录ls:列出.ssh目录下的文件  </code></pre><p><img src="http://file.liangxiegame.com/7c48ab93-799b-411b-9ffe-3dc894a8b5d9.png">  </p><p><img src="http://file.liangxiegame.com/e8feb75f-dfd5-42ae-b612-dc0650408e67.png"><br>3.生成秘钥，然后得到id_rsa和id_rsa.pub文件(默认保存路径：C:\Users\Administrator.ssh)，命令是：<strong>ssh-keygen -t rsa -C</strong> <strong>“自己的邮箱”<strong>，中间会有三次停顿，敲三次回车就行了<br><img src="http://file.liangxiegame.com/e0ce3e6f-c3bf-4686-a6ba-004c0c68121a.png"><br>4.添加秘钥到ssh-agent，命令是：</strong>eval “$(ssh-agent -s)”</strong><br><img src="http://file.liangxiegame.com/f9d5874b-a04c-4098-a9fb-d4ff74e61f76.png"><br>5.将生成的SSH key添加到ssh-agent,命令是：<strong>ssh-add ~&#x2F;.ssh&#x2F;id_rsa</strong><br><img src="http://file.liangxiegame.com/717e62d6-f236-49a0-a485-707efc0ccf5c.png">  </p><h2 id="配置Github信息"><a href="#配置Github信息" class="headerlink" title="配置Github信息"></a>配置Github信息</h2><p>1.网页登录自己的github，然后点击右上角头像，选择setting<br>然后选择左侧的<strong>SSH and GPG keys</strong>,然后点击<strong>New ssh key</strong>添加一个ssh key<br><img src="http://file.liangxiegame.com/4186b9a5-9e02-4e91-8d08-c9aef5db1e23.png"><br>2.将上次创建的id_rsa.pub(默认保存路径：C:\Users\Administrator.ssh)里面的内容复制到github新建的ssh key里，Title可以随便起名字<br><img src="http://file.liangxiegame.com/d4473797-89f6-473e-bab8-a329fef0881c.png"><br>3.此时在git命令下测试ssh是不是成功，如果看到Hi 后面是你的名字，就说明成功了。命令是：<strong>ssh -T <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;">&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;</a></strong><br><font size="4" color="#FF0000">注：此时git所在的还是.ssh目录，如果不在此目录，输入：cd ~&#x2F;.ssh跳到.ssh目录</font> </p><h2 id="假如配置失败："><a href="#假如配置失败：" class="headerlink" title="假如配置失败："></a>假如配置失败：</h2><pre><code>    1.出现 Host key verification failed    当出现 Are key sure you want to continue.... (yes/no)?的时候不要点击回车，输入yes就行了</code></pre><p><img src="http://file.liangxiegame.com/97286e05-3f6c-48b7-b680-34ddcbf062e6.png"></p><pre><code>2.假如上述方法还不成功：首先，清除所有的key-pairssh-add -Drm -r ~/.ssh删除你在github中的public-key重新生成ssh密钥对ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot;接下来正常操作在github上添加公钥public-key:1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板2、在github上添加公钥时，直接复制即可3、保存测试：在终端 ssh -T git@github.com</code></pre><h1 id="配置并创建博客"><a href="#配置并创建博客" class="headerlink" title="配置并创建博客"></a>配置并创建博客</h1><p>1.在自己创建的博客文件夹下面，找到_config.yml文件，修改里面deoloy下面的数据(在文件最底下)   </p><pre><code>1.复制repositor值，在自己创建的github项目里的ssh2.在后面添加：branch: master</code></pre><p><img src="http://file.liangxiegame.com/8d1d96a0-bee4-4867-a104-23a09aef29b0.png">  </p><p><img src="http://file.liangxiegame.com/f6272673-15d8-4e45-9987-e8db13223844.png"><br>2.创建一篇新的文章，在<strong>博客目录\source_posts</strong>下右键使用git bash here调用git命令，命令是：hexo new post “博客名”<br><img src="http://file.liangxiegame.com/1e0f3593-eada-42fc-97fc-53a1dc4c4385.png"><br>3.随便找一个编译makedown的编译器，作者在这里用的是MakedownPad2编译器，(编译器的使用这里就不教学了，网上可以自己百度学习)<br>4.提交已经编好的文章，在<strong>博客目录</strong>下右键使用git bash here调用git命令，命令是：hexo d -g<br><img src="http://file.liangxiegame.com/f8785de1-ddd8-460b-b1e5-433e12b37e08.png"></p>]]></content>
      
      
      <categories>
          
          <category> 搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shader</title>
      <link href="/2019/09/20/Unity/Shader/"/>
      <url>/2019/09/20/Unity/Shader/</url>
      
        <content type="html"><![CDATA[<h1 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h1><pre><code>normalize() 用来把一个向量，单位化（原来方向保持不变，长度变为1）max() 用来取得函数中最大的一个dot 用来取得两个向量的点积_WorldSpaceLightPos0 取得平行光的位置_LightColor0取得平行光的颜色UNITY_MATRIX_MVP 这个矩阵用来把一个坐标从模型空间转换到剪裁空间_World2Object 这个矩阵用来把一个方向从世界空间转换到模型空间UNITY_LIGHTMODEL_AMBIENT用来获取环境光_WorldSpaceCameraPos可以获得相机的位置</code></pre><h2 id="shader简介"><a href="#shader简介" class="headerlink" title="shader简介"></a>shader简介</h2><h3 id="Mesh-Filter"><a href="#Mesh-Filter" class="headerlink" title="Mesh Filter"></a>Mesh Filter</h3><p> 存储一个Mesh（网格，模型的网格，就是模型的由哪些三角面组成，组成一个什么样子的模型，三角面的一些顶点信息）  </p><h3 id="Mesh-Renderer"><a href="#Mesh-Renderer" class="headerlink" title="Mesh Renderer"></a>Mesh Renderer</h3><p>用来渲染一个模型的外观,就是样子,按照 mesh给它皮肤，给它颜色,通过Material（材质）控制模型渲染的样子</p><h3 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h3><p>贴图(可以没有，可以是一个单纯的颜色)<br>Shader</p><h2 id="OpenGL、DirectX-DX"><a href="#OpenGL、DirectX-DX" class="headerlink" title="OpenGL、DirectX(DX)"></a>OpenGL、DirectX(DX)</h2><p>shader可以认为是一种渲染命令 ，由opengl 或者dx进行解析，来控制渲染丰富多彩的图形  </p><p>OpenGL 使用GLSL 编写shader<br>DirectX 使用HSSL 编写shader<br>英伟达 CG 编写shader（跨平台）</p><h2 id="unity-shader的分类"><a href="#unity-shader的分类" class="headerlink" title="unity shader的分类"></a>unity shader的分类</h2><p>使用的是ShaderLab(对CG进行了封装)编写Unity中的Shader  </p><h3 id="表面着色器Surface-Shader"><a href="#表面着色器Surface-Shader" class="headerlink" title="表面着色器Surface Shader"></a>表面着色器Surface Shader</h3><p>unity独有的着色器  </p><h3 id="顶点-x2F-片元着色器Vertex-x2F-Fragment-Shader"><a href="#顶点-x2F-片元着色器Vertex-x2F-Fragment-Shader" class="headerlink" title="顶点&#x2F;片元着色器Vertex&#x2F;Fragment Shader"></a>顶点&#x2F;片元着色器Vertex&#x2F;Fragment Shader</h3><p>比较基本的着色器，表面着色器对顶点&#x2F;片元着色器进行封装，最后还被解析成顶点片元着色器  </p><h3 id="固定函数着色器Fixed-Function-Shader-已经被弃用"><a href="#固定函数着色器Fixed-Function-Shader-已经被弃用" class="headerlink" title="固定函数着色器Fixed Function Shader(已经被弃用)"></a>固定函数着色器Fixed Function Shader(已经被弃用)</h3><h2 id="创建一个unity-shader"><a href="#创建一个unity-shader" class="headerlink" title="创建一个unity shader"></a>创建一个unity shader</h2><p>基本结构</p><pre><code>Shader &quot;LianBai/01-myshader&quot; //引号内为shader的路径+名字，可以跟文件名字不一样&#123;     Properties//属性（类似于C#脚本中的public属性，通过外界可以调节），一个shader只可以有一个    &#123;        //颜色，变量名字为_Color,面板上显示的名字为MyColor,类型为color,        _Color(&quot;MyColor&quot;,Color) = (1,1,1,1)    &#125;    SubShader//子shader块，可以有很多个，编写渲染的代码。显卡运行效果的时候，从第一个SubShader,如果第一个SubShader中有部分无法实现，就会自动运行下一个SubShader    &#123;        Pass//必须有一个pass块，可以有很多pass块，一个pass块代表的一个方法        &#123;            //编写shader代码 可以用CGPROGRAM 或者HLSLPROGRAM            CGPROGRAM            //使用CG语言编写代码            ENDCG        &#125;    &#125;    Fallback &quot;VertexLit&quot;//当设备发现上面的SubShader都无法执行的时候，就会执行后这个后备方案&#125;</code></pre><h3 id="属性可以有哪些数据类型"><a href="#属性可以有哪些数据类型" class="headerlink" title="属性可以有哪些数据类型"></a>属性可以有哪些数据类型</h3><pre><code>//颜色，变量名字为_Color,面板上显示的名字为MyColor,类型为color,_Color(&quot;MyColor&quot;,Color) = (1,1,1,1)//向量，四维向量,syzw,Color和Vector本质上是一种类型_Vector(&quot;MyVector&quot;,Vector) = (1,2,3,4)//整数_Int(&quot;MyInt&quot;,Int) = 1234//小数_Float(&quot;MyFloat&quot;,Float) = 4.5//范围类型_Range(&quot;MyRange&quot;,Range(1,11)) = 6//图片,当不指定图片的时候，用&quot;red&quot;,可以是其他颜色_2D(&quot;MyTexture&quot;,2D) = &quot;red&quot;&#123;&#125;//立方体纹理,天空盒子可以用到_Cube(&quot;MyCube&quot;,Cube) = &quot;white&quot;&#123;&#125;//3D纹理_3D(&quot;MyTexture&quot;,3D) = &quot;black&quot;&#123;&#125;</code></pre><h3 id="如何使用属性"><a href="#如何使用属性" class="headerlink" title="如何使用属性"></a>如何使用属性</h3><pre><code>float4 _Color;float4 _Vector;float _Int;float _Float;float _Range;sampler2D _2D;samplerCube _Cube;sampler3D _3D;</code></pre><p>float &#x3D; half &#x3D; fixed 都可以代替<br>float 32位存储<br>half 16位存储(-6万 ~ 6万)<br>fixed 11位存储(-2 ~ 2)&#x2F;&#x2F;color一般用fixed存储  </p><h3 id="创建vertex和fragment"><a href="#创建vertex和fragment" class="headerlink" title="创建vertex和fragment"></a>创建vertex和fragment</h3><pre><code>//顶点函数 函数名vert 这里只是声明了顶点函数的函数名//基本作用是 完成顶点坐标从模型空间到剪裁空间的转换（从游戏环境转换到视野相机屏幕上）#pragma vertex vert//片元函数 //基本作用是 返回模型对应的屏幕上的每一个像素的颜色值#pragma fragment frag//返回值和参数都可以不固定 //通过语义告诉系统: POSITION标明要把顶点值传进v、SV_POSITION标明函数返回值是剪裁空间下的顶点坐标float4 vert(float4 v : POSITION) : SV_POSITION&#123;    return UnityObjectToClipPos(v);//把模型空间坐标转换到剪裁空间坐标,UNITY_MATRIX_MVP(4x4矩阵)&#125;float4 frag(): SV_Target&#123;    return fixed4(0.5,0.5,1,1);&#125;</code></pre><h3 id="顶点其他信息"><a href="#顶点其他信息" class="headerlink" title="顶点其他信息"></a>顶点其他信息</h3><pre><code>struct a2v&#123;    float4 vertex : POSITION;    //获取法线    float3 normal : NORMAL;    //纹理坐标0代表第一套纹理坐标，纹理坐标一般0~1    float4 texcoord : TEXCOORD0;&#125;;</code></pre><h3 id="语义总结"><a href="#语义总结" class="headerlink" title="语义总结"></a>语义总结</h3><p><strong>从应用程序传递到顶点函数的语义有哪些a2v</strong></p><pre><code>POSITION 顶点坐标（模型空间下的）NORMAL 法线( 模型空间下)TANGENT 切线（模型空间）TEXCOORD0 ~ｎ　纹理坐标COLOR 顶点颜色</code></pre><p><strong>从顶点函数传递给片元函数的时候可以使用的语义</strong></p><pre><code>SV_POSITION 剪裁空间中的顶点坐标（一般是系统直接使用）COLOR0 可以传递一组值 4个COLOR1 可以传递一组值 4个TEXCOORD0~7 传递纹理坐标</code></pre><p><strong>片元函数传递给系统</strong></p><pre><code>SV_Target 颜色值，显示到屏幕上的颜色</code></pre><h2 id="什么是光照模型"><a href="#什么是光照模型" class="headerlink" title="什么是光照模型"></a>什么是光照模型</h2><p><strong>光照模型就是一个公式，使用这个公式来计算在某个点的光照效果</strong><br><strong>只有定义了正确的LightMode才能得到一些Unity的内置光照变量</strong>  </p><h3 id="标准光照模型"><a href="#标准光照模型" class="headerlink" title="标准光照模型"></a>标准光照模型</h3><p>在标准光照模型里面，我们把进入摄像机的光分为下面四个部分：</p><blockquote><p>自发光<br>高光反射<br>漫反射<br>环境光   </p></blockquote><h3 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h3><blockquote><p>Diffuse &#x3D; 直射光颜色 * max(0,cos夹角(光和法线的夹角) )<br>cosθ &#x3D; 光方向· 法线方向（单位向量的点积）</p></blockquote><pre><code>Shader &quot;LianBai/04-Diffuse&quot;&#123;    SubShader    &#123;        Pass        &#123;            Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;//只有定义了正确的LightMode才能得到一些Unity的内置光照变量            CGPROGRAM#include &quot;Lighting.cginc&quot;//引入定义好的命名空间内的变量            //顶点函数 函数名vert 这里只是声明了顶点函数的函数名            //基本作用是 完成顶点坐标从模型空间到剪裁空间的转换（从游戏环境转换到视野相机屏幕上）#pragma vertex vert            //片元函数             //基本作用是 返回模型对应的屏幕上的每一个像素的颜色值#pragma fragment frag        //返回值和参数都可以不固定         //通过语义告诉系统: POSITION标明要把顶点值传进v、SV_POSITION标明函数返回值是剪裁空间下的顶点坐标            //application to wertex            struct a2v            &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;            &#125;;            struct v2f            &#123;                float4 position : SV_POSITION;                fixed3 color : COLOR0;            &#125;;            v2f vert(a2v v)            &#123;                v2f f;                f.position = UnityObjectToClipPos(v.vertex);//把模型空间坐标转换到剪裁空间坐标,UNITY_MATRIX_MVP(4x4矩阵)                //在Lighting.cginc命名空间下 _LightColor0取得第一个直射光的颜色 _WorldSpaceLightPos0第一个直射光的位置                //dot用于计算点乘  normalize用来把一个向量单位化 _World2Object这个矩阵用来把一个方向从世界空间转换到模型空间                float3 normalDir = normalize(mul(v.normal, (float3x3)unity_WorldToObject));//变量位置交换，就是从模型空间转换到世界空间 float3x3强制把矩阵变成3*3的矩阵                fixed3 lightDir = normalize(_WorldSpaceLightPos0.xyz); //对于每一个点来说光的位置就是光的方向，因为光是平行光                fixed3 diffuse = _LightColor0.rgb * max(0, dot(normalDir, lightDir)); //取得漫反射的颜色                f.color = diffuse;                return f;            &#125;            float4 frag(v2f f) : SV_Target            &#123;                return fixed4(f.color,1);            &#125;            ENDCG        &#125;    &#125;        FallBack &quot;Diffuse&quot;&#125;</code></pre><h3 id="漫反射颜色"><a href="#漫反射颜色" class="headerlink" title="漫反射颜色"></a>漫反射颜色</h3><pre><code>properties&#123;    _DiffuseColor(&quot;MyDiffuseColor&quot;,Color) = (1,1,1,1)&#125;fixed4 _DiffuseColor;fixed3 diffuse = _LightColor0.rgb * max(0, dot(normalDir, lightDir)) * _DiffuseColor.rgb; //把两种颜色融合</code></pre><h3 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h3><pre><code>fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.rgb;//得到系统的环境光f.color = diffuse + ambient;// + 代表颜色叠加</code></pre><h3 id="逐像素漫反射"><a href="#逐像素漫反射" class="headerlink" title="逐像素漫反射"></a>逐像素漫反射</h3><pre><code>Shader &quot;LianBai/05-Diffuse Fragment&quot;&#123;    properties    &#123;        _DiffuseColor(&quot;MyDiffuseColor&quot;,Color) = (1,1,1,1)    &#125;    SubShader    &#123;        Pass        &#123;                        Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;//只有定义了正确的LightMode才能得到一些Unity的内置光照变量            CGPROGRAM#include &quot;Lighting.cginc&quot;//引入定义好的命名空间内的变量            //顶点函数 函数名vert 这里只是声明了顶点函数的函数名            //基本作用是 完成顶点坐标从模型空间到剪裁空间的转换（从游戏环境转换到视野相机屏幕上）#pragma vertex vert            //片元函数             //基本作用是 返回模型对应的屏幕上的每一个像素的颜色值#pragma fragment frag        //返回值和参数都可以不固定         //通过语义告诉系统: POSITION标明要把顶点值传进v、SV_POSITION标明函数返回值是剪裁空间下的顶点坐标            fixed4 _DiffuseColor;            //application to wertex            struct a2v            &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;            &#125;;            struct v2f            &#123;                float4 position : SV_POSITION;                fixed3 worldnormaldir : COLOR0;            &#125;;            v2f vert(a2v v)            &#123;                v2f f;                f.position = UnityObjectToClipPos(v.vertex);//把模型空间坐标转换到剪裁空间坐标,UNITY_MATRIX_MVP(4x4矩阵)                f.worldnormaldir = mul(v.normal, (float3x3)unity_WorldToObject);                return f;            &#125;            float4 frag(v2f f) : SV_Target            &#123;                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.rgb;//得到系统的环境光                //在Lighting.cginc命名空间下 _LightColor0取得第一个直射光的颜色 _WorldSpaceLightPos0第一个直射光的位置                //dot用于计算点乘  normalize用来把一个向量单位化 _World2Object这个矩阵用来把一个方向从世界空间转换到模型空间                float3 normalDir = normalize(f.worldnormaldir);//变量位置交换，就是从模型空间转换到世界空间 float3x3强制把矩阵变成3*3的矩阵                fixed3 lightDir = normalize(_WorldSpaceLightPos0.xyz); //对于每一个点来说光的位置就是光的方向，因为光是平行光                fixed3 diffuse = _LightColor0.rgb * max(0, dot(normalDir, lightDir)) * _DiffuseColor.rgb; //取得漫反射的颜色                fixed3 tempcolor = diffuse + ambient;                return fixed4(tempcolor,1);            &#125;            ENDCG        &#125;    &#125;        FallBack &quot;Diffuse&quot;&#125;</code></pre><h3 id="半兰伯特光照模型"><a href="#半兰伯特光照模型" class="headerlink" title="半兰伯特光照模型"></a>半兰伯特光照模型</h3><pre><code>Diffuse = 直射光颜色 *（ cosθ *0.5 +0.５ ）float halfLambert = dot(normalDir, lightDir) * 0.5 + 0.5;fixed3 diffuse = _LightColor0.rgb * halfLambert * _DiffuseColor.rgb; //取得漫反射的颜色</code></pre><h2 id="高光反射"><a href="#高光反射" class="headerlink" title="高光反射"></a>高光反射</h2><p><strong>Blinn光照模型</strong>   </p><pre><code>Specular(高光反射) =直射光  * pow( max(cosθ,0),高光参数)  θ:是法线和x的夹角  x 是平行光和视野方向的平分线高光参数可以控制高光范围，值越小，范围越大，一般情况是高光参数&gt;=10</code></pre><p><strong>Blinn-Phong光照模型(改进)</strong>  </p><pre><code>Specular=直射光  * pow( max(cosθ,0),10)  θ:是法线和x的夹角  x 是平行光和视野方向的平分线</code></pre><h3 id="高光反射-逐顶点"><a href="#高光反射-逐顶点" class="headerlink" title="高光反射(逐顶点)"></a>高光反射(逐顶点)</h3><pre><code>Shader &quot;LianBai/07-Specular Vertex&quot;&#123;    properties    &#123;        _DiffuseColor(&quot;MyDiffuseColor&quot;,Color) = (1,1,1,1)    &#125;    SubShader    &#123;        Pass        &#123;                        Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;//只有定义了正确的LightMode才能得到一些Unity的内置光照变量            CGPROGRAM#include &quot;Lighting.cginc&quot;//引入定义好的命名空间内的变量            //顶点函数 函数名vert 这里只是声明了顶点函数的函数名            //基本作用是 完成顶点坐标从模型空间到剪裁空间的转换（从游戏环境转换到视野相机屏幕上）#pragma vertex vert            //片元函数             //基本作用是 返回模型对应的屏幕上的每一个像素的颜色值#pragma fragment frag        //返回值和参数都可以不固定         //通过语义告诉系统: POSITION标明要把顶点值传进v、SV_POSITION标明函数返回值是剪裁空间下的顶点坐标            fixed4 _DiffuseColor;            //application to wertex            struct a2v            &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;            &#125;;            struct v2f            &#123;                float4 position : SV_POSITION;                fixed3 color : COLOR0;            &#125;;            v2f vert(a2v v)            &#123;                v2f f;                f.position = UnityObjectToClipPos(v.vertex);//把模型空间坐标转换到剪裁空间坐标,UNITY_MATRIX_MVP(4x4矩阵)                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.rgb;//得到系统的环境光                //在Lighting.cginc命名空间下 _LightColor0取得第一个直射光的颜色 _WorldSpaceLightPos0第一个直射光的位置                //dot用于计算点乘  normalize用来把一个向量单位化 _World2Object这个矩阵用来把一个方向从世界空间转换到模型空间                float3 normalDir = normalize(mul(v.normal, (float3x3)unity_WorldToObject));//变量位置交换，就是从模型空间转换到世界空间 float3x3强制把矩阵变成3*3的矩阵                fixed3 lightDir = normalize(_WorldSpaceLightPos0.xyz); //对于每一个点来说光的位置就是光的方向，因为光是平行光                fixed3 diffuse = _LightColor0.rgb * max(0, dot(normalDir, lightDir)) * _DiffuseColor.rgb; //取得漫反射的颜色                fixed3 reflectDir = normalize(reflect(-lightDir, normalDir));//reflect 用来求反射光方向向量，lightDir是指向平行光的方向，所以需要带符号变成入射方向，                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - mul(v.vertex, unity_WorldToObject).xyz); //_WorldSpaceCameraPos.xyz相机的位置，                fixed3 specular = _LightColor0.rgb * pow(max(0, dot(reflectDir, viewDir)), 10);                f.color = diffuse + ambient + specular;                return f;            &#125;            float4 frag(v2f f) : SV_Target            &#123;                return fixed4(f.color,1);            &#125;            ENDCG        &#125;    &#125;        FallBack &quot;Diffuse&quot;&#125;</code></pre><h3 id="高光反射-逐像素"><a href="#高光反射-逐像素" class="headerlink" title="高光反射(逐像素)"></a>高光反射(逐像素)</h3><pre><code>Shader &quot;LianBai/08-Specular Fragment&quot;&#123;    properties    &#123;        _DiffuseColor(&quot;MyDiffuseColor&quot;,Color) = (1,1,1,1)        _Gloss(&quot;MyGloss&quot;,Range(8,200)) = 10        _SpecularColor(&quot;MySpecularColor&quot;,Color) = (1,1,1,1)    &#125;    SubShader    &#123;        Pass        &#123;                        Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;//只有定义了正确的LightMode才能得到一些Unity的内置光照变量            CGPROGRAM#include &quot;Lighting.cginc&quot;//引入定义好的命名空间内的变量            //顶点函数 函数名vert 这里只是声明了顶点函数的函数名            //基本作用是 完成顶点坐标从模型空间到剪裁空间的转换（从游戏环境转换到视野相机屏幕上）#pragma vertex vert            //片元函数             //基本作用是 返回模型对应的屏幕上的每一个像素的颜色值#pragma fragment frag        //返回值和参数都可以不固定         //通过语义告诉系统: POSITION标明要把顶点值传进v、SV_POSITION标明函数返回值是剪裁空间下的顶点坐标            fixed4 _DiffuseColor;            fixed4 _SpecularColor;            half _Gloss;            //application to wertex            struct a2v            &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;            &#125;;            struct v2f            &#123;                float4 position : SV_POSITION;                float3 worldnormal : TEXCOORD0;                float3 worldvertex : TEXCOORD1;            &#125;;            v2f vert(a2v v)            &#123;                v2f f;                f.position = UnityObjectToClipPos(v.vertex);//把模型空间坐标转换到剪裁空间坐标,UNITY_MATRIX_MVP(4x4矩阵)                f.worldnormal = mul(v.normal, (float3x3)unity_WorldToObject);                f.worldvertex = mul(v.vertex, unity_WorldToObject).xyz;                return f;            &#125;            float4 frag(v2f f) : SV_Target            &#123;                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.rgb;//得到系统的环境光                //在Lighting.cginc命名空间下 _LightColor0取得第一个直射光的颜色 _WorldSpaceLightPos0第一个直射光的位置                //dot用于计算点乘  normalize用来把一个向量单位化 _World2Object这个矩阵用来把一个方向从世界空间转换到模型空间                float3 normalDir = normalize(f.worldnormal);//变量位置交换，就是从模型空间转换到世界空间 float3x3强制把矩阵变成3*3的矩阵                fixed3 lightDir = normalize(_WorldSpaceLightPos0.xyz); //对于每一个点来说光的位置就是光的方向，因为光是平行光                fixed3 diffuse = _LightColor0.rgb * max(0, dot(normalDir, lightDir)) * _DiffuseColor.rgb; //取得漫反射的颜色                fixed3 reflectDir = normalize(reflect(-lightDir, normalDir));//reflect 用来求反射光方向向量，lightDir是指向平行光的方向，所以需要带符号变成入射方向，                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - f.worldvertex); //_WorldSpaceCameraPos.xyz相机的位置，                fixed3 specular = _LightColor0.rgb * pow(max(0, dot(reflectDir, viewDir)), _Gloss) * _SpecularColor.rgb;                fixed3 tempcolor = diffuse + ambient + specular;                return fixed4(tempcolor,1);            &#125;            ENDCG        &#125;    &#125;        FallBack &quot;Diffuse&quot;&#125;</code></pre><h2 id="unity内置函数"><a href="#unity内置函数" class="headerlink" title="unity内置函数"></a>unity内置函数</h2><pre><code>//摄像机方向（视角方向）float3 WorldSpaceViewDir(float4 v)  根据模型空间中的顶点坐标 得到 （世界空间）从这个点到摄像机的观察方向float3 UnityWorldSpaceViewDir(float4 v) 世界空间中的顶点坐标==》世界空间从这个点到摄像机的观察方向float3 ObjSpaceViewDir(float4 v) 模型空间中的顶点坐标==》模型空间从这个点到摄像机的观察方向//光源方向float3 WorldSpaceLightDir(float4 v) 模型空间中的顶点坐标==》世界空间中从这个点到光源的方向float3 UnityWorldSpaceLightDir(float4 v) 世界空间中的顶点坐标==》世界空间中从这个点到光源的方向float3 ObjSpaceLightDir(float4 v) 模型空间中的顶点坐标==》模型空间中从这个点到光源的方向//方向转换float3 UnityObjectToWorldNormal(float3 norm) 把法线方向 模型空间==》世界空间float3 UnityObjectToWorldDir(float3 dir) 把方向 模型空间=》世界空间float3 UnityWorldToObjectDir(float3 dir) 把方向 世界空间=》模型空间</code></pre><h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><p><strong>使用纹理的颜色代替漫反射的颜色(需要逐像素，这样三角形内不会出现偏差)</strong>  </p><blockquote><p>纹理坐标只能在顶点函数里取到，所以需要传递  </p></blockquote><p><strong>在使用纹理的时候，环境光与纹理颜色做一个融合比较好一点</strong>   </p><pre><code>fixed3 tempcolor = diffuse + specular + UNITY_LIGHTMODEL_AMBIENT.rgb * texColor;</code></pre><p><strong>示例脚本</strong>  </p><pre><code>Shader &quot;LianBai/11-Single Texture&quot;&#123;    Properties    &#123;        //_DiffuseColor(&quot;MyDiffuseColor&quot;,Color) = (1,1,1,1)        _TexColor(&quot;MyTexColor&quot;,Color) = (1,1,1,1)        _MainTex(&quot;MyMainTex&quot;,2D) = &quot;white&quot;&#123;&#125;        _SpecularColor(&quot;MySpecularColor&quot;,Color) = (1,1,1,1)        _Gloss(&quot;MyGloss&quot;,Range(10,200)) = 20    &#125;        SubShader        &#123;            Pass            &#123;                Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;                CGPROGRAM    #include &quot;Lighting.cginc&quot;    #pragma vertex vert    #pragma fragment frag            //float4 _DiffuseColor;            fixed4 _TexColor;            sampler2D _MainTex;            float4 _SpecularColor;            float _Gloss;            struct a2v            &#123;                float4 vertex : POSITION;                float4 normal : NORMAL;                float4 texcoord :TEXCOORD0;//得到纹理坐标            &#125;;            struct v2f            &#123;                float4 svPos : SV_POSITION;                float3 worldnormal : TEXCOORD0;                float4 worldvertex : TEXCOORD1;                float4 uv:TEXCOORD2;            &#125;;            v2f vert(a2v v)            &#123;                v2f f;                f.svPos = UnityObjectToClipPos(v.vertex);                f.worldnormal = UnityObjectToWorldNormal(v.normal);                f.worldvertex = mul(v.vertex, unity_WorldToObject);                f.uv = v.texcoord;                return f;            &#125;            fixed4 frag(v2f f) : SV_Target            &#123;                fixed3 normalDir = normalize(f.worldnormal);                fixed3 lightDir = normalize(WorldSpaceLightDir(f.worldvertex));                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(f.worldvertex));                fixed3 halfDir = normalize(viewDir + lightDir);                fixed3 texColor = tex2D(_MainTex, f.uv.xy) * _TexColor;//的到纹理上的颜色tex()                fixed3 diffuse = _LightColor0.rgb * texColor * max(0,dot(normalDir,lightDir));                fixed3 specular = _LightColor0.rgb * _SpecularColor.rgb * pow(max(0,dot(normalDir, halfDir)),_Gloss);                fixed3 tempcolor = diffuse + specular + UNITY_LIGHTMODEL_AMBIENT.rgb * texColor;                return fixed4(tempcolor,1);            &#125;            ENDCG        &#125;    &#125;    FallBack &quot;Diffuse&quot;&#125;</code></pre><h3 id="给纹理添加便宜和缩放"><a href="#给纹理添加便宜和缩放" class="headerlink" title="给纹理添加便宜和缩放"></a>给纹理添加便宜和缩放</h3><blockquote><p>Offset:控制材质的偏移<br>Tiling:图片的压缩倍数  </p></blockquote><p><strong>固定的，必须是：纹理的名字_ST</strong>  </p><pre><code>float4 _MainTex_ST;</code></pre><p><strong>示例脚本</strong>  </p><pre><code>f.uv = v.texcoord.xy *_MainTex_ST.xy + _MainTex_ST.zw;//xy是缩放，zw是偏移</code></pre><h2 id="凹凸映射和法线映射"><a href="#凹凸映射和法线映射" class="headerlink" title="凹凸映射和法线映射"></a>凹凸映射和法线映射</h2><h3 id="基础-示例脚本"><a href="#基础-示例脚本" class="headerlink" title="基础+示例脚本"></a>基础+示例脚本</h3><pre><code>pixel = (normal+1)/2normal = pixel*2 - 1</code></pre><blockquote><p>把所有跟法线方向有关的运算都放在切线空间下<br>因为从法线贴图里面取得的法线方向是在切线空间下的  </p></blockquote><pre><code>Shader &quot;LianBai/13-Rock NormalMap&quot;&#123;    Properties    &#123;        //_DiffuseColor(&quot;MyDiffuseColor&quot;,Color) = (1,1,1,1)        _TexColor(&quot;MyTexColor&quot;,Color) = (1,1,1,1)        _MainTex(&quot;MyMainTex&quot;,2D) = &quot;white&quot;&#123;&#125;        _NorMap(&quot;MyNormap&quot;,2D) = &quot;bump&quot;&#123;&#125;    &#125;    SubShader    &#123;        Pass        &#123;            Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;            CGPROGRAM#include &quot;Lighting.cginc&quot;#pragma vertex vert#pragma fragment frag            //float4 _DiffuseColor;            fixed4 _TexColor;            sampler2D _MainTex;            float4 _MainTex_ST;//固定的，必须是：纹理的名字_ST            sampler2D _NorMap;            float4 _NorMap_ST;            struct a2v            &#123;                float4 vertex : POSITION;                float3 normal : NORMAL;//切线空间的确定是通过(存储到模型里面的)法线和(存储到模型里面的)切线确定的                float4 tangent : TANGENT;//tangent.w是用来确定切线空间中坐标轴方向的                float4 texcoord :TEXCOORD0;//得到纹理坐标            &#125;;            struct v2f            &#123;                float4 svPos : SV_POSITION;                //float3 worldnormal : TEXCOORD0;                float3 lightDir : TEXCOORD0;//切线空间下平行光的方向                float4 worldvertex : TEXCOORD1;                float4 uv : TEXCOORD2;//xy用来存储maintex zw用来存储法线贴图的纹理            &#125;;            v2f vert(a2v v)            &#123;                v2f f;                f.svPos = UnityObjectToClipPos(v.vertex);                //f.worldnormal = UnityObjectToWorldNormal(v.normal);                f.worldvertex = mul(v.vertex, unity_WorldToObject);                f.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;//xy是缩放，zw是偏移                f.uv.zw = v.texcoord.xy * _NorMap_ST.xy + _NorMap_ST.zw;                TANGENT_SPACE_ROTATION;//调用这个宏之后会得到一个矩阵 rotation 用来把模型空间下的方向转换成切线空间下                /*float3 binormal = cross(v.normal, v.tangent.xyz) * v.tangent.w;                float3x3 rotation = float3x3(v.tangent.xyz, binormal, v.normal);*/                //ObjSpaceLightDir(v.vertex);//得到模型空间下的平行光的方向                f.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex));                return f;            &#125;            //把所有跟法线方向有关的运算都放在切线空间下            //因为从法线贴图里面取得的法线方向是在切线空间下的            fixed4 frag(v2f f) : SV_Target            &#123;                //fixed3 normalDir = normalize(f.worldnormal);                fixed4 normalcolor = tex2D(_NorMap,f.uv.zw);                //fixed3 tangentNormal = normalize(normalcolor.xyz * 2 - 1);                fixed3 tangentNormal = UnpackNormal(normalcolor);                tangentNormal = normalize(tangentNormal);                fixed3 lightDir = normalize(f.lightDir);                fixed3 texColor = tex2D(_MainTex, f.uv.xy) * _TexColor;//的到纹理上的颜色tex()                fixed3 diffuse = _LightColor0.rgb * texColor * max(0,dot(tangentNormal,lightDir));                fixed3 tempcolor = diffuse + UNITY_LIGHTMODEL_AMBIENT.rgb * texColor;                return fixed4(tempcolor,1);            &#125;            ENDCG        &#125;    &#125;    FallBack &quot;Diffuse&quot;&#125;</code></pre><h3 id="凹凸映射和法线映射添加参数"><a href="#凹凸映射和法线映射添加参数" class="headerlink" title="凹凸映射和法线映射添加参数"></a>凹凸映射和法线映射添加参数</h3><p><strong>切线空间的z轴是和原来法线方向是一致的</strong>  </p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA学习笔记</title>
      <link href="/2018/08/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/08/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>参考文献：**<a href="http://www.runoob.com/java/java-tutorial.html"><font color="steelblue" size="3">菜鸟教程</font></a>**</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><pre><code>1.系统：Ubnuto18.04(桌面版)2.环境：JDK10.0.23.有一定的C/C++编程基础</code></pre><h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><ul><li><p>从**<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html"><font color="steelblue" size="3">官网</font></a>**或者其他网站下载JDK<br><img src="https://i.imgur.com/9MpwXvL.png">  </p></li><li><p>下载后解压到自己指定的目录</p></li><li><p>解压后在解压包所在的文件夹打开终端命令，输入sudo gedit ~&#x2F;.bashrc,必须在当前用户下执行，不需要打开管理员权限，执行后会打开一个文件夹<br><img src="https://i.imgur.com/pwgMNpY.png"></p></li><li><p>打开文件后在文件最后加入以下文字  </p><blockquote><p>JAVA_HOME&#x3D;jdk10.0.2<br>JRE_HOME&#x3D;${JAVA_HOME}&#x2F;jre<br>CLASSPATH&#x3D;${JAVA_HOME}&#x2F;lib: ${JRE_HOME}&#x2F;lib<br>PATH&#x3D;${JAVA_HOME}&#x2F;bin: ${JRE_HOME}&#x2F;bin:$PATH<br>export JAVA_HOME JRE_HOME CLASSPATH PATH</p></blockquote></li></ul><p><img src="https://i.imgur.com/ONaL4JW.png">  </p><ul><li>保存后退出，然后在终端上输入source .bashrc即可</li><li>在终端上输入java -version即可看到安装包信息</li></ul><p><img src="https://i.imgur.com/hmoLoLU.png"></p><h1 id="JAVA基础教程"><a href="#JAVA基础教程" class="headerlink" title="JAVA基础教程"></a>JAVA基础教程</h1><h2 id="JAVA基础教程-1"><a href="#JAVA基础教程-1" class="headerlink" title="JAVA基础教程"></a>JAVA基础教程</h2><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h3><p>1.创建一个文件（作者文件名字Test_001.java）,文件类型为.java<br>2.编辑文件，在文件内写入下列脚本  </p><pre><code>public class Test_001 &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;Hello World&quot;);    &#125;&#125;</code></pre><p>3.在脚本文件页面打开终端执如下图输入javac Test_001.java和java Test_001即可<br><img src="https://i.imgur.com/urJ1IX9.png"></p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>脚本如下  </p><pre><code>public class Test_001 &#123;    enum MyEnum&#123;One,Two,Three&#125;public static void main(String[] args) &#123;    System.out.println(&quot;Hello World&quot;);    System.out.println(MyEnum.One);    &#125;&#125;</code></pre><p>运行结果如下<br><img src="https://i.imgur.com/qG1Raui.png"></p><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p><strong>JAVA源文件规则</strong>  </p><blockquote><ul><li>一个源文件中只能有一个public类  </li><li>一个源文件可以有多个非public类  </li><li>源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。  </li><li>如果一个类定义在某个包中，那么package语句应该在源文件的首行。  </li><li>如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。  </li><li>import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li></ul></blockquote><p><strong>包和Import</strong><br>包主要用来对类和接口进行分类。当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。<br>在Java中，如果给出一个完整的限定名，包括包名、类名，那么Java编译器就可以很容易地定位到源代码或者类。Import语句就是用来提供一个合理的路径，使得编译器可以找到某个类。<br>import java.io.* 导入项目根目录下所有的包</p><p>Tset_002脚本  </p><pre><code>import java.io.*;public class Test_002&#123;    public static void main(String[] args)    &#123;        People peo=new People(1615925241,&quot;lianbai&quot;,&quot;man&quot;);        peo.ShowPeople();    &#125;&#125;</code></pre><p>People脚本</p><pre><code>public class People&#123;    int Id;    String Name;    String Sex;    public People(int id,String name,String sex)    &#123;        this.Id=id;        this.Name=name;        this.Sex=sex;    &#125;    public void ShowPeople()    &#123;        System.out.println(&quot;Id:&quot;+Id);        System.out.println(&quot;Name:&quot;+Name);        System.out.println(&quot;Sex:&quot;+Sex);    &#125;&#125;</code></pre><p>运行结果如下<br><img src="https://i.imgur.com/TQOXTPB.png"></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><strong>内置数据类型</strong><br>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。  </p><pre><code>byte：byte 数据类型是8位、有符号的，以二进制补码表示的整数；最小值是 -128（-2^7）；最大值是 127（2^7-1）；默认值是 0；byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；例子：byte a = 100，byte b = -50。short：short 数据类型是 16 位、有符号的以二进制补码表示的整数最小值是 -32768（-2^15）；最大值是 32767（2^15 - 1）；Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；默认值是 0；例子：short s = 1000，short r = -20000。int：int 数据类型是32位、有符号的以二进制补码表示的整数；最小值是 -2,147,483,648（-2^31）；最大值是 2,147,483,647（2^31 - 1）；一般地整型变量默认为 int 类型；默认值是 0 ；例子：int a = 100000, int b = -200000。long：long 数据类型是 64 位、有符号的以二进制补码表示的整数；最小值是 -9,223,372,036,854,775,808（-2^63）；最大值是 9,223,372,036,854,775,807（2^63 -1）；这种类型主要使用在需要比较大整数的系统上；默认值是 0L；例子： long a = 100000L，Long b = -200000L。&quot;L&quot;理论上不分大小写，但是若写成&quot;l&quot;容易与数字&quot;1&quot;混淆，不容易分辩。所以最好大写。float：float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；float 在储存大型浮点数组的时候可节省内存空间；默认值是 0.0f；浮点数不能用来表示精确的值，如货币；例子：float f1 = 234.5f。double：double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；浮点数的默认类型为double类型；double类型同样不能表示精确的值，如货币；默认值是 0.0d；例子：double d1 = 123.4。boolean：boolean数据类型表示一位的信息；只有两个取值：true 和 false；这种类型只作为一种标志来记录 true/false 情况；默认值是 false；例子：boolean one = true。char：char类型是一个单一的 16 位 Unicode 字符；最小值是 \u0000（即为0）；最大值是 \uffff（即为65,535）；char 数据类型可以储存任何字符；例子：char letter = &#39;A&#39;;。</code></pre><p><strong>脚本代码</strong> </p><pre><code>public class Test&#123;    public static void main(String[] args)     &#123;          // byte          System.out.println(&quot;基本类型：byte 二进制位数：&quot; + Byte.SIZE);          System.out.println(&quot;包装类：java.lang.Byte&quot;);          System.out.println(&quot;最小值：Byte.MIN_VALUE=&quot; + Byte.MIN_VALUE);          System.out.println(&quot;最大值：Byte.MAX_VALUE=&quot; + Byte.MAX_VALUE);          System.out.println();                // short          System.out.println(&quot;基本类型：short 二进制位数：&quot; + Short.SIZE);          System.out.println(&quot;包装类：java.lang.Short&quot;);          System.out.println(&quot;最小值：Short.MIN_VALUE=&quot; + Short.MIN_VALUE);          System.out.println(&quot;最大值：Short.MAX_VALUE=&quot; + Short.MAX_VALUE);          System.out.println();                // int          System.out.println(&quot;基本类型：int 二进制位数：&quot; + Integer.SIZE);          System.out.println(&quot;包装类：java.lang.Integer&quot;);          System.out.println(&quot;最小值：Integer.MIN_VALUE=&quot; + Integer.MIN_VALUE);          System.out.println(&quot;最大值：Integer.MAX_VALUE=&quot; + Integer.MAX_VALUE);          System.out.println();                // long          System.out.println(&quot;基本类型：long 二进制位数：&quot; + Long.SIZE);          System.out.println(&quot;包装类：java.lang.Long&quot;);          System.out.println(&quot;最小值：Long.MIN_VALUE=&quot; + Long.MIN_VALUE);          System.out.println(&quot;最大值：Long.MAX_VALUE=&quot; + Long.MAX_VALUE);          System.out.println();                // float          System.out.println(&quot;基本类型：float 二进制位数：&quot; + Float.SIZE);          System.out.println(&quot;包装类：java.lang.Float&quot;);          System.out.println(&quot;最小值：Float.MIN_VALUE=&quot; + Float.MIN_VALUE);          System.out.println(&quot;最大值：Float.MAX_VALUE=&quot; + Float.MAX_VALUE);          System.out.println();                // double          System.out.println(&quot;基本类型：double 二进制位数：&quot; + Double.SIZE);          System.out.println(&quot;包装类：java.lang.Double&quot;);          System.out.println(&quot;最小值：Double.MIN_VALUE=&quot; + Double.MIN_VALUE);          System.out.println(&quot;最大值：Double.MAX_VALUE=&quot; + Double.MAX_VALUE);          System.out.println();                // char          System.out.println(&quot;基本类型：char 二进制位数：&quot; + Character.SIZE);          System.out.println(&quot;包装类：java.lang.Character&quot;);          // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台          System.out.println(&quot;最小值：Character.MIN_VALUE=&quot;                  + (int) Character.MIN_VALUE);          // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台          System.out.println(&quot;最大值：Character.MAX_VALUE=&quot;  + (int) Character.MAX_VALUE);      &#125;  &#125;</code></pre><p><strong>输出结果</strong><br><img src="https://i.imgur.com/3APpPIo.png"><br>自动转换类型的层级由低到高为：  </p><pre><code>byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double</code></pre><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p><strong>静态变量</strong>   </p><blockquote><p>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。<br><strong>静态方法</strong><br>static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据<br>对类变量和方法的访问可以直接使用 classname.variablename 和 classname.methodname 的方式访问。</p></blockquote><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p><strong>变量</strong>  </p><blockquote><p>final 变量能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。<br>final 修饰符通常和 static 修饰符一起使用来创建类常量  </p></blockquote><p><strong>方法</strong>  </p><blockquote><p>类中的 final 方法可以被子类继承，但是不能被子类修改。<br>声明 final 方法的主要目的是防止该方法的内容被修改。  </p></blockquote><p><strong>类</strong>  </p><blockquote><p>final 类不能被继承，没有类能够继承 final 类的任何特性。  </p></blockquote><h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p><strong>类</strong><br>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。<br>一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。<br>抽象类可以包含抽象方法和非抽象方法。<br><strong>方法</strong><br>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。<br>抽象方法不能被声明成 final 和 static。<br>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。<br>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。<br>抽象方法的声明以分号结尾，例如：public abstract sample();<br>脚本如下  </p><pre><code>class Static&#123;    static int a=99;    static void Show()    &#123;        System.out.println(&quot;This is Static&quot;);    &#125;&#125;abstract class People&#123;    protected String Name;    public abstract void Show();&#125;class Student extends People&#123;    protected String Grade;    public void SetInformation(String name,String grade)    &#123;        this.Name=name;        this.Grade=grade;    &#125;    public void Show()    &#123;        System.out.println(&quot;My name is &quot;+Name);        System.out.println(&quot;My grade is &quot;+Grade);    &#125;&#125;public class Test&#123;    public static void main(String[] agr)    &#123;        final int a=66;        System.out.println(Static.a);        Static.Show();        //a=Static.a;//最终会报错,final修饰的变量不可被修改        Student stu=new Student();        stu.SetInformation(&quot;LianBai&quot;,&quot;One&quot;);        stu.Show();    &#125;&#125;</code></pre><p>运行结果如下<br><img src="https://i.imgur.com/YN93AbE.png">  </p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。  </p><pre><code>public synchronized 函数返回类型 函数名(参数)&#123;    函数主题&#125;</code></pre><h3 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h3><p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。<br>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。  </p><pre><code>public transient 变量类型 变量名 = 变量值;   // 不会持久化public 变量类型 变量名; // 持久化</code></pre><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。<br>一个 volatile 对象引用可能是 null。  </p><pre><code>public class MyRunnable implements Runnable&#123;    private volatile boolean active;    public void run()    &#123;        active = true;        while (active) // 第一行        &#123;            // 代码        &#125;    &#125;    public void stop()    &#123;        active = false; // 第二行    &#125;&#125;</code></pre><p>通常情况下，在一个线程调用run()方法（在Runnable开启的线程，在另一个线程调用 stop() 方法。如果第一行中缓冲区的active值被使用，那么在第二行的active值为false时循环不会停止。<br>但是以上代码中我们使用了 volatile 修饰 active，所以该循环会停止  </p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>位运算符  </p><pre><code>A = 0011 1100B = 0000 1101-----------------A&amp;b = 0000 1100A | B = 0011 1101A ^ B = 0011 0001~A= 1100 0011</code></pre><p>脚本如下  </p><pre><code>class Type&#123;&#125;public class Test&#123;    public static void main(String arg[])    &#123;        int a=40;        int b=30;        int c=20;        boolean T=true;        boolean F=false;        //算术运算符        System.out.println(a+&quot;+&quot;+b+&quot;=&quot;+(a+b));        System.out.println(a+&quot;-&quot;+b+&quot;=&quot;+(a-b));        System.out.println(a+&quot;*&quot;+b+&quot;=&quot;+(a*b));        System.out.println(a+&quot;/&quot;+b+&quot;=&quot;+(a/b));        System.out.println(a+&quot;%&quot;+b+&quot;=&quot;+(a%b));        System.out.println(a+&quot;%&quot;+c+&quot;=&quot;+(a%c));        System.out.println(a+&quot;++&quot;+&quot;=&quot;+(a++));        System.out.println(&quot;++&quot;+a+&quot;=&quot;+(++a));        //关系运算符        System.out.println(&quot;a == b = &quot; + (a == b) );         System.out.println(&quot;a != b = &quot; + (a != b) );         System.out.println(&quot;a &gt; b = &quot; + (a &gt; b) );         System.out.println(&quot;a &lt; b = &quot; + (a &lt; b) );         System.out.println(&quot;b &gt;= a = &quot; + (b &gt;= a) );         System.out.println(&quot;b &lt;= a = &quot; + (b &lt;= a) );        //逻辑运算符        System.out.println(&quot;T &amp;&amp; F = &quot; + (T&amp;&amp;F));         System.out.println(&quot;T || F = &quot; + (T||F) );         System.out.println(&quot;!(T &amp;&amp; F) = &quot; + !(T&amp;&amp;F));        a = 5;//定义一个变量；        boolean d = (a&lt;4)&amp;&amp;(a++&lt;10);        System.out.println(&quot;使用短路逻辑运算符的结果为&quot;+d);        System.out.println(&quot;a的结果为&quot;+a);        //条件运算符        a = 10;          b = (a == 1) ? 20 : 30;// 如果 a 等于 1 成立，则设置 b 为 20，否则为 30          System.out.println( &quot;Value of b is : &quot; +  b );          b = (a == 10) ? 20 : 30;// 如果 a 等于 10 成立，则设置 b 为 20，否则为 30          System.out.println( &quot;Value of b is : &quot; + b );        //instanceof该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。        Type t=new Type();        boolean res=t instanceof Type;        System.out.println(res);    &#125;&#125;</code></pre><p>结果如下<br><img src="https://i.imgur.com/bzxDN0Z.png">  </p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>脚本如下  </p><pre><code>class Loop&#123;    public void ForLoop()    &#123;        for(int i=1;i&lt;10;i++)        &#123;            for(int j=1;j&lt;i+1;j++)                System.out.print(i+&quot;*&quot;+j+&quot;=&quot;+i*j+&quot;\t&quot;);            System.out.println();        &#125;    &#125;    public void StrengthenForLoop()    &#123;        int[] number=&#123;1,2,3,4,5&#125;;        String[] name=&#123;&quot;One&quot;,&quot;Two&quot;,&quot;Three&quot;&#125;;        for(String c:name)        &#123;            for(int i:number)            &#123;                if(i==3)                    break;                System.out.print(i+&quot;\t&quot;);            &#125;            System.out.println(c);        &#125;        System.out.println(&quot;--------------------------------&quot;);        for(String c:name)        &#123;            for(int i:number)            &#123;                if(i==3)                    continue;                System.out.print(i+&quot;\t&quot;);            &#125;            System.out.println(c);        &#125;    &#125;    public void WhileLoop()    &#123;        int i=1;        while(i&lt;10)        &#123;            int j=1;            while(j&lt;i+1)            &#123;                System.out.print(i+&quot;*&quot;+j+&quot;=&quot;+i*j+&quot;\t&quot;);                j++;            &#125;            System.out.println();            i++;        &#125;    &#125;    public void DoWhileLoop()    &#123;        int i=1;        do        &#123;            int j=1;            do            &#123;                System.out.print(i+&quot;*&quot;+j+&quot;=&quot;+i*j+&quot;\t&quot;);                j++;            &#125;while(j&lt;i+1);            System.out.println();            i++;        &#125;while(i&lt;10);    &#125;&#125;public class Test&#123;    public static void main(String[] arg)    &#123;        Loop l=new Loop();        l.ForLoop();        l.WhileLoop();        l.DoWhileLoop();        l.StrengthenForLoop();    &#125;&#125;</code></pre><p>运行结果如下<br><img src="https://i.imgur.com/F4kfpvs.png">  </p><h2 id="分支语句（if-switch）"><a href="#分支语句（if-switch）" class="headerlink" title="分支语句（if,switch）"></a>分支语句（if,switch）</h2><p>脚本如下  </p><pre><code>class Branch&#123;    public void IfFrame(int achieve)    &#123;        if(achieve==100)        &#123;            System.out.println(&quot;You got full marks&quot;);        &#125;        else if(achieve&gt;=90&amp;&amp;achieve&lt;100)        &#123;            System.out.println(&quot;You got excellent&quot;);        &#125;        else if(achieve&gt;=80&amp;&amp;achieve&lt;90)            System.out.println(&quot;You got good&quot;);        else if(achieve&gt;=60&amp;&amp;achieve&lt;80)            System.out.println(&quot;You got pass&quot;);        else            System.out.println(&quot;You got file&quot;);    &#125;    public void SwitchFrame(String achieve)    &#123;        switch(achieve)        &#123;            case &quot;a&quot;:;            case &quot;A&quot;:System.out.println(&quot;You got full marks&quot;);break;            case &quot;b&quot;:;            case &quot;B&quot;:System.out.println(&quot;You got excellent&quot;);;break;            case &quot;c&quot;:;            case &quot;C&quot;:System.out.println(&quot;You got good&quot;);break;            default:System.out.println(&quot;You got file&quot;);break;        &#125;    &#125;&#125;public class Test&#123;    public static void main(String[] arg)    &#123;        Branch bran=new Branch();        bran.IfFrame(95);        bran.IfFrame(85);        bran.IfFrame(75);        bran.IfFrame(55);        bran.SwitchFrame(&quot;a&quot;);        bran.SwitchFrame(&quot;A&quot;);        bran.SwitchFrame(&quot;b&quot;);        bran.SwitchFrame(&quot;B&quot;);        bran.SwitchFrame(&quot;C&quot;);        bran.SwitchFrame(&quot;D&quot;);    &#125;&#125;</code></pre><p>运行结果如下<br><img src="https://i.imgur.com/l7BQoyV.png"><br><strong>Switch规则</strong>  </p><blockquote><p>switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串类型了，同时 case 标签必须为字符串常量或字面量。<br>switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。<br>case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。<br>当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。<br>当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直&gt;到出现 break 语句。<br>switch 语句可以包含一个 default 分支，该分支必须是 switch 语句的最后一个分支。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。  </p></blockquote><h2 id="Number-amp-amp-Math"><a href="#Number-amp-amp-Math" class="headerlink" title="Number&amp;&amp;Math"></a>Number&amp;&amp;Math</h2><p><strong>Number</strong><br>在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问题，Java 语言为每一个内置数据类型提供了对应的包装类。<br>所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。<br><img src="https://i.imgur.com/QGXxQsk.png"><br><strong>Number&amp;&amp;Math方法</strong>  </p><table><thead><tr><th align="left">名字</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">xxxValue()</td><td align="left">将 Number 对象转换为xxx数据类型的值并返回。</td></tr><tr><td align="left">compareTo()</td><td align="left">将number对象与参数比较。</td></tr><tr><td align="left">equals()</td><td align="left">判断number对象是否与参数相等。</td></tr><tr><td align="left">valueOf()</td><td align="left">返回一个 Number 对象指定的内置数据类型</td></tr><tr><td align="left">toString()</td><td align="left">以字符串形式返回值</td></tr><tr><td align="left">parseInt()</td><td align="left">将字符串解析为int类型。</td></tr><tr><td align="left">abs()</td><td align="left">返回参数的绝对值。</td></tr><tr><td align="left">ceil()</td><td align="left">返回大于等于( &gt;&#x3D; )给定参数的的最小整数。</td></tr><tr><td align="left">floor()</td><td align="left">返回小于等于（&lt;&#x3D;）给定参数的最大整数 。</td></tr><tr><td align="left">rint()</td><td align="left">返回与参数最接近的整数。返回类型为double。</td></tr><tr><td align="left">round()</td><td align="left">它表示四舍五入，算法为 Math.floor(x+0.5)，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11。</td></tr><tr><td align="left">min()</td><td align="left">返回两个参数中的最小值</td></tr><tr><td align="left">max()</td><td align="left">返回两个参数中的最大值</td></tr><tr><td align="left">exp()</td><td align="left">返回自然数底数e的参数次方。</td></tr><tr><td align="left">log()</td><td align="left">返回参数的自然数底数的对数值。</td></tr><tr><td align="left">pow()</td><td align="left">返回第一个参数的第二个参数次方。</td></tr><tr><td align="left">sqrt()</td><td align="left">求参数的算术平方根</td></tr><tr><td align="left">sin()</td><td align="left">求指定double类型参数的正弦值。</td></tr><tr><td align="left">cos()</td><td align="left">求指定double类型参数的余弦值。</td></tr><tr><td align="left">tan()</td><td align="left">求指定double类型参数的正切值。</td></tr><tr><td align="left">asin()</td><td align="left">求指定double类型参数的反正弦值。</td></tr><tr><td align="left">acos()</td><td align="left">求指定double类型参数的反余弦值。</td></tr><tr><td align="left">atan()</td><td align="left">求指定double类型参数的反正切值。</td></tr><tr><td align="left">atan2()</td><td align="left">将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。</td></tr><tr><td align="left">toDegrees()</td><td align="left">将参数转化为角度。</td></tr><tr><td align="left">toRadians()</td><td align="left">将角度转换为弧度。</td></tr><tr><td align="left">random()</td><td align="left">返回一个随机数。</td></tr></tbody></table><p>脚本如下  </p><pre><code>class NumberValue&#123;    public void TestNumber()    &#123;    &#125;    public void TestMath()    &#123;        System.out.println(&quot;90 度的正弦值：&quot; + Math.sin(Math.PI/2));          System.out.println(&quot;0度的余弦值：&quot; + Math.cos(0));          System.out.println(&quot;60度的正切值：&quot; + Math.tan(Math.PI/3));          System.out.println(&quot;1的反正切值： &quot; + Math.atan(1));          System.out.println(&quot;π/2的角度值：&quot; + Math.toDegrees(Math.PI/2));          System.out.println(Math.PI);    &#125;    public void TestMath(double num)    &#123;        System.out.println(&quot;Math.floor(&quot; + num + &quot;)=&quot; + Math.floor(num));               System.out.println(&quot;Math.round(&quot; + num + &quot;)=&quot; + Math.round(num));               System.out.println(&quot;Math.ceil(&quot; + num + &quot;)=&quot; + Math.ceil(num));     &#125;&#125;public class Test&#123;    public static void main(String[] args)    &#123;        NumberValue num=new NumberValue();        num.TestMath();        double[] nums = &#123; 1.4, 1.5, 1.6, -1.4, -1.5, -1.6 &#125;;       for (double i : nums)        &#123;         num.TestMath(i);    &#125;     &#125;&#125;</code></pre><p>运行结果如下<br><img src="https://i.imgur.com/AJPvJhv.png">  </p><h2 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h2><p>在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情况。为了解决这个问题，Java语言为内置数据类型char提供了包装类Character类。<br>脚本如下  </p><pre><code>public class Test&#123;    public static void main(String[] args)    &#123;        Character ch=&#39;a&#39;;        char c=&#39;x&#39;;        System.out.println(ch);        System.out.println(c);    &#125;&#125;</code></pre><p>运行结果如下<br><img src="https://i.imgur.com/Ys0K262.png">  </p><p><strong>Character方法</strong>  </p><table><thead><tr><th align="left">函数名称</th><th align="left">函数功能</th></tr></thead><tbody><tr><td align="left">isLetter()</td><td align="left">是否是一个字母</td></tr><tr><td align="left">isDigit()</td><td align="left">是否是一个数字字符</td></tr><tr><td align="left">isWhitespace()</td><td align="left">是否是一个空格</td></tr><tr><td align="left">isUpperCase()</td><td align="left">是否是大写字母</td></tr><tr><td align="left">isLowerCase()</td><td align="left">是否是小写字母</td></tr><tr><td align="left">toUpperCase()</td><td align="left">指定字母的大写形式</td></tr><tr><td align="left">toLowerCase()</td><td align="left">指定字母的小写形式</td></tr><tr><td align="left">toString()</td><td align="left">返回字符的字符串形式，字符串的长度仅为1</td></tr></tbody></table><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>代码如下  </p><pre><code>public class Test&#123;    public static void main(String[] args)    &#123;        int a=10;        double b=3.14;        String str1=&quot;My name is &quot;;        String str2=&quot;LianBai&quot;;        a=str2.length();        System.out.println(str1.length());        String str=str1.concat(str2);        System.out.println(str);        System.out.println(str1+str2);        System.out.printf(&quot;整型类a的值为%d&quot;+                   &quot;浮点型b的值为%lf&quot;+                   &quot;字符串的值为%s&quot;,a,b,str1+str2);        str=String.format(&quot;整型类a的值为%d&quot;+&quot;浮点型b的值为%lf&quot;+                   &quot;字符串的值为%s&quot;,a,b,str1+str2);    &#125;&#125;</code></pre><p>运行结果如下<br><img src="https://i.imgur.com/msSxt6G.png"><br><strong>String方法</strong>  </p><table><thead><tr><th align="left">返回类型</th><th align="left">函数名</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">char</td><td align="left">charAt(int index)</td><td align="left">返回指定索引处的 char 值。</td></tr><tr><td align="left">int</td><td align="left">compareTo(Object o)</td><td align="left">把这个字符串和另一个对象比较。</td></tr><tr><td align="left">int</td><td align="left">compareTo(String anotherString)</td><td align="left">按字典顺序比较两个字符串。</td></tr><tr><td align="left">int</td><td align="left">compareToIgnoreCase(String str)</td><td align="left">按字典顺序比较两个字符串，不考虑大小写。</td></tr><tr><td align="left">String</td><td align="left">concat(String str)</td><td align="left">将指定字符串连接到此字符串的结尾。</td></tr><tr><td align="left">boolean</td><td align="left">contentEquals(StringBuffer sb)</td><td align="left">当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。</td></tr><tr><td align="left">static String</td><td align="left">copyValueOf(char[] data)</td><td align="left">返回指定数组中表示该字符序列的 String。</td></tr><tr><td align="left">static String</td><td align="left">copyValueOf(char[] data, int offset, int count)</td><td align="left">返回指定数组中表示该字符序列的 String。</td></tr><tr><td align="left">boolean</td><td align="left">endsWith(String suffix)</td><td align="left">测试此字符串是否以指定的后缀结束。</td></tr><tr><td align="left">boolean</td><td align="left">equals(Object anObject)</td><td align="left">将此字符串与指定的对象比较。</td></tr><tr><td align="left">boolean</td><td align="left">equalsIgnoreCase(String anotherString)</td><td align="left">将此 String 与另一个 String 比较，不考虑大小写。</td></tr><tr><td align="left">byte[]</td><td align="left">getBytes()</td><td align="left">使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td></tr><tr><td align="left">byte[]</td><td align="left">getBytes(String charsetName)</td><td align="left">使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td></tr><tr><td align="left">void</td><td align="left">getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</td><td align="left">将字符从此字符串复制到目标字符数组。</td></tr><tr><td align="left">int</td><td align="left">hashCode()</td><td align="left">返回此字符串的哈希码。</td></tr><tr><td align="left">int</td><td align="left">indexOf(int ch)</td><td align="left">返回指定字符在此字符串中第一次出现处的索引。</td></tr><tr><td align="left">int</td><td align="left">indexOf(int ch, int fromIndex)</td><td align="left">返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。</td></tr><tr><td align="left">int</td><td align="left">indexOf(String str)</td><td align="left">返回指定子字符串在此字符串中第一次出现处的索引。</td></tr><tr><td align="left">int</td><td align="left">indexOf(String str, int fromIndex)</td><td align="left">返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</td></tr><tr><td align="left">String</td><td align="left">intern()</td><td align="left">返回字符串对象的规范化表示形式。</td></tr><tr><td align="left">int</td><td align="left">lastIndexOf(int ch)</td><td align="left">返回指定字符在此字符串中最后一次出现处的索引。</td></tr><tr><td align="left">int</td><td align="left">lastIndexOf(int ch, int fromIndex)</td><td align="left">返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。</td></tr><tr><td align="left">int</td><td align="left">lastIndexOf(String str)</td><td align="left">返回指定子字符串在此字符串中最右边出现处的索引。</td></tr><tr><td align="left">int</td><td align="left">lastIndexOf(String str, int fromIndex)</td><td align="left">返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</td></tr><tr><td align="left">int</td><td align="left">length()</td><td align="left">返回此字符串的长度。</td></tr><tr><td align="left">boolean</td><td align="left">matches(String regex)</td><td align="left">告知此字符串是否匹配给定的正则表达式。</td></tr><tr><td align="left">boolean</td><td align="left">regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)</td><td align="left">测试两个字符串区域是否相等。</td></tr><tr><td align="left">boolean</td><td align="left">regionMatches(int toffset, String other, int ooffset, int len)</td><td align="left">测试两个字符串区域是否相等。</td></tr><tr><td align="left">String</td><td align="left">replace(char oldChar, char newChar)</td><td align="left">返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</td></tr><tr><td align="left">String</td><td align="left">replaceAll(String regex, String replacement)</td><td align="left">使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</td></tr><tr><td align="left">String</td><td align="left">replaceFirst(String regex, String replacement)</td><td align="left">使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</td></tr><tr><td align="left">String[]</td><td align="left">split(String regex)</td><td align="left">根据给定正则表达式的匹配拆分此字符串。</td></tr><tr><td align="left">String[]</td><td align="left">split(String regex, int limit)</td><td align="left">根据匹配给定的正则表达式来拆分此字符串。</td></tr><tr><td align="left">boolean</td><td align="left">startsWith(String prefix)</td><td align="left">测试此字符串是否以指定的前缀开始。</td></tr><tr><td align="left">boolean</td><td align="left">startsWith(String prefix, int toffset)</td><td align="left">测试此字符串从指定索引开始的子字符串是否以指定前缀开始。</td></tr><tr><td align="left">CharSequence</td><td align="left">subSequence(int beginIndex, int endIndex)</td><td align="left">返回一个新的字符序列，它是此序列的一个子序列。</td></tr><tr><td align="left">String</td><td align="left">substring(int beginIndex)</td><td align="left">返回一个新的字符串，它是此字符串的一个子字符串。</td></tr><tr><td align="left">String</td><td align="left">substring(int beginIndex, int endIndex)</td><td align="left">返回一个新字符串，它是此字符串的一个子字符串。</td></tr><tr><td align="left">char[]</td><td align="left">toCharArray()将此字符串转换为一个新的字符数组。</td><td align="left"></td></tr><tr><td align="left">String</td><td align="left">toLowerCase()</td><td align="left">使用默认语言环境的规则将此 String 中的所有字符都转换为小写。</td></tr><tr><td align="left">String</td><td align="left">toLowerCase(Locale locale)</td><td align="left">使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。</td></tr><tr><td align="left">String</td><td align="left">toString()</td><td align="left">返回此对象本身（它已经是一个字符串！）。</td></tr><tr><td align="left">String</td><td align="left">toUpperCase()</td><td align="left">使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</td></tr><tr><td align="left">String</td><td align="left">toUpperCase(Locale locale)</td><td align="left">使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。</td></tr><tr><td align="left">String</td><td align="left">trim()</td><td align="left">返回字符串的副本，忽略前导空白和尾部空白。</td></tr><tr><td align="left">static String</td><td align="left">valueOf(primitive data type x)</td><td align="left">返回给定data type类型x参数的字符串表示形式。</td></tr></tbody></table><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTC VIVE</title>
      <link href="/2018/08/19/Unity/HTC-VIVE/"/>
      <url>/2018/08/19/Unity/HTC-VIVE/</url>
      
        <content type="html"><![CDATA[<h1 id="开发前的准备"><a href="#开发前的准备" class="headerlink" title="开发前的准备"></a>开发前的准备</h1><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><pre><code>1.unity 2017.3.1f1  2.HTC VIVE3.steam</code></pre><h2 id="开发所需插件"><a href="#开发所需插件" class="headerlink" title="开发所需插件"></a>开发所需插件</h2><pre><code>1.steam VR(去steam上下载即可)2.Steam VR Plugin(unity的商店下载即可，我的版本是V1.2.3)3.VIVE Input Utility(unity的商店即可下载，我的版本是V1.8.3)4.UGUI</code></pre><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote><p>去百度里找HTC VIVE的安装教程即可（两个基站的通道一个是A一个是b即可）</p></blockquote><h1 id="开发测试过程"><a href="#开发测试过程" class="headerlink" title="开发测试过程"></a>开发测试过程</h1><ol><li>首先导入VIVE Input Unility包，导入时如下图，选择Accept All。<br><img src="https://i.imgur.com/Lt2gga0.png">  </li><li>导入后会出现一个HTC.UnityPlugin文件夹，在文件夹里会有给的案例，可以通过案例进行学习<br><img src="https://i.imgur.com/5Hil8nD.png">  </li><li>导入Steam VR Plugin包，因为我用的unity是2017.3.1f1版本，所有会一些错误，接下来开始改错</li><li>通过报错找到代码所指向的地方，把所有的VR全部改成XR，但是这里面还会有一个错误，XRSetting的一个方法过时了，换成另一个方法即可<br><img src="https://i.imgur.com/whV4vdb.png"></li></ol><h2 id="案例一：button-按钮"><a href="#案例一：button-按钮" class="headerlink" title="案例一：button 按钮"></a>案例一：button 按钮</h2><ol><li>首先新建一个场景，在场景中把main camera去掉，然后在刚才导入的文件夹的Prefabs文件里找到ViveCameraRig和VivePointers两个预制体，导入到场景中即可<br><img src="https://i.imgur.com/Nj2ST54.png">  </li><li>在场景中添加UGUI的button按钮，然后把EventSystem去掉</li><li>把canvas物体上的canvas组件中的Render Mode改为World space（世界坐标）<br><img src="https://i.imgur.com/QtwuUIq.png">  </li><li>把canvas画布上面的canvas Scaler和Graphic Raycaster组件去掉  </li><li>把canvas上canvas组件中的Addition Shader Channes的值选中TexCoord1、Normal和Tangent（每次打开选中一个，打开三次依次选中三个即可）<br><img src="https://i.imgur.com/CWAeDJl.png">  </li><li>在canvas上面添加canvas Raycast Target脚本<br><img src="https://i.imgur.com/vCNxajz.png">  </li><li>然后把canvas缩小到原来的0.01,然后把canvas移动到ViveCameraRig摄像头能看到的地方，最好先移动到摄像头在的位置，然后微调，离摄像头近一些，否则手柄射线无法扫描到button，就无法进行点击<br><img src="https://i.imgur.com/bDilsoP.png">  </li><li>接着连接HTC VIVE设备直接运行即可</li></ol><h2 id="案例二：2D-Drag-amp-Drop-拖拽"><a href="#案例二：2D-Drag-amp-Drop-拖拽" class="headerlink" title="案例二：2D Drag&amp;Drop(拖拽)"></a>案例二：2D Drag&amp;Drop(拖拽)</h2><ol><li>跟案例一一样建立一个UGUI的场景，把案例一中的button换成image  </li><li>创建一个脚本(作者脚本名字UIDropDrag),然后在脚本中继承IBeginDragHandler,IDragHandler,IEndDragHandler并实现接口</li></ol><p>脚本如下  </p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using UnityEngine.EventSystems;public class UIDropDrag : MonoBehaviour, IBeginDragHandler,IDragHandler,IEndDragHandler&#123;    private RectTransform DragObject;//保留拖拽物体    public void OnBeginDrag(PointerEventData eventData)//开始拖拽    &#123;        DragObject = eventData.pointerEnter.transform as RectTransform;//初始化拖拽物体        SetDraggedPosition(eventData);//设置拖拽物体的坐标    &#125;    public void OnDrag(PointerEventData eventData)//正在拖拽    &#123;        if (DragObject != null) //判断拖拽物体是否为空            SetDraggedPosition(eventData);//设置拖拽物体的坐标    &#125;    public void OnEndDrag(PointerEventData eventData)    &#123;        if (DragObject != null)        &#123;            SetDraggedPosition(eventData);//设置拖拽物体的坐标            DragObject = null;//清空拖拽物体        &#125;    &#125;    //设置拖拽物体坐标    private void SetDraggedPosition(PointerEventData eventData)    &#123;        var rt = DragObject.GetComponent&lt;RectTransform&gt;();        Vector3 globalMousePos;        if (RectTransformUtility.ScreenPointToWorldPointInRectangle(DragObject, eventData.position, eventData.pressEventCamera, out globalMousePos))        &#123;            rt.position = globalMousePos;            rt.rotation = DragObject.rotation;        &#125;    &#125;&#125;</code></pre><h2 id="案例三：3D-Drag-amp-amp-Drop-拖拽"><a href="#案例三：3D-Drag-amp-amp-Drop-拖拽" class="headerlink" title="案例三：3D Drag&amp;&amp;Drop(拖拽)"></a>案例三：3D Drag&amp;&amp;Drop(拖拽)</h2><ol><li>如案例一搭建一个VR场景，但是不用创建UGUI画布</li><li>在场景中新建一个3D物体（作者创建的是个cube）</li><li>在3D物体上添加一个rigibody组件和一个Draggable脚本，组件和脚本的设置如下<br><img src="https://i.imgur.com/Ic8Aa0P.png">  </li><li>接下来直接运行就好了，通过手柄扳机进行拖拽，手柄触摸区域进行远近拉伸</li></ol><h2 id="案例四：Telrport-远程传送"><a href="#案例四：Telrport-远程传送" class="headerlink" title="案例四：Telrport(远程传送)"></a>案例四：Telrport(远程传送)</h2><ol><li>新建一个场景，把默认添加的相机去掉，然后在场景中搭建添加ViveCameraRig和ViveCurvePointers两个物体，把这俩物体挂在空物体上(作者空物体名字VROrigins)<br><img src="https://i.imgur.com/XWoJ3Xf.png">  </li><li>在场景中搭建一个用来移动的场景，最好设置一些障碍<br><img src="https://i.imgur.com/ZFKYXdm.png">  </li><li>在允许位移的物体上添加一个Teleportable组件，这样就可以在物体上移动了，障碍物不添加这个组件就不会移动到这个组件中了<br><img src="https://i.imgur.com/hcrcBS6.png">  </li><li>接下来直接运行游戏就行了，通过按下触摸键来改变位置移动</li></ol><h2 id="案例五：Collider-Evenrt-碰撞事件"><a href="#案例五：Collider-Evenrt-碰撞事件" class="headerlink" title="案例五：Collider Evenrt(碰撞事件)"></a>案例五：Collider Evenrt(碰撞事件)</h2><ol><li>新建一个场景，把默认添加的相机去掉，然后在场景中搭建添加ViveCameraRig、ViveCurvePointers和ViveColliders三个物体，把这俩物体挂在空物体上(作者空物体名字VROrigins)<br><img src="https://i.imgur.com/tLPcc0b.png">  </li><li>在场景中搭建一个场景，分别创建5个3D物体(作者使用的是5个Capsule,并且用颜色区分开),并且分别为他们添加了Rigibody，并且把Use Gravity取消掉,是为了方便抓取<br><img src="https://i.imgur.com/thsUtpt.png">   </li><li>为前两个Capsule添加Basic Grabbable脚本，并且两个Unblockable Grab一个勾选上，一个不勾选<br><img src="https://i.imgur.com/RMKNsy3.png">  </li><li>为后两个Capsule添加Sticky Grabbable脚本，并且两个Unblockable Grab一个勾选上，一个不勾选<br><img src="https://i.imgur.com/7To7ZlV.png">  </li><li>运行脚本进行抓取，可以发现抓取Basic Grabbable脚本物体的时候手柄扳机一直扣着才可以一直抓取，扳机松开就会结束，然而抓取Sticky Grabbable脚本物体的时候扣动一次扳机就代表抓取，扳机松开后还是一直抓取，再次扣动扳机就松开了，两个脚本的Unblockable Grab功能其实是一样的，如果打上对勾，代表的是抓取过程中无视障碍，不会被阻挡，不勾选代表抓取过程中会被物体阻挡，在抓取过程中碰撞物体就可以试试了</li><li>为场景添加一个新的Capsule,为其添加一个Material Changer脚本，这个脚本是根据触碰物体后扣动扳机来触发材质改变，类似于button的点击<br><img src="https://i.imgur.com/5uqNt1E.png"></li></ol><h2 id="案例六：Collider-Evenrt-Manager-控制器事件管理"><a href="#案例六：Collider-Evenrt-Manager-控制器事件管理" class="headerlink" title="案例六：Collider Evenrt Manager(控制器事件管理)"></a>案例六：Collider Evenrt Manager(控制器事件管理)</h2><ol><li>如案例五新建一个3D的场景，并且能够瞬间移动  </li><li>在场景中添加一个Capsule，并且如案例一添加一个UI界面，并且在界面里添加一个image和Test用来输出触发事件信息，方便监测<br><img src="https://i.imgur.com/iVo6e4Z.png">  </li><li>在Capssule身上添加Material Changer脚本，用来观测触发事件  </li><li>新建一个脚本(作者脚本名字ColliderEventManage),并且悬挂在Capsule物体上<br><img src="https://i.imgur.com/2HAUTx0.png"></li><li>脚本中添加一个Text变量，用来修改显示数据，监测事件触发，脚本继承,IColliderEventHoverEnterHandler,IColliderEventHoverExitHandler,IColliderEventPressEnterHandler, IColliderEventPressExitHandler分别实现接口，这些接口就可以触发事件。</li></ol><p>脚本内容如下 </p><pre><code>using HTC.UnityPlugin.ColliderEvent;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class ColliderEventManage : MonoBehaviour    , IColliderEventHoverEnterHandler    , IColliderEventHoverExitHandler    , IColliderEventPressEnterHandler    , IColliderEventPressExitHandler&#123;    public Text Message;    public void OnColliderEventHoverEnter(ColliderHoverEventData eventData)    &#123;        Message.text = &quot;OnColliderEventHoverEnter&quot;;    &#125;    public void OnColliderEventHoverExit(ColliderHoverEventData eventData)    &#123;        Message.text = &quot;OnColliderEventHoverExit&quot;;    &#125;    public void OnColliderEventPressEnter(ColliderButtonEventData eventData)    &#123;        Message.text = &quot;OnColliderEventPressEnter&quot;;    &#125;    public void OnColliderEventPressExit(ColliderButtonEventData eventData)    &#123;        Message.text = &quot;OnColliderEventPressExit&quot;;    &#125;&#125;</code></pre><ol start="6"><li>连接设备，运行程序即可发现触发的事件</li></ol><p>本文仅仅是带领读者入门，看完本文后从**<a href="https://www.vive.com/cn/forum/1728?1"><font color="steelblue" size="3">点击这里</font></a>**可进行详细学习   </p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统教程</title>
      <link href="/2018/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/"/>
      <url>/2018/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统序论"><a href="#操作系统序论" class="headerlink" title="操作系统序论"></a>操作系统序论</h1><p>平台是操作系统的重要特点。<br>平台很重要，但是不是所有的平台都是操作系统。<br>操作系统在计算机中的主要特点是管理硬件及资源。   </p><h2 id="什么是好的操作系统"><a href="#什么是好的操作系统" class="headerlink" title="什么是好的操作系统"></a>什么是好的操作系统</h2><p>公平性对操作系统很重要，是操作系统较核心的理念。<br>操作系统的开发，效率仍然是其追求的目标。<br>操作系统本身要保持稳定的特性。<br>安全对于操作系统也比较重要。  </p><h2 id="操作系统设计的主要目标"><a href="#操作系统设计的主要目标" class="headerlink" title="操作系统设计的主要目标"></a>操作系统设计的主要目标</h2><p>1.方便<br>2.硬件的高效利用<br>3.整体可靠、稳定、安全；  </p><h2 id="根据用途操作系统分类"><a href="#根据用途操作系统分类" class="headerlink" title="根据用途操作系统分类"></a>根据用途操作系统分类</h2><p>1.Embedded systems(嵌入式系统):mp3、摄像机、汽车<br>2.Multimedia systems(多媒体系统)<br>3.Handheld systems(手持设备)  </p><h1 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h1><p>1.GUI图形用户界面<br>2.命令行界面  </p><blockquote><p>目前为止，各种系统都有命令行界面的位置，对于小型的嵌入式系统，命令行界面会和内核绑定通过内核实现。  </p></blockquote><p>3.System Calls(系统调用)  </p><blockquote><p>计算机和程序员的接口，一般都是c和C++  </p></blockquote><p>4.API(应用编程接口)  </p><blockquote><p>是由系统调用实现的API。<br>重要的三个API:Win32 API for Windows、POSIX API for POSIX—based systems、Java API for the Java virual machine(JVM)  </p></blockquote><p>5.中断服务程序的特点  </p><blockquote><p>中断服务程序一定是操作系统编写的。  </p></blockquote><p>系统程序通常和系统内的各种功能距离较近，帮助我们完成系统的重要职能。<br>一般很少用到的系统程序，如系统分区、磁盘碎片整理、磁盘快照等等。<br>系统级的功能有系统程序来完成。这部分程序普通的用户不常用，一般由系统管理员用。<br><strong>操作系统的设计和实现</strong><br>软件体系结构：来源是操作系统。<br>1.User goals(用户角度看)<br>2.System goals(系统角度)<br>容易设计、实现和维护，有很好的灵活性、可靠性。能够没有错误、效率非常高。<br>策略与机制的分割(设计的重要原则)<br><strong>选择语言的原则</strong><br>1.选择的语言要适合所设计的操作系统<br>2.设计团队要能良好的驾驭这个语言  </p><h2 id="简单结构"><a href="#简单结构" class="headerlink" title="简单结构"></a>简单结构</h2><p>1.DOS的结构<br>病毒很容易入侵、并且很容易被软件剔除。<br>2.UNIX结构<br>做到了内核的保护，保证了安全，内核里没有结构。任何一点出问题，导致整个内核就完蛋。  </p><h2 id="虚拟机结构"><a href="#虚拟机结构" class="headerlink" title="虚拟机结构"></a>虚拟机结构</h2><p>VMware  </p><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p>进程就是操作系统对CPU是如何管理的<br>一个程序运行起来了就叫一个进程  </p><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p><strong>新建</strong>：<br><strong>就绪态</strong>：给个CPU就会运行<br><strong>运行态</strong>：正拥有CPU的进程（同一个CPU只运行一个进程）<br><strong>等待态</strong>：进程主动让出CPU，等待满足的条件后进入就绪态<br><strong>结束</strong>：<br><img src="https://i.imgur.com/7JPFVoq.png"></p><h2 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuforia教程</title>
      <link href="/2018/06/01/Unity/Vuforia%E6%95%99%E7%A8%8B/"/>
      <url>/2018/06/01/Unity/Vuforia%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Vuforia简介"><a href="#Vuforia简介" class="headerlink" title="Vuforia简介"></a>Vuforia简介</h1><p>Vuforia是创建增强现实应用程序的软件平台。开发人员可以轻松地将高级计算机视觉功能添加到任何应用程序，使其能够识别图像和对象，并与现实世界中的空间进行交互。<br>Vuforia平台支持Android，iOS和UWP设备的AR应用程序开发。</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>首先，需要在**<a href="https://library.vuforia.com/getting-started"><font color="steelblue" size="3">Vurforia的官网</font></a>**上注册一个账户，自己所有做的项目都是和这个账户进行关联的。<br>在官网上可以下载Vuforia的SDK,但是从unity 2017.2版本以后，vuforia已经可以在安装unity的时候就可以直接选择安装了，官网提供了两个与unity有关的插件，第一个Download unity Extension(legacy)是为了以前用vuforia SDK做的程序在用新版本打开的时候接入使用的，第二个Download Unity打开会发现其实就是进入unity的官网，就是因为vuforia已经可以随着unity安装了。<br>如何查看自己是否已经安装过Vuforia<br>打开unity任意一个项目，打开GameObject菜单下如果有Vuforia选项就代表已经安装过了  </p><p>下面我来图解一下安装教程：<br>1.首先打开安装包（与自己使用的unity的版本相同的安装包）,点击next<br><img src="https://i.imgur.com/O8GTqD7.png">  </p><p>2.然后在Iaccept the terms of the License Agreement前面的框选择上，点击next<br><img src="https://i.imgur.com/Sazmun9.png">  </p><p>3.接着是选择unity的一些插件，把Vuforia Augmented….这个插件选择上点击next即可。<br><img src="https://i.imgur.com/9NyMVFN.png"></p><p>4.接着选择自己以前安装unity的位置，选择相同的路径后点击next（在unity install folder）内容里进行选择<br><img src="https://i.imgur.com/JimQzIr.png"></p><p>5.安装完毕后点击Ignore即可<br><img src="https://i.imgur.com/0Pr1tL5.png"></p><p>6.然后就是进行自动安装了<br><img src="https://i.imgur.com/2VTFREz.png"></p><p>7.安装完毕后运行即可使用<br><img src="https://i.imgur.com/450ceKq.png"></p><h1 id="LicenseKey获取及注册"><a href="#LicenseKey获取及注册" class="headerlink" title="LicenseKey获取及注册"></a>LicenseKey获取及注册</h1><p>1.首先先创建一个Unity工程，和普通的3D工程一样。<br>2.第一打开程序，如果采用的是unity下载补充的vuforia，需要打开GameObject菜单里面Vuforia里面的AR Camera,会弹出一个提示框提示导入资源，点击Import即可。<br><img src="https://i.imgur.com/q5ALyBk.png"><br>3.我们需要的资源从GameObject菜单里面的vuforia进行点击即可，如果选择用的是2017.2以前版本使用的是补丁包的情况，需要在项目窗口下的Vuforia里面的Prefabs里寻找自己需要创建的资源进行拖拽到层级窗口里即可。<br>4.在开始项目制作前需要激活自己的vuforia，首先需要打开file菜单下的Build Setting…,然后点击Player Settings…，然后在检视窗口找到XR Setting目录，打开里面的Vuforia Augmented Realit即可<br><img src="https://i.imgur.com/mHiWhbg.png"><br>5.接着是在官网注册自己的项目，先打开vuforia的官网，然后点击Develop目录，然后点击Get Development Key,然后输入自己项目的名字，在By checking….前面打钩，点击Confirm即可。<br><img src="https://i.imgur.com/3V4j9ZZ.png"><br><img src="https://i.imgur.com/dC4yq1y.png"><br>6.在官网Develop目录下点击自己的项目，进入的页面也就包含我们需要的LicenseKey。复制我们的LicenseKey即可<br><img src="https://i.imgur.com/4aw2v35.png"><br><img src="https://i.imgur.com/EcyewMr.png"><br>7.打开自己的unity项目，然后在项目里创建一个AR Camera(上面已经讲述创建AR资源的方法了，在第3步)。在AR Camera的检视窗口里找到Vuforia Behaviour插件，点击里面的Open Vuforia con…,然后在App License Key里粘贴自己刚才复制的key。<br><img src="https://i.imgur.com/nW6GgF0.png"><br><img src="https://i.imgur.com/izp4MUG.png">  </p><h1 id="AR-Camera介绍"><a href="#AR-Camera介绍" class="headerlink" title="AR Camera介绍"></a>AR Camera介绍</h1><p>简单的说这个资源就是用来调用我们设备上的照相机的。</p><h2 id="Vuforia-Behaviour组件"><a href="#Vuforia-Behaviour组件" class="headerlink" title="Vuforia Behaviour组件"></a>Vuforia Behaviour组件</h2><p>Woeld Center Mode用来设置我们的中心点的。里面有四个选项，分别设置我们以什么为直接中心坐标的。  </p><table><thead><tr><th align="center">名称</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">Camera</td><td align="left">是以我们的摄像机为世界坐标</td></tr><tr><td align="center">FIST_TARGET</td><td align="left">是以我们第一个需要识别的资源为中心坐标</td></tr><tr><td align="center">DEVICE_TRACKING</td><td align="left">是以设备正在追踪的物体为世界中心坐标</td></tr><tr><td align="center">SPECIFIC_TARGET</td><td align="left">我们指定物体为中心坐标，物体必须继承Trankable Behaviour</td></tr></tbody></table><h2 id="Open-Vuforia-configuration"><a href="#Open-Vuforia-configuration" class="headerlink" title="Open Vuforia configuration"></a>Open Vuforia configuration</h2><table><thead><tr><th align="center">名称</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">Vuforia Version</td><td align="left">版本信息</td></tr><tr><td align="center">App License Key</td><td align="left">秘钥，用来标识软件用的</td></tr><tr><td align="center">Camera Device Mode</td><td align="left">MODE_OPTIMIZE_QUALITY:质量优先。MODE_OPTIMIZE_SPEED:速度优先。  MODE_DEFAULT:默认，在质量和速度之间取合适。</td></tr><tr><td align="center">Max Simultaneous Tracked Images</td><td align="left">最大追踪图片数量，可以识别多张图片。</td></tr><tr><td align="center">Max Simultaneous Tracked Object</td><td align="left">最大追踪物体数量，可以识别多个物体。</td></tr><tr><td align="center">Camera Direction</td><td align="left">摄像机的调用，有前置、后置和默认，默认就是设备系统默认的摄像头，电脑唯一的摄像头识别为后置摄像头。</td></tr><tr><td align="center">Digital Eyewear</td><td align="left">判断设备的类型，Handheld:手持。Digital Eyeweay:应用于微软的全息眼睛的。 Phone+Viewer:MR(AR与VR结合)所用。</td></tr><tr><td align="center">Databases</td><td align="left">数据库，把要识别的图片上传到数据库，这样数据库生成的包会传回来，下次识别就会识别出上传的图片了。</td></tr></tbody></table><h1 id="图片的选择"><a href="#图片的选择" class="headerlink" title="图片的选择"></a>图片的选择</h1><p>Vuforia识别的原理是通过检测自然特征点的匹配来完成的。将Target Manager中的image检测出的特征点保存在数据库中，然后在实时检测出真实图像中的特征点与数据库中模板图片的特征点数据进行匹配。<br>1.服务器对上传图片进行灰度处理，图片变为黑白图像；<br>2.提取黑白图像特征点；<br>3.将特征点数据打包；<br>4.程序运行时对比特征点数据包；<br>被上传到官网的整幅图片的8%宽度被称为功能排斥缓冲区，意为该8%的区域不会被书别。</p><h1 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h1><p>1.登录到官网，在官网的Develop目录下，有个Target Manager,这个就是图片的数据库。<br><img src="https://i.imgur.com/ftUakYE.png">  </p><p>2.点击AddDatabese按钮添加数据库，并且自定义数据库名字，然后点击Create。<br><img src="https://i.imgur.com/BHgQwTG.png"> </p><p>3.点击刚才创建的数据库，进入数据库<br><img src="https://i.imgur.com/6laU8k8.png"></p><p>4.点击Add Target按钮添加图片，然后点击Browse选择自己的图片，Width自己可以先随意设置，然后设置图片的名字，最后点击Add进行添加即可<br><img src="https://i.imgur.com/keLryHY.png"></p><p>5.上传完后点击Download Database进行下载，可以下载全部，也可以选择下载，然后就是选择Unity Editor进行下载，最后点击Download就可下载我们需要的资源了。<br><img src="https://i.imgur.com/zNc8v0g.png"></p><p>6.把下载的包导入unity项目里。（上面是数据库中图片，下面是配置文件）<br><img src="https://i.imgur.com/wTFeOhn.png">    </p><h1 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h1><p>1.首先在层级视图框创建一个AR资源ImageTarget<br>2.在刚才创建的ImageTarget的检视窗口中，找到Image Target Behaviour组件，找到里面的Database属性，选择刚才导入的数据库，然后在ImageTarget属性里选择自己想要识别的图片。<br><img src="https://i.imgur.com/lAqsoNi.png">  </p><p>3.在AR Camera的层级视图里点击Open Vuforia ….,然后找到Database，把自己的数据库打上对勾并且把Achieve也打上对勾。<br><img src="https://i.imgur.com/FVjvGwW.png">  </p><p>4.然后在ImageTargrt下面放入自己想要展现的Object,然后就可以识别出现自己想要的效果了。</p><h1 id="ImageTarget机制分析"><a href="#ImageTarget机制分析" class="headerlink" title="ImageTarget机制分析"></a>ImageTarget机制分析</h1><p>在AR Camera组件上有一个DefaultTrackableEventHandler脚本，在这个脚本的PRIVATE_METHODS里有两个函数，OnTrackingFound()和OnTrackingLost()分别是识别图片时和丢失图片时的两个执行函数，丢失就是摄像头没检测到能识别的图片。自己可以在这两个脚本里添加自己想要操作的代码。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络原理教程</title>
      <link href="/2018/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E6%95%99%E7%A8%8B/"/>
      <url>/2018/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h1><h2 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h2><h3 id="网络介绍"><a href="#网络介绍" class="headerlink" title="网络介绍"></a>网络介绍</h3><blockquote><p>网络：许多计算机连接在一起；（交换机）<br>互联网：Internet 许多网络连接在一起；（路由器）<br>因特网：internet 全球最大的一个互联网<br>中国的互联网<br><img src="https://i.imgur.com/pNaEA4n.png"></p></blockquote><h2 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h2><p><img src="https://i.imgur.com/u2eLNz8.png"><br><img src="https://i.imgur.com/two7RR6.png"></p><h3 id="英特网边缘部分"><a href="#英特网边缘部分" class="headerlink" title="英特网边缘部分"></a>英特网边缘部分</h3><p>主机之间的通信方式  </p><blockquote><p>客户服务器方式(Client&#x2F;Server方式 –C&#x2F;S)<br><img src="https://i.imgur.com/yWIukQE.png"><br>对等方式(Peer–to–Peer方式–P2P)<br><img src="https://i.imgur.com/3XGGBb3.png"></p></blockquote><h3 id="英特网的核心"><a href="#英特网的核心" class="headerlink" title="英特网的核心"></a>英特网的核心</h3><p>数据交换方式</p><blockquote><p>**电路交换(Circuit Switching) ** </p><blockquote><p>电路交换的典型应用就是打电话,当A和B打电话的时候，交换机就会建立一个连线，把A和B连接在一起。通话结束后就释放。<br>建立连接：申请占用通信资源<br>通话：一直占用通信资源<br>释放连接：释放通信资源<br><strong>电路交换适合于数据量很大的实时性传输：核心路由器之间可以使用电路交换。</strong><br><img src="https://i.imgur.com/HLhASm0.png"><br><img src="https://i.imgur.com/w988UZB.png">   </p></blockquote><p><strong>报文交换(Message Switching)</strong><br><strong>分组交换(Packet Switching)</strong>  </p><blockquote><p>计算机网络用的就是分组交换,不会被占线，走的路线不固定，路由器有存储转发的功能<br>分组交换的有点是：高校、灵活、迅速、可靠<br>问题：延时、开销大<br><img src="https://i.imgur.com/ehR3y1Y.png"><br><img src="https://i.imgur.com/nWGAfCl.png">  </p></blockquote></blockquote><blockquote><p><strong>报文交换方式(Message Switching)</strong></p><blockquote><p>报文一般比分组长的多<br>报文交换的时延较长  </p></blockquote><p><strong>三种方式的比较</strong></p><blockquote><p>分组交换比较省时间，<br><img src="https://i.imgur.com/ulWOwZW.png"></p></blockquote></blockquote><h2 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h2><h3 id="作用范围分类"><a href="#作用范围分类" class="headerlink" title="作用范围分类"></a>作用范围分类</h3><table><thead><tr><th align="center">名字</th><th align="center">概念</th></tr></thead><tbody><tr><td align="center">广域网(WAN)</td><td align="center">简称WAN，是一种跨越大的、地域性的计算机网络的集合。通常跨越省、市，甚至一个国家。广域网包括大大小小不同的子网，子网可以是局域网，也可以是小型的广域网。</td></tr><tr><td align="center">局域网(LAN)</td><td align="center">简称LAN，是指在某一区域内由多台计算机互联成的计算机组。“某一区域”指的是同一办公室、同一建筑物、同一公司和同一学校等，一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、扫描仪共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。</td></tr><tr><td align="center">城域网(MAN)</td><td align="center">覆盖一个城市的网络</td></tr><tr><td align="center">个人区域网(PAN)</td><td align="center">个人在多台电脑上建立的连接</td></tr></tbody></table><blockquote><p>局域网：自己该买设备，自己维护，带宽固定，网线长度100m以内<br>广域网：花钱买服务，花钱买带宽<br>带宽：  </p><blockquote><p>带宽应用的领域非常多，可以用来标识信号传输的数据传输能力、标识单位时间内通过链路的数据量、标识显示器的显示能力。  </p></blockquote></blockquote><ol><li>在模拟信号系统又叫频宽，是指在固定的时间可传输的资料数量，亦即在传输管道中可以传递数据的能力。通常以每秒传送周期或赫兹(Hz)来表示。  </li><li>在数字设备中，带宽指单位时间能通过链路的数据量。通常以bps来表示，即每秒可传输之位数。</li></ol><h3 id="按使用者分类"><a href="#按使用者分类" class="headerlink" title="按使用者分类"></a>按使用者分类</h3><table><thead><tr><th align="center">名字</th><th align="center">概念</th></tr></thead><tbody><tr><td align="center">公用网(Public Network)</td><td align="center">整个Internet就是一个公共的网络，谁都可以连接。</td></tr><tr><td align="center">专用网(Private Network)</td><td align="center">政府办公网，一些公司的内网</td></tr></tbody></table><h3 id="按拓扑结构分类"><a href="#按拓扑结构分类" class="headerlink" title="按拓扑结构分类"></a>按拓扑结构分类</h3><blockquote><p>总线型、环型、星型、树型、网型。<br>计算机网络拓扑结构是指网络中各个站点相互连接的形式，在局域网中明确一点讲就是文件服务器、工作站和电缆等的连接形式。现在最主要的拓扑结构有总线型拓扑、星形拓扑、环形拓扑、树形拓扑（由总线型演变而来）以及它们的混合型。顾名思义，总线型其实就是将文件服务器和工作站都连在称为总线的一条公共电缆上，且总线两端必须有终结器；星形拓扑则是以一台设备作为中央连接点，各工作站都与它直接相连形成星型；而环形拓扑就是将所有站点彼此串行连接，像链子一样构成一个环形回路；把这三种最基本的拓扑结构混合起来运用自然就是混合型了！  </p><p>计算机网络的拓扑结构是引用拓扑学中研究与大小、形状无关的点、线关系的方法，把网络中的计算机和通信设备抽象为一个点，把传输介质抽象为一条线，由点和线组成的几何图形就是计算机网络的拓扑结构。</p></blockquote><h3 id="按交换方式分类"><a href="#按交换方式分类" class="headerlink" title="按交换方式分类"></a>按交换方式分类</h3><blockquote><p>电路交换、报文交换、分组交换</p></blockquote><h3 id="按工作方式分类"><a href="#按工作方式分类" class="headerlink" title="按工作方式分类"></a>按工作方式分类</h3><blockquote><p>资源子网、通信子网、接入网</p></blockquote><h2 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h2><table><thead><tr><th align="center">名字</th><th align="left">概念</th></tr></thead><tbody><tr><td align="center">速率</td><td align="left">连接在计算机网络上的<strong>主机</strong>在数字信道上传送<strong>数据位数</strong>的速率，也称为<strong>data rate</strong>或者<strong>bit rate</strong>,单位是b&#x2F;s,kb&#x2F;s,Mb&#x2F;s,Gb&#x2F;s。</td></tr><tr><td align="center">带宽</td><td align="left">数据通信领域中，数字信道所传送的最高数据率,单位是b&#x2F;s,kb&#x2F;s,Mb&#x2F;s,Gb&#x2F;s。</td></tr><tr><td align="center">吞吐量</td><td align="left">在单位时间内通过某个网络的数据量，单位是b&#x2F;s,Mb&#x2F;s等。</td></tr><tr><td align="center">时延</td><td align="left">发送时延、传播时延、处理时延、排队时延</td></tr><tr><td align="center">时延带宽积</td><td align="left">时延带宽积&#x3D;传播时延*带宽,链路上的最大比特数，也称以比特为单位的链路长度。</td></tr><tr><td align="center">往返时间(RTT)</td><td align="left">从发送方发送数据开始，到发送方收到接收方确认</td></tr><tr><td align="center">利用率</td><td align="left">信道利用率、网络利用率</td></tr><tr><td align="center">非性能指标</td><td align="left">费用、质量、标准化、可靠性、可扩展性、可升级性、管理与维护</td></tr></tbody></table><blockquote><p><strong>数字信道</strong>：能传输数字信号的信道称之为数字信道。数字信号的变化不是连续的，在它的整个信号中只有两种状态，高电平与低电上平，高电平用逻辑1表示低电平用逻辑0表示。<br><strong>发送时延</strong>：数据块长度(比特)&#x2F;信道带宽(比特&#x2F;秒)<br><strong>传播时延</strong>：信道长度(米)&#x2F;信号在信道上传播速率(米&#x2F;秒)<br><strong>处理时延</strong>：网络结点储存转发处理时间<br><strong>排队时延</strong>：网络结点缓存队列排队时间<br><strong>信道利用率</strong>：有数据通过时间&#x2F;（有+无）数据通过时间<br><strong>网络利用率</strong>：信道利用率加权平均值</p></blockquote><h2 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h2><table><thead><tr><th align="center">名称</th><th align="left">概念</th></tr></thead><tbody><tr><td align="center">ISO</td><td align="left">国际标准化组织，专门定义一些标准的</td></tr><tr><td align="center">OSI&#x2F;RM</td><td align="left">互联网法律上的国际标准</td></tr><tr><td align="center">Network Protocols</td><td align="left">数据交换遵守的规则、标准或约定</td></tr><tr><td align="center">网络体系结构</td><td align="left">计算机网络各层及其协议的集合</td></tr></tbody></table><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><table><thead><tr><th align="center">层次</th><th align="center">概念</th></tr></thead><tbody><tr><td align="center">应用层</td><td align="center">能够<strong>产生网络流量</strong>，能够<strong>和用户交互</strong>的<strong>应用程序</strong></td></tr><tr><td align="center">表示层</td><td align="center">是否加密，压缩，二进制或者ASCII,开发人员需要考虑的问题</td></tr><tr><td align="center">会话层</td><td align="center">服务和客户端建立的会话，(netstat -n)命令查看会话，利用会话层可以查木马</td></tr><tr><td align="center">传输层</td><td align="center">可靠传输(建立会话)、不可靠传输(不建立会话，例：QQ发送消息，域名解析、老师讲课广播的信息)、流量控制</td></tr><tr><td align="center">网络层</td><td align="center">选择最佳路径，IP地址编址</td></tr><tr><td align="center">数据链路层</td><td align="center">输入数据如何封装、添加物理层地址（MAC地址）</td></tr><tr><td align="center">物理层</td><td align="center">规定电压、接口标准</td></tr></tbody></table><blockquote><p>分层之后有利于标准化，一层的变化不会影响其它层，尽量降低相互之间的依赖。<br>网络排错：从底层往高层排错<br>网络安全和OSI参考模型：物理层安全、数据链路层安全(ADSL、AP密码)、网络层安全、应用层安全（SQL注入漏洞，上传漏洞）。</p></blockquote><h3 id="TCP-x2F-IP四层模型"><a href="#TCP-x2F-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h3><p>参考OSI，把应用层、表示层、会话层归为应用层，传输层、网络层不变，数据链路层、物理层归为网络接口层。</p><h3 id="开放系统信息交换涉及的几个概念"><a href="#开放系统信息交换涉及的几个概念" class="headerlink" title="开放系统信息交换涉及的几个概念"></a>开放系统信息交换涉及的几个概念</h3><table><thead><tr><th align="center">名称</th><th align="left">概念</th></tr></thead><tbody><tr><td align="center">实体(entity)</td><td align="left">交换信息的硬件或软件进程</td></tr><tr><td align="center">协议(protocol)</td><td align="left">控制两个对等实体通信的规则</td></tr><tr><td align="center">服务(service)</td><td align="left">下层向上层提供服务，上层需要使用下层提供的服务来实现本层的功能</td></tr><tr><td align="center">服务访问点(SAP)</td><td align="left">相邻两层实体间交换信息的地方</td></tr><tr><td align="center"><img src="https://i.imgur.com/2JU2dUs.png"></td><td align="left"></td></tr></tbody></table><h3 id="五层协议对应的数据单元"><a href="#五层协议对应的数据单元" class="headerlink" title="五层协议对应的数据单元"></a>五层协议对应的数据单元</h3><table><thead><tr><th align="center">名称</th><th align="left">对应的数据单元</th></tr></thead><tbody><tr><td align="center">应用层</td><td align="left">传输数据单元PDU</td></tr><tr><td align="center">运输层</td><td align="left">运输层报文</td></tr><tr><td align="center">网络层</td><td align="left">IP数据报（IP分组）</td></tr><tr><td align="center">数据链路层</td><td align="left">数据帧</td></tr><tr><td align="center">物理层</td><td align="left">01101010101001</td></tr></tbody></table><blockquote><p>传输的数据先分段,编上号，用TCP&#x2F;IP或者UDP协议，分完段加上IP地址成为数据包，然后加上物理层（MAC)地址叫数据帧，然后通过数据帧编程bite(01011010)<br><img src="https://i.imgur.com/zbJUQFz.png"><br><img src="https://i.imgur.com/mQXWCqE.png"></p></blockquote><h3 id="客户进程和服务进程通信使用TCP-x2F-IP协议进行通信"><a href="#客户进程和服务进程通信使用TCP-x2F-IP协议进行通信" class="headerlink" title="客户进程和服务进程通信使用TCP&#x2F;IP协议进行通信"></a>客户进程和服务进程通信使用TCP&#x2F;IP协议进行通信</h3><p><img src="https://i.imgur.com/jZVpGVG.png"><br><strong>功能较强的计算机可同时运行多个服务进程</strong><br><img src="https://i.imgur.com/JgtDQw1.png"></p><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h2><p>物理层解决如何在连接各种计算机的<strong>传输媒体</strong>上传输<strong>数据比特流</strong>，不是指具体传输媒体。<br>物理层的主要任务描述为：确定与传输媒体接口的一些特性：  </p><table><thead><tr><th align="center">名称</th><th align="left">概念</th></tr></thead><tbody><tr><td align="center">机械特性</td><td align="left">例接口形状、大小、引线数目</td></tr><tr><td align="center">电气特性</td><td align="left">例规定电压范围（-5V到5V）</td></tr><tr><td align="center">功能特性</td><td align="left">例规定-5V表示0，+5V表示1</td></tr><tr><td align="center">过程特性</td><td align="left">也称规程特性，连接建立连接时各个相关部件工作步骤</td></tr></tbody></table><h2 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h2><p>典型的数据通信模型<br><img src="https://i.imgur.com/DNzPKQc.png"></p><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><p>通信的目的是传送消息。  </p><table><thead><tr><th align="center">名称</th><th align="left">概念</th></tr></thead><tbody><tr><td align="center">数据（data）</td><td align="left">运送消息的实体</td></tr><tr><td align="center">信号（signal）</td><td align="left">数据的电气或电磁的表现</td></tr><tr><td align="center">模拟信号</td><td align="left">代表消息的参数的取值是连续的</td></tr><tr><td align="center">数字信号</td><td align="left">代表消息的参数的取值是离散的</td></tr><tr><td align="center">码元（code）</td><td align="left">在使用时间域（一段时间）的波形表示数字信号事，则代表不同离散数值的基本波形就称为码元</td></tr><tr><td align="center">在数字通信过程中常常用时间间隔的符号来表示一个二进制数字，这样的时间间隔内的信称为二进制码元，而这个间隔被称为码元长度。1码元可以携带nbit的信息量。</td><td align="left"></td></tr><tr><td align="center">有关</td><td align="left"></td></tr></tbody></table><h3 id="有关信道的几个基本概念"><a href="#有关信道的几个基本概念" class="headerlink" title="有关信道的几个基本概念"></a>有关信道的几个基本概念</h3><p>信道一般表示向一个方向传送的媒体。所以咱们说平常的通信线路往往包含一条发送信息的信道和一条接受信息的信道。（我发送你接收就是一个简单的信道）</p><table><thead><tr><th align="center">名称</th><th align="left">概念</th></tr></thead><tbody><tr><td align="center">单向通信（单工通信）</td><td align="left">只能有一个方向的通信而没有反向的交互，类似于广播电视台</td></tr><tr><td align="center">双向交替通信（半双工通信）</td><td align="left">通信的双方都可以发送信息，但不能双方同时发送（当然也就不能同时接收）,类似于对讲机</td></tr><tr><td align="center">双向同时通信（全双工通信）</td><td align="left">通信的双方可以同时发送和接收信息</td></tr></tbody></table><h3 id="基带信号换人带通信号"><a href="#基带信号换人带通信号" class="headerlink" title="基带信号换人带通信号"></a>基带信号换人带通信号</h3><p><img src="https://i.imgur.com/KnxEb3E.png"><br><strong>基带信号</strong><br>来自信号源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出去直接表达了要传输的信息的信号，比如我们说话的声波就是基带信号。<br><strong>带通信号</strong><br>把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）</p><blockquote><p>因此在传输距离较近时，计算机网路都采用基带传输方式由于在近距离范围内基带信号的衰弱不大，从而信号内容不会发生变化。因此在传输距离较近时，计算机网络都采用基带传输方式。例如计算机到监视器、打印机等外设的信号就是基带信号。</p></blockquote><h3 id="几种最基本的调制方法"><a href="#几种最基本的调制方法" class="headerlink" title="几种最基本的调制方法"></a>几种最基本的调制方法</h3><table><thead><tr><th align="center">方法名称</th><th align="left">方法的功能</th></tr></thead><tbody><tr><td align="center">调幅（AM）</td><td align="left">载波的振幅随基带数字信号而变化</td></tr><tr><td align="center">调频（FM）</td><td align="left">载波的频率随基带数字信号而变化</td></tr><tr><td align="center">调相（PM）</td><td align="left">载波德初始相位随基带数字信号而变化</td></tr><tr><td align="center"><img src="https://i.imgur.com/tCrNziF.png"></td><td align="left"></td></tr></tbody></table><h3 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h3><table><thead><tr><th align="center">编码名称</th><th align="left">编码的功能</th></tr></thead><tbody><tr><td align="center">单极性不归零码</td><td align="left">只使用一个电压值，用高电压表示1，没电压表示0</td></tr><tr><td align="center">双极性不归零码</td><td align="left">用正电平和负电平分别表示二进制数据的1和0，正负幅值相等</td></tr><tr><td align="center">双极性归零码</td><td align="left">正负零三个电平，信号本身携带同步信息</td></tr><tr><td align="center">曼彻斯特编码</td><td align="left"></td></tr><tr><td align="center">差分曼特斯特编码</td><td align="left"></td></tr><tr><td align="center">(a)单极性不归零码（b）双极性不归零码</td><td align="left"></td></tr><tr><td align="center"><img src="https://i.imgur.com/m3z0Jqf.png"></td><td align="left"></td></tr><tr><td align="center">(a)单极性归零码（b）双极性归零码</td><td align="left"></td></tr><tr><td align="center"><img src="https://i.imgur.com/QNGGiVA.png"></td><td align="left"></td></tr><tr><td align="center"><strong>曼彻斯特编码</strong></td><td align="left"></td></tr><tr><td align="center">采用曼彻斯特编码，一个时钟周期只可表示一个bit，并且必须通过两次采样才能得到一个bit，但它能携带时钟信号，且可表示没有数据传输。</td><td align="left"></td></tr><tr><td align="center">bit中间有信号低-高跳变为0</td><td align="left"></td></tr><tr><td align="center"><img src="https://i.imgur.com/q00MztR.png"></td><td align="left"></td></tr><tr><td align="center">bit中间有信号高-低跳变为1</td><td align="left"></td></tr><tr><td align="center"><img src="https://i.imgur.com/XR4CWy2.png"></td><td align="left"></td></tr><tr><td align="center"><strong>差分曼彻斯特编码</strong></td><td align="left"></td></tr><tr><td align="center">差分曼彻斯特编码与曼彻斯特编码相同，但抗干扰性能强于曼彻斯特编码</td><td align="left"></td></tr><tr><td align="center">bit中间有信号跳变，bit与bit之间也有信号跳变，表示下一个bit为0</td><td align="left"></td></tr><tr><td align="center"><img src="https://i.imgur.com/9bfnWRI.png"></td><td align="left"></td></tr><tr><td align="center">bit中间有信号跳变，bit与bit之间无信号跳变，表示下一个bit为1</td><td align="left"></td></tr><tr><td align="center"><img src="https://i.imgur.com/eYZPosz.png"></td><td align="left"></td></tr><tr><td align="center"><strong>将10001001111进行曼彻斯特和差分曼彻斯特编码</strong></td><td align="left"></td></tr><tr><td align="center"><img src="https://i.imgur.com/iVBijmN.png"></td><td align="left"></td></tr><tr><td align="center"><strong>信道的极限容量</strong></td><td align="left"></td></tr><tr><td align="center">有失真，但可识别</td><td align="left"></td></tr><tr><td align="center"><img src="https://i.imgur.com/y6y5KJz.png"></td><td align="left"></td></tr><tr><td align="center">失真大，无法识别</td><td align="left"></td></tr><tr><td align="center"><img src="https://i.imgur.com/hu7itzE.png"></td><td align="left"></td></tr><tr><td align="center"><strong>奈氏准则</strong></td><td align="left"></td></tr><tr><td align="center">1924年，奈奎斯特就推导出了著名的奈氏准则。他给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。</td><td align="left"></td></tr><tr><td align="center">在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。</td><td align="left"></td></tr><tr><td align="center">如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。</td><td align="left"></td></tr></tbody></table><blockquote><p><strong>理想低通信道的最高码元传输速率&#x3D;2WBaud</strong><br>W是理想低通信道的带宽，单位为HZ。<br>Baud是波特，是码元传输速率的单位。  </p></blockquote><p><strong>波特（Baud）与bit 的区别</strong><br>波特在调解器中经常出现，bit 是信息量<br>如果一个码元含有3个bit 信息量则 1波特 &#x3D; 3bit&#x2F;s<br><img src="https://i.imgur.com/9twRaTx.png"><br><strong>信噪比</strong><br>香农（shannon）用信息论的理论推导出了带宽。受限且有高斯白噪声干扰的信道的<em>极限</em>、<em>无差错的</em>信息传输速率。  </p><blockquote><p><strong>信道的极限信息传输速率 C可表达为</strong><br><img src="https://i.imgur.com/8AaOc8j.png"><br>W为信道的带宽（以Hz为单位）<br>S为信道内所传信号的平均功率<br>N为信道内部的高斯噪音功率<br><strong>香农公式表明</strong><br>信道的带宽或信道中的噪音比越大，则信息的极限传输速率就越高。<br>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。<br>若信道带宽W或信噪比S&#x2F;N没有上才能（当然实际信道不可能是这样的），则信道的极限信息传输速率C也就没有上限。  </p></blockquote><p><strong>奈氏准则和香农公式的应用范围</strong><br><img src="https://i.imgur.com/vbqIra1.png">  </p><h2 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h2><h3 id="电信领域使用的电磁波的频谱"><a href="#电信领域使用的电磁波的频谱" class="headerlink" title="电信领域使用的电磁波的频谱"></a>电信领域使用的电磁波的频谱</h3><p><img src="https://i.imgur.com/SdQ5yIH.png"> </p><blockquote><p>波速一定，波长越长，频率越低。</p></blockquote><h3 id="导向传输媒体"><a href="#导向传输媒体" class="headerlink" title="导向传输媒体"></a>导向传输媒体</h3><p>导向传输媒体中，电磁波沿着固体媒体传播。<br><strong>双绞线</strong><br>1.<strong>屏蔽双绞线（STP）</strong>抗干扰能力强，适合用于长距离传<br>2.<strong>无屏蔽双绞线（UTP）</strong><br><strong>同轴电缆</strong><br>1.<strong>50Ω同轴电缆</strong> 用于数字传输，由于多用于基带传输，也叫基带同轴电缆<br>2.<strong>75Ω同轴电缆</strong>用于模拟传输，即宽带同轴电缆。<br><strong>光缆（光纤）</strong><br><img src="https://i.imgur.com/ddtcqyL.png"><br><img src="https://i.imgur.com/CZlKjJQ.png"><br><img src="https://i.imgur.com/JwUtqbT.png"><br><strong>单模光纤与多模光纤</strong>   </p><blockquote><p>单模光纤指只能传输一种电磁波模式，多模光纤只可以传输多个电磁波模式，实际上单模光纤和多模光纤之分，也就是纤芯的直径之分。单模光纤细，多模光纤粗。在有线电视网络中使用的光纤全是单模光纤，其传播特性好，宽带可达10GHZ,可以再一根光纤中传输60套PAL——D电视节目。<br><img src="https://i.imgur.com/G10nO7u.png"><br><img src="https://i.imgur.com/Gw05dYN.png">  </p></blockquote><h3 id="非导向传输媒体"><a href="#非导向传输媒体" class="headerlink" title="非导向传输媒体"></a>非导向传输媒体</h3><p>非导向车损书媒体就是指自由空间，其中的电磁波传输被称为无线传输。<br><strong>无线传输</strong>所使用的频段很广。<br><strong>短波通信</strong>主要是靠电离层的反射，但短波信道的通信质量较差。<br><strong>微波</strong>在空间主要是直线传播<br>1.地面微波接为通信<br>2.卫星通信  </p><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>这是一个以前的设备，现在都改用交换机，集线器是一个大的冲突域，在某个时间域里只允许一个信道通信，半双工，集线器连的网不安全，计算机越多，带宽越少。<br>工作特点：他的网络中只起到信号放大和重发作用，其目的是扩大网络的传输范围，而不具备信号的定向传送能力<br>最大传输距离：100m  </p><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><p>复用是通信技术中的基本概念<br><img src="https://i.imgur.com/LDLYs2Y.png"></p><h3 id="频分复用-FDM"><a href="#频分复用-FDM" class="headerlink" title="频分复用 FDM"></a>频分复用 FDM</h3><p>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。<br>频道复用的所有用户在同样的时间占用不同的宽带资源（注意：这里的“带宽”是频率带宽而不是数据的发送速率）。<br>打电话利用的就是频分复用技术。</p><h3 id="时分复用技术-TDM"><a href="#时分复用技术-TDM" class="headerlink" title="时分复用技术 TDM"></a>时分复用技术 TDM</h3><p>时分复用则是将时间划分为一段段等长时间的<strong>时分复用帧</strong>。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙。每一个用户所占用的时隙是周期性地出现（其周期就是TDM帧的长度对应的时间）。<br>TDM信号也称<strong>等时</strong>信号。<br>时分复用的所有用户是在不同的时间占用同样的频带宽度。<br><img src="https://i.imgur.com/FPnP27Z.png">  </p><h3 id="统计时分复用-STDM"><a href="#统计时分复用-STDM" class="headerlink" title="统计时分复用 STDM"></a>统计时分复用 STDM</h3><p>放数据的时候加上标记，不用排好顺序，只有在传输中加标记<br><img src="https://i.imgur.com/INKVtFi.png"> </p><h3 id="波分复用-WDM"><a href="#波分复用-WDM" class="headerlink" title="波分复用 WDM"></a>波分复用 WDM</h3><p>波分复用其实就是频分复用，因为波长一定，频率固定波长就固定<br><img src="https://i.imgur.com/QzhVuON.png">  </p><h3 id="码分复用-CDM"><a href="#码分复用-CDM" class="headerlink" title="码分复用 CDM"></a>码分复用 CDM</h3><p>常用名词是马粪多址(CDMA),手机利用的就是码分复用。<br>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。<br>这种系统发送的信号有很强的干扰能力，其频谱类似于白噪声，不易被敌人发现。<br>每一个比特时间划分为m个短的时间间隔，称为码片。<br>缺点：本来发送1bit现在需要mbit才能解决。<br>CDMA的工作原理<br><img src="https://i.imgur.com/yNuXcR3.png">  </p><p><strong>码片序列的正交关系</strong>  </p><blockquote><p>和其他码片正交的值必须是0<br><img src="https://i.imgur.com/UXFlPd8.png">  </p></blockquote><p><strong>正交关系的另一个重要特性</strong>  </p><blockquote><p>任何一个码片向量和该码片向量自己的规格化内积都是1。<br>一个码片向量和该码片反向量的规格化内积值都是-1。<br><img src="https://i.imgur.com/h9qK6uR.png"></p></blockquote><h2 id="数字传输技术"><a href="#数字传输技术" class="headerlink" title="数字传输技术"></a>数字传输技术</h2><p>电话运用的是脉码调制 PCM 体制，最初是为了在电话局之间的中继线上传送多路电话  </p><h2 id="带宽接入技术"><a href="#带宽接入技术" class="headerlink" title="带宽接入技术"></a>带宽接入技术</h2><h3 id="xDSL-用数字技术对现有的模拟电话用户线进行改进"><a href="#xDSL-用数字技术对现有的模拟电话用户线进行改进" class="headerlink" title="xDSL(用数字技术对现有的模拟电话用户线进行改进)"></a>xDSL(用数字技术对现有的模拟电话用户线进行改进)</h3><p>xDLS就是把0~4kHz地段频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。<br><img src="https://i.imgur.com/edQsjRb.png">    </p><h3 id="光纤同轴混合网HFC"><a href="#光纤同轴混合网HFC" class="headerlink" title="光纤同轴混合网HFC"></a>光纤同轴混合网HFC</h3><p>HFC王是在目前覆盖面很广的有线电视网CATV的基础上开发的一种居民宽带接入网。<br>HFC网除可传送CATY外，还提供电话，数据和其他宽带交互型业务。<br>现有的CATV网是树形拓扑结构的同轴电缆网络，它采用<strong>模拟技术的频分复用</strong>对电视节目进行单项传输。而HFC网则需要对CATV网进行改造。  </p><h3 id="FTTx-技术"><a href="#FTTx-技术" class="headerlink" title="FTTx 技术"></a>FTTx 技术</h3><p>FTTx也是一种实现宽带居民接入网的方案，这里字母x可代表不同意思<br><strong>光纤到家FTTH</strong>：光纤一直铺设到用户家庭可能是居民接入网最后的解决方案。<br><strong>光纤到大楼FTTB</strong>:光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。<br><strong>光纤到路边HTTC</strong>：从路边到各用户可使用星型结构双绞线作为传输媒体。  </p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="数据发送模型"><a href="#数据发送模型" class="headerlink" title="数据发送模型"></a>数据发送模型</h2><p><img src="https://i.imgur.com/KkFKDiH.png"><br><img src="https://i.imgur.com/04kkqVs.png">  </p><h2 id="数据链路层的信道类型"><a href="#数据链路层的信道类型" class="headerlink" title="数据链路层的信道类型"></a>数据链路层的信道类型</h2><p>数据线路层使用的信道主要有一下两种类型：<br>1.<strong>点对点信道</strong>：这种信道使用一对一的点对点通信方式。<br>2.<strong>广播信道</strong>：这种信道使用一对多的广播通信方式，因此过程比较复杂。光波通信上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。  </p><h2 id="链路与数据链路"><a href="#链路与数据链路" class="headerlink" title="链路与数据链路"></a>链路与数据链路</h2><h3 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h3><p>链路是一条点到点的物理线路段，中间没有任何其他的点。<br>一条链路只是一条通路的一个组成部分  </p><h3 id="数据链路"><a href="#数据链路" class="headerlink" title="数据链路"></a>数据链路</h3><p>数据链路除了物理线路外，还必须有通信协议来控制这些数据的传输。若把视线这些协议的硬件和软件加到连路上，就构成了数据链路。  </p><h2 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h2><p>帧是链路层传输的内容。<br><img src="https://i.imgur.com/CFBotfT.png">  </p><h2 id="数据链路层的三个问题"><a href="#数据链路层的三个问题" class="headerlink" title="数据链路层的三个问题"></a>数据链路层的三个问题</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>封装成帧就是在一段数据的前后添加首部和尾部，然后就构成了一个帧，确定帧的界限。<br>首部和尾部的一个重要作用就是进行帧的定界。  </p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XLua</title>
      <link href="/2018/05/12/Unity/XLua/"/>
      <url>/2018/05/12/Unity/XLua/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote><p>从**<a href="https://github.com/Tencent/xLua"><font color="steelblue" size="3">这里</font></a>**下载一个zip压缩包，解压后会有Assets等几个文件夹，其他文件夹放进你所创建的unity工程的Assets同级的目录下，然后把加压出来的Assets里的文件和文件夹复制进unity项目的Assets文件夹里即可。</p></blockquote><h1 id="XLua教程"><a href="#XLua教程" class="headerlink" title="XLua教程"></a>XLua教程</h1><h2 id="XLua加载文件"><a href="#XLua加载文件" class="headerlink" title="XLua加载文件"></a>XLua加载文件</h2><h3 id="加载字符串"><a href="#加载字符串" class="headerlink" title="加载字符串"></a>加载字符串</h3><pre><code>1.LuaEnv luaenv = new LuaEnv();  2.luaenv.DoString(&quot;print(&#39;hello world&#39;)&quot;);  </code></pre><blockquote><p>第1行是用来实例LuaEnv虚拟机的，类似于用这个类来实现所有lua的操作，尽量定义为全局，这样优化<br>第2行是通过DoString函数来加载lua脚本，也可直接加载lua脚本内容，如上述代码，print(‘hello world’)就是lua的代码内容。加载就是把lua的脚本加载到luaenv虚拟机里。</p></blockquote><h3 id="加载lua文件"><a href="#加载lua文件" class="headerlink" title="加载lua文件"></a>加载lua文件</h3><pre><code>LuaEnv luaenv = new LuaEnv();//方法一public TextAsset lua_001;//方法二private TextAsset lua_002;//方法三//在Start函数里luaenv.DoString(&quot;require &#39;LuaText/lua_003&#39;&quot;);void Start()&#123;    lua_002 = Resources.Load&lt;TextAsset&gt;(&quot;LuaText/lua_002.lua&quot;);    luaenv.DoString(lua_001.text);    luaenv.DoString(lua_002.text);    luaenv.DoString(&quot;require &#39;LuaText/lua_003&#39;&quot;);&#125;void Update()&#123;&#125;void OnDestroy()&#123;    luaenv.Dispose();&#125;</code></pre><blockquote><p>lua脚本在放在Resources文件夹的时候，后缀必须加上.txt，例如<strong>lua_001.lua.txt</strong>，因为Resources对支持的文件类型有限，也就是无法用Resouces读取.lua文件。  </p><p>方法一是在脚本所挂物体上，通过拖拽赋值变量的方法，直接把lua的脚本拖拽到脚本的变量上，然后通过DoString执行lua文件<br>方法二是先定义TextAsset变量，然后在初始化的时候读取Resources里的文件，然后赋值到变量上，然后通过DoString执行lua文件。<br>方法三此处主要是对require和loader的理解，可以吧loader看成是指向某个路径里的一个个文件，require实际上就是调用一个个loader去加载，和自己所输入文件名字匹配，有一个成功，就不再往下进行查找，全部失败则报找不到文件的错误，目前xLua除了包含自己原本的loader外还包含了Resource所加载的loader，也就是require也可直接读取Resources目录下的文件，类似Resources的读取，但是因为Resource支持的文件类型有限，所以如果lua脚本放进了Resources文件里，就必须在后面加一个.txt的后缀，就像<strong>lua_001.lua.txt</strong>。<br>建议在整个程序中加载脚本只用一个DoString(“require’main’”),然后在main.lua脚本里可以加载自己所需要的其他脚本，其实就只把main.lua脚本看成一个接口脚本，然后在这个脚本里加载其他的lua脚本。  </p></blockquote><h3 id="自定义Loader"><a href="#自定义Loader" class="headerlink" title="自定义Loader"></a>自定义Loader</h3><pre><code>LuaEnv luaenv = null;void Start () &#123;    luaenv = new LuaEnv();    LuaEnv.CustomLoader loader = CustomLoaderMethod;    luaenv.AddLoader(loader);    luaenv.DoString(&quot;require(&#39;main&#39;)&quot;);&#125;// Update is called once per framevoid Update () &#123;    &#125;private byte[] CustomLoaderMethod(ref string filepath)&#123;    if(filepath== &quot;main&quot;)    &#123;        TextAsset lua_003 = Resources.Load&lt;TextAsset&gt;(&quot;LuaText/lua_003.lua&quot;);        return System.Text.Encoding.UTF8.GetBytes(lua_003.text);    &#125;    return null;&#125;</code></pre><blockquote><p>有些脚本可能是程序运行下载下来的，或者是自定义的文件格式里头解压出来的，或者是需要解密的，所以存在文件不在指定的目录里，或者不是规定的lua脚本或者lua.txt格式，这样可有使用自定的loader，就类似于上面脚本，假如loader只包含原生的loader，这样就无法读取Resources里的文件夹，这样可以自定义loader,然后根据所要查找的lua脚本名字，指定到对应所在的地址，然后读取到需要的脚本，把文件里的内容一byte[]的形式回调回来即可，这样require(“脚本名字”)就可以直接执行脚本，不论脚本在什么位置，只要脚本所在的位置已经增加到loader上即可，即用LuaEnv.AddLoader（自己定义的loader），定义loader可以用LuaEnv.CustomLoader loader名字&#x3D;CustomLoaderMethod来定义loader,用private byte[] CustomLoaderMethod(ref string filepath)函数来实现自己定义的loader.<br>通过AddLoader可以注册个回调，该回调参数是字符串，lua代码里头调用require时，参数将会透传给回调，回调中就可以根据这个参数去加载指定文件，如果需要支持调试，需要把filepath修改为真实路径传出。该回调返回值是一个byte数组，如果为空表示该loader找不到，否则则为lua文件的内容。 有了这个就简单了，用IIPS的IFS？没问题。写个loader调用IIPS的接口读文件内容即可。文件已经加密？没问题，自己写loader读取文件解密后返回即可。。。（<strong>此处的IIPS是什么可以不做了解</strong>）</p></blockquote><h2 id="C-访问Lua"><a href="#C-访问Lua" class="headerlink" title="C#访问Lua"></a>C#访问Lua</h2><h3 id="访问全局基本类型"><a href="#访问全局基本类型" class="headerlink" title="访问全局基本类型"></a>访问全局基本类型</h3><p>lua脚本  </p><pre><code>a = 10  b = 100  c = &quot;LianBai&quot;</code></pre><p>c#脚本   </p><pre><code>LuaEnv luaenv = null;private TextAsset luatext;void Start () &#123;    luaenv = new LuaEnv();    luatext = Resources.Load&lt;TextAsset&gt;(&quot;LuaText/lua_004.lua&quot;);    luaenv.DoString(luatext.text);    int a = luaenv.Global.Get&lt;int&gt;(&quot;a&quot;);    string b = luaenv.Global.Get&lt;string&gt;(&quot;b&quot;);    string c = luaenv.Global.Get&lt;string&gt;(&quot;c&quot;);    print(&quot;a = &quot;+a);    print(&quot;b = &quot; + b);    print(&quot;c = &quot; + c);&#125;</code></pre><blockquote><p>C#访问Lua脚本里的变量其实很简单，只需要先用DoString加载脚本，然后在通过luaenv.Global.Get&lt;变量类型&gt;(“变量名”);即可读取自己所需要的基础变量。</p></blockquote><h3 id="访问一个全局的table"><a href="#访问一个全局的table" class="headerlink" title="访问一个全局的table"></a>访问一个全局的table</h3><p>lua脚本  </p><pre><code>d =&#123;    x1=2,    x2=3,    x3=&quot;LianBai&quot;,    4,    5,    6,    add = function(self,a,b)        return a+b    end&#125;</code></pre><h4 id="映射到一个普通的class"><a href="#映射到一个普通的class" class="headerlink" title="映射到一个普通的class"></a>映射到一个普通的class</h4><p>C#脚本</p><pre><code>public class Table1&#123;    public int x2;    public int x1;    public string x3;&#125;Table1 table1 = luaenv.Global.Get&lt;Table1&gt;(&quot;d&quot;);</code></pre><blockquote><p>可以自己测试输出table1的结果，根据结果可以看出lua的table映射到C#的class的时候，并不是按照顺序一一对应进行映射的，而是根据名字映射，lua的table中的x1变量只会映射到C#的class中的x1变量中，如果lua的table里没有class中所包含的变量，则会在class中赋值为空，如果lua中table变量多余class，多余的也不会赋值过来，只会把class所包含的赋值过来。</p></blockquote><h4 id="映射到一个Dictionary中"><a href="#映射到一个Dictionary中" class="headerlink" title="映射到一个Dictionary中"></a>映射到一个Dictionary中</h4><p>C#脚本</p><pre><code>Dictionary&lt;string,double&gt; table2= luaenv.Global.Get&lt;Dictionary&lt;string,double&gt;&gt;(&quot;d&quot;);print(&quot;table1.x1:&quot; + table2[&quot;x1&quot;]);print(&quot;table1.x2:&quot; + table2[&quot;x2&quot;]);</code></pre><blockquote><p>在映射到Dictionary的时候，只会映射符合Dictionary自己定义的规则的变量，把变量名存为keys，把变量值存为对应的数据，所以不会把x3等后面的数据存到Dictionary里。</p></blockquote><h4 id="映射到一个List里"><a href="#映射到一个List里" class="headerlink" title="映射到一个List里"></a>映射到一个List里</h4><p>C#脚本</p><pre><code>List&lt;double&gt; table3= luaenv.Global.Get&lt;List&lt;double&gt;&gt;(&quot;d&quot;);print(&quot;List的Count&quot; + table3.Count);foreach(double i in table3)&#123;    print(&quot;i:&quot; + i);&#125;</code></pre><blockquote><p>在映射到List中，也只会映射到符合List规则的变量，但是有一点要注意的是，table中带keys的不会映射进List，不管储存的变量是不是符合规则，都不会映射进去，所以在上述脚本打印的时候，table3存的值是lua脚本中table中的4,5,6,三个变量。</p></blockquote><h4 id="映射到一个interface"><a href="#映射到一个interface" class="headerlink" title="映射到一个interface"></a>映射到一个interface</h4><p>C#脚本</p><pre><code>[CSharpCallLua]public interface ITable4&#123;    int x1 &#123; get; set; &#125;    int x2 &#123; get; set; &#125;    string x3 &#123; get; set; &#125;    int add(int a, int b);&#125;ITable4 table4 = luaenv.Global.Get&lt;ITable4&gt;(&quot;d&quot;);print(&quot;table4 x1 = &quot; + table4.x1);print(&quot;table4 x2 = &quot; + table4.x2);print(&quot;table4 x3 = &quot; + table4.x3);print(&quot;table4 add = &quot; + table4.add(5, 6));</code></pre><blockquote><p>什么是interface？**<a href="http://www.runoob.com/csharp/csharp-interface.html"><font color="steelblue" size="3">点击这里</font></a>**。理解清楚interface后，从代码里我们可以看出接口类多了一个[CSharpCallLua]，这是在为这个类打上了一个标签，因为与LUA交互的代理和类型需要添加 CSharpCallLua 标签，xlua的特性之一就是标记，这一次与lua交互的特性标记则是[CSharpCallLua]，只有这样写，才可支持热更新。然后接口类的继承和普通类类似，也是根据变量名字一一对应的关系。</p></blockquote><h4 id="映射到一个LuaTable变量"><a href="#映射到一个LuaTable变量" class="headerlink" title="映射到一个LuaTable变量"></a>映射到一个LuaTable变量</h4><p>C#脚本</p><pre><code>LuaTable table5= luaenv.Global.Get&lt;LuaTable&gt;(&quot;d&quot;);print(&quot;table5长度:&quot; + table5.Length);print(&quot;table5.x1:&quot; + table5.Get&lt;int&gt;(&quot;x1&quot;));print(&quot;table5.x2:&quot; + table5.Get&lt;int&gt;(&quot;x2&quot;));print(&quot;table5.x3:&quot; + table5.Get&lt;string&gt;(&quot;x3&quot;));</code></pre><blockquote><p>这是一种by ref方式，所以不会生成代码，但是这种方式比较慢，并且没有变量检测。</p></blockquote><h3 id="访问一个funaction"><a href="#访问一个funaction" class="headerlink" title="访问一个funaction"></a>访问一个funaction</h3><p>Lua脚本</p><pre><code>function e()&#123;    print(&quot;lua脚本的函数&quot;)&#125;function f(a, b)    print(&#39;a&#39;, a, &#39;b&#39;, b)    return 1, 2, &#123;x1 = 1024,x2 = 2048&#125;endfunction ret_e()    print(&quot;LuaScripts return e function&quot;)    return eend</code></pre><h4 id="映射到一个委托（Action或者delgate）"><a href="#映射到一个委托（Action或者delgate）" class="headerlink" title="映射到一个委托（Action或者delgate）"></a>映射到一个委托（Action或者delgate）</h4><p>C#脚本</p><pre><code>public static class AddGenerateList&#123;     [CSharpCallLua]       public static List&lt;Type&gt; CSharpCallLua = new List&lt;Type&gt;()    &#123;        typeof(Action),        typeof(Action&lt;bool&gt;),    &#125;;&#125;Action function1 = luaenv.Global.Get&lt;Action&gt;(&quot;e&quot;);function1();</code></pre><blockquote><p>在把函数映射到Action的时候，一定要把Action添加到生成列表，脚本中第一个静态的AddGenerateList类就是把Action增加到生成列表里。然后才可把函数映射到Action中。否则将会报错。</p></blockquote><h4 id="lua脚本多返回值映射"><a href="#lua脚本多返回值映射" class="headerlink" title="lua脚本多返回值映射"></a>lua脚本多返回值映射</h4><p>C#脚本</p><pre><code>[CSharpCallLua]public delegate int Function2(int a, string b, out int c, out Table1 d);Function2 function2 = luaenv.Global.Get&lt;Function2&gt;(&quot;f&quot;);Table1 table1;int fun2_02;int fun2_01 = function2(66, &quot;LianBai&quot;, out fun2_02, out table1);print(&quot;fun2_01:&quot; + fun2_01);print(&quot;fun2_02:&quot; + fun2_02);print(&quot;table1.x1:&quot; + table1.x1);print(&quot;table1.x2:&quot; + table1.x2);</code></pre><blockquote><p>lua脚本里的函数支持多个返回值，而且返回值的类型也不同，在C#访问lua函数的时候，可以通过上述方法接收lua函数的多个返回值，第一个返回值直接接收映射过来函数的返回值，正如上述脚本里的fun2_01就是第一个返回值，然后后面的返回值均可用out接收，不过映射前声明的时候要用上述的声明方法：<br>[CSharpCallLua]<br>public delegate 第一个返回值类型 Function(参数1,参数2，…, out 第二个返回值,out 第三个返回值，…)</p></blockquote><h4 id="映射lua返回复杂类型的函数"><a href="#映射lua返回复杂类型的函数" class="headerlink" title="映射lua返回复杂类型的函数"></a>映射lua返回复杂类型的函数</h4><p>C#脚本</p><pre><code>[CSharpCallLua]public delegate Action Function3();Function3 function3 = luaenv.Global.Get&lt;Function3&gt;(&quot;ret_e&quot;);print(&quot;第一步：&quot;);function3();print(&quot;第二步：&quot;);Action function3_01 = function3();function3_01();</code></pre><blockquote><p>在C#访问lua的函数返回类型是复杂类型的时候，可以用委托接收，例如上述脚本，访问的函数的返回值是一个函数，在访问的时候，同样用委托接收，不过是两层委托，例如Function3的定义，function3所访问的就是访问对应的函数，然后用一个委托接收function3的返回值，然后就可以访问所返回的函数。</p></blockquote><h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><blockquote><p>1.访问lua全局数据，特别是table以及function，代价比较大，建议尽量少做，比如在初始化时把要调用的lua function获取一次（映射到delegate）后，保存下来，后续直接调用该delegate即可。table也类似。 </p></blockquote><blockquote><p>2.如果lua测的实现的部分都以delegate和interface的方式提供，使用方可以完全和xLua解耦：由一个专门的模块负责xlua的初始化以及delegate、interface的映射，然后把这些delegate和interface设置到要用到它们的地方。</p></blockquote><h2 id="Lua访问C-脚本"><a href="#Lua访问C-脚本" class="headerlink" title="Lua访问C#脚本"></a>Lua访问C#脚本</h2><h3 id="lua创建一个C-的对象"><a href="#lua创建一个C-的对象" class="headerlink" title="lua创建一个C#的对象"></a>lua创建一个C#的对象</h3><p>Lua脚本</p><pre><code>local CShapObject = CS.UnityEngine.GameObject(&quot;LianBai&quot;)</code></pre><blockquote><p>通过上述方法可以用lua脚本创建一个新的gameobject,后面跟的字符串就是物体的名字，所以创建新物体的lua脚本就是**local lua函数名 &#x3D; CS.对象(class)命名空间.C#对象(class)名(参数)**。</p></blockquote><h3 id="lua访问C-的静态属性、静态方法"><a href="#lua访问C-的静态属性、静态方法" class="headerlink" title="lua访问C#的静态属性、静态方法"></a>lua访问C#的静态属性、静态方法</h3><p>C#脚本</p><pre><code>LuaEnv luaenv = null;private TextAsset luatext;namespace MySpace&#123;    [LuaCallCSharp]    public static class CShapStaticClass    &#123;        public static int a = 10;        public static string b = &quot;LianBai&quot;;    &#125;&#125;luaenv = new LuaEnv();luatext = Resources.Load&lt;TextAsset&gt;(&quot;LuaText/lua_005.lua&quot;); luaenv.DoString(luatext.text);print(CShapStaticClass.a);</code></pre><p>Lua脚本</p><pre><code>local CShapObject = CS.UnityEngine.GameObject(&quot;LianBai&quot;)local a=CS.MySpace.CShapStaticClass.alocal b=CS.MySpace.CShapStaticClass.bCS.MySpace.CShapStaticClass.a=66print(a);print(b);</code></pre><blockquote><p>lua在访问c#的静态变量时与创建对象类似，CS.命名空间.静态类.静态变量<br>如果需要经常访问的类，可以先用局部变量引用后访问，除了减少敲代码的时间，还能提高性能。</p></blockquote><h3 id="lua访问C-成员属性、方法"><a href="#lua访问C-成员属性、方法" class="headerlink" title="lua访问C#成员属性、方法"></a>lua访问C#成员属性、方法</h3><h4 id="lua访问普通的类"><a href="#lua访问普通的类" class="headerlink" title="lua访问普通的类"></a>lua访问普通的类</h4><p>C#脚本</p><pre><code>[LuaCallCSharp]public class CShapClass02&#123;    public int c = 99;    public void Class02Fun01()    &#123;        Debug.Log(&quot;This is CShapClass01&#39;s function d&quot;);    &#125;&#125;</code></pre><p>lua脚本</p><pre><code>local LuaClass02 = CS.MySpace.CShapClass02local luaclass02 = LuaClass02()print(luaclass02.c)luaclass02.c = 88luaclass02:Class02Fun01()</code></pre><blockquote><p>lua在访问C#的成员属性和方法的时候，先用变量映射出C#的类，然后再用一个变量接收。local 变量1 &#x3D; CS.类所在命名空间.类名,变量1是映射过来的对象的声明，需要自己定义一个对象，local 变量2 &#x3D; 变量1()，即变量2就是所映射过来的类的实例，通过<strong>变量2.变量名</strong>就可访问变量，通过**变量2: 函数名()**就可启用C#的函数。</p></blockquote><h4 id="lua访问继承的类"><a href="#lua访问继承的类" class="headerlink" title="lua访问继承的类"></a>lua访问继承的类</h4><p>C#脚本</p><pre><code>[LuaCallCSharp]public class CShapClass01&#123;    public static int a = 1;    public static string b = &quot;LianBai&quot;;    public static void Class01Fun01()    &#123;        Debug.Log(&quot;This is Class01Fun01&quot;);    &#125;    public void Class01Fun02()    &#123;        Debug.Log(&quot;This is Class01Fun02&quot;);    &#125;&#125;[LuaCallCSharp]public class CShapClass02: CShapClass01&#123;    public int c = 99;    public void Class02Fun01()    &#123;        Debug.Log(&quot;This is CShapClass01&#39;s function d&quot;);    &#125;&#125;</code></pre><p>lua脚本  </p><pre><code>local LuaClass02 = CS.MySpace.CShapClass02local luaclass02 = LuaClass02()print(luaclass02.c)print(LuaClass02.a)print(LuaClass02.b)luaclass02.c = 88luaclass02:Class02Fun01()LuaClass02.Class01Fun01()luaclass02:Class01Fun02()</code></pre><blockquote><p>lua在访问C#的含有继承类的类的时候，访问基类普通变量和访问子类一样，用<strong>变量2.变量名</strong>，和<strong>变量2：函数名</strong>来访问，但是在访问基类的静态变量的时候，通过<strong>变量1.变量名</strong>来访问基类<strong>静态变量</strong>，通过<strong>变量1：函数名</strong>来访问基类<strong>静态函数</strong>。xlua支持（通过派生类）访问基类的静态属性，静态方法，（通过派生类实例）访问基类的成员属性，成员方法。</p></blockquote><h4 id="访问复杂函数"><a href="#访问复杂函数" class="headerlink" title="访问复杂函数"></a>访问复杂函数</h4><p>C#脚本</p><pre><code>[LuaCallCSharp]public class CShapClass02&#123;    public int c = 99;    public void Class02Fun01()    &#123;        Debug.Log(&quot;This is CShapClass01&#39;s function d&quot;);    &#125;    public double Class02Fun02(CShapClass01 cshapclass01,ref int x1,out string x2,Action luafun,out Action csfun)    &#123;        Debug.Log(cshapclass01.c + &quot; : &quot; + cshapclass01.d);        luafun();        x1 = x1 * cshapclass01.c;        x2 = &quot;CShapClass01.d = &quot; + cshapclass01.d;        csfun = () =&gt;        &#123;            Debug.Log(&quot;This is CsFun&quot;);        &#125;;        Debug.Log(x1 + &quot; : &quot; + x2);        return 6.66;    &#125;&#125;</code></pre><p>Lua脚本</p><pre><code>local LuaClass02 = CS.MySpace.CShapClass02local luaclass02 = LuaClass02()function LuaFun()    print(&quot;This is LuaFun&quot;)endlocal cshapclass01,x1,x2,csfun = luaclass02:Class02Fun02(&#123;c = 100,d = &quot;LianHei&quot;&#125;,88,LuaFun)print(&quot;cshapclass01:&quot;,cshapclass01)print(&quot;x1:&quot;, x1)print(&quot;x2:&quot;, x2)print(&quot;csfun:&quot;, csfun)csfun();</code></pre><blockquote><p>参数的输入输出属性（out，ref）<br>Lua调用测的参数处理规则：C#的普通参数算一个输入形参，ref修饰的算一个输入形参，out不算，然后从左往右对应lua 调用测的实参列表；<br>Lua调用测的返回值处理规则：C#函数的返回值（如果有的话）算一个返回值，out算一个返回值，ref算一个返回值，然后从左往右对应lua的多返回值。  </p><p>上述话的意思是lua在映射复杂的函数的时候，C#函数中的参数中有普通参数，ref定义的参数，out定义的参数，例如上述的<em>Class02Fun02</em>函数中<em>CShapClass01 cshapclass01</em>是普通的参数，就是我们正常定义的参数，<em>ref int x1</em>和<em>out string x2</em>分别是ref和out定义的参数，在lua调用的时候，<em>luaclass02:Class02Fun02({c &#x3D; 100,d &#x3D; “LianHei”},88,LuaFun)<em>，第一个表</em>{c &#x3D; 100,d &#x3D; “LianHei”}<em>是给</em>cshapclass01</em>传参数，88传给的是x1,LuaFun是传给的,Action luafun,因为x2和csfun是out形容的参数，所以不用传递。  </p><p>ref定义的参数，在调用的时候要传参数，在返回的时候也要接收，out定义的参数在调用的时候不用传递参数，但是在接收的时候要接收参数<br>在调用这个函数的时候会执行C#脚本里面的函数，然后函数会有返回值，如果函数本身就有返回值，则lua脚本在接收的第一个返回值就是函数的返回值，然后在C#函数中有些参数是ref或者out参数，这些参数从左往右依次都是函数的返回值，所以在C#函数里必须为这些参数赋值。</p></blockquote><h4 id="访问重载方法"><a href="#访问重载方法" class="headerlink" title="访问重载方法"></a>访问重载方法</h4><p>C#脚本</p><pre><code>[LuaCallCSharp]public class CShapClass03&#123;    public void CShapFun()    &#123;        Debug.Log(&quot;This is NULL&quot;);    &#125;    public void CShapFun(int a)    &#123;        Debug.Log(&quot;This is int&quot;);    &#125;    public void CShapFun(string a)    &#123;        Debug.Log(&quot;This is string&quot;);    &#125;&#125;</code></pre><p>Lua脚本</p><pre><code>local LuaClass03 = CS.MySpace.CShapClass03local luaclass03 = LuaClass03()luaclass03:CShapFun()luaclass03:CShapFun(2)luaclass03:CShapFun(&quot;LianBai&quot;)</code></pre><blockquote><p>在C#里运行脚本可以看出，在访问重载函数的时候，只要改变穿进去的参数，就会自动调用重载对应的函数。<br>注意：xlua只一定程度上支持重载函数的调用，因为lua的类型远远不如C#丰富，存在一对多的情况，比如C#的int，float，double都对应于lua的number，上面的例子中TestFunc如果有这些重载参数，第一行将无法区分开来，只能调用到其中一个（生成代码中排前面的那个）</p></blockquote><h4 id="调用操作符"><a href="#调用操作符" class="headerlink" title="调用操作符"></a>调用操作符</h4><p>C#脚本</p><pre><code>[LuaCallCSharp]public class CShapClass03&#123;    public int a = 66;    public string b = &quot;LianBai&quot;;    public static CShapClass03 operator + (CShapClass03 class1, CShapClass03 class2)    &#123;        CShapClass03 ret = new CShapClass03();        ret.a = class1.a + class2.a;        ret.b = class1.b + class2.b;        return ret;    &#125;&#125;</code></pre><p>Lua脚本</p><pre><code>local LuaClass03 = CS.MySpace.CShapClass03local luaclass03 = LuaClass03()local luaclass04 = LuaClass03()print(luaclass03.a)print(luaclass04.b)luaclass04.a = 88print(luaclass04.a)print(&quot;This &quot;,(luaclass03 + luaclass04).a)luaclass03.b=&quot;I am &quot;print((luaclass03+luaclass04).b)</code></pre><blockquote><p>在lua使用所访问的对象的操作符的时候，在对象内部必须重载此运算符，这样才可以使用此运算符，C#的运算符可以自己百度查询。然后在类里面即可像C#里面一样调用，允许操作的运算符有：<br>+，-，*，&#x2F;，&#x3D;&#x3D;，一元-，&lt;，&lt;&#x3D;， %，[]</p></blockquote><h4 id="访问含默认值方法"><a href="#访问含默认值方法" class="headerlink" title="访问含默认值方法"></a>访问含默认值方法</h4><p>C#脚本</p><pre><code>public void CShapClass03DefaultFun(int a = 66,string b = &quot;LianBai&quot;,string c = null)&#123;    Debug.Log(&quot;a = &quot; + a + &quot; b = &quot; + b + &quot; c = &quot; + c);&#125;</code></pre><p>Lua脚本  </p><pre><code>local LuaClass03 = CS.MySpace.CShapClass03local luaclass03 = LuaClass03()luaclass03:CShapClass03DefaultFun()luaclass03:CShapClass03DefaultFun(88)luaclass03:CShapClass03DefaultFun(88,&quot;LianHei&quot;)luaclass03:CShapClass03DefaultFun(88,&quot;LianHei&quot;,&quot;COOL&quot;)</code></pre><blockquote><p>在访问含有默认值的方法时，在lua里调用函数和C#调用有默认值参数的函数一样，如果所给的实参少于形参，则会用默认值补上。  </p></blockquote><h4 id="访问可变参数方法"><a href="#访问可变参数方法" class="headerlink" title="访问可变参数方法"></a>访问可变参数方法</h4><p>C#脚本</p><pre><code>[LuaCallCSharp]public class CShapClass03&#123;    public int a = 66;    public string b = &quot;LianBai&quot;;    public void CShapClassVariableFun(int a,params string[] str)    &#123;        string s = null;        foreach(string c in str)        &#123;            s = s + c +&quot; &quot;;        &#125;        Debug.Log(&quot;a = &quot; + a + &quot;  str = &quot; + s);    &#125;&#125;</code></pre><p>Lua脚本</p><pre><code>local LuaClass03 = CS.MySpace.CShapClass03local luaclass03 = LuaClass03()luaclass03:CShapClassVariableFun(10,&quot;I&quot;)luaclass03:CShapClassVariableFun(20,&quot;I&quot;,&quot;am&quot;)luaclass03:CShapClassVariableFun(30,&quot;I&quot;,&quot;am&quot;,&quot;LianBai&quot;)</code></pre><blockquote><p>lua在访问的方法中含有可变参数（<a href="http://www.runoob.com/csharp/csharp-param-arrays.html"><font color="steelblue">params</font></a>）的时候，也可以类似于在C#脚本的使用方法传进去参数。</p></blockquote><h4 id="映射枚举并访问枚举"><a href="#映射枚举并访问枚举" class="headerlink" title="映射枚举并访问枚举"></a>映射枚举并访问枚举</h4><p>C#脚本</p><pre><code>[LuaCallCSharp]public enum MyEnum&#123;    x1 = 66,    x2 = 88,    x3 = 99&#125;[LuaCallCSharp]public class CShapClass04&#123;    public MyEnum CShapEnumFun(MyEnum e)    &#123;        Debug.Log(&quot;MyEnum:&quot; + e);        return e;    &#125;&#125;</code></pre><p>Lua脚本</p><pre><code>local LuaEnum = CS.MySpace.MyEnumprint(LuaEnum.__CastFrom(&quot;x1&quot;),LuaEnum.__CastFrom(&quot;x2&quot;),LuaEnum.__CastFrom(&quot;x3&quot;))local LuaClass04 = CS.MySpace.CShapClass04local luaclass04 = LuaClass04()local luaenum = luaclass04:CShapEnumFun(CS.MySpace.MyEnum.x1)print(luaenum,luaenum == LuaEnum.x1)print(LuaEnum.__CastFrom(0),LuaEnum.__CastFrom(1),LuaEnum.__CastFrom(2))</code></pre><blockquote><p>在映射枚举的时候，直接像类一样直接声明枚举对象就可调用，方法是：<strong>local 变量1 &#x3D; CS.枚举所在命名空间.枚举名</strong>，然后就可以通过<strong>变量1.key值</strong>就可访问枚举中的对象。<br>在映射类里面含有枚举参数的时候，可以直接通过**CS.枚举所在命名空间.枚举名.key值”<strong>直接传进key对应的值，也可直接通过映射过来的变量1，通过</strong>变量1.key值”<strong>访问对应的key值。<br>如果枚举类加入到生成代码的话，枚举类将支持</strong>__CastFrom()**方法，可以实现从一个整数或者字符串到枚举值的转换。（<font color="red">注：CastFrom前面是两个英文的下划线</font>)  </p></blockquote><h4 id="Lua访问C-委托"><a href="#Lua访问C-委托" class="headerlink" title="Lua访问C#委托"></a>Lua访问C#委托</h4><p>C#脚本</p><pre><code>[LuaCallCSharp]public class CShapClass04&#123;    public MyEnum CShapEnumFun(MyEnum e)    &#123;        Debug.Log(&quot;MyEnum:&quot; + e);        return e;    &#125;    public static Action&lt;string&gt; CShapStaticAction;    public Action&lt;string&gt; CShapAction = (param) =&gt;    &#123;        Debug.Log(&quot;This is My CShapAction：&quot; + param);    &#125;;public delegate void CShapDelegate(string obj);&#125;[LuaCallCSharp]public class CShapClass05&#123;    public CShapClass04.CShapDelegate MyClassFun = null;    public CShapClass05()    &#123;        MyClassFun = new CShapClass04.CShapDelegate(MyAction) ;    &#125;    private void MyAction(string obj)    &#123;        Debug.Log(&quot;This is My CShapDelegates：&quot; + obj);    &#125;&#125;MySpace.CShapClass04.CShapStaticAction += MyStaticAction;</code></pre><p>Lua脚本</p><pre><code>local LuaClass04 = CS.MySpace.CShapClass04local luaclass04 = LuaClass04()local LuaClass05 = CS.MySpace.CShapClass05local luaclass05 = LuaClass05()LuaClass04.CShapStaticAction(&quot;LianBai&quot;)luaclass04.CShapAction(&quot;LianBai&quot;)local MyLuaClass = luaclass05.MyClassFun上MyLuaClass(&quot;LianBai&quot;)MyLuaClass(&quot;LianBai&quot;)local function LuaAction(str)    print(&quot;This is LuaAction :&quot;,str)endlocal luaaction = LuaAction + LuaClass04.CShapStaticActionluaaction(&quot;+&quot;)local luaaction = LuaClass04.CShapStaticAction - LuaActionluaaction(&quot;-&quot;)local luaaction = LuaClass04.CShapStaticAction + LuaActionluaaction(&quot;+2&quot;)local luaaction = LuaClass04.CShapStaticAction - LuaActionluaaction(&quot;-2&quot;)</code></pre><blockquote><p>C#的委托关键字是delegate,Action和Func都是别人封装好的委托，通过上述方法可以观测到，delegate在定义委托的时候，默认就是静态的方法，但是Action定义委托的时候需要手动添加关键字，如果没有添加关键字，只能通过对象调用，但是无法传递参数，因为delegate本身是静态的，所以导致无法使用，关于delegate和Action、Func的区别请**<a href="https://blog.csdn.net/cubesky/article/details/39577879"><font color="steelblue" size="3">点击这里</font></a>**  、<br>通过上述脚本，测试可发现，lua在访问委托的时候，和调用普通的函数方法一样。<br>+操作符：对应C#的+操作符，把两个调用串成一个调用链，右操作数可以是同类型的C# delegate或者是lua函数。<br>-操作符：和+相反，把一个delegate从调用链中移除。<br>+操作符左右任意一个是delegate就可以，但是-操作符delegate必须放在左边<br>Ps：delegate属性可以用 一个luafunction来赋值。</p></blockquote><h4 id="Lua访问类的事件-Event"><a href="#Lua访问类的事件-Event" class="headerlink" title="Lua访问类的事件(Event)"></a>Lua访问类的事件(Event)</h4><p>C#脚本  </p><pre><code>[LuaCallCSharp]public class DelegateClass&#123;    public delegate void MyDelegate();  //定义一个委托    public event MyDelegate myevent;    //定义了一个事件    public void ClassFun01()    &#123;        myevent();    &#125;&#125;</code></pre><p>Lua脚本  </p><pre><code>local LuaClass = CS.MySpace01.DelegateClasslocal luaclass = LuaClass()local function luafun01()    print(&quot;This is luafun01&quot;)endlocal function luafun02()    print(&quot;This is luafun02&quot;)endluaclass:myevent(&quot;+&quot;,luafun01)luaclass:ClassFun01()luaclass:myevent(&quot;+&quot;,luafun02)luaclass:ClassFun01()luaclass:myevent(&quot;-&quot;,luafun01)luaclass:ClassFun01()</code></pre><blockquote><p>Lua在访问<a href="http://www.runoob.com/csharp/csharp-event.html"><font color="steelblue">Event</font></a>的时候，添加事件回调的方法是**类对象:委托名(“+”,函数名)<strong>，同样的，在移除事件回调的时候是</strong>类对象:委托名(“-“,函数名)**。</p></blockquote><h4 id="Lua访问64位整数"><a href="#Lua访问64位整数" class="headerlink" title="Lua访问64位整数"></a>Lua访问64位整数</h4><p>C#脚本</p><pre><code>public ulong LongFun(long l)&#123;    return (ulong)l + 1;&#125;</code></pre><p>Lua脚本</p><pre><code>local LuaClass = CS.MySpace01.DelegateClasslocal luaclass = LuaClass()local a = luaclass:LongFun(11)print(type(a),a+10,a+100,a+1000,a+10000)</code></pre><blockquote><p>Lua53版本64位整数（long，ulong）映射到原生的64未整数，而luaji版本t，相当于lua5.1的标准，本身不支持64位，xlua做了个64位支持的扩展库，C#的long和ulong都将映射到userdata：<br>支持在lua里头进行64位的运算，比较，打印<br>支持和lua number的运算，比较<br>要注意的是，在64扩展库中，实际上只有int64，ulong也会先强转成long再传递到lua，而对ulong的一些运算，比较，我们采取和java一样的支持方式，提供一组API，详情请看API文档。</p></blockquote><h4 id="C-复杂类型和table的转换"><a href="#C-复杂类型和table的转换" class="headerlink" title="C#复杂类型和table的转换"></a>C#复杂类型和table的转换</h4><p>C#脚本</p><pre><code>[LuaCallCSharp]public class MyClass01&#123;    public int a;    public void Show()    &#123;        Debug.Log(&quot;This is MyClass01&#39;s a:&quot; + a);    &#125;&#125;[LuaCallCSharp]public class MyClass02&#123;    public MyClass01 a;    public string b;    public void Show()    &#123;        a.Show();        Debug.Log(&quot;This is MyClass02&#39;s b:&quot; + a);    &#125;&#125;[LuaCallCSharp]public class MyClass03&#123;    public void Set(MyClass02 my)    &#123;        my.Show();    &#125;&#125;</code></pre><p>Lua脚本</p><pre><code>local LuaClass = CS.MySpace01.MyClass03local luaclass = LuaClass()luaclass:Set(&#123;a=&#123;a=66&#125;,b=&quot;LianBai&quot;&#125;)</code></pre><blockquote><p>Lua在访问复杂的Class参数时，一个{}就是一个类，如果想用上述方法，变量必须public，这样lua才能根据变量名进行赋值，就像一开头讲的，根据变量名字进行赋值。</p></blockquote><h4 id="Lua获取C-的类型-相当于C-的typeof"><a href="#Lua获取C-的类型-相当于C-的typeof" class="headerlink" title="Lua获取C#的类型(相当于C#的typeof)"></a>Lua获取C#的类型(相当于C#的typeof)</h4><p>Lua脚本<br>    print(typeof(CS.MySpace01))</p><blockquote><p>要获取CS.MySpace01类的Type信息，可以用上述脚本</p></blockquote><h4 id="Lua强转数据"><a href="#Lua强转数据" class="headerlink" title="Lua强转数据"></a>Lua强转数据</h4><p>C#脚本</p><pre><code>[LuaCallCSharp]public interface MyClass04&#123;    void  Show(int a, string b);&#125;[LuaCallCSharp]public class MyClass05 : MyClass04&#123;    public int ID = 88;    public void Show(int a, string b)    &#123;        Debug.Log(a);        Debug.Log(b);    &#125;    public MyClass04 GetClass04()    &#123;        return new MyClass05();    &#125;&#125;</code></pre><p>Lua脚本</p><pre><code>local LuaClass01 = CS.MySpace01.MyClass05 local luaclass01 = LuaClass01()local luainterface01 = luaclass01:GetClass04()luainterface01:Show(66,&quot;LianBai&quot;)assert(luainterface01.ID == 88)--assert(luainterface01.ID == nil)local LuaClass02 = CS.MySpace01.MyClass05 local luaclass02 = LuaClass02()local luainterface02 = luaclass02:GetClass04()cast(luainterface02,typeof(CS.MySpace01.MyClass04))luainterface02:Show(88,&quot;LianHei&quot;)--assert(luainterface02.ID == 88)assert(luainterface02.ID == nil)</code></pre><blockquote><p>什么是<a href="http://www.runoob.com/lua/lua-error-handling.html"><font color="steelblue">assert</font></a>？<br>通过上代码演示和输出，我们不难看出第一种访问和第二种访问的区别，如果我们把lua里面注释掉的两个代码解放开，就会抛出异常，我们在访问interface或者抽象的时候，我们的实现类都是隐藏的，所以，在访问的时候是进行映射到C#脚本里，其实还是在C#脚本里运行，这就是映射过去，所以我们第一种访问，依旧可以访问到ID，因为C#里有ID这个变量，其实luainterface只是C#的类的映射，本质还是C#的类，然后我们在第二种方法中，只是添加了一个**cast(luainterface02,typeof(CS.MySpace01.MyClass04))**这样我们就告诉lua，把这个接口加到生成代码里，所以我们就是把接口类放进了lua文件里，只是我们看不见而已，这样我们的接口就不存在ID这个变量了。但是方法依然存在。<br>lua没类型，所以不会有强类型语言的“强转”，但有个有点像的东西：告诉xlua要用指定的生成代码去调用一个对象，这在什么情况下能用到呢？有的时候第三方库对外暴露的是一个interface或者抽象类，实现类是隐藏的，这样我们无法对实现类进行代码生成。该实现类将会被xlua识别为未生成代码而用反射来访问，如果这个调用是很频繁的话还是很影响性能的，这时我们就可以把这个interface或者抽象类加到生成代码，然后指定用生成代码来访问。</p></blockquote><h1 id="XLua配置"><a href="#XLua配置" class="headerlink" title="XLua配置"></a>XLua配置</h1>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
