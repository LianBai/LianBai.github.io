<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LianBai</title>
  
  <subtitle>手握日月摘星辰，世间无我这般人。</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-02-18T07:23:45.913Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LianBai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity杂文——扩展Inspector面板(一)</title>
    <link href="http://yoursite.com/2022/02/18/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95Inspector%E9%9D%A2%E6%9D%BF(%E4%B8%80)/"/>
    <id>http://yoursite.com/2022/02/18/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95Inspector%E9%9D%A2%E6%9D%BF(%E4%B8%80)/</id>
    <published>2022-02-18T05:45:59.000Z</published>
    <updated>2022-02-18T07:23:45.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在使用unity的时候我们会经常使用到inspector面板来查看我们选中对象的信息，也会经常修改一些信息，但是，untiy默认的指挥显示我们组件上序列化的信息，也并不是所有的序列化的信息都显示，我们只需要添加**[HideInInspector]**标签就可以隐藏信息。但是这些并不能满足我们修改信息的需求，unity也为我们提供了自动绘制面板，这样我们不仅仅有修改字段的功能，还可以添加更多的功能了。  </p><h1 id="自定义绘制Inspector"><a href="#自定义绘制Inspector" class="headerlink" title="自定义绘制Inspector"></a>自定义绘制Inspector</h1><p>笔者是以自己写的一个UI的动画控制器为例来讲解的。  </p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>存放文件的目录如下  </p><blockquote><p>—Asset<br>——Scripts<br>———Editor<br>————UIAnimManagerEditor.cs<br>———Engine<br>————UIAnimManager.cs  </p></blockquote><h2 id="组件脚本"><a href="#组件脚本" class="headerlink" title="组件脚本"></a>组件脚本</h2><p>首先我们先创建一个需要绘制的脚本：  </p><pre><code>/// &lt;summary&gt;/// 动画播放状态/// &lt;/summary&gt;public enum UIAnimPlayState&#123;    Stop,                   //停止    Playing,                //播放中    Pause,                  //暂停    Finish,                 //完成&#125;/// &lt;summary&gt;/// 动画播放控制器/// &lt;/summary&gt;public class UIAnimManager : MonoBehaviour&#123;    public float m_SumTime;                                                     //总时间    public bool m_IsDefReversed;                                                //默认的是否倒放    public bool m_IsDefLoop;                                                    //默认的是否循环    public bool m_IsDefAutoPlay;                                                //默认的是否自动播放        [NonSerialized]    public float m_CurTime;                                                     //当前时间    [NonSerialized]    public UIAnimPlayState m_UIAnimPlayState = UIAnimPlayState.Stop;            //当前状态&#125;</code></pre><p>下面我们来看看默认的inspector的面板显示：  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1645165132213-2022-2-1814:18:53.png"></p><p>不仅仅**[HideInInspector]<strong>标签会隐藏字段，</strong>[NonSerialized]**标记没有序列化的字段也不会显示出来。  </p><h2 id="绘制Inspector面板脚本-CustomEditor"><a href="#绘制Inspector面板脚本-CustomEditor" class="headerlink" title="绘制Inspector面板脚本(CustomEditor)"></a>绘制Inspector面板脚本(CustomEditor)</h2><pre><code>[CustomEditor(typeof(UIAnimManager))]public class UIAnimManagerEditor : UnityEditor.Editor&#123;    #region 字段    private UIAnimManager m_UIAnimManager;                                      //面板的脚本        private SerializedProperty m_IsDefReversed;                                 //是否倒放    private SerializedProperty m_IsDefLoop;                                     //是否循环    private SerializedProperty m_IsDefAutoPlay;                                 //是否自动播放    #endregion        #region 继承方法    private void OnEnable()    &#123;        m_UIAnimManager = (UIAnimManager) target;                               //获取绑定的脚本                m_IsDefReversed = serializedObject.FindProperty(&quot;m_IsDefReversed&quot;);     //获取m_IsDefReversed字段        m_IsDefLoop = serializedObject.FindProperty(&quot;m_IsDefLoop&quot;);             //获取m_IsDefLoop字段        m_IsDefAutoPlay = serializedObject.FindProperty(&quot;m_IsDefAutoPlay&quot;);     //获取m_IsDefAutoPlay字段    &#125;    /// &lt;summary&gt;    /// 自定义绘制Inspector面板    /// &lt;/summary&gt;    public override void OnInspectorGUI()    &#123;        OnPropertyFieldGUI();    &#125;    #endregion        #region 自定义方法    /// &lt;summary&gt;    /// 绘制属性字段    /// &lt;/summary&gt;    private void OnPropertyFieldGUI()    &#123;        EditorGUI.BeginChangeCheck();                                       //监听面板是否发生变化        &#123;            EditorGUILayout.PropertyField(m_IsDefReversed);                 //绘制m_IsDefReversed属性            EditorGUILayout.PropertyField(m_IsDefLoop);                     //绘制m_IsDefLoop属性            EditorGUILayout.PropertyField(m_IsDefAutoPlay);                    //绘制m_IsAutoPlay属性        &#125;        if (EditorGUI.EndChangeCheck())                                     //如果发生变化为true        &#123;            EditorUtility.SetDirty(target);                                 //标记用于触发保存            serializedObject.ApplyModifiedProperties();                     //更新序列化的数据        &#125;    &#125;    #endregion&#125;</code></pre><p>如上述代码，编写脚本只需要类上面打上**[CustomEditor(typeof(UIAnimManager))]<strong>即可，中间的UIAnimManager换成需要绑定的类即可，然后在代码中继承</strong>OnInspectorGUI**方法，在这个方法里绘制自己想绘制的面板。<br>绘制样子如下：  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1645168657839-2022-2-1815:17:38.png">  </p><h2 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h2><p>首先开<strong>OnEnable</strong>函数里：  </p><blockquote><p>m_UIAnimManager = (UIAnimManager) target;获取当前绑定的脚本对象<br>serializedObject.FindProperty是获取脚本上的属性，是拿这些属性绘制的  </p></blockquote><p><strong>OnInspectorGUI</strong>函数就是我们编写绘制Inspector面板的函数，在代码里我们可以编写untiy提供的编辑器代码，笔者这里只是通过EditorGUILayout.PropertyField来绘制属性，也可以使用其他unity的编辑器绘制代码，这里就不举例了。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在使用unity的时候我们会经常使用到inspector面板来查看我们选中对象的信息，也会经常修改一些信息，但是，untiy默认的指挥显示我</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Unity编辑器" scheme="http://yoursite.com/tags/Unity%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>解决Hexo博客提交Warning</title>
    <link href="http://yoursite.com/2022/01/29/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E8%A7%A3%E5%86%B3Hexo%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4Warning/"/>
    <id>http://yoursite.com/2022/01/29/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E8%A7%A3%E5%86%B3Hexo%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4Warning/</id>
    <published>2022-01-29T07:19:22.000Z</published>
    <updated>2022-01-29T07:26:23.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Warning-Accessing-non-existent-property-‘XXX’-of-module-exports-inside-circular-dependency"><a href="#Warning-Accessing-non-existent-property-‘XXX’-of-module-exports-inside-circular-dependency" class="headerlink" title="Warning: Accessing non-existent property ‘XXX’ of module exports inside circular dependency"></a>Warning: Accessing non-existent property ‘XXX’ of module exports inside circular dependency</h1><p>笔者在更新本地npm和node后，提交hexo博客的时候遇到了这个问题。原因在于本地node的版本太高导致的。  </p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>降低node的版本，选择一个低版本的node，node的12版本应该就可以。  </p><p><a href="https://nodejs.org/download/release/"><font color=steelblue size=5>node各版本下载</font></a>  </p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>笔者并不想更新node版本，于是笔者找到了第二种解决方案，在博客目录下：  </p><pre><code>myBlog\node_modules\nib\node_modules\stylus\lib\nodes\index.jsmyBlog\node_modules\stylus\lib\nodes\index.js.</code></pre><p>上面两个路径下的<strong>index.js</strong>文件的前面分别添加下面代码即可。(两个文件都需要添加)  </p><pre><code>exports.lineno = null;exports.column = null;exports.filename = null;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Warning-Accessing-non-existent-property-‘XXX’-of-module-exports-inside-circular-dependency&quot;&gt;&lt;a href=&quot;#Warning-Accessing-non-existent</summary>
      
    
    
    
    <category term="搭建博客" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客Warning" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2Warning/"/>
    
  </entry>
  
  <entry>
    <title>UnityECS入门(三)——写一个简单的ECS</title>
    <link href="http://yoursite.com/2022/01/29/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%B8%89)%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84ECS/"/>
    <id>http://yoursite.com/2022/01/29/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%B8%89)%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84ECS/</id>
    <published>2022-01-29T03:12:57.000Z</published>
    <updated>2022-02-17T06:34:47.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><pre><code>unity: 2020.3.18f1Entities: 0.17.0Jobs: 0.8.0</code></pre><h1 id="SimpleECS"><a href="#SimpleECS" class="headerlink" title="SimpleECS"></a>SimpleECS</h1><p>一个简单的ECS应该包括Entity、Component和System，接下来笔者就带着大家写一个简单的ECS。  </p><h2 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h2><p>unity的<strong>Entity是已经封装好的，不需要自己创建</strong>。笔者一开始也没有理解，每个实例不一样，为啥不是自己制作Entity，笔者目前的理解是Entity就像一个没有任何属性的GameObject，我们是通过给这个空的GameObject添加Component来组成我们理解的实体对象。<br>下面我们来分析一下Entity，源码如下：  </p><pre><code>using System;namespace Unity.Entities&#123;        public struct Entity : IEquatable&lt;Entity&gt;, IComparable&lt;Entity&gt;    &#123;                public int Index;        public int Version;        public static bool operator==(Entity lhs, Entity rhs)        &#123;            return lhs.Index == rhs.Index &amp;&amp; lhs.Version == rhs.Version;        &#125;        public static bool operator!=(Entity lhs, Entity rhs)        &#123;            return !(lhs == rhs);        &#125;        public int CompareTo(Entity other)        &#123;            return Index - other.Index;        &#125;        public override bool Equals(object compare)        &#123;            return this == (Entity)compare;        public override int GetHashCode()        &#123;            return Index;        &#125;        public static Entity Null =&gt; new Entity();        public bool Equals(Entity entity)        &#123;            return entity.Index == Index &amp;&amp; entity.Version == Version;        &#125;        public override string ToString()        &#123;            return Equals(Entity.Null) ? &quot;Entity.Null&quot; : $&quot;Entity(&#123;Index&#125;:&#123;Version&#125;)&quot;;        &#125;    &#125;&#125;</code></pre><p>上面的代码重要部分是两个字段，<strong>Index</strong>和<strong>Version</strong>。<br>Index其实不难理解，笔者在上一篇文章提起过，Entity绑定的component是统一放在一个Chunk上的，为了提高访问的速度，当我们想要操作一个Entity的Component的时候，我们是通过Index在EntityDataManager中查找所在的Chunk和IndexInChunk。<br>Version是一个类似于版本号的东西，就像版本号会递增一样，Entity每次被回收的时候这个值会+1。用途的话，笔者猜测可能是当我们回调一个实例的时候，可以判断实例是否已经被回收了或者改变了。  </p><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><pre><code>[GenerateAuthoringComponent]public struct SimpleEcsComp : IComponentData&#123;    public float m_MoveSpeed;&#125;</code></pre><p>Component可以理解为Entity具有的属性或者组件，一个Entity是可以绑定多个Component的，就像一个GameObject上挂很多组件一样。<br>Component一般定义成struct，并且继承IComponentData或者ISharedComponentData这两个接口。   </p><h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>在以前的UnityECS版本里存在ComponentSystem和JobSystem两种System，但是目前已经被Unity弃用，这里就不介绍了，在新的ECS版本里，System采用的是<strong>SystemBase</strong>。  </p><pre><code>public class SimpleEcsSystem : SystemBase&#123;    protected override void OnUpdate()    &#123;        var deltaTime = Time.DeltaTime;        Entities.ForEach((ref Translation translation, ref SimpleEcsComp simpleEcsComp) =&gt;        &#123;            translation.Value.y += simpleEcsComp.m_MoveSpeed * deltaTime;            if (translation.Value.y &gt; 5f)            &#123;                simpleEcsComp.m_MoveSpeed = -math.abs(simpleEcsComp.m_MoveSpeed);            &#125;            else if (translation.Value.y &lt; -5f)            &#123;                simpleEcsComp.m_MoveSpeed = math.abs(simpleEcsComp.m_MoveSpeed);            &#125;        &#125;).ScheduleParallel();    &#125;&#125;</code></pre><p>如上述代码，在System的中，在进行Entities.ForEach的时候，最后需要执行一下<strong>ScheduleParallel</strong>这个方法，这里是一种扩展方法，这里常用的不仅仅是ScheduleParallel，还有Run和Schedul两个方法。下面介绍一下方法的用途：  </p><blockquote><p>Run() : evaluates the entity query and invokes the lambda function for each selected entity immediately on the main thread. Calling Run() completes the system Dependency JobHandle before running, blocking the main thread, if necessary, while it waits for those jobs to finish.<br>Schedul(): schedules the work to be done in a single job (no matter how many entities are selected).<br>ScheduleParallel() – schedules the work to be done in parallel using the C# Job system. Each parallel job instance processes at least one chunk of entities at a time. In other words, if all the selected entities are in the same chunk, then only one job instance is spawned.   </p></blockquote><h2 id="运行结果如下"><a href="#运行结果如下" class="headerlink" title="运行结果如下"></a>运行结果如下</h2><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1645079644114-2022-2-1714:34:04.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;unity: 2020.3.18f1
Entities: 0.17.0
Jobs: 0.8.0
&lt;/code&gt;&lt;/pre&gt;
</summary>
      
    
    
    
    <category term="UnityECS" scheme="http://yoursite.com/categories/UnityECS/"/>
    
    
    <category term="ECS" scheme="http://yoursite.com/tags/ECS/"/>
    
  </entry>
  
  <entry>
    <title>给hexo博客添加访问密码</title>
    <link href="http://yoursite.com/2022/01/28/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E7%BB%99hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E5%AF%86%E7%A0%81/"/>
    <id>http://yoursite.com/2022/01/28/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E7%BB%99hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E5%AF%86%E7%A0%81/</id>
    <published>2022-01-28T07:31:45.000Z</published>
    <updated>2022-01-29T06:25:45.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔者记忆力比较差，于是笔者想有个空间能记录笔者一些私人的内容，于是笔者想起来比较经常会遇到一些加密的博客，笔者便想如果自己如果有一个博客能记录自己的私人内容，然后把博客进行加密即可，这样自己想要查看内容的额时候只需要访问隐私博客，然后输入密码就可以看到了。  </p><h1 id="安装Hexo-Blog-Encrypt"><a href="#安装Hexo-Blog-Encrypt" class="headerlink" title="安装Hexo-Blog-Encrypt"></a>安装Hexo-Blog-Encrypt</h1><p>hexo的博客添加密码其实只需要安装一个插件就可以了。<br>通过npm在hexo博客目录安装Hexo-Blog-Encrypt  </p><pre><code>npm install --save hexo-blog-encrypt</code></pre><h1 id="博客使用密码"><a href="#博客使用密码" class="headerlink" title="博客使用密码"></a>博客使用密码</h1><p>只需要在博客的开头使用  </p><pre><code>---title: Hello Worlddate: 2022-01-28 15:31:45password: 密码---</code></pre><p>还可以添加一些描述的标签  </p><pre><code>---title: Hello Worldtags:- 加密文章的tagdate: 2022-01-28 15:31:45password: 密码abstract: 这里有东西被加密了，需要输入密码查看哦。message: 您好，这里需要密码。wrong_pass_message: 抱歉，这个密码看着不太对，请再试试。wrong_hash_message: 抱歉，这个文章不能被纠正，不过您还是能看看解密后的内容。---</code></pre><h1 id="根目录添加配置文件"><a href="#根目录添加配置文件" class="headerlink" title="根目录添加配置文件"></a>根目录添加配置文件</h1><pre><code># 安全encrypt: # hexo-blog-encrypt  abstract: 这里有东西被加密了，需要输入密码查看哦。  message: 您好, 这里需要密码.  tags:  - &#123;name: tagName, password: 密码A&#125;  - &#123;name: tagName, password: 密码B&#125;  #密码主题 https://github.com/D0n9X1n/hexo-blog-encrypt#encrypt-theme  theme: wave      wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.  wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;笔者记忆力比较差，于是笔者想有个空间能记录笔者一些私人的内容，于是笔者想起来比较经常会遇到一些加密的博客，笔者便想如果自己如果有一个博客能记</summary>
      
    
    
    
    <category term="搭建博客" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客密码" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>私人密码记事本</title>
    <link href="http://yoursite.com/2022/01/28/%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E7%A7%81%E4%BA%BA%E5%AF%86%E7%A0%81%E8%AE%B0%E4%BA%8B%E6%9C%AC/"/>
    <id>http://yoursite.com/2022/01/28/%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E7%A7%81%E4%BA%BA%E5%AF%86%E7%A0%81%E8%AE%B0%E4%BA%8B%E6%9C%AC/</id>
    <published>2022-01-28T06:29:49.000Z</published>
    <updated>2022-01-28T10:35:56.410Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="4f431ce80e75583a40387149286d0dfff427b508115b59b96e7e695ed04d0755">dfbc7818f5975f69a806ed91c99e4957d1bc4a02d0d8c0a3135d34e3e6dc1fe546af677c92c14f2681bc066fb0eba2516d0277fd20b8a58c93efe976b64baf88f1291e7e9c7dd51f96fd8f9daf24d25eb50cf655dd3910894fc9080b0a9f4df247254a9a39c46950fe49017f859d7f3144b3f9249086c34f905064a4cac8c00d3dfe621b32b5ec2e62ee91d9888c900ba62849a21addaa6d6962f62436be0e0f0453ea15e87673aa8c32bb44577b5e9700f52805862ddbf23dc0c2a68f3b00ddd50a344d068f5f8e9233a7234baeef25e36de2a88aea44eba02b84dbdbf797945a48bcd359c422f60ac0aa810f2afe252f8bddeb32a5272aeff2eb8f4054bda24ecbc10e819bbd47dc90dde73e22057a3dabf4a7313e2862a6445b135cb591420e36051e5a085c8ada8be70ed7e0d2ffa5f8b47f438eb1895ab93f4b46ed66d79fb3a268fedec05a9c7724f9b090778cc070ae9699f35932208008b10845e9e720965ccdf385d10c1d9f439cacae90eefcf90008441cff8b0fbe3144e85155010fe6e110667d257269d1022db720998833370feb1dabb504f4e28ebc90c30fec30766a9da3fc925f52298d739020303a657aa37e8871d95ab0139b9f405b99b3e7a02dac6299bc2ddf61ea7be517466c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这里有东西被加密了，需要输入密码查看哦。</summary>
    
    
    
    <category term="私人文件" scheme="http://yoursite.com/categories/%E7%A7%81%E4%BA%BA%E6%96%87%E4%BB%B6/"/>
    
    
    <category term="密码记事本" scheme="http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E8%AE%B0%E4%BA%8B%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>UnityECS入门(二)——简单讲解一下ECS</title>
    <link href="http://yoursite.com/2022/01/28/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%BA%8C)%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3%E4%B8%80%E4%B8%8BECS/"/>
    <id>http://yoursite.com/2022/01/28/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%BA%8C)%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3%E4%B8%80%E4%B8%8BECS/</id>
    <published>2022-01-28T05:17:37.000Z</published>
    <updated>2022-01-28T08:04:29.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇我们已经成功的配置好本地的环境了，接下来我们来简单的讲解一下ECS。(笔者也是初学者，如果有错误欢迎大家指出)  </p><h1 id="ECS简介"><a href="#ECS简介" class="headerlink" title="ECS简介"></a>ECS简介</h1><p>在写ECS之前我们先了解一下什么是ECS？  </p><h2 id="ECS是什么？"><a href="#ECS是什么？" class="headerlink" title="ECS是什么？"></a>ECS是什么？</h2><p>ECS的缩写就是Entity Component System。对应的就是实例、组件和系统。笔者认为这是和MVC框架类似，虽然作用不是一样的，但是都代表了一种思想。ECS的思想打破了我们面向对象的思想，让我们直接面向数据变成。以往的Unity提供给使用者的都是GameObject，让我们来面向对象思想，但是ECS则是把GameObject拆成了Entity和Component，然后由System再进行同意管理。  </p><h2 id="为什么使用ECS？"><a href="#为什么使用ECS？" class="headerlink" title="为什么使用ECS？"></a>为什么使用ECS？</h2><h3 id="在编写思想上"><a href="#在编写思想上" class="headerlink" title="在编写思想上"></a>在编写思想上</h3><p>笔者认为，现在的大部分游戏其实都是数据驱动的游戏，游戏的界面对象其实是给使用者提供的。一个好的程序猿应该做到真正的数据和显示分离，这样不管显示是什么样，数据都可以去应对，但其实这是理想化的，因为显示是很难统一的。  </p><h3 id="在编写代码上"><a href="#在编写代码上" class="headerlink" title="在编写代码上"></a>在编写代码上</h3><p>ECS为我们提供了面向数据编程的结构、强迫使我们数据和显示进行分离，这样虽然编写复杂了一些，但是我们的扩展性和适应性会有很大的提高。<br>Unity的MonoBehavior的class其实是非常笨重的，里面包含了大量的信息，我们在平时开发中其实用不到那么多信息，在ECS上我们只需要添加上我们需要用到的组件即可。  </p><h3 id="在内存管里方面"><a href="#在内存管里方面" class="headerlink" title="在内存管里方面"></a>在内存管里方面</h3><p>ECS引入了Archetype和Chuck两个概念，Archetype对应的是我们的Component，就是存放我们Entity需要的所有组件，然后多个Archetype会被封装成一个个的Archetype Chuck，然后在内存里按照顺序进行存放，如果一个Chuck存放满了，会在后面内存里创建新的Chuck，这样Component就是在一起的，每次查找Component的时候速度会大大提升。<br>下面我们来看一看内存结构图：  </p><p><img src="https://i0.hdslb.com/bfs/article/6cb305d158f9daf75ef880b035a26afdea2961af.png" alt="在这里插入图片描述"></p><p><img src="https://i0.hdslb.com/bfs/article/363335a8d53167863db8a0c040e29e37d2f9b269.png" alt="在这里插入图片描述">  </p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>Unity使用的是单线程，虽然里面会有携程一些，但其根本原理都是单线程，所以并不能完全发挥CPU，ECS引入了多线程的Job system，并且Job System会把Entities分发到CPU的线程上，这样就提高了CPU的利用率。  </p><h1 id="怎么使用ECS"><a href="#怎么使用ECS" class="headerlink" title="怎么使用ECS"></a>怎么使用ECS</h1><p>ECS主要提升的是CPU的性能，并不是所有的项目都适合使用ECS，因为ECS是新的思想，团队开发成本也是有一定提高的，笔者业主要是为了学习了解，拓展一下自己的思路。<br>接下来笔者会继续学习如何使用ECS。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在上一篇我们已经成功的配置好本地的环境了，接下来我们来简单的讲解一下ECS。(笔者也是初学者，如果有错误欢迎大家指出)  &lt;/p&gt;
&lt;h1 </summary>
      
    
    
    
    <category term="UnityECS" scheme="http://yoursite.com/categories/UnityECS/"/>
    
    
    <category term="ECS" scheme="http://yoursite.com/tags/ECS/"/>
    
  </entry>
  
  <entry>
    <title>UnityECS入门(一)——安装Unity官方的ECS</title>
    <link href="http://yoursite.com/2022/01/27/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%B8%80)%E2%80%94%E2%80%94%E5%AE%89%E8%A3%85Unity%E5%AE%98%E6%96%B9%E7%9A%84ECS/"/>
    <id>http://yoursite.com/2022/01/27/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%B8%80)%E2%80%94%E2%80%94%E5%AE%89%E8%A3%85Unity%E5%AE%98%E6%96%B9%E7%9A%84ECS/</id>
    <published>2022-01-27T05:49:25.000Z</published>
    <updated>2022-01-28T05:16:43.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>笔者最近准备学习Unity官方的ECS，笔者才刚开始学习，这里就先不卖弄了，笔者写这篇博客的主要目的是为了分享如何安装官方ECS。  </p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><pre><code>Unity 2020.3.18f1c1</code></pre><h1 id="安装Entitie-com-unity-entities"><a href="#安装Entitie-com-unity-entities" class="headerlink" title="安装Entitie(com.unity.entities)"></a>安装Entitie(com.unity.entities)</h1><p>unity的版本低于2020.1的可以直接在Package Manager里搜索Entitie就可以了。<br>在unity2020.1版本的时候，官方对unity的Package Manager做了一些整改，默认不再显示Preview Package了。<br>首先笔者先介绍如何打开显示Preview Package。<br><img src="https://img-blog.csdnimg.cn/a6e1dd43a96d4951834981e78c8054e2.png" alt="在这里插入图片描述">  </p><p><img src="https://img-blog.csdnimg.cn/74d2605b303549cbbcc895a4013b83e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IS455m9,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">  </p><p>虽然打开了Preview Package但是依旧会搜不到部分Preview Package的库，这是因为处于早期开发阶段和开发不活跃的包无法直接搜索到。<br>笔者这里便介绍另外一种方式，通过url的方式导入需要的库。笔者在文章后面也会放入一些无法搜到的库。<br><strong>通过URL安装需要本地安装git来进行下载</strong><br>Entitie的url是： <strong>com.unity.entities</strong><br>导入步骤如下：<br><img src="https://img-blog.csdnimg.cn/b093196413e44d178d9a5656aee4ed7e.png" alt="在这里插入图片描述">  </p><p><img src="https://img-blog.csdnimg.cn/126370bd43ae4f8ca103be329245adde.png" alt="在这里插入图片描述">  </p><h1 id="安装Jobs-com-unity-jobs"><a href="#安装Jobs-com-unity-jobs" class="headerlink" title="安装Jobs(com.unity.jobs)"></a>安装Jobs(com.unity.jobs)</h1><p>通过git url的方式输入com.unity.jobs即可安装，笔者安装entities的时候会自动安装jobs，如果没有安装可以使用这种方式安装。  </p><h1 id="安装HyBrid-Renderer-com-unity-rendering-hybrid"><a href="#安装HyBrid-Renderer-com-unity-rendering-hybrid" class="headerlink" title="安装HyBrid Renderer(com.unity.rendering.hybrid)"></a>安装HyBrid Renderer(com.unity.rendering.hybrid)</h1><p>学习ECS过程中还有可能用到HyBrid Renderer这个package，这里也提供一下对应的URL  </p><p><strong>com.unity.rendering.hybrid</strong>  </p><h1 id="安装Burst-com-unity-barracuda-burst"><a href="#安装Burst-com-unity-barracuda-burst" class="headerlink" title="安装Burst(com.unity.barracuda.burst)"></a>安装Burst(com.unity.barracuda.burst)</h1><p>直接在package manager里搜索Burst是可以搜到的</p><h1 id="安装Mathematics-com-unity-mathematics"><a href="#安装Mathematics-com-unity-mathematics" class="headerlink" title="安装Mathematics(com.unity.mathematics)"></a>安装Mathematics(com.unity.mathematics)</h1><p>直接在package manager里搜索Mathematics是可以搜到的，这里也放一下url </p><p><strong>com.unity.mathematics</strong></p><h1 id="无法搜到的Preview-Package的URL"><a href="#无法搜到的Preview-Package的URL" class="headerlink" title="无法搜到的Preview Package的URL"></a>无法搜到的Preview Package的URL</h1><p>com.ptc.vuforia.engine<br>com.unity.2d.entities<br>com.unity.ai.planner<br>com.unity.aovrecorder<br>com.unity.assetbundlebrowser<br>com.unity.assetgraph<br>com.unity.barracuda<br>com.unity.barracuda.burst<br>com.unity.build-report-inspector<br>com.unity.cloud.userreporting<br>com.unity.collections<br>com.unity.connect.share<br>com.unity.dots.editor<br>com.unity.entities<br>com.unity.film-tv.toolbox<br>com.unity.google.resonance.audio<br>com.unity.immediate-window<br>com.unity.mathematics<br>com.unity.meshsync<br>com.unity.multiplayer-hlapi<br>com.unity.package-manager-doctools<br>com.unity.package-manager-ui<br>com.unity.package-validation-suite<br>com.unity.physics<br>com.unity.platforms<br>com.unity.platforms.android<br>com.unity.platforms.linux<br>com.unity.platforms.macos<br>com.unity.platforms.web<br>com.unity.platforms.windows<br>com.unity.playablegraph-visualizer<br>com.unity.render-pipelines.lightweight<br>com.unity.rendering.hybrid<br>com.unity.renderstreaming<br>com.unity.scene-template<br>com.unity.simulation.client<br>com.unity.simulation.core<br>com.unity.simulation.capture<br>com.unity.simulation.games<br>com.unity.standardevents<br>com.unity.streaming-image-sequence<br>com.unity.test-framework.performance<br>com.unity.tiny.all<br>com.unity.transport<br>com.unity.upm.develop<br>com.unity.vectorgraphics<br>com.unity.webrtc<br>com.unity.xr.googlevr.android<br>com.unity.xr.googlevr.ios<br>com.unity.xr.legacyinputhelpers<br>com.unity.xr.oculus.android<br>com.unity.xr.oculus.standalone<br>com.unity.xr.openvr.standalone<br>com.unity.xr.arsubsystems<br>com.unity.xr.interactionsubsystems<br>com.unity.xr.windowsmr.metro  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;笔者最近准备学习Unity官方的ECS，笔者才刚开始学习，这里就先不卖弄了，笔者写这篇博客的主要目的是为了分享如何安装官方ECS。  &lt;/p</summary>
      
    
    
    
    <category term="UnityECS" scheme="http://yoursite.com/categories/UnityECS/"/>
    
    
    <category term="ECS" scheme="http://yoursite.com/tags/ECS/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——序列化AnimationCurve</title>
    <link href="http://yoursite.com/2022/01/25/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%BA%8F%E5%88%97%E5%8C%96AnimationCurve/"/>
    <id>http://yoursite.com/2022/01/25/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%BA%8F%E5%88%97%E5%8C%96AnimationCurve/</id>
    <published>2022-01-24T16:18:28.000Z</published>
    <updated>2022-01-27T06:26:58.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者在开发一个地图编辑器的过程中，需要配置一个摄像机的移动速度，这个时候策划提了一个需求，他希望能够通过设置曲线的方式来设置摄像机的移动，于是笔者便想到了unity编辑器自带的AnimationCurve就可以获得运动曲线，但是这里有个问题，我们编辑器配置后是需要保存下来的，笔者选择了利用json保存，但是json是没有办法序列化一个AnimationCurve对象的，json序列化是有规则的，这里就不介绍了。没有办法序列化我们需要的对象我们应该怎么办呢？  </p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>我们没有办法序列化我们需要的AnimationCurve，但是我们知道AnimationCurve是由很多个keyframe组成的，我们只需要保留下来keyframe，每次保存的时候只保存keeyfram数组，然后加载的时候通过添加保存的keyframe既可以生成我们需要的AnimationCurve了。<br>当笔者想去保存keyframe的时候，通过rider编辑器可以看到keyframe的类似源码，里面的字段都是私有的，依旧没有办法序列化，这个时候我们可以换一种方式，那就是自定义一个新的keyframe，然后通过自己的keyframe去生成需要的keyframe就可以了。<br>话不多说，直接上代码：<br>通过查看keyframe的源码，我们可以摘取我们需要的数据，然后自定义类即可。（这里定义struct，打包的时候序列化会出错，具体原因还未查明）  </p><pre><code>public class LBSerializeAnimCurveKeyFrame&#123;    #region 字段    public float m_Time;    public float m_Value;    public float m_InTangent;    public float m_OutTangent;    public int m_TangentMode;    public int m_WeightedMode;    public float m_InWeight;    public float m_OutWeight;    #endregion        #region 属性        #endregion        #region 方法        public LBSerializeAnimCurveKeyFrame(        float time,        float value,        float inTangent,        float outTangent,        float inWeight,        float outWeight)    &#123;        this.m_Time = time;        this.m_Value = value;        this.m_InTangent = inTangent;        this.m_OutTangent = outTangent;        this.m_WeightedMode = 3;        this.m_InWeight = inWeight;        this.m_OutWeight = outWeight;        this.m_TangentMode = 0;    &#125;    public static implicit operator LBSerializeAnimCurveKeyFrame(Keyframe keyframe)    &#123;        return new LBSerializeAnimCurveKeyFrame(keyframe);    &#125;        public static implicit operator Keyframe(LBSerializeAnimCurveKeyFrame keyframe)    &#123;        return new Keyframe(keyframe.m_Time, keyframe.m_Value, keyframe.m_InTangent, keyframe.m_OutTangent,            keyframe.m_InWeight, keyframe.m_OutWeight);    &#125;        #endregion&#125;</code></pre><p>上面就是笔者自己定义的keyframe，然后我们只需要在我们需要序列化的类添加上即可，示例如下：<br>首先查看我们需要序列化的数据应该怎么设计：  </p><pre><code>public class SerializeAnimationCurveData&#123;    #region 字段        public List&lt;LBSerializeAnimCurveKeyFrame&gt; m_AnimCurveKeyFrameList;        [IgnoreDataMember]    public AnimationCurve AnimCurve    &#123;        get        &#123;            Keyframe[] keyframeArray;            if (m_AnimCurveKeyFrameList != null)            &#123;                keyframeArray = new Keyframe[m_AnimCurveKeyFrameList.Count];                for (int i = 0; i &lt; m_AnimCurveKeyFrameList.Count; i++)                &#123;                    keyframeArray[i] = m_AnimCurveKeyFrameList[i];                &#125;            &#125;            else            &#123;                keyframeArray = AnimationCurve.Linear(0f, 0f, 1f, 1f).keys;            &#125;            return new AnimationCurve(keyframeArray);        &#125;        set        &#123;            m_AnimCurveKeyFrameList.Clear();            foreach (var keyframe in value.keys)            &#123;                m_AnimCurveKeyFrameList.Add(keyframe);            &#125;        &#125;    &#125;    #endregion    #region 方法    public SerializeAnimationCurveData()    &#123;        AnimCurve = AnimationCurve.Linear(0, 0, 1, 1);        m_AnimCurveKeyFrameList = new List&lt;LBSerializeAnimCurveKeyFrame&gt;();        foreach (var keyframe in AnimCurve.keys)        &#123;            m_AnimCurveKeyFrameList.Add(keyframe);        &#125;    &#125;    #endregion&#125;</code></pre><p>接着我们看一下如何编辑器上设置，笔者是在自定义的窗口上绘制的，其他面板也是类似：  </p><pre><code>private SerializeAnimationCurveData m_SerAnimCurveData;private void Awake()&#123;    m_SerAnimCurveData = new SerializeAnimationCurveData();&#125;private void OnGUI()&#123;    EditorGUILayout.BeginVertical(GUILayout.Width(400f));    &#123;        m_SerAnimCurveData.AnimCurve =            EditorGUILayout.CurveField(LBEditorLNG.SerAnimCurveTitle, m_SerAnimCurveData.AnimCurve);    &#125;    EditorGUILayout.EndVertical();&#125;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当我们想序列化一个字段的时候，如果字段不可以序列化，我们可以通过保留组成的数据，然后在反序列化的时候通过保留下来的数据重新组成我们需要的字段。如果字段也是封装好的私有字段，我们只需要自己重新设计一个类，用来保留这些字段。当我们需要一个成品的时候，如果我们没有办法保留成品，我们可以拆分这些，这样使用的时候重新组成就行了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;笔者在开发一个地图编辑器的过程中，需要配置一个摄像机的移动速度，这个时候策划提了一个需求，他希望能够通过设置曲线的方式来设置摄像机的移动，于</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="JSON" scheme="http://yoursite.com/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——基于UGUI的UI拖拽监听</title>
    <link href="http://yoursite.com/2022/01/13/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EUGUI%E7%9A%84UI%E6%8B%96%E6%8B%BD%E7%9B%91%E5%90%AC/"/>
    <id>http://yoursite.com/2022/01/13/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EUGUI%E7%9A%84UI%E6%8B%96%E6%8B%BD%E7%9B%91%E5%90%AC/</id>
    <published>2022-01-13T15:46:06.000Z</published>
    <updated>2022-01-14T01:57:54.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果一个UI的面板想监听拖拽事件通常会有两种方式：  </p><blockquote><ol><li>继承IBeginDragHandler，IDragHandler，IEndDragHandler接口，然后实现自己需要的逻辑。（此方法需要脚本继承MonoBehaviour）  </li><li>监听Input的输入，通过判断按下和按住来实现自己拖拽的逻辑。  </li></ol></blockquote><p>已经有写好的放发笔者为什么还要写这边文章呢，是因为笔者目前参与的项目中的UI框架，面板的脚本都不是继承MonoBeehaviour的，都是通过统一管理的，这样的方式的好处就是UI的初始化和Update的一些都可以自己控制。面板的View都是通过绑定的方式进行操作的，了解框架的应该都知道，这样的好处有很多，这里就不过多介绍了。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>如果一个UI面板是通过绑定的方式进行的，没有继承MonoBehaviour，有不想在Update里写大量的逻辑，我们想见监听一个UI的拖拽应该怎么操作呢。  </p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>我们只需要自己写一个继承MonoBehaviour的脚本，然后脚本继承这些接口，在脚本里添加拖拽需要的一些参数，然后脚本里添加我们需要注册的委托就可以了，我们的面板脚本可以绑定面板的UI，我们只需要通过UI物体获取我们需要的拖拽脚本组件，然后注册我们需要的一些委托就可以了。脚本如下：  </p><pre><code>using System;using UnityEngine;using UnityEngine.EventSystems;public class UDragEvent : MonoBehaviour,IBeginDragHandler,IDragHandler,IEndDragHandler&#123;    private bool m_IsDraging;    public bool IsDraging    &#123;        get =&gt; m_IsDraging;        private set =&gt; m_IsDraging = value;    &#125;    public Action&lt;PointerEventData&gt; OnBeginDragEvent;    public Action&lt;PointerEventData&gt; OnDragEvent;    public Action&lt;PointerEventData&gt; OnEndDragEvent;    public void OnBeginDrag(PointerEventData eventData)    &#123;        OnBeginDragEvent?.Invoke(eventData);        m_IsDraging = true;    &#125;    public void OnDrag(PointerEventData eventData)    &#123;        OnDragEvent?.Invoke(eventData);    &#125;    public void OnEndDrag(PointerEventData eventData)    &#123;        OnEndDragEvent?.Invoke(eventData);        m_IsDraging = false;    &#125;&#125;</code></pre><p>上述脚本非常简单，只是把一些接口转换成了委托，然后在需要监听拖拽的组件上放上挂上这个脚本，在面板的控制脚本里获取这个脚本，然后绑定上对应的委托就可以使用了。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当我们使用一个接口或者方法的时候，如果我们没有办法直接调用，我们不仅仅只考虑找和它相同功能的方法替换掉，我们还可以通过转换的方式，间接的使用我们需要的。笔者就是通过委托的方式简介的使用了拖拽的接口。不仅仅是拖拽，很多接口我们都可以这样间接使用。也不仅仅是接口，很多开发者遇到的阻挡，我们不应该考虑换路，我们也要考虑能不能跨过阻挡或者绕过阻挡。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;如果一个UI的面板想监听拖拽事件通常会有两种方式：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;继承IBeginDragHand</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="UGUI" scheme="http://yoursite.com/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——自定义创建模板脚本</title>
    <link href="http://yoursite.com/2022/01/13/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%9B%E5%BB%BA%E6%A8%A1%E6%9D%BF%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2022/01/13/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%9B%E5%BB%BA%E6%A8%A1%E6%9D%BF%E8%84%9A%E6%9C%AC/</id>
    <published>2022-01-13T06:33:29.000Z</published>
    <updated>2022-01-18T09:39:48.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>相信大多数Unity开发人员在创建脚本的时候，经常会修改自从生成的脚本内容，比如去掉继承的MonoBehavior,添加命名空间，或者继承固定的接口、类等。这样重复的工作看似花费不了多少时间，但是如果每次创建都需要修改，还是有点麻烦的，所以如果我们能按照我们自定一的模板脚本去创建脚本就可以了。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者在团队开发中发现，每次创建UI的脚本的时候都需要固定修改继承，和添加一些标签等，这些重复性的工作笔者想了想可不可按照自定义的模板创建脚本。笔者发现unity自带的在unity安装目录下创建模板脚本有很大的缺点，只能创建C#脚本，并且只可以自己使用，并不可以上传到项目的库进行团队使用，于是笔者参考网上的一些文章写了下面的解决方案。  </p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>首先我们在创建一个Editor Default Resources目录，这个目录是提供为编辑器模式使用的资源路径，加载此目录的资源文件代码如下：<br><strong>EditorGUIUtility.Load(filePath)</strong><br>加载后通过as转换成需要的类型就可以了<br>笔者模板文件存放的目录如下：<br>—Assets<br>——Editor Default Resources<br>———CustomScriptTemplate<br>————C# Script-NewNoMonoBehaviourScript.text  </p><p>模板文件的内容如下：  </p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;namespace #NAMESPACE#&#123;    public class #SCRIPTNAME#    &#123;        #region 字段                #endregion                #region 属性                #endregion                #region 方法                                #endregion    &#125;&#125;</code></pre><h2 id="在选中的目录里创建模板脚本"><a href="#在选中的目录里创建模板脚本" class="headerlink" title="在选中的目录里创建模板脚本"></a>在选中的目录里创建模板脚本</h2><p>制作的原理就是通过读取模板文件的内容，然后将内容写入新的脚本中，监听编辑结束后替换新模板中的固定字符串就可以了。<br>直接上代码：  </p><pre><code>using System.Text;using System.Text.RegularExpressions;using UnityEditor;using UnityEditor.Compilation;using UnityEditor.ProjectWindowCallback;using UnityEngine;public static class CreatNewCShapScript&#123;        /// &lt;summary&gt;        /// 创建不继承MonoBehaviour脚本        /// &lt;/summary&gt;        [MenuItem(&quot;Assets/Create/C# Scripts Menu/C# NoMonoBehaviourScript&quot;, false,81)]        public static void CreatNoMonoBehaviourScript()        &#123;            //参数为传递给CreateEventCSScriptAsset类action方法的参数            ProjectWindowUtil.StartNameEditingIfProjectWindowExists(0,                ScriptableObject.CreateInstance&lt;CreateNewCShapScriptAsset&gt;(),                GetSelectPathOrFallback() + &quot;/NewNoMonoBehaviourScript.cs&quot;, null,                &quot;CustomScriptTemplate/C# Script-NewNoMonoBehaviourScript.txt&quot;);        &#125;        /// &lt;summary&gt;        /// 取得要创建文件的路径        /// &lt;/summary&gt;        /// &lt;returns&gt;&lt;/returns&gt;        public static string GetSelectPathOrFallback()        &#123;            string path = &quot;Assets&quot;;            //遍历选中的资源以获得路径            //Selection.GetFiltered是过滤选择文件或文件夹下的物体，assets表示只返回选择对象本身            foreach (UnityEngine.Object obj in Selection.GetFiltered(typeof(UnityEngine.Object), SelectionMode.Assets))            &#123;                path = AssetDatabase.GetAssetPath(obj);                if (!string.IsNullOrEmpty(path) &amp;&amp; File.Exists(path))                &#123;                    path = Path.GetDirectoryName(path);                    break;                &#125;            &#125;            return path;        &#125;        /// &lt;summary&gt;        /// 创建脚本文件的委托类        /// &lt;/summary&gt;        class CreateNewCShapScriptAsset : EndNameEditAction        &#123;            public override void Action(int instanceId, string pathName, string resourceFile)            &#123;                UnityEngine.Object obj = CreateScriptAssetFromTemplate(pathName, resourceFile);                         //创建资源                ProjectWindowUtil.ShowCreatedAsset(obj);                                                                //高亮显示资源            &#125;                        internal static UnityEngine.Object CreateScriptAssetFromTemplate(string pathName, string resourceFile)            &#123;                string fullPath = Path.GetFullPath(pathName);                                                           //获取要创建资源的绝对路径                string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(pathName);                           //获取文件名，不含扩展名                var textAsset = EditorGUIUtility.Load(resourceFile) as TextAsset;                string resourceFileText = textAsset.text;                resourceFileText = Regex.Replace(resourceFileText, &quot;#NAMESPACE#&quot;,                    CompilationPipeline.GetAssemblyRootNamespaceFromScriptPath(pathName));                resourceFileText = Regex.Replace(resourceFileText, &quot;#SCRIPTNAME#&quot;, fileNameWithoutExtension);              //将模板类中的类名替换成你创建的文件名                bool encoderShouldEmitUTF8Identifier = true;                                                            //参数指定是否提供 Unicode 字节顺序标记                bool throwOnInvalidBytes = false;                                                                       //是否在检测到无效的编码时引发异常                UTF8Encoding encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier, throwOnInvalidBytes);                bool append = false;                StreamWriter streamWriter = new StreamWriter(fullPath, append, encoding);                               //写入文件                streamWriter.Write(resourceFileText);                streamWriter.Close();                AssetDatabase.ImportAsset(pathName);                                                                    //刷新资源管理器                AssetDatabase.Refresh();                return AssetDatabase.LoadAssetAtPath(pathName, typeof(UnityEngine.Object));            &#125;        &#125;&#125;</code></pre><p>此代码有一个比较重要的一点就是获取文件所在的程序集的命名空间名字，因为要自动添加命名空间，最后找到了对应的API，通过**CompilationPipeline.GetAssemblyRootNamespaceFromScriptPath(pathName)**获取地址路径下的命名空间名字，然后动态替换就可以了。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;相信大多数Unity开发人员在创建脚本的时候，经常会修改自从生成的脚本内容，比如去掉继承的MonoBehavior,添加命名空间，或者继承固</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Unity工具" scheme="http://yoursite.com/tags/Unity%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Unity游戏开发知识点整理</title>
    <link href="http://yoursite.com/2022/01/12/Unity/Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2022/01/12/Unity/Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</id>
    <published>2022-01-12T12:23:29.000Z</published>
    <updated>2022-01-18T09:36:52.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面试是打工人都需要经历的，有一份好的面试整理是很重要的。笔者参加工作一年多后经历了人生第一次裁员，被裁肯定是要找工作的，经过这次找工作，笔者发现自己虽然学习了很多知识，但是很难梳理清楚，复习起来也比较乱，于是笔者准备整理一下自己学习的知识，并且深入学习一下自己的知识，于是便有了这篇博客。  </p><p><strong>持续更新中。。。</strong><br><strong>本博客内容仅是笔者通过学习后的自己理解，欢迎各位大佬及时指出笔者的错误。</strong>  </p><h1 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h1><h2 id="栈-堆栈-与堆-托管堆"><a href="#栈-堆栈-与堆-托管堆" class="headerlink" title="栈(堆栈)与堆(托管堆)"></a>栈(堆栈)与堆(托管堆)</h2><details><summary>点击展开内容</summary><p>一款程序需要运行是需要占用内存空间的，我们学习一款编程语言的同时需要了解语言的内存空间，只有更深入的了解编程语言的内存空间管理，我们才能使我们的程序的性能达到更好。<br>C#的内存空间总共分为两种，分别是栈与堆，其实这两个都是简称，正规的叫法是堆栈与托管堆，因为我们经常将两者放在一起说，所以就简称栈与堆。  </p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ol><li>栈的空间比较小。  </li><li>栈的读取速度比较快。  </li><li>栈不能动态申请空间，只能申请大小确定的数据空间，比如char、int、struct等一些值类型的数据。  </li><li>栈的储存是按照顺序储存的。</li><li>栈主要储存代码执行或者调用的空间。例如类里面一个函数，栈里储存的指向一个空间的地址，指向的是函数逻辑代码所在的托管堆。需要注意的是函数内申请的变量依旧是存在栈空间内的。  </li><li>栈就想我们学的容器库里面的栈一样，后进先出。比如一个函数方法，函数里申请变量后是倒着释放的。  </li><li>栈的GC(垃圾回收)是自动管理的，生命周期结束后就自己释放了。  </li></ol><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ol><li>堆的空间比较大。</li><li>堆的读取速度没有栈快</li><li>堆可以动态申请空间，并且存储的是大量的数据，比如一些引用类型数据、代码执行块等。  </li><li>堆的存储是不连续的，找到足够的空间就可以申请。  </li><li>堆主要存储一些代码执行块。比如一些函数的具体执行块等。  </li><li>堆的存储就像一张地图，哪里有你需要的空间大小就可以申请，当栈中指向空间的引用消失后有不会释放空间，会标记空间引用为0。</li><li>堆的GC(垃圾回收)是由CLR(公共语言运行库)进行管理的，具体如何回收后续会有讲解。  </li></ol></details>## 值类型与引用类型<details><summary>点击展开内容</summary><p>C#的数据类型分为两种，分别是值类型与引用类型。两个类型都继承自System.Object，不过值类型继承的是System.Object的子类System.ValueType。  </p><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>值类型包括：byte，short，int，long，float，double，decimal，char，bool 和 struct。  </p><ol><li>值类型数据储存在栈上  </li><li>值类型声明变量的同时，编译器会在栈上分配对应大小的内存  </li><li>值类型不可以赋值为null  </li><li>内存管理方面效率高，不支持多态，适用于做储存数据的载体  </li><li>传参的时候传递的是数据本身   </li><li>赋值的时候是将变量值赋值给另一个值类型的变量  </li></ol><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用类型包括：class和string。  </p><ol><li>引用类型数据储存在堆上  </li><li>引用类型声明的时候会先在栈上分配一个存在地址的小内存，赋值的时候会指向新创建的堆中的地址或者引用类型指向的地址     </li><li>引用类型可以赋值为null  </li><li>支持多态，适用于定义一些程序的行为对象  </li><li>传参的时候传递的是指向数据的地址，就是栈中的空间  </li><li>赋值的时候是将本身指向的地址的引用赋值给新的引用  </li></ol><h3 id="值类型和引用类型中的特殊类型"><a href="#值类型和引用类型中的特殊类型" class="headerlink" title="值类型和引用类型中的特殊类型"></a>值类型和引用类型中的特殊类型</h3><p>值类型：enum、struct<br>引用类型：字符串、数组、Interface、delete(委托)  </p><h3 id="函数和引用类型中的值类型变量储存在哪里？"><a href="#函数和引用类型中的值类型变量储存在哪里？" class="headerlink" title="函数和引用类型中的值类型变量储存在哪里？"></a>函数和引用类型中的值类型变量储存在哪里？</h3><p>函数中的值类型变量是在方法内部进行创建的，在创建的时候随方法申请在栈中。<br>引用类型中的变量是跟随着引用类型创建的，在引用类型的堆空间中。  </p><h3 id="struct是否可以继承接口"><a href="#struct是否可以继承接口" class="headerlink" title="struct是否可以继承接口"></a>struct是否可以继承接口</h3><p>可以  </p></details>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;面试是打工人都需要经历的，有一份好的面试整理是很重要的。笔者参加工作一年多后经历了人生第一次裁员，被裁肯定是要找工作的，经过这次找工作，笔者</summary>
      
    
    
    
    <category term="Unity" scheme="http://yoursite.com/categories/Unity/"/>
    
    
    <category term="unity知识点" scheme="http://yoursite.com/tags/unity%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——扩展变量增加OnValueChange功能</title>
    <link href="http://yoursite.com/2022/01/07/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95%E5%8F%98%E9%87%8F%E5%A2%9E%E5%8A%A0OnValueChange%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2022/01/07/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95%E5%8F%98%E9%87%8F%E5%A2%9E%E5%8A%A0OnValueChange%E5%8A%9F%E8%83%BD/</id>
    <published>2022-01-07T06:00:09.000Z</published>
    <updated>2022-01-07T06:31:58.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔者参与的项目的UI框架并没有采用MVC结构，而是把MVC中的C去掉了，只使用了MV，把C的逻辑拆分了一下，分别分为M里的C和V里的C，分别写在了对应的M或者V里面，V是根据M里的数据变化从而进行变化的。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>C#自带的属性并没有数据变化响应的事件或者委托，笔者的UI结构是需要根据数据变化进行更新的，所以笔者希望属性能有一个类似于OnValueChange的功能。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="方法一（使用委托）"><a href="#方法一（使用委托）" class="headerlink" title="方法一（使用委托）"></a>方法一（使用委托）</h2><p>这种方式是自己增加一个变量的委托事，然后在属性的set方法里进行响应对应的委托，每次需要监听数据变化的时候注册一下对应的委托就可以了。<br>缺点：变量需要定义成委托，并且每个需要监听变化的变量都需要增加一个委托的变量。<br>代码如下：  </p><pre><code>public class ExtendProperty&#123;    private int m_Value;    public Action&lt;int, int&gt; OnValueChange;    public int Value    &#123;        get =&gt; m_Value;        set        &#123;            OnValueChange?.Invoke(m_Value, value);            m_Value = value;        &#125;    &#125;&#125;</code></pre><p>根据代码可以看出，如果是属性使用只需要两个变量，但是如果是字段使用就需要三个变量了。<br>使用方法如下：  </p><pre><code> void Start()&#123;    ExtendProperty property = new ExtendProperty();    property.Value = 10;    property.OnValueChange += OnValueChange;    property.Value = 20;&#125;private void OnValueChange(int arg1, int arg2)&#123;    Debug.Log(string.Format(&quot;&#123;0&#125;-&#123;1&#125;&quot;, arg1, arg2));&#125;</code></pre><h2 id="方法二（推荐）"><a href="#方法二（推荐）" class="headerlink" title="方法二（推荐）"></a>方法二（推荐）</h2><p>方法一的缺点很明显，如果是少数变量使用还可以，但是如果大量的变量都需要监听会比较麻烦，于是笔者就找到了另外的解决办法，笔者自定义一个类，然后变量都使用这个类定义，在类里面进行变量监听就可以了。<br>代码如下：  </p><pre><code>public class ExtendProperty&lt;T&gt;&#123;    private T m_Value;    public Action&lt;T, T&gt; OnValueChange;    public T Value    &#123;        get =&gt; m_Value;        set        &#123;            OnValueChange?.Invoke(m_Value, value);            m_Value = value;        &#125;    &#125;    public ExtendProperty(T value)    &#123;        m_Value = value;    &#125;        public ExtendProperty()    &#123;        m_Value = default;    &#125;        public static implicit operator T(ExtendProperty&lt;T&gt; vl)    &#123;        return vl.Value;    &#125;&#125;</code></pre><p>缺点：定义普通变量的时候都需要初始化，不会默认赋值，并且每次使用变量的时候都不是直接赋值，而是采用property.Value = value的方式赋值。<br>使用案例如下：  </p><pre><code>ExtendProperty&lt;int&gt; property = new ExtendProperty&lt;int&gt;(10);property.OnValueChange += OnValueChange;property.Value = 20;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>采用OnValue的方式是一种简单的响应式框架，类似于UniRx，笔者在使用方法二的时候一直在想办法解决如何让使用者使用的时候像普通变量一样赋值而不是采用.Value的方式赋值，奈何一直找不到能拿到赋值的左值的方法。第二种方式更像是把第一种方式整合成一个对象，从而减少代码量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;笔者参与的项目的UI框架并没有采用MVC结构，而是把MVC中的C去掉了，只使用了MV，把C的逻辑拆分了一下，分别分为M里的C和V里的C，分别</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="C#-Property" scheme="http://yoursite.com/tags/C-Property/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——解决Unity修改Prefab的参数不生效，无法保存</title>
    <link href="http://yoursite.com/2021/12/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3Unity%E4%BF%AE%E6%94%B9Prefab%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%8D%E7%94%9F%E6%95%88%EF%BC%8C%E6%97%A0%E6%B3%95%E4%BF%9D%E5%AD%98/"/>
    <id>http://yoursite.com/2021/12/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3Unity%E4%BF%AE%E6%94%B9Prefab%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%8D%E7%94%9F%E6%95%88%EF%BC%8C%E6%97%A0%E6%B3%95%E4%BF%9D%E5%AD%98/</id>
    <published>2021-12-30T02:06:39.000Z</published>
    <updated>2022-01-07T06:30:40.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔者刚入职一家公司，团队的项目在UI方面处理和外面大部分框架都差不多，都是采用绑定的方式处理UI面板，笔者在开发UI面板的时候发现，笔者修改绑定的脚本的数据的时候，发现无法触发prefab的保存，所以不管从场景还是资源中修改参数，在重新打开的时候都没有生效。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者经过一系列的搜索，最后发现是因为笔者所在团队的框架，修改prefab上绑定面板的脚本是通过这个脚本的编辑器扩展脚本中的OnInspectorGUI方法中进行赋值的，但是在这个方法中通过代码赋值的数据都无法触发Prefab的修改，所以无法进行保存，因此下次再打开prefab的时候依旧不生效。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="方法一（不建议使用）"><a href="#方法一（不建议使用）" class="headerlink" title="方法一（不建议使用）"></a>方法一（不建议使用）</h2><p>这个方法是笔者同事用的方法，采用的方式是通过其他方式触发Prefab的修改，从而进行Apply或者Save，这个时候进行保存就会把修改进行保存。笔者同事是Prefab拖到场景中，通过设置Prefab的显示隐藏，触发修改，然后保存。笔者在测试过程中是通过增加节点再删除触发的。这个方法并不推荐使用，因为每次修改都需要想办法触发保存。  </p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>这个方法是在OnInspectorGUI函数中，在调用参数修改的地方，通过**Undo.RecordObject(object,”value change”)**的方法,然后在修改的时候发现就可以触发了，这个方法笔者是从度娘那里学到的方法，笔者并没有采用成功是因为笔者框架的Object是System.Object,但是接口要求的是UnityEngine.Object，因此笔者如果修改会修改大量代码。并且据说这个方法不是百分百生效。  </p><h2 id="方法三（推荐）"><a href="#方法三（推荐）" class="headerlink" title="方法三（推荐）"></a>方法三（推荐）</h2><p>这个方法是在OnInspectorGUI函数中，在调用参数修改的地方，通过**EditorUtility.SetDirty(obj);**的方法监听赋的值就可以了，这是笔者采用的发放，这样修改就可以直接保存了。不过此方法有个确定，就是修改后无法使用ctrl+z进行回退，本身修改也是无法回退，据说方法二是可以支持回退的。  </p><pre><code>[CustomEditor(typeof(XXX))]public class XXXEditor : Editor&#123;    public override void OnInspectorGUI()    &#123;        ...        XXX xxx = value as XXX;        if (#change#)        //数据发生变化        &#123;            xxx.Value = object;            EditorUtility.SetDirty(object);        &#125;        ...    &#125;&#125;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>笔者的方法依旧存在无法回退的方法，如果那位大佬有好的方法可以联系笔者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;笔者刚入职一家公司，团队的项目在UI方面处理和外面大部分框架都差不多，都是采用绑定的方式处理UI面板，笔者在开发UI面板的时候发现，笔者修改</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Prefab" scheme="http://yoursite.com/tags/Prefab/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2021/12/27/hello-world/"/>
    <id>http://yoursite.com/2021/12/27/hello-world/</id>
    <published>2021-12-27T03:39:09.484Z</published>
    <updated>2021-12-27T03:39:09.484Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Unity杂文——海外开发踩坑笔记</title>
    <link href="http://yoursite.com/2021/07/09/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%B5%B7%E5%A4%96%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/07/09/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%B5%B7%E5%A4%96%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</id>
    <published>2021-07-09T10:25:32.000Z</published>
    <updated>2021-12-27T03:39:09.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><h2 id="Gradle版本问题"><a href="#Gradle版本问题" class="headerlink" title="Gradle版本问题"></a>Gradle版本问题</h2><p>本地打包的大部分错误都是因为这个问题，这是因为笔者接入的SDK自定义了gradle的插件版本，这个再unity本身其实已经定义过了，但是自己是可以通过修改build.gradle进行修改的。查看unity本身gradel的插件版本的路径是：Editor\Data\PlaybackEngines\AndroidPlayer\Tools\GradleTemplates\baseProjectTemplate.gradle,以2019.4.28版本为例，里面代码为：  </p><pre><code>// GENERATED BY UNITY. REMOVE THIS COMMENT TO PREVENT OVERWRITING WHEN EXPORTING AGAINallprojects &#123;    buildscript &#123;        ***        dependencies &#123;            ***            classpath &#39;com.android.tools.build:gradle:3.4.0&#39;            **BUILD_SCRIPT_DEPS**        &#125;    &#125;    ***&#125;***</code></pre><p>如上图，可以看到插件版本为3.4.0，如果unity里本身修改了baseProjectTemplate.gradle就按照修改后的来，这个文件夹内所有的gradle和properties都是默认的，如果程序里修改就按照程序里的来。修改的方法在Editor–&gt;ProjectSettings–&gt;Player–&gt;Publishing Settings，如下图所示：  </p><p>  <img src="https://file.liangxiegame.com/f69ca480-57fe-4313-8391-4318b1cead9a.png" alt="image.png">   </p><p>如上图，其实就是对应编辑器文件夹下的gradle文件，如果打勾就会在pluging/Android文件夹下生成对应的文件，就可以直接修改，不再按照unity默认的来，就可以修改配置了。</p><p>经过上面的介绍已经知道如何查看并修改unity的gradle插件版本，下面就是修改对应的gradle版本。首先打开Editor–&gt;Preference–&gt;External Tools就可以看到Android的打包环境配置。  </p><p><img src="https://file.liangxiegame.com/13b80d7b-6dd0-4fdd-8199-82222a81d8e2.png" alt="image.png">   </p><p>2020版本以后的Unity是默认路径下就自己配置好环境，选择默认就可以，但是依旧可能会存在环境不存在或者版本不对，所以可以自己配置，这样修改也方便。这里有需要特别关注的一点也是大部分打包失败的原因，就是gradle的版本和对应的插件版本是有对照关系的，必须对照上才能正常打包。对应关系如下图：  </p><p><img src="https://file.liangxiegame.com/10319033-5e95-4d83-a544-060a7ff6cac3.png" alt="image.png">   </p><p>只要配置好对应的关系就行了。  </p><h2 id="NDK版本问题"><a href="#NDK版本问题" class="headerlink" title="NDK版本问题"></a>NDK版本问题</h2><p>在打包的时候也遇到了NDK版本不对无法打包的问题，打包失败会提示打包需要的版本，下载对应的版本即可，笔者打包的时候需要的是版本19，但是下载19版本依旧无法打包，这是因为版本的小版本依旧对不上，这里可以不用找对应的小版本，只要对应的大版本一样，在自己ndk安装目录下，找到source.properties文件，编辑文件，如下，修改对应的<strong>Pkg.Revision</strong>即可。  </p><pre><code>Pkg.Desc = Android NDKPkg.Revision = 19.0.5232133</code></pre><h2 id="maven仓库下载问题"><a href="#maven仓库下载问题" class="headerlink" title="maven仓库下载问题"></a>maven仓库下载问题</h2><p>这个问题是打包的时候并没有找到对应的maven仓库，笔者接入的SDK需要的maven都写在了launcherTemplate文件里，但是打包的时候并没有找到仓库，这是因为maven的仓库应该写在mainTemplate文件里，在launcherTemplate文件里可能会存在没有下载到的情况。  </p><h2 id="API版本问题API"><a href="#API版本问题API" class="headerlink" title="API版本问题API"></a>API版本问题API</h2><p>这里牵扯到两个API的版本，分别是minSdkVersion和targetSdkVersion，打包的时候会报错版本问题，这里只需要在Editor–&gt;ProjectSettings–&gt;Player–&gt;Other Settings里修改对应的Minimum API Level和Target API Level，修改到要求的版本或者更高的版本即可。  </p><p><img src="https://file.liangxiegame.com/8f76046e-d068-4e4a-a7f0-09db7505453d.png" alt="image.png">   </p><h2 id="APK-obb分包无法运行问题"><a href="#APK-obb分包无法运行问题" class="headerlink" title="APK+obb分包无法运行问题"></a>APK+obb分包无法运行问题</h2><p>因为Google商店对上传的apk有内存限制，要求是100M以内，这里推荐使用的是APk+OBB进行分包，根据最新的要求是要求使用AAB包，这里先介绍APK+OBB的分包遇到的问题。  </p><p>分开打包的方法是Editor–&gt;ProjectSettings–&gt;Player–&gt;Publishing Settings里，勾选上最下面的Split Application Binary。 </p><p><img src="https://file.liangxiegame.com/1ce243b5-e799-4710-a446-0e141fc2a4c1.png" alt="image.png">    </p><p>这个是可以代码控制的：  </p><pre><code>PlayerSettings.Android.useAPKExpansionFiles = true;</code></pre><p>分包后如何在手机上运行呢，这里只需要安装分包后的APK，然后在手机上运行，发现第一次运行不成功，这是因为资源都在OBB中，所以无法正常运行，这里只需要吧自己的OBB改好名字放在对应的文件夹就行了。然后再运行就可以了。   </p><p>文件夹地址：手机目录\Android\obb&quot;APP的包名”<br>OBB文件的名字: main.安卓内部版本号.APP包名.obb (举例：main.102.com.XXX.XXX.XXX.obb)</p><h2 id="打包AAB报错-FileNotFoundException-Temp-launcher-aab-does-not-exist"><a href="#打包AAB报错-FileNotFoundException-Temp-launcher-aab-does-not-exist" class="headerlink" title="打包AAB报错:FileNotFoundException: Temp...\launcher.aab does not exist"></a>打包AAB报错:FileNotFoundException: Temp...\launcher.aab does not exist</h2><p>打包aab的方法就是打开File–&gt;Build Settings的面板，然后勾选上Build AppBundle(Google Play)再进行打包就可以了。  </p><p><img src="https://file.liangxiegame.com/09a6726f-1fd1-4805-be17-d0bbb3ad5481.png" alt="image.png">   </p><p>这个报错网上查了一下原因，说的是因为gradle版本过高，导致unity内部逻辑出错的问题。笔者的gradle的版本确实比unity自带的版本过高，于是利用网上给的解决方案解决了。解决方法是在launcher的gradle的defaultConfig里添加下面代码，笔者不导出安卓工程于是就在launcherTemplate的defaultConfig里添加了下列的代码。  </p><pre><code>defaultConfig &#123;    ***    //打包abb的话需要这个    tasks.whenTaskAdded &#123;        task -&gt;        if (task.name.startsWith(&quot;bundle&quot;)) &#123;                   def renameTaskName = &quot;rename$&#123;task.name.capitalize()&#125;Aab&quot;            def flavor = task.name.substring(&quot;bundle&quot;.length()).uncapitalize()            tasks.create(renameTaskName, Copy) &#123;                       def path = &quot;$&#123;buildDir&#125;/outputs/bundle/$&#123;flavor&#125;/&quot;                from(path)                include &quot;launcher-release.aab&quot;                destinationDir file(&quot;$&#123;buildDir&#125;/outputs/bundle/$&#123;flavor&#125;/&quot;)                rename &quot;launcher-release.aab&quot;, &quot;launcher.aab&quot;            &#125;                 task.finalizedBy(renameTaskName)        &#125;    &#125;&#125;</code></pre><h2 id="AAB格式手机安装方法"><a href="#AAB格式手机安装方法" class="headerlink" title="AAB格式手机安装方法"></a>AAB格式手机安装方法</h2><p>首先需要把aab格式的安装包解析成apks格式的安装包，在解析的时候需要一个jar的包，这个jar包是bundletool-all-1.6.1，版本不要求一定是1.6.1，解析的方法是下面CMD的命令：  </p><pre><code>java -jar &lt;bundletool.jar的路径&gt; build-apks --bundle=&lt;.aab文件的路径&gt; --output=&lt;输出.apks的路径&gt; --ks=&lt;打包.aab文件时的秘钥文件路径，如果.aab文件时没有使用秘钥则可以省去秘钥环节的配置&gt; --ks-pass=pass:&lt;秘钥密码&gt; --ks-key-alias=&lt;秘钥别名&gt; --key-pass=pass:&lt;秘钥别名密码&gt; --device-spec=&lt;要输出的目标sdkVersion的APK的json配置文件路径&gt;</code></pre><p>举例：  </p><pre><code>java -jar C:\Users\XX\Desktop\bundletool-all-1.0.0.jar build-apks --bundle=C:\Users\XX\Desktop\test23.aab --output=C:\Users\XX\Desktop\test23.apks --ks=G:\Client\Trunk\key\user.keystore --ks-pass=pass:abcdef --ks-key-alias=yunzhong --key-pass=pass:abcdef --device-spec=C:\Users\XX\Desktop\config.json</code></pre><p>然后手机链接电脑，打开调试模式，接着调用CMD的安装命令：  </p><pre><code>java -jar C:\Users\XX\Desktop\bundletool-all-1.6.1.jar install-apks --apks=C:\Users\XX\Desktop\test23.apks  </code></pre><p>安装结束后手机上就存在自己需要的安装包了。  </p><h2 id="报错Illegal-usage-of-unity-detected-shutdown-unity"><a href="#报错Illegal-usage-of-unity-detected-shutdown-unity" class="headerlink" title="报错Illegal usage of unity detected, shutdown unity"></a>报错Illegal usage of unity detected, shutdown unity</h2><p>分包之后笔者运行发现APP直接闪退，看了半天日志最后发现了一句报错是Illegal usage of unity detected, shutdown unity。笔者使用的是unity2019.4.26f1c1(中国版，以后的中国版本后面都会有个c)。通过百度发现Unity中国版2019.4版本再分割obb编译的时候会导致这个错误，其他版本还没试过，不知道会不会有这个问题。发现只需要使用国际版本即可。  </p><h2 id="报错DSL-element-‘useProguard’-is-obsolete-and-will-be-removed-soon-Use-‘android-enableR8’-in-gradle-pro"><a href="#报错DSL-element-‘useProguard’-is-obsolete-and-will-be-removed-soon-Use-‘android-enableR8’-in-gradle-pro" class="headerlink" title="报错DSL element ‘useProguard’ is obsolete and will be removed soon. Use ‘android.enableR8’ in gradle.pro"></a>报错DSL element ‘useProguard’ is obsolete and will be removed soon. Use ‘android.enableR8’ in gradle.pro</h2><p>出现这个警告是因为build.gradle里配置了 ‘useProguard’属性，而这个属性将很快被移除，使用‘android.enableR8’来代替。这里只需要在gradleTemplate.properties文件后面添加下面一句话就可以了： </p><pre><code>android.enableR8 = true</code></pre><h2 id="报错自己定义的Application丢失"><a href="#报错自己定义的Application丢失" class="headerlink" title="报错自己定义的Application丢失"></a>报错自己定义的Application丢失</h2><p>打包后出现自己写的Application脚本丢失，这个大部分是因为AndroidManifest没有配置自己的Application，配置方法这里就不多做介绍，网上很多介绍。笔者这里遇到的并不是因为没有配置，是因为笔者接入的SDK是继承的MultiDexApplication，这里需要注意的是如果您的 minSdkVersion 设为 21 或更高版本，系统会默认启用 MultiDex，并且您不需要 MultiDex 库。<br>不过，如果您的 minSdkVersion 设为 20 或更低版本，您必须使用 MultiDex 库并对应用项目进行以下修改：</p><pre><code>android &#123;    defaultConfig &#123;        ...        multiDexEnabled true    &#125;    ...&#125;dependencies &#123;    implementation &quot;androidx.multidex:multidex:2.0.1&quot;&#125;</code></pre><p>此时重新编译打包后发现果然打包出多个dex文件，在安卓6.0上测试完美运行，并且用360加固以后5.0以上都能正常运行。<br>但是坑来了 ：在5.0，5.1系统上一运行就奔溃！<br>后来知道在高版本系统上使用art支持多dex，而低版本dalvik默认先加载主dex，如果启动时需要的类不在主dex内就会报错ClassNotFoundException。 解压apk发现里面有上百个dex文件，一般不会拆分如此多，百度查阅后得知：<br>对于dex 的–multi-dex 选项设置与预编译的library工程有冲突,如果你的应用中包含引用的lirary工程,需要将预编译设置为false:<br>在 build.gradle中添加  </p><pre><code>dexOptions&#123;    preDexLibraries = false&#125;</code></pre><h1 id="SDK遇到问题"><a href="#SDK遇到问题" class="headerlink" title="SDK遇到问题"></a>SDK遇到问题</h1><h2 id="华为手机出现水滴屏无法适配的问题"><a href="#华为手机出现水滴屏无法适配的问题" class="headerlink" title="华为手机出现水滴屏无法适配的问题"></a>华为手机出现水滴屏无法适配的问题</h2><p>笔者的项目要求手机在遇到水滴屏或者刘海屏的时候，上面显示黑条不进行渲染就可以，笔者查了一下unity的设置方法，发现只需要不勾选Editor–&gt;ProjectSettings–&gt;Resolution and Presentation里的Render outside safe area即可。  </p><p><img src="https://file.liangxiegame.com/45f3375d-4006-40a8-a599-3efb2978e578.png" alt="image.png">   </p><p>但是笔者发现APP在某个测试的华为手机上依旧渲染了，最后发现是接入的SDK里设置了华为手机的屏幕渲染。在华为手机Android8.0的适配方案是在AndroidManfiest里面添加下面的话即可，笔者发现接入的SDK设置了这个，于是去掉就没有问题了。  </p><pre><code>&lt;meta-data android:name=&quot;android.notch_support&quot; android:value=&quot;true&quot;/&gt; </code></pre><p>这里列举一下小米手机的适配方案是：  </p><pre><code>&lt;meta-data android:name=&quot;notch.config&quot; android:value=&quot;portrait|landscape&quot;/&gt;</code></pre><h2 id="如何修改build-gradle"><a href="#如何修改build-gradle" class="headerlink" title="如何修改build.gradle"></a>如何修改build.gradle</h2><p>关于对Android的gradle的脚本进行修改，其实上面已经介绍了。Pluging/Android文件夹下的XXXTemplate对应的其实就是导出android工程下的build.gradle，修改对应的Template就是修改对应的build.gradle。  </p><h2 id="如何添加Android需要的java脚本"><a href="#如何添加Android需要的java脚本" class="headerlink" title="如何添加Android需要的java脚本"></a>如何添加Android需要的java脚本</h2><p>首先导出一个安卓工程，然后用AndroidStudio打开导出的Android工程，然后直接在安卓工程里写对应的脚本，脚本完成后直接复制到unity工程中pluging下Android文件夹下面。这里因为每次都要复制文件，所以笔者写了一个脚本直接一键复制所有的bat脚本。脚本内容如下：  </p><pre><code>@echo offset filePath=unityLibrary\src\main\java\com\ksset targetFilePath=..\..\project\Assets\Plugins\Androidfor /R %filePath% %%i in (*.java) do (    xcopy /y /c /h /r %%i %targetFilePath%    echo %%i)pause</code></pre><p>后来发现每次改好脚本后，还需要找到这个bat文件执行，于是笔者简化了这个步骤，笔者添加了一个unity的编辑器脚本，用于执行这个bat文件。脚本内容如下：  </p><pre><code>public static void SyncAndroidJava2()&#123;    var filepath = FileEditorTools.FormatPath(Application.dataPath + &quot;/../../android/AndroidBDSDK_R/&quot;);    RunBat(&quot;CopyJavaScripts.bat&quot;, &quot;&quot;, filepath);&#125;//cmd是执行的脚本的名字    args是参数，可以直接设置为“”        workingDir是执行bat文件所在文件夹路径public static System.Diagnostics.Process CreateShellExProcess(string cmd, string args, string workingDir = &quot;&quot;)&#123;    var pStartInfo = new System.Diagnostics.ProcessStartInfo(cmd);    pStartInfo.Arguments = args;    pStartInfo.CreateNoWindow = false;    pStartInfo.UseShellExecute = true;    pStartInfo.RedirectStandardError = false;    pStartInfo.RedirectStandardInput = false;    pStartInfo.RedirectStandardOutput = false;    if (!string.IsNullOrEmpty(workingDir))        pStartInfo.WorkingDirectory = workingDir;    return System.Diagnostics.Process.Start(pStartInfo);&#125;public static void RunBat(string batfile, string args, string workingDir = &quot;&quot;)&#123;    var p = CreateShellExProcess(batfile, args, workingDir);    p.Close();&#125;</code></pre><p>在执行bat脚本的时候笔者发现，自己完全可以写一个复制用的脚本，就不需要再依靠bat脚本进行执行。脚本如下：<br>    public static void SyncAndroidJava()<br>    {<br>        var filepath = FileEditorTools.FormatPath(Application.dataPath + “/../../android/AndroidBDSDK_R/unityLibrary/src/main/java/com/ks/“);            //需要复制的java文件所在的文件夹<br>        var folderpath = Application.dataPath + “/Plugins/Android/“;            //复制到的文件位置<br>        var filelist = FileEditorTools.GetallFile(filepath, “.java”);</p><pre><code>    var curcount = 0;    var sumcount = filelist.Count;        EditorUtility.DisplayProgressBar(&quot;同步Android的Java脚本&quot;, &quot;开始复制文字...&quot;, 0);    foreach (var javafile in filelist)    &#123;        EditorUtility.DisplayProgressBar(&quot;复制文件&quot;, javafile.FullName, (float)curcount / sumcount);        // 判断目标目录是否存在如果不存在则新建        try        &#123;            FileEditorTools.CopyFileToFolder(javafile,folderpath);        &#125;        catch (Exception e)        &#123;            Debug.LogError(e);            EditorUtility.ClearProgressBar();            return;        &#125;        Debug.Log(javafile.FullName);        curcount++;    &#125;    EditorUtility.ClearProgressBar();&#125;public class FileEditorTools&#123;    // 文件列表    private static List&lt;FileInfo&gt; _FileList = new List&lt;FileInfo&gt;();        #region   公有方法    /// &lt;summary&gt;    /// 获得目录下所有文件或指定文件类型文件(包含所有子文件夹)    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件夹路径&lt;/param&gt;    /// &lt;param name=&quot;extName&quot;&gt;扩展名可以多个 例如[.mp4] [.mp3] [.wma] 等&lt;/param&gt;    /// &lt;returns&gt;List&lt;FileInfo&gt;&lt;/returns&gt;    public static List&lt;FileInfo&gt; GetallFile(string path, string extName)    &#123;        //检查目录是否存在        if (!string.IsNullOrWhiteSpace(path))        &#123;            if (Directory.Exists(path))            &#123;                GetallfilesOfDir(path, extName);            &#125;            else            &#123;                Directory.CreateDirectory(path);            &#125;        &#125;        else        &#123;            //注意这里的EverydayLog.Write()是我自定义的日志文件，可以根据需要保留或删除            Debug.LogError(&quot;GetAllFileOfFolder/GetallFile()/存储视频文件的路径为空，请检查！！！&quot; );        &#125;        return _FileList;    &#125;    public static void CopyFileToFolder(FileInfo fileinfo,string fildername)    &#123;        var destfilename = FormatPath(fildername+fileinfo.Name);        File.Copy(fileinfo.FullName, destfilename, true);    &#125;        public static string FormatPath(string path)    &#123;        path = path.Replace(&quot;/&quot;, &quot;\\&quot;);        if (Application.platform == RuntimePlatform.OSXEditor)            path = path.Replace(&quot;\\&quot;, &quot;/&quot;);        return path;    &#125;    #endregion        #region   私有方法    /// &lt;summary&gt;    /// 递归获取指定类型文件,包含子文件夹    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;指定文件夹的路径&lt;/param&gt;    /// &lt;param name=&quot;extName&quot;&gt;文件拓展名&lt;/param&gt;    private static void GetallfilesOfDir(string path, string extName)    &#123;        try        &#123;            string[] dir = Directory.GetDirectories(path); //文件夹列表               DirectoryInfo fdir = new DirectoryInfo(path);            FileInfo[] file = fdir.GetFiles();            if (file.Length != 0 || dir.Length != 0) //当前目录文件或文件夹不为空                               &#123;                foreach (FileInfo f in file) //显示当前目录所有文件                   &#123;                    if (extName.ToLower().IndexOf(f.Extension.ToLower()) &gt;= 0)                    &#123;                        _FileList.Add(f);                    &#125;                &#125;                foreach (string d in dir)                &#123;                    GetallfilesOfDir(d, extName);//递归                   &#125;            &#125;        &#125;        catch (Exception ex)        &#123;            //注意这里的EverydayLog.Write()是我自定义的日志文件，可以根据需要保留或删除            Debug.LogError(&quot;/GetAllFileOfFolder()/GetallfilesOfDir()/获取指定路径：&quot;+path+&quot;   下的文件失败！！！，错误信息=&quot;+ex.Message);        &#125;    &#125;    #endregion    &#125;</code></pre><h2 id="设备唯一标识"><a href="#设备唯一标识" class="headerlink" title="设备唯一标识"></a>设备唯一标识</h2><p>这里的设备唯一标识一开始笔者用的是设备的OAID，后来发现有些设备并不能获取到设别的OAID，并且换位的手机如果打开了”关闭广告追踪“，那么获取的OAID所以这个并不能作为设别的唯一标识，网上有很多进行多数据拼接的方法，于是笔者从自己公司的SDK摘取了或者设备唯一标识的方法，这是一个比较简单的方法，就是先获取设备的androidID，如果获取不到就会自己保存一个数据到文件里，然后每次从文件里读取就行了。  </p><pre><code>private static String deviceId;public String GetDeviceID() &#123;    Application yourApplicatoin = this;            //这里只是举个例子，这里需要大家获取一下自己的Application    if (yourApplicatoin.getApplicationContext() == null) //这里是获取Application的实例，如果没有就可以直接返回空        return &quot;&quot;;    else &#123;        String var1;        if ((var1 = deviceId) != null)            //先判断deviceID是否已经赋值过了，如果已经赋值就直接返回就行了            return var1;        else &#123;            deviceId = getSPValue(yourApplicatoin, &quot;DeviceId&quot;);    //如果没有就先从文件里获取一下            if (!TextUtils.isEmpty(deviceId)) &#123;                    //如果获取到了就直接返回                return deviceId;            &#125; else &#123;                deviceId = getAndroidIdAsDeviceId(yourApplicatoin);    //如果文件里没有就先尝试获取一下androidID作为设备唯一标识                if (!TextUtils.isEmpty(deviceId)) &#123;                    //获取到了就进行保存并返回这个标识                    saveSPValue(yourApplicatoin, &quot;DeviceId&quot;, deviceId);                        return deviceId;                &#125; else &#123;                    deviceId = generateSoftDeviceId();                //如果没有获取到就通过自己的混合加密方式进行缓存                    if (!TextUtils.isEmpty(deviceId)) &#123;                //如果不为空就保存然后返回标识                        saveSPValue(yourApplicatoin, &quot;DeviceId&quot;, deviceId);                        return deviceId;                    &#125; else &#123;                                        //如果都没获取到就是特殊情况，直接返回                        return deviceId;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="保存DeviceID到文件里"><a href="#保存DeviceID到文件里" class="headerlink" title="保存DeviceID到文件里"></a>保存DeviceID到文件里</h2><p>通过getSharedPreferences方法将deviceid保存到文件里。</p><pre><code>private static void saveSPValue(Context mycontext, String datakey, String datavalue) &#123;    mycontext.getSharedPreferences(&quot;myappsdkdeviceid&quot;, 0).edit().putString(&quot;datakey&quot;, datavalue).apply();&#125;</code></pre><p>myappsdkdeviceid是文件名字，datakey是保存的关键字名字，然后datavalue是储存的值，就是我们要储存的deviceid。  </p><h2 id="从文件里获取DeviceID"><a href="#从文件里获取DeviceID" class="headerlink" title="从文件里获取DeviceID"></a>从文件里获取DeviceID</h2><pre><code>private static String getSPValue(Context mycontext, String datakey) &#123;    return var0.getSharedPreferences(&quot;myappsdkdeviceid&quot;, 0).getString(datakey, (String)null);&#125;</code></pre><p>myappsdkdeviceid是文件名字，datakey是保存的关键字名字。 </p><h2 id="获取设备的AndroidID"><a href="#获取设备的AndroidID" class="headerlink" title="获取设备的AndroidID"></a>获取设备的AndroidID</h2><pre><code>private static String getAndroidIdAsDeviceId(Context mycontext) &#123;    String andid = Settings.Secure.getString(mycontext.getContentResolver(), &quot;android_id&quot;);    //获取设备的AndroidID    return isLegalAndroidId(andid) ? &quot;ANDROID_&quot; + andid : null;                //如果符合条件就添加前缀，不符合就返回空&#125;private static final Pattern ANDROID_ID_PATTERN = Pattern.compile(&quot;^[0-9a-fA-F]&#123;16&#125;$&quot;);private static boolean isLegalAndroidId(String andid) &#123;                                return !TextUtils.isEmpty(andid) &amp;&amp; ANDROID_ID_PATTERN.matcher(andid).find();&#125;</code></pre><p>第二个函数是判断获得到的android是否不为空并且符合正则表达式的规则  </p><h2 id="自定义的设备唯一标识"><a href="#自定义的设备唯一标识" class="headerlink" title="自定义的设备唯一标识"></a>自定义的设备唯一标识</h2><pre><code>private static long randomLong(long var0) &#123;    return Build.VERSION.SDK_INT &gt;= 21 ? ThreadLocalRandom.current().nextLong(var0) : (long)((new Random()).nextDouble() * (double)(var0 - 1L));&#125;private static String generateSoftDeviceId() &#123;    String arg0  = Build.SERIAL;            //首先获取序列号    if (TextUtils.isEmpty(arg0)) &#123;            //如果没有获取到序列化就赋值为&quot;NA&quot;        arg0 = &quot;NA&quot;;    &#125;    long arg1 = 2564562216496361285L;        //设置两个随机的long型的数据    long arg2 = 8545649582269949258L;    arg2 = randomLong(arg2);        //获取一个随机数，获取失败就调回去重新获取    arg1 += arg2;    String var8 = &quot;ANDROID_%1$s_%2$s&quot;;        //设置一下格式    Object[] arg3 = new Object[2];    arg3[0] = Long.toHexString(arg1);        //设置第一个参数    try &#123;        arg3[1] = arg0;                        //设置第二个参数        return String.format(var8, arg3);    &#125; catch (Throwable var3) &#123;    &#125;    Object[] arg4;                            //如果上述存在问题就根据时间设置一个随机数    Object[] arg5 = arg4 = new Object[2];    arg5[0] = &quot;NA&quot; + Long.toHexString(System.currentTimeMillis());    arg5[1] = arg0;    return String.format(&quot;ANDROID_%1$s_%2$s&quot;, arg4);&#125;</code></pre><h1 id="AWS-亚马逊-的CDN上传"><a href="#AWS-亚马逊-的CDN上传" class="headerlink" title="AWS(亚马逊)的CDN上传"></a>AWS(亚马逊)的CDN上传</h1><h2 id="网页上传"><a href="#网页上传" class="headerlink" title="网页上传"></a>网页上传</h2><p>这种上传方式就是访问网页，然后按照需求把自己需要上传的文件上传到对应网页的进行上传。  </p><h2 id="自动上传"><a href="#自动上传" class="headerlink" title="自动上传"></a>自动上传</h2><p>笔者采用的是利用python环境然后写的bat脚本进行上传。  </p><h2 id="Python环境配置"><a href="#Python环境配置" class="headerlink" title="Python环境配置"></a>Python环境配置</h2><p>首先需要在Python虚拟环境中安装 AWS CLI  </p><pre><code>$ pip install awscli</code></pre><p>这里介绍一个python比较好的版本管理工具，可以管理本地多版本的python。<a href="https://www.jianshu.com/p/d66fce9a7bdc"><font color=steelblue size=3>pyenv</font></a>   </p><h2 id="aws版本查看"><a href="#aws版本查看" class="headerlink" title="aws版本查看"></a>aws版本查看</h2><pre><code>$ aws --version</code></pre><p><img src="https://file.liangxiegame.com/12c0d1cf-5a76-4322-bbb6-55654310b33d.png" alt="image.png">   </p><h2 id="更新aws"><a href="#更新aws" class="headerlink" title="更新aws"></a>更新aws</h2><pre><code>$ aws install awscli --upgrade</code></pre><h2 id="卸载aws"><a href="#卸载aws" class="headerlink" title="卸载aws"></a>卸载aws</h2><pre><code>$ pip uninstall awscli  </code></pre><h2 id="配置AWS-CLI"><a href="#配置AWS-CLI" class="headerlink" title="配置AWS CLI"></a>配置AWS CLI</h2><pre><code>$ aws configureAWS Access Key ID [None]: *******AWS Secret Access Key [None]: *******Default region name [None]: us-east-2Default output format [None]: json</code></pre><p>这里分辨需要填上对应的参数，上面的ID和Key就是自己页面申请aws给提供的。下面的json也只输出的格式，这里最关键的其实是<strong>Default region name</strong>，这里并不是随便填的，而是填上aws终端节点对应的区域代码。  </p><p><img src="https://file.liangxiegame.com/63176da0-0361-49ed-8413-00163af95287.png" alt="image.png">   </p><p>这里其实会再打开终端的目录生成一个.aws文件夹，里面会有config和credentials两个文件就是我们的配置文件了。  </p><h2 id="aws与s3配合使用"><a href="#aws与s3配合使用" class="headerlink" title="aws与s3配合使用"></a>aws与s3配合使用</h2><p>想要使用aws cli上传文件需要与s3配合使用。  </p><h3 id="列举自己的库"><a href="#列举自己的库" class="headerlink" title="列举自己的库"></a>列举自己的库</h3><pre><code>$ aws s3 ls  </code></pre><h3 id="列举库中文件夹内容"><a href="#列举库中文件夹内容" class="headerlink" title="列举库中文件夹内容"></a>列举库中文件夹内容</h3><pre><code>$ aws s3 ls s3://my-bucket  </code></pre><h3 id="上传文件到s3的库"><a href="#上传文件到s3的库" class="headerlink" title="上传文件到s3的库"></a>上传文件到s3的库</h3><pre><code>$aws s3 cp my-file s3://my-bucket/my-folder</code></pre><p>如果每次都使用上面的命令传输文件还是比较麻烦的，所以笔者自己写了一个简单的bat脚本，可以更方便的上传文件  </p><pre><code>@echo offset filePath=..\resource\cdnfileroot\resource\packres\default-pack\android-defaultset cdnPath=s3://cyber-era-cdn/resource/packres/default-pack/android-defaultcall cd %filePath%for %%i in (*.zip) do (    call aws s3 cp %%i %cdnPath%/%%i    echo %%i)pause</code></pre><h1 id="海外文本替换"><a href="#海外文本替换" class="headerlink" title="海外文本替换"></a>海外文本替换</h1><h2 id="提取Prefab中文字到表里"><a href="#提取Prefab中文字到表里" class="headerlink" title="提取Prefab中文字到表里"></a>提取Prefab中文字到表里</h2><p>这里是把prefab上的文字全部提取到一个自定定义的Language表里。首先需要读取自定义的Language表里的数据，这是为了去重用的。然后加载本地所有的prefab，再遍历prefab所有的节点，然后判断是否包含Text的组件，如果包含文字就把文字记录在自己的字典中。在放进字典中是需要排重的。<br>加载Prefab的代码  </p><pre><code>private static void doLoadPrefab(bool clearText,bool onlyFindText = false)        //两个参数分别是是否清除Text组件和是否之查找文本，下面会有详细介绍&#123;    ...    if (string.IsNullOrEmpty(ExportExcel.excelFolder))        //接下来是查找自己的需要导入的表，不存在就创建一个新的表    &#123;        excelPath = EditorUtility.OpenFilePanel(&quot;选择SVN中的ProgramLanguage表&quot;,&quot;&quot;,&quot;&quot;);    &#125;    else    &#123;        excelPath = ExportExcel.excelFolder + &quot;/ProgramLanguage.xlsx&quot;;    &#125;    if (!string.IsNullOrEmpty(excelPath))    &#123;        ReadExcel();                                        //进行读取加载表格        LoadAllPrefabText(clearText,onlyFindText);            //进行加载所有prefab的文本内容        if (clearText)                                        //如果是清除文本组件的就只是需要清除字典        &#123;            textDesAddDic.Clear();        &#125;        else                                                //如果不是清除的就把读取内容写入到表格中        &#123;            WroadExcel();        &#125;    &#125;&#125;</code></pre><p>读取Language代码如下:  </p><pre><code>private static int exKey;private static string exValue;public static void ReadExcel()&#123;    var attrArr = File.GetAttributes(excelPath);            //这个是获取表格的属性，因为有些表格可能是只读属性，需要修改    File.SetAttributes(excelPath, FileAttributes.Normal);    //把表格的属性设置成普通属性，这样就一定能写入了，之所以不是去掉只读属性是因为只是单独修改可读属性不知道为何还是不能写入，就先设置为普通的属性了    textDesDic.Clear();                                        //清空自己的字典    excelFile = new FileInfo(excelPath);                    //接着就是获取表格文件    using (ExcelPackage excelPackage = new ExcelPackage(excelFile))        //下面就是循环读取表格内容然后写入到字典中    &#123;        var worksheet = excelPackage.Workbook.Worksheets[1];        for (int i = startRow; i &lt;= worksheet.Dimension.End.Row; i++)        &#123;            exKey = worksheet.Cells[i, keyColumn].GetValue&lt;int&gt;();            exValue = worksheet.Cells[i, valueVolumn].GetValue&lt;string&gt;();            startTextIndex = Mathf.Max(exKey, startTextIndex);            textDesDic.Add(exKey, exValue);        &#125;    &#125;    textDesAddDic.Clear();                                    //接着就是把第二个增加的字典清空，是为了记录新增的文字    File.SetAttributes(excelPath, attrArr);                    //然后就是把文件属性设置为原来的属性&#125;</code></pre><p>写入Language和读取类似，只是把原来的遍历读取变成遍历新增字典，然后一行一行写入。代码如下:  </p><pre><code>public static void WroadExcel()&#123;    var attrArr = File.GetAttributes(excelPath);    File.SetAttributes(excelPath, FileAttributes.Normal);    excelFile = new FileInfo(excelPath);    using (ExcelPackage excelPackage = new ExcelPackage(excelFile))    &#123;        var worksheet = excelPackage.Workbook.Worksheets[1];        var curRow = worksheet.Dimension.End.Row;        foreach (var textdespair in textDesAddDic)        &#123;            worksheet.Cells[++curRow, keyColumn].Value = textdespair.Key;            worksheet.Cells[curRow, valueVolumn].Value = textdespair.Value;        &#125;                excelPackage.Save();                                //保存表    &#125;        File.SetAttributes(excelPath, attrArr);        textDesAddDic.Clear();&#125;</code></pre><p>加载prefab中的Text文本，代码如下:  </p><pre><code>static StringBuilder newTexts = new StringBuilder();public static void LoadAllPrefabText(bool isClearText,bool onlyFindTxt = false)&#123;    newTexts.Clear();                            //清空字符串    textDesAddDic.Clear();                        //清空新增的字典    var sdirs =GetAllPrefabFiles();                //获取Prefab的存在文件夹    EditorUtility.DisplayProgressBar(&quot;Progress&quot;, &quot;LoadPrefabTxtDes...&quot;, 0);        //打开一个进度掉，为了方便查看加载进度使用    var asstIds = AssetDatabase.FindAssets(&quot;t:Prefab&quot;, sdirs);                    //得到所有Prefab的资源    int count = 0;                                //初始化加载的进度    for (int i = 0; i &lt; asstIds.Length; i++)    //循环遍历一下自己加载出来的prefab    &#123;        string path = AssetDatabase.GUIDToAssetPath(asstIds[i]);            //得到prefab资源的路径        //Debug.LogError(&quot;try deal with path &quot;+path);                                var pfb = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(path);            //根据路径加载对应的prefab        var texts = pfb.GetComponentsInChildren&lt;Text&gt;(true);                //得到prefab上所有节点的Text组件        if (texts == null || texts.Length &lt;= 0)                                //如果不存在就跳过，遍历到下一个prefab        &#123;            //Debug.LogError(&quot;asset no texts: &quot;+path);            continue;        &#125;        foreach (var item in texts)                                            //遍历prefab中的Text组件        &#123;            textDes = item.text;                                            //获取组件上的文字            if (textDes.IsNullOrWhitespace())                                //如果文字为空就跳过到下一个                continue;                        var langTextComp = item.gameObject.GetComponent&lt;MutiLangText&gt;();//获取Text文本上的脚本，自己写的替换文本的脚本            if (langTextComp &amp;&amp; onlyFindTxt)                                //如果存在脚本并且只是查找文本，说明已经添加过就可以直接跳过了            &#123;                continue;                //Debug.LogError(&quot;has Added MutiText: &quot;+item.name);            &#125;            bool addComP = false;                                            //标记是否增加组件为false            if (isClearText)                                                //判断是否需要清除自己的替换语言脚本            &#123;                if (!textDesDic.ContainsValue(textDes))                        //判断表里是否已经存在文本                &#123;                    item.text = &quot;&quot;;                                            //如果不存在就先清除文字                    if (langTextComp)                                        //如果不存在自己的脚本就一并删除                    &#123;                        //TODO  remove  comp                        DestroyImmediate(langTextComp);                    &#125;                &#125;                else                                                        //如果表里存在就从字典里获取到表里的ID                &#123;                    curDesId = textDesDic.Where(q =&gt; q.Value == textDes).Select(q =&gt; q.Key).ToArray()[0];                    addComP = true;                                            //标记需要增加组件                &#125;            &#125;            else                                                            //如果不是清除文本            &#123;                if (onlyFindTxt)                                            //如果只是查找文本                &#123;                    if (!textDesDic.ContainsValue(textDes))                    //如果字典中不存在就记录下来                    &#123;                        newTexts.AppendLine(textDes);                    &#125;                    continue;                &#125;                if (!textDesDic.ContainsValue(textDes))                        //如果字典中不存在，就往字典中添加，并且在新增字典中增加                &#123;                    textDesDic.Add(++startTextIndex, textDes);                    textDesAddDic.Add(startTextIndex,textDes);                    curDesId = startTextIndex;                &#125;                else                                                        //如果存在就记录下来文本对应的ID                &#123;                    curDesId = textDesDic.Where(q =&gt; q.Value == textDes).Select(q =&gt; q.Key).ToArray()[0];                &#125;                                if(!langTextComp)                                            //如果并没有增加切换语言脚本就标记需要增加脚本                &#123;                    addComP = true;                &#125;            &#125;            if (addComP &amp;&amp; !langTextComp)                                    //如果需要增加并且组件不存在，就增加一下自己的脚本                    &#123;                langTextComp = item.gameObject.AddComponent&lt;MutiLangText&gt;();                langTextComp.baseText = item;            &#125;                        if (langTextComp)                                                //如果存在组件就更新一下ID                langTextComp.languageID = curDesId;        &#125;        PrefabUtility.SavePrefabAsset(pfb, out bool success);                //修改完毕保存prefab就可以了        if (success)                                                        //记录加载进度，然后更新进度条        &#123;            count++;        &#125;        EditorUtility.DisplayProgressBar(&quot;LoadPrefabTxtDes Progress&quot;, pfb.name, count / (float)asstIds.Length);    &#125;    if (newTexts.Length &gt; 0)                                                //如果有新增的文字就记录下来    &#123;        Debug.LogError(&quot;write new text: &quot;+newTexts.Length);        File.WriteAllText(ExportExcel.excelFolder + &quot;/newText.txt&quot;,newTexts.ToString());    &#125;    EditorUtility.ClearProgressBar();                                        //结束之后清除加载进度条&#125;</code></pre><p>获取Prefab文件路径的代码：  </p><pre><code>private static string[] GetAllPrefabFiles()&#123;    string sdir = &quot;Assets/XXX/XXX&quot;;    List&lt;string&gt; sdirlist = new List&lt;string&gt;();    sdirlist.Add(sdir);    sdirlist.Add(&quot;Assets/Resources/RootPrefab&quot;);       return sdirlist.ToArray();    &#125;</code></pre><h2 id="查找代码中的中文"><a href="#查找代码中的中文" class="headerlink" title="查找代码中的中文"></a>查找代码中的中文</h2><p>因为一开始没有考虑到会做海外，并且写的代码不规范，所以存在一部分中文是在代码里。这部分中文代码是不好查找的，所以写了一个小脚本，可以快速标记到中文代码的位置，这个脚本可以解决大部分，但是仍旧是存在找不到的问题的。下面来看代码:  </p><p>首先会打开一个面板用来选择代码脚本所在的文件路径</p><pre><code>[MenuItem(&quot;Tools/ReplaceText/FindScriptsLanguage&quot;)]public static void Pack()&#123;    Rect wr = new Rect(300, 400, 400, 100);    FindChineseWindow window = (FindChineseWindow)EditorWindow.GetWindowWithRect(typeof(FindChineseWindow), wr, true, &quot;查找项目中的中文字符&quot;);    window.Show();&#125;public class FindChineseWindow : EditorWindow&#123;    private ArrayList csList = new ArrayList();    private int eachFrameFind = 4;    private int currentIndex = 0;    private bool isBeginUpdate = false;    private string outputText;    public string filePath = &quot;/Scripts&quot;;    private string strForShader = &quot;&quot;;    //这个是需要忽略检测的文件夹    private List&lt;string&gt; ingoreFileInfoDirNameList = new List&lt;string&gt; &#123;&quot;GMConsole&quot;, &quot;LogicWorld&quot;, &quot;NetWork&quot;, &quot;SDK&quot;&#125;;    //这个是需要忽略的代码文件名    private List&lt;string&gt; ingoreFileInfoNameList = new List&lt;string&gt; &#123;&quot;LocalLanguage&quot;&#125;;    //这个是需要忽略的代码包含的字符串    private List&lt;string&gt; ingoreScriptesDesList = new List&lt;string&gt; &#123;&quot;Debug&quot;, &quot;LogWrapper&quot;, &quot;Tooltip&quot;, &quot;throw new&quot;&#125;;    //获取需要检测的文件    private void GetAllFile(DirectoryInfo dir)    &#123;        FileInfo[] allFile = dir.GetFiles();        foreach (FileInfo fi in allFile)        &#123;            if (ingoreFileInfoDirNameList.Where(str =&gt; fi.DirectoryName.Contains(str)).Count() &gt; 0)                 continue;            if (ingoreFileInfoNameList.Where(str =&gt; fi.Name.Contains(str)).Count() &gt; 0)                 continue;            if (fi.FullName.IndexOf(&quot;.meta&quot;) == -1 &amp;&amp; fi.FullName.IndexOf(&quot;.cs&quot;) != -1)            &#123;                csList.Add(fi.DirectoryName + &quot;/&quot; + fi.Name);            &#125;        &#125;        DirectoryInfo[] allDir = dir.GetDirectories();        foreach (DirectoryInfo d in allDir)        //遍历子文件夹        &#123;            GetAllFile(d);        &#125;    &#125;    public void OnGUI()            //面板显示的代码    &#123;        filePath = EditorGUILayout.TextField(&quot;路径：&quot;, filePath);        //输入路径        EditorGUILayout.Space();        EditorGUILayout.Space();        if (GUILayout.Button(&quot;开始遍历目录&quot;))                                //显示的按钮        &#123;            csList.Clear();            DirectoryInfo d = new DirectoryInfo(Application.dataPath + filePath);    //从绝对路径读取文件            GetAllFile(d);                                                //获取所有的文件            //GetAllFile(d);            outputText = &quot;游戏内代码文件的数量：&quot; + csList.Count;            isBeginUpdate = true;            outputText = &quot;开始遍历项目&quot;;        &#125;        GUILayout.Label(outputText, EditorStyles.boldLabel);    &#125;    private bool HasChinese(string str)                //这是个判断是否是中文的方法    &#123;        return Regex.IsMatch(str, @&quot;[\u4e00-\u9fa5]&quot;);    &#125;    private Regex regex = new Regex(&quot;\&quot;[^\&quot;]*\&quot;&quot;);    private void printChinese(string path)            //开始输出中文文字所在位置    &#123;        if (File.Exists(path))        &#123;            string[] fileContents = File.ReadAllLines(path, Encoding.Default);            int count = fileContents.Length;            for (int i = 0; i &lt; count; i++)            &#123;                string printStr = fileContents[i].Trim();                if (printStr.IndexOf(&quot;//&quot;) == 0) //说明是注释                    continue;                if (ingoreScriptesDesList.Where(str =&gt; printStr.Contains(str)).Count() &gt; 0) //说明是需要排除的代码                    continue;                MatchCollection matches = regex.Matches(printStr);                foreach (Match match in matches)                &#123;                    if (HasChinese(match.Value))                    &#123;                        string[] fullPath = path.Split(&#39;/&#39;);                        path = fullPath[fullPath.Length - 1];                        Debug.Log(&quot;路径:&quot; + path + &quot; 行数:&quot; + i + &quot; 内容:&quot; + printStr);                        break;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;打包&quot;&gt;&lt;a href=&quot;#打包&quot; class=&quot;headerlink&quot; title=&quot;打包&quot;&gt;&lt;/a&gt;打包&lt;/h1&gt;&lt;h2 id=&quot;Gradle版本问题&quot;&gt;&lt;a href=&quot;#Gradle版本问题&quot; class=&quot;headerlink&quot; title=&quot;Gradl</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="海外Google" scheme="http://yoursite.com/tags/%E6%B5%B7%E5%A4%96Google/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——基于UGUI实现性能更好的圆形Image</title>
    <link href="http://yoursite.com/2021/04/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EUGUI%E5%AE%9E%E7%8E%B0%E6%80%A7%E8%83%BD%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%9C%86%E5%BD%A2Image/"/>
    <id>http://yoursite.com/2021/04/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EUGUI%E5%AE%9E%E7%8E%B0%E6%80%A7%E8%83%BD%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%9C%86%E5%BD%A2Image/</id>
    <published>2021-04-30T03:00:36.000Z</published>
    <updated>2021-12-27T03:39:09.483Z</updated>
    
    <content type="html"><![CDATA[<p>参考博客地址：<a href="https://www.cnblogs.com/leoin2012/p/6425089.html">https://www.cnblogs.com/leoin2012/p/6425089.html</a>  </p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在我们开发游戏过程中，会经常使用Mask来进行图片的裁剪，但是笔者在使用Mask进行裁剪的时候发现锯齿特别严重，因此笔者选择了利用shader进行图形遮罩，详情请看<a href="https://lianbai.github.io/2021/04/20/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UGUI%E5%9F%BA%E4%BA%8E%E5%9B%BE%E9%9B%86%E7%9A%84shader%E9%81%AE%E7%BD%A9/">Unity杂文——UGUI基于图集的shader遮罩</a>。<br>笔者虽然已经利用shader做好了遮罩并应用项目中的，但是在笔者在学习UGUI优化的时候发现Mask不仅有锯齿，也会增加两个DrawCall，因为Mask会把自己和子节点都和外面分开，不会进行合批，这样mask越多，DrawCall就会比较严重，笔者利用Shader进行遮罩虽然也会多一个DrawCall，但是相同的材质会进行合批，<br>裁剪随然已经改好了，但是笔者发现了不会增加DrawCall的方法。  </p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>我们在屏幕上看到的图形是GPU渲染出来的，而GPU渲染的最小单位是三角面片，我们从Unity的Scence场景中，切换视图方式为WireFrame或者Shader Wireframe都可以明显看到图片是三角形组成的，而我们要制作出圆形的Image可以利用多个等腰三角形，这样就可以拼接成看似圆形的Image，三角形数量越多就越像圆形。如下图：  </p><p><img src="https://file.liangxiegame.com/fc913a59-b938-4129-8c69-fc299a3ba79b.png" alt="image.png">   </p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>首先我们需要自己重写Image，我们要自己实现画图，我们首先查看Image的原码：  </p><pre><code>public class Image : MaskableGraphic, ISerializationCallbackReceiver, ILayoutElement, ICanvasRaycastFilter</code></pre><p>我们可以看到Image继承了MaskableGraphic，并且实现了ISerializationCallbackReceiver、ILayoutElement、ICanvasRaycastFilter的接口。最关键的其实是MaskableGraphic类，因为这个类主要是负责画图的，我们可以很简单的看到MaskableGraphic类其实继承了Graphic类，在这个类里面有个OnPopulateMesh函数，这个函数就是我们需要重写的函数。<br>当UI元素生成顶点数据时就会调用OnPopulateMesh函数，我们只需要继承这个函数并且将原来的顶带你数据清除，改写成我们自己设置的圆形的顶带你数据，这样我们就可以画我们需要的圆形了。<br>由于在Unity中，继承UnityEngine基类的派生类并不能在Inspector面板里显示参数，笔者在制作圆形的Image的时候肯定要设置一些可调节的参数，这样可以应用到更多的场景中，因为笔者就像参考博客一样新建一个BaseImage类去继承Image类，然后自己再写一个CircleImage类去继承BaseImage类，这样我们把可调节的变量放在CircleImage类中，这样就可以通过面板调节参数了。<font color=red>(原Image源码有近千行代码，BaseImage对其进行了部分精简，只支持Simple Image Type，并去掉了eventAlphaThreshold的相关代码。经过删减，得到一个百行代码的BaseImage类，精简版Image就完成了。)</font>  </p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>完整代码在最后面，因为内容过多，笔者就先写代码分析，您可以先复制最后的完整代码到工程里，然后自己对着代码一步一步进行。  </p><h3 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h3><p>笔者首先介绍一下笔者设置的允许调节的参数，参数描述都在代码中，代码如下：  </p><pre><code>[Tooltip(&quot;圆形的半径&quot;)][Range(0, 1)]public float fillRadius = 1f;[Tooltip(&quot;UV缩放比例&quot;)][Range(0, 1)]public float UVScale = 1f;[Tooltip(&quot;圆形的中心点&quot;)]public Vector2 fillCenter = new Vector2(0.5f, 0.5f);[Tooltip(&quot;圆形或扇形填充比例&quot;)][Range(0, 1)]public float fillPercent = 1f;[Tooltip(&quot;是否填充圆形&quot;)]public bool fill = true;[Tooltip(&quot;圆环宽度&quot;)]public float thickness = 5;[Tooltip(&quot;圆形&quot;)][Range(3, 100)]public int segements = 20;        //填充三角形数量</code></pre><p>在OnPopulateMesh函数中，函数的参数VertexHelper就是原来图片的顶带你信息，因为我们要重写这些顶点信息，所以我们要清空vh。在我们设置自己的顶点的信息之前，我们需要获得UV信息，获取方法就是DataUtility.GetOuterUV(overrideSprite)。  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    Vector4 uv = overrideSprite != null ? DataUtility.GetOuterUV(overrideSprite) : Vector4.zero;    float uvCenterX = (uv.x + uv.z) * (0.5f + (fillCenter.x - 0.5f) * (uv.z - uv.x));    float uvCenterY = (uv.y + uv.w) * (0.5f + (fillCenter.y - 0.5f) * (uv.w - uv.y));    float uvScaleX = (uv.z - uv.x) / tw  * fillRadius * UVScale;    float uvScaleY = (uv.w - uv.y) / th  * fillRadius * UVScale;    ...&#125;</code></pre><p>在设置的属性中我们有一个变量segements就是我们需要的三角形数量，正如原理将的，三角形数量越多，越像圆形，但是顶点数据就越多，影响性能，所以我们设置这个参数可以根据需求设置数量，然后我们知道数量后就可以算出顶点的夹角，然后面片数segements与填充比例fillPercent相乘，就知道要用多少个面片来显示圆形/扇形  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    //算出每个面片的顶点夹角，面片数segements与填充比例fillPercent相乘，就知道要用多少个面片来显示圆形/扇形    float degreeDelta = (float)(2 * Mathf.PI / segements);    int curSegements = (int)(segements * fillPercent);    ...&#125;</code></pre><p>我们可以通过RectTransform获取原图矩形的宽高，笔者这里也添加了一个可以调整的参数圆形半径个圆环宽度，圆环宽度是用来做圆环形状显示的，圆形半径其实就是原图的宽高乘以圆的半径就行了，这里圆的半径其实是一个比例，把原图的比作为1。  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    //通过RectTransform获取矩形宽高，计算出半径    float tw = rectTransform.rect.width * fillRadius;    float th = rectTransform.rect.height * fillRadius;    float outerRadius = rectTransform.pivot.x * tw;    float innerRadius = rectTransform.pivot.x * tw - thickness;    ...&#125;</code></pre><p>已经有了半径，夹角信息，根据圆形点坐标公式(radius * cosA,radius * sinA)可以算出顶点坐标，每次迭代新建UIVertex，将求出的坐标，color，uv等参数传入，再将UIVertex传给VertexHelper。重复迭代n次，VertexHelper就获得了多边形顶点及圆心点信息了。  这里笔者也设置了参数，UV的缩放和圆的中心点，也是为了适应更多的场景</p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    float uvCenterX = (uv.x + uv.z) * (0.5f + (fillCenter.x - 0.5f) * (uv.z - uv.x));    float uvCenterY = (uv.y + uv.w) * (0.5f + (fillCenter.y - 0.5f) * (uv.w - uv.y));    float uvScaleX = (uv.z - uv.x) / tw  * fillRadius * UVScale;    float uvScaleY = (uv.w - uv.y) / th  * fillRadius * UVScale;    float curDegree = 0;    UIVertex uiVertex;    int verticeCount;    int triangleCount;    Vector2 curVertice;    curVertice = Vector2.zero;    verticeCount = curSegements + 1;    uiVertex = new UIVertex();    uiVertex.color = color;    uiVertex.position = curVertice;    uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);    vh.AddVert(uiVertex);    for (int i = 1; i &lt; verticeCount; i++)    &#123;        float cosA = Mathf.Cos(curDegree);        float sinA = Mathf.Sin(curDegree);        curVertice = new Vector2(cosA * outerRadius, sinA * outerRadius);        curDegree += degreeDelta;        uiVertex = new UIVertex();        uiVertex.color = color;        uiVertex.position = curVertice;        uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);        vh.AddVert(uiVertex);        outterVertices.Add(curVertice);    &#125;    ...&#125;</code></pre><p>虽然已经传入了所有的顶带你信息，但是GPU还不知道顶点信息之间的关系，不知道顶带你分成了多少个三角形片面，所以还需要把三角形的信息告诉GPU,这里有一个VertexHelper的接口就是**AddTriangle(int idx0, int idx1, int idx2)**来接受三角形信息。<br>接口的传入参数并不是UIVertex类型，而是int类型的索引值。哪来的索引？还记得之前往VertexHelper传入了一堆顶点吗？按照传入顺序，第一个顶点，索引记为0，依次类推。每次传入三个顶点的索引，就记录下了一个三角形。  </p><blockquote><p>需要注意，GPU 默认是做backface culling(背面剔除)的，GPU只渲染正对屏幕的三角面片，当GPU认为某个三角面片是背对屏幕时，直接丢弃该三角面片，不做渲染。那么GPU怎么判断我们传入的某个三角形是正对屏幕，还是背对屏幕？答案是通过三个顶点的时针顺序，当三个顶点是呈顺时针时，判定为正对屏幕；呈逆时针时，判定为背对屏幕。</p></blockquote><p><img src="https://file.liangxiegame.com/f83adeb0-049d-413a-b538-e8a2cab10a6c.png" alt="image.png"></p><p>VertexHelper收到的第一个顶点是圆心，且算法是按逆时针方向，迭代计算出的多边形顶点，并依次传给VertexHelper。因此按(i, 0, i+1)(i&gt;=1)的规律取索引，就可以保证顶点顺序是顺时针的。  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    triangleCount = curSegements*3;    for (int i = 0, vIdx = 1; i &lt; triangleCount - 3; i += 3, vIdx++)    &#123;        vh.AddTriangle(vIdx, 0, vIdx+1);    &#125;    if (fillPercent == 1)    &#123;        //首尾顶点相连        vh.AddTriangle(verticeCount - 1, 0, 1);    &#125;    ...&#125;</code></pre><p>到此我们的圆形算是绘制完成了，但是观测我们的变量可以看出，笔者还支持了圆环的绘制  </p><h3 id="圆环"><a href="#圆环" class="headerlink" title="圆环"></a>圆环</h3><p>圆环的情况稍微复杂：顶点集没有圆心顶点了，只有内环、外环顶点；三角形集也不是简单的切饼式分割，采用一种比较直观的三角形划分，让内外环相邻的顶点类似一根鞋带那样互相连接，来划分三角形。  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    float uvCenterX = (uv.x + uv.z) * (0.5f + (fillCenter.x - 0.5f) * (uv.z - uv.x));    float uvCenterY = (uv.y + uv.w) * (0.5f + (fillCenter.y - 0.5f) * (uv.w - uv.y));    float uvScaleX = (uv.z - uv.x) / tw  * fillRadius * UVScale;    float uvScaleY = (uv.w - uv.y) / th  * fillRadius * UVScale;    float curDegree = 0;    UIVertex uiVertex;    int verticeCount;    int triangleCount;    Vector2 curVertice;    curVertice = Vector2.zero;    verticeCount = curSegements + 1;    uiVertex = new UIVertex();    uiVertex.color = color;    uiVertex.position = curVertice;    uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);    vh.AddVert(uiVertex);     verticeCount = curSegements*2;    for (int i = 0; i &lt; verticeCount; i += 2)    &#123;        float cosA = Mathf.Cos(curDegree);        float sinA = Mathf.Sin(curDegree);        curDegree += degreeDelta;        curVertice = new Vector3(cosA * innerRadius, sinA * innerRadius);        uiVertex = new UIVertex();        uiVertex.color = color;        uiVertex.position = curVertice;        uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);        vh.AddVert(uiVertex);        innerVertices.Add(curVertice);        curVertice = new Vector3(cosA * outerRadius, sinA * outerRadius);        uiVertex = new UIVertex();        uiVertex.color = color;        uiVertex.position = curVertice;        uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);        vh.AddVert(uiVertex);        outterVertices.Add(curVertice);    &#125;    ...&#125;</code></pre><h3 id="点击判断"><a href="#点击判断" class="headerlink" title="点击判断"></a>点击判断</h3><p>传统的UGUI的Image的点击判断是只要在矩形内点击，不管是不是透明，都认定为点击到了，笔者从网上学习了一套更好的判断点击的方法，利用的是<strong>Ray-Crossing算法</strong>。Ray-Crossing算法大概思路是从指定点p发出一条射线，与多边形相交，假若交点个数是奇数，说明点p落在多边形内，交点个数为偶数说明点p在多边形外。<br>射线选取哪个方向并没有限制，但为了实现起来方便，考虑屏幕点击点为点p，向水平方向右侧发出射线的情况，那么顶点v1,v2组成的线段与射线若有交点q，则点q必定满足两个条件：</p><blockquote><p>v2.y &lt; q.y = p.y &gt; v1.y<br>p.x &lt; q.x  </p></blockquote><p>我们根据这两个条件，逐一跟多边形线段求交点，并统计交点个数，最后判断奇偶即可得知点击点是否在圆形内。  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    public override bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)    &#123;        Sprite sprite = overrideSprite;        if (sprite == null)            return true;        Vector2 local;        RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, screenPoint, eventCamera, out local);        return Contains(local, outterVertices, innerVertices);    &#125;        private bool Contains(Vector2 p, List&lt;Vector3&gt; outterVertices, List&lt;Vector3&gt; innerVertices)    &#123;        var crossNumber = 0;        if(!fill)            RayCrossing(p, innerVertices, ref crossNumber);//检测内环        RayCrossing(p, outterVertices, ref crossNumber);//检测外环        return (crossNumber &amp; 1) == 1;    &#125;        /// &lt;summary&gt;    /// 使用RayCrossing算法判断点击点是否在封闭多边形里    /// &lt;/summary&gt;    /// &lt;param name=&quot;p&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;vertices&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;crossNumber&quot;&gt;&lt;/param&gt;    private void RayCrossing(Vector2 p, List&lt;Vector3&gt; vertices, ref int crossNumber)    &#123;        for (int i = 0, count = vertices.Count; i &lt; count; i++)        &#123;            var v1 = vertices[i];            var v2 = vertices[(i + 1) % count];            //点击点水平线必须与两顶点线段相交            if (((v1.y &lt;= p.y) &amp;&amp; (v2.y &gt; p.y))                || ((v1.y &gt; p.y) &amp;&amp; (v2.y &lt;= p.y)))            &#123;                //只考虑点击点右侧方向，点击点水平线与线段相交，且交点x &gt; 点击点x，则crossNumber+1                if (p.x &lt; v1.x + (p.y - v1.y) / (v2.y - v1.y) * (v2.x - v1.x))                &#123;                    crossNumber += 1;                &#125;            &#125;        &#125;    &#125;    ...&#125;</code></pre><p>###SetNativeSize<br>SetNativeSize的实现比较简单，只要把宽高设置图片的高度就行了。</p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    public override void SetNativeSize()    &#123;        if (activeSprite != null)        &#123;            float w = activeSprite.rect.width / pixelsPerUnit;            float h = activeSprite.rect.height / pixelsPerUnit;            rectTransform.anchorMax = rectTransform.anchorMin;            rectTransform.sizeDelta = new Vector2(w, h);            SetAllDirty();        &#125;    &#125;    ...&#125;</code></pre><p>在这里笔者遇到了一个问题，就是我们怎么能像Image那样调用这个方法呢，笔者参考了Image的原码，Imnage是有一个专门的Editor脚本设置面板显示的，于是笔者就写了一个CircleImageEditor的脚本来控制。只需要脚本继承GraphicEditor，然后通过[CustomEditor(typeof(CircleImage))]标签就可以实现脚本的控制了。  </p><pre><code>[CustomEditor(typeof(CircleImage))]public class CircleImageEditor : GraphicEditor&#123;    public override void OnInspectorGUI() &#123;        DrawDefaultInspector();                CircleImage myScript = (CircleImage)target;        EditorGUILayout.BeginHorizontal();        &#123;            GUILayout.Space(EditorGUIUtility.labelWidth);            if (GUILayout.Button(&quot;Set Native Size&quot;, EditorStyles.miniButtonRight))            &#123;                myScript.SetNativeSize();            &#125;        &#125;        EditorGUILayout.EndHorizontal();    &#125;&#125;</code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>笔者在制作BaseImage的时候并没有继承MaskableGraphic而是自己复制了一份到BaseMaskableGraphic类中，这是因为笔者不喜欢脚本在Inspector面面板中显示m_OnCullStateChanged这个事件，因此笔者复制了一份，只是把这个变量变成了私有，就不在面板显示，如果不介意面板的了可以继续继承MaskableGraphic。</p><h3 id="BaseImage"><a href="#BaseImage" class="headerlink" title="BaseImage"></a>BaseImage</h3><pre><code>public class BaseImage : BaseMaskableGraphic,ISerializationCallbackReceiver, ILayoutElement, ICanvasRaycastFilter&#123;    [FormerlySerializedAs(&quot;m_Frame&quot;)]    [SerializeField]    private Sprite m_Sprite;        //私有的sorite，内部调用，防止外部修改    //对外公开的sprite属性    public Sprite sprite    &#123;        get &#123; return m_Sprite; &#125;        set&#123;if (SetPropertyUtilityExt.SetClass(ref m_Sprite, value)) SetAllDirty();&#125;    &#125;    [NonSerialized]    private Sprite m_OverrideSprite;        protected BaseImage()    &#123;        useLegacyMeshGeneration = false;    &#125;    public Sprite overrideSprite    &#123;        get &#123; return m_OverrideSprite == null ? sprite : m_OverrideSprite; &#125;        set        &#123;            if (SetPropertyUtilityExt.SetClass(ref m_OverrideSprite, value)) SetAllDirty();        &#125;    &#125;    /// &lt;summary&gt;    /// Image&#39;s texture comes from the UnityEngine.Image.    /// &lt;/summary&gt;    public override Texture mainTexture    &#123;        get        &#123;            return overrideSprite == null ? s_WhiteTexture : overrideSprite.texture;        &#125;    &#125;    public Sprite activeSprite &#123; get &#123; return overrideSprite != null ? overrideSprite : sprite; &#125; &#125;            public float pixelsPerUnit    &#123;        get        &#123;            float spritePixelsPerUnit = 100;            if (sprite)                spritePixelsPerUnit = sprite.pixelsPerUnit;            float referencePixelsPerUnit = 100;            if (canvas)                referencePixelsPerUnit = canvas.referencePixelsPerUnit;            return spritePixelsPerUnit / referencePixelsPerUnit;        &#125;    &#125;            /// &lt;summary&gt;    /// 子类需要重写该方法来自定义Image形状    /// &lt;/summary&gt;    /// &lt;param name=&quot;vh&quot;&gt;&lt;/param&gt;    protected override void OnPopulateMesh(VertexHelper vh)    &#123;        base.OnPopulateMesh(vh);    &#125;    #region ISerializationCallbackReceiver        public void OnBeforeSerialize()    &#123;    &#125;    public void OnAfterDeserialize()    &#123;    &#125;        #endregion    #region ILayoutElement    public virtual void CalculateLayoutInputHorizontal() &#123; &#125;    public virtual void CalculateLayoutInputVertical() &#123; &#125;    public virtual float minWidth &#123; get &#123; return 0; &#125; &#125;    public virtual float preferredWidth    &#123;        get        &#123;            if (overrideSprite == null)                return 0;            return overrideSprite.rect.size.x / pixelsPerUnit;        &#125;    &#125;    public virtual float flexibleWidth &#123; get &#123; return -1; &#125; &#125;    public virtual float minHeight &#123; get &#123; return 0; &#125; &#125;    public virtual float preferredHeight    &#123;        get        &#123;            if (overrideSprite == null)                return 0;            return overrideSprite.rect.size.y / pixelsPerUnit;        &#125;    &#125;    public virtual float flexibleHeight &#123; get &#123; return -1; &#125; &#125;    public virtual int layoutPriority &#123; get &#123; return 0; &#125; &#125;    #endregion        #region ICanvasRaycastFilter    public virtual bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)    &#123;        return true;    &#125;    #endregion&#125;</code></pre><h3 id="CircleImage"><a href="#CircleImage" class="headerlink" title="CircleImage"></a>CircleImage</h3><pre><code>[AddComponentMenu(&quot;UI/Circle Image&quot;)]public class CircleImage : BaseImage&#123;    [Tooltip(&quot;圆形的半径&quot;)]    [Range(0, 1)]    public float fillRadius = 1f;    [Tooltip(&quot;UV缩放比例&quot;)]    [Range(0, 1)]    public float UVScale = 1f;    [Tooltip(&quot;圆形的中心点&quot;)]    public Vector2 fillCenter = new Vector2(0.5f, 0.5f);    [Tooltip(&quot;圆形或扇形填充比例&quot;)]    [Range(0, 1)]    public float fillPercent = 1f;    [Tooltip(&quot;是否填充圆形&quot;)]    public bool fill = true;    [Tooltip(&quot;圆环宽度&quot;)]    public float thickness = 5;    [Tooltip(&quot;圆形&quot;)]    [Range(3, 100)]    public int segements = 20;    private List&lt;Vector3&gt; innerVertices;    private List&lt;Vector3&gt; outterVertices;    void Awake()    &#123;        innerVertices = new List&lt;Vector3&gt;();        outterVertices = new List&lt;Vector3&gt;();    &#125;        // Update is called once per frame    void Update () &#123;        if(!fill)            this.thickness = (float)Mathf.Clamp(this.thickness, 0, rectTransform.rect.width / 2);    &#125;    protected override void OnPopulateMesh(VertexHelper vh)    &#123;        vh.Clear();        innerVertices.Clear();        outterVertices.Clear();        //算出每个面片的顶点夹角，面片数segements与填充比例fillPercent相乘，就知道要用多少个面片来显示圆形/扇形        float degreeDelta = (float)(2 * Mathf.PI / segements);        int curSegements = (int)(segements * fillPercent);        //通过RectTransform获取矩形宽高，计算出半径        float tw = rectTransform.rect.width * fillRadius;        float th = rectTransform.rect.height * fillRadius;        float outerRadius = rectTransform.pivot.x * tw;        float innerRadius = rectTransform.pivot.x * tw - thickness;        Vector4 uv = overrideSprite != null ? DataUtility.GetOuterUV(overrideSprite) : Vector4.zero;        float uvCenterX = (uv.x + uv.z) * (0.5f + (fillCenter.x - 0.5f) * (uv.z - uv.x));        float uvCenterY = (uv.y + uv.w) * (0.5f + (fillCenter.y - 0.5f) * (uv.w - uv.y));        float uvScaleX = (uv.z - uv.x) / tw  * fillRadius * UVScale;        float uvScaleY = (uv.w - uv.y) / th  * fillRadius * UVScale;        float curDegree = 0;        UIVertex uiVertex;        int verticeCount;        int triangleCount;        Vector2 curVertice;        if (fill) //圆形        &#123;            curVertice = Vector2.zero;            verticeCount = curSegements + 1;            uiVertex = new UIVertex();            uiVertex.color = color;            uiVertex.position = curVertice;            uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);            vh.AddVert(uiVertex);            for (int i = 1; i &lt; verticeCount; i++)            &#123;                float cosA = Mathf.Cos(curDegree);                float sinA = Mathf.Sin(curDegree);                curVertice = new Vector2(cosA * outerRadius, sinA * outerRadius);                curDegree += degreeDelta;                uiVertex = new UIVertex();                uiVertex.color = color;                uiVertex.position = curVertice;                uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);                vh.AddVert(uiVertex);                outterVertices.Add(curVertice);            &#125;            triangleCount = curSegements*3;            for (int i = 0, vIdx = 1; i &lt; triangleCount - 3; i += 3, vIdx++)            &#123;                vh.AddTriangle(vIdx, 0, vIdx+1);            &#125;            if (fillPercent == 1)            &#123;                //首尾顶点相连                vh.AddTriangle(verticeCount - 1, 0, 1);            &#125;        &#125;        else//圆环        &#123;            verticeCount = curSegements*2;            for (int i = 0; i &lt; verticeCount; i += 2)            &#123;                float cosA = Mathf.Cos(curDegree);                float sinA = Mathf.Sin(curDegree);                curDegree += degreeDelta;                curVertice = new Vector3(cosA * innerRadius, sinA * innerRadius);                uiVertex = new UIVertex();                uiVertex.color = color;                uiVertex.position = curVertice;                uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);                vh.AddVert(uiVertex);                innerVertices.Add(curVertice);                curVertice = new Vector3(cosA * outerRadius, sinA * outerRadius);                uiVertex = new UIVertex();                uiVertex.color = color;                uiVertex.position = curVertice;                uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);                vh.AddVert(uiVertex);                outterVertices.Add(curVertice);            &#125;            triangleCount = curSegements*3*2;            for (int i = 0, vIdx = 0; i &lt; triangleCount - 6; i += 6, vIdx += 2)            &#123;                vh.AddTriangle(vIdx+1, vIdx, vIdx+3);                vh.AddTriangle(vIdx, vIdx + 2, vIdx + 3);            &#125;            if (fillPercent == 1)            &#123;                //首尾顶点相连                vh.AddTriangle(verticeCount - 1, verticeCount - 2, 1);                vh.AddTriangle(verticeCount - 2, 0, 1);            &#125;        &#125;    &#125;        public override bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)    &#123;        Sprite sprite = overrideSprite;        if (sprite == null)            return true;        Vector2 local;        RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, screenPoint, eventCamera, out local);        return Contains(local, outterVertices, innerVertices);    &#125;        private bool Contains(Vector2 p, List&lt;Vector3&gt; outterVertices, List&lt;Vector3&gt; innerVertices)    &#123;        var crossNumber = 0;        if(!fill)            RayCrossing(p, innerVertices, ref crossNumber);//检测内环        RayCrossing(p, outterVertices, ref crossNumber);//检测外环        return (crossNumber &amp; 1) == 1;    &#125;        /// &lt;summary&gt;    /// 使用RayCrossing算法判断点击点是否在封闭多边形里    /// &lt;/summary&gt;    /// &lt;param name=&quot;p&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;vertices&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;crossNumber&quot;&gt;&lt;/param&gt;    private void RayCrossing(Vector2 p, List&lt;Vector3&gt; vertices, ref int crossNumber)    &#123;        for (int i = 0, count = vertices.Count; i &lt; count; i++)        &#123;            var v1 = vertices[i];            var v2 = vertices[(i + 1) % count];            //点击点水平线必须与两顶点线段相交            if (((v1.y &lt;= p.y) &amp;&amp; (v2.y &gt; p.y))                || ((v1.y &gt; p.y) &amp;&amp; (v2.y &lt;= p.y)))            &#123;                //只考虑点击点右侧方向，点击点水平线与线段相交，且交点x &gt; 点击点x，则crossNumber+1                if (p.x &lt; v1.x + (p.y - v1.y) / (v2.y - v1.y) * (v2.x - v1.x))                &#123;                    crossNumber += 1;                &#125;            &#125;        &#125;    &#125;            /// &lt;summary&gt;    /// Adjusts the image size to make it pixel-perfect.    /// &lt;/summary&gt;    /// &lt;remarks&gt;    /// This means setting the Images RectTransform.sizeDelta to be equal to the Sprite dimensions.    /// &lt;/remarks&gt;    public override void SetNativeSize()    &#123;        if (activeSprite != null)        &#123;            float w = activeSprite.rect.width / pixelsPerUnit;            float h = activeSprite.rect.height / pixelsPerUnit;            rectTransform.anchorMax = rectTransform.anchorMin;            rectTransform.sizeDelta = new Vector2(w, h);            SetAllDirty();        &#125;    &#125;&#125;</code></pre><h3 id="CircleImageEditor"><a href="#CircleImageEditor" class="headerlink" title="CircleImageEditor"></a>CircleImageEditor</h3><pre><code>[CustomEditor(typeof(CircleImage))]public class CircleImageEditor : GraphicEditor&#123;    public override void OnInspectorGUI() &#123;        DrawDefaultInspector();                CircleImage myScript = (CircleImage)target;        EditorGUILayout.BeginHorizontal();        &#123;            GUILayout.Space(EditorGUIUtility.labelWidth);            if (GUILayout.Button(&quot;Set Native Size&quot;, EditorStyles.miniButtonRight))            &#123;                myScript.SetNativeSize();            &#125;        &#125;        EditorGUILayout.EndHorizontal();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考博客地址：&lt;a href=&quot;https://www.cnblogs.com/leoin2012/p/6425089.html&quot;&gt;https://www.cnblogs.com/leoin2012/p/6425089.html&lt;/a&gt;  &lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="UGUI" scheme="http://yoursite.com/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——UGUI基于图集的shader遮罩</title>
    <link href="http://yoursite.com/2021/04/20/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UGUI%E5%9F%BA%E4%BA%8E%E5%9B%BE%E9%9B%86%E7%9A%84shader%E9%81%AE%E7%BD%A9/"/>
    <id>http://yoursite.com/2021/04/20/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UGUI%E5%9F%BA%E4%BA%8E%E5%9B%BE%E9%9B%86%E7%9A%84shader%E9%81%AE%E7%BD%A9/</id>
    <published>2021-04-20T06:25:21.000Z</published>
    <updated>2021-12-27T03:39:09.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Unity开发过程中，为了节省图，经常会做一些图形的遮罩，笔者开发UI使用的是UGUI遮罩，用过UGUI的Mask做遮罩的应该都知道，UGUI的mask做遮罩有很明显的锯齿，于是笔者就从网上学习一套shader做的遮罩，但是仅仅是shader做的遮罩虽然效果很好，但是在正式开发中，为了优化性能，大部分图片都是会打成图集的，这时候shader中的UV就不是我们想要的UV了，这时候就需要做一些修改了。所以本文是基于图集的shader遮罩。</p><h1 id="普通的shader遮罩"><a href="#普通的shader遮罩" class="headerlink" title="普通的shader遮罩"></a>普通的shader遮罩</h1><p><img src="https://file.liangxiegame.com/e2f8acff-6e17-45c0-8bd1-ec8027772385.png" alt="image.png"> </p><p>上图左边是普通的UGUI的正常mask，右边是shader写的遮罩，边缘锯齿比较很明显。</p><h2 id="shader代码"><a href="#shader代码" class="headerlink" title="shader代码"></a>shader代码</h2><pre><code>Shader &quot;ImageMask01&quot;&#123;    Properties    &#123;        [PerRendererData] _MainTex (&quot;Sprite Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Mask (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;         _Color (&quot;Tint&quot;, Color) = (1,1,1,1)        _StencilComp(&quot;Stencil Comparison&quot;, Float) = 8        _Stencil(&quot;Stencil ID&quot;, Float) = 0        _StencilOp(&quot;Stencil Operation&quot;, Float) = 0        _StencilWriteMask(&quot;Stencil Write Mask&quot;, Float) = 255        _StencilReadMask(&quot;Stencil Read Mask&quot;, Float) = 255        _ColorMask(&quot;Color Mask&quot;, Float) = 15    &#125;    SubShader    &#123;        Tags        &#123;            &quot;Queue&quot;=&quot;Transparent&quot;            &quot;IgnoreProjector&quot;=&quot;True&quot;            &quot;RenderType&quot;=&quot;Transparent&quot;            &quot;PreviewType&quot;=&quot;Plane&quot;            &quot;CanUseSpriteAtlas&quot;=&quot;True&quot;        &#125;        Stencil        &#123;            Ref [_Stencil]            Comp [_StencilComp]            Pass [_StencilOp]            ReadMask [_StencilReadMask]            WriteMask [_StencilWriteMask]        &#125;        Cull Off        Lighting Off        ZWrite Off        ZTest [unity_GUIZTestMode]        Blend SrcAlpha OneMinusSrcAlpha        ColorMask [_ColorMask]        Pass        &#123;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #pragma target 2.0            #include &quot;UnityCG.cginc&quot;            #include &quot;UnityUI.cginc&quot;            #pragma multi_compile_local _ UNITY_UI_CLIP_RECT            #pragma multi_compile_local _ UNITY_UI_ALPHACLIP            struct appdata_t            &#123;                fixed2 uv : TEXCOORD0;                float4 vertex   : POSITION;                float4 color    : COLOR;            &#125;;            struct v2f            &#123;                fixed2 uv : TEXCOORD0;                float4 vertex   : SV_POSITION;                fixed4 color    : COLOR;            &#125;;            sampler2D _MainTex;            fixed4 _Color;            sampler2D _Mask;            v2f vert(appdata_t IN)            &#123;                v2f OUT;                OUT.vertex = UnityObjectToClipPos(IN.vertex);                OUT.uv = IN.uv;                OUT.color = IN.color * _Color;#ifdef PIXELSNAP_ON                OUT.vertex = UnityPixelSnap(OUT.vertex);#endif                return OUT;            &#125;            fixed4 frag(v2f IN) : SV_Target            &#123;                fixed4 color = tex2D(_MainTex, IN.uv) * IN.color;                fixed4 mask = tex2D(_Mask, IN.uv);                color.a *= mask.a;                return color;            &#125;        ENDCG        &#125;    &#125;&#125;</code></pre><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>上述代码虽然多，但是大部分都是通用的固定写法，包含一些shader支持UGUI的mask的写法，这里就不要进行讲解了，我们来看看我们shader做mask的关键代码。</p><pre><code>Properties&#123;    ...    _Mask (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;     ...&#125;</code></pre><p>在Properties主要是把我们需要遮罩的形状放进去，这里需要注意的是需要遮罩的部分图片必须不透明，因为在做遮罩的时候是读取这个图片的透明度来判断是否需要进行遮罩的。也就是下面的代码：</p><pre><code>fixed4 frag(v2f IN) : SV_Target&#123;    fixed4 color = tex2D(_MainTex, IN.uv) * IN.color;    fixed4 mask = tex2D(_Mask, IN.uv);    color.a *= mask.a;    return color;&#125;</code></pre><p>逐片源操作的时候来进行读取来遮罩显示。</p><h1 id="基于图集的遮罩"><a href="#基于图集的遮罩" class="headerlink" title="基于图集的遮罩"></a>基于图集的遮罩</h1><p>虽然上述已经实现了遮罩，但是在假如我们需要遮罩的图片是在图集上，会发现我们的遮罩会出现错误，不遮罩或者遮罩的不对，这是因为shader在读取图片的UV坐标的时候读取的并不是0<del>1而是图片在图集中的坐标，所以根据坐标进行遮罩是不行的。<br>解决方案就是需要把遮罩的坐标转成0</del>1的坐标，这样就可以判断是否需要遮罩了。<br>虽然我们有了解决方案，但是我们如何在shader中获取图片在图集的坐标呢，笔者的解决方案是利用一个C#的脚本，把图片坐标传递给shader。</p><h2 id="Shader新的代码"><a href="#Shader新的代码" class="headerlink" title="Shader新的代码"></a>Shader新的代码</h2><pre><code>Properties&#123;    ...    _Mask (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;     _UvRect (&quot;UvRect&quot;, Vector) = (0, 0, 1, 1)    ...&#125;</code></pre><p>上述是Properties中的代码，可以看出和普通的相比多了一个_UvRect参数，是用来保存图片在图集中的坐标的。  </p><pre><code>fixed4 frag(v2f IN) : SV_Target&#123;    fixed4 color = tex2D(_MainTex, IN.uv) * IN.color;        float2 temuv = float2((IN.uv.x - _UvRect.x)/(_UvRect.z - _UvRect.x),(IN.uv.y - _UvRect.y)/(_UvRect.w - _UvRect.y));    fixed4 mask = tex2D(_Mask, temuv);    color.a *= mask.a;    return color;&#125;</code></pre><p>在判断是否遮罩的时候，可以看到笔者关键性的代码，就是teamuv的赋值，算法很简单，知道图片四个角在图集的UV坐标，就是_UvRect参数，然后**(IN.uv.x - _UvRect.x)<strong>和</strong>(IN.uv.y - _UvRect.y)**就为了计算图片距离图片原点坐标的差值，也就是坐标系的坐标，他们在分别除以他们坐在的长度就转换成新的UV坐标了，其实就是图片本身的UV坐标了，然后就可以和普通的shader一样计算了。  </p><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C#代码"></a>C#代码</h2><pre><code>public class RefreshUVRect : MonoBehaviour&#123;    private Material material;    private Image img;    // Start is called before the first frame update    void Start()    &#123;        img = GetComponent&lt;Image&gt;();        material = img.material;        Refresh();    &#125;    public void Refresh()    &#123;        if (img)        &#123;            Vector4 uvRect = UnityEngine.Sprites.DataUtility.GetOuterUV(img.overrideSprite);            material.SetVector(&quot;_UvRect&quot;, uvRect);        &#125;    &#125;&#125;</code></pre><p>C#的代码比较简单，就是获取一下材质，然后把图片四个角的UV坐标传递给材质，<strong>UnityEngine.Sprites.DataUtility.GetOuterUV</strong>这个方法就是获取UV的边界坐标。<br><font color=red size=4>特别提醒一下，遮罩后编辑器模式下是错误的，因为获取的还是图片坐标，运行状态下观看就是正确的了</font></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在Unity开发过程中，为了节省图，经常会做一些图形的遮罩，笔者开发UI使用的是UGUI遮罩，用过UGUI的Mask做遮罩的应该都知道，UG</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="UGUI" scheme="http://yoursite.com/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——UGUI中粒子的遮罩与裁剪</title>
    <link href="http://yoursite.com/2021/04/19/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UGUI%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E9%81%AE%E7%BD%A9%E4%B8%8E%E8%A3%81%E5%89%AA/"/>
    <id>http://yoursite.com/2021/04/19/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UGUI%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E9%81%AE%E7%BD%A9%E4%B8%8E%E8%A3%81%E5%89%AA/</id>
    <published>2021-04-19T02:48:13.000Z</published>
    <updated>2021-12-27T03:39:09.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Unity开发中，在使用UGUI的mask的时候，如果子节点存在粒子特效，发现mask并不能裁剪粒子，比如笔者在开发中，有一个滑动列表，列表中的button上面存在按钮特效，在滑动的时候滑动的mask并不能裁剪粒子，因此笔者从网上找到了一些解决方案，并应用了一下，用着还可以。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>粒子的裁剪是用shader制作的，但是仅仅用shader是并不能满足需求的，因为特效有可能是会动的，这样剪裁区域就会发生变化，所以需要一个脚本把裁剪的区域传递给shader，然后shader在进行裁剪处理。  </p><h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C#代码"></a>C#代码</h1><pre><code>public class TailorParticle : MonoBehaviour&#123;    private Material material;    private Mask mask;    private RectMask2D rectmask2d;    public void Start()    &#123;        material = GetComponentInChildren&lt;ParticleSystem&gt;().GetComponent&lt;Renderer&gt;().material;        mask = GetComponentInParent&lt;Mask&gt;();        rectmask2d = GetComponentInParent&lt;RectMask2D&gt;();        SetClip();        //如果运行时裁剪区域不会发生改变，可以注释掉下面这句代码        var scrollrecct = GetComponentInParent&lt;ScrollRect&gt;();        if (scrollrecct)        &#123;            scrollrecct.onValueChanged.AddListener(v =&gt; &#123; SetClip(); &#125;);        &#125;    &#125;    private bool isMask;    private Vector3[] corners = new Vector3[4];    private Vector3[] cornerstemp = new Vector3[4];    public void SetClip()    &#123;        //获取到需要裁剪的区域        isMask = false;        if (mask)         &#123;            mask.GetComponent&lt;RectTransform&gt;().GetWorldCorners(corners);            isMask = true;        &#125;        if(rectmask2d)        &#123;            rectmask2d.GetComponent&lt;RectTransform&gt;().GetWorldCorners(cornerstemp);            if (isMask)            &#123;                corners[0].x = Mathf.Min(corners[0].x, cornerstemp[0].x);                corners[0].y = Mathf.Min(corners[0].y, cornerstemp[0].y);                corners[2].x = Mathf.Max(corners[2].x, cornerstemp[2].x);                corners[2].y = Mathf.Max(corners[2].y, cornerstemp[2].y);            &#125;            else            &#123;                isMask = true;            &#125;        &#125;        if (material &amp;&amp; isMask)        &#123;            //将裁剪区域传入到Shader中            material.SetFloat(&quot;_MinX&quot;, corners[0].x);            material.SetFloat(&quot;_MinY&quot;, corners[0].y);            material.SetFloat(&quot;_MaxX&quot;, corners[2].x);            material.SetFloat(&quot;_MaxY&quot;, corners[2].y);        &#125;    &#125;&#125;</code></pre><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><pre><code>material = GetComponentInChildren&lt;ParticleSystem&gt;().GetComponent&lt;Renderer&gt;().material;mask = GetComponentInParent&lt;Mask&gt;();rectmask2d = GetComponentInParent&lt;RectMask2D&gt;();SetClip();//如果运行时裁剪区域不会发生改变，可以注释掉下面这句代码var scrollrecct = GetComponentInParent&lt;ScrollRect&gt;();if (scrollrecct)&#123;    scrollrecct.onValueChanged.AddListener(v =&gt; &#123; SetClip(); &#125;);&#125;</code></pre><p>首先我们先看Start函数中，material是获取子节点的粒子特效的材质(如果粒子多了可以自己扩展成组)，mask是获取父节点的Mask遮罩，rectmask2d和mask一样是获取父节点的RectMask2D组件，笔者之所以获取RectMask2D这个组件是因为笔者有些裁剪是用这个做的。接着就是进行裁剪函数，这里后面介绍。正常的裁剪到这里就结束了，但是我们如果想裁剪区域进行动态变化，那我们就要进行动态刷新shader，笔者这里只是简单的用ScrollRect进行举例，大家可以根据自己的项目进行监听。只要当变化的时候刷新一下裁剪就行了。  </p><pre><code>isMask = false;if (mask) &#123;    mask.GetComponent&lt;RectTransform&gt;().GetWorldCorners(corners);    isMask = true;&#125;if(rectmask2d)&#123;    rectmask2d.GetComponent&lt;RectTransform&gt;().GetWorldCorners(cornerstemp);    if (isMask)    &#123;        corners[0].x = Mathf.Min(corners[0].x, cornerstemp[0].x);        corners[0].y = Mathf.Min(corners[0].y, cornerstemp[0].y);        corners[2].x = Mathf.Max(corners[2].x, cornerstemp[2].x);        corners[2].y = Mathf.Max(corners[2].y, cornerstemp[2].y);    &#125;    else    &#123;        isMask = true;    &#125;&#125;</code></pre><p>接着我们来看一下裁剪的代码，首先是标记不需要裁剪，只有当父节点存在Mask的时候才进行裁剪，然后就是获取父节点的剪裁区域，笔者这里是把两个Mask进行融合，获取最小的范围，这里可以根据自己的需求进行变化，然后就是关键性的代码  </p><pre><code>if (material &amp;&amp; isMask)&#123;    //将裁剪区域传入到Shader中    material.SetFloat(&quot;_MinX&quot;, corners[0].x);    material.SetFloat(&quot;_MinY&quot;, corners[0].y);    material.SetFloat(&quot;_MaxX&quot;, corners[2].x);    material.SetFloat(&quot;_MaxY&quot;, corners[2].y);&#125;</code></pre><p>这里就是将剪裁区域传递给次材质的shader，然后shader进行裁剪。</p><h1 id="Shader关键代码"><a href="#Shader关键代码" class="headerlink" title="Shader关键代码"></a>Shader关键代码</h1><pre><code>Properties &#123;        ...    _MinX (&quot;Min X&quot;, Float) = -10    _MaxX (&quot;Max X&quot;, Float) = 10    _MinY (&quot;Min Y&quot;, Float) = -10    _MaxY (&quot;Max Y&quot;, Float) = 10&#125;SubShader &#123;    Pass &#123;        ...        float _MinX;        float _MaxX;        float _MinY;        float _MaxY;                ...        float4 frag(VertexOutput i) : COLOR &#123;                        ...                    c.a *= (i.vpos.x &gt;= _MinX );               c.a *= (i.vpos.x &lt;= _MaxX);            c.a *= (i.vpos.y &gt;= _MinY);            c.a *= (i.vpos.y &lt;= _MaxY);            c.rgb *= c.a;            return c;        &#125;        ...    &#125;&#125;</code></pre><p>shader的代码也比较简单，就是将传过来的区域进行判断，如果在区域内据显示，如果超出区域就将颜色的透明度设置为0，也就看不见了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在Unity开发中，在使用UGUI的mask的时候，如果子节点存在粒子特效，发现mask并不能裁剪粒子，比如笔者在开发中，有一个滑动列表，列</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="UGUI" scheme="http://yoursite.com/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>LBFramwork框架搭建</title>
    <link href="http://yoursite.com/2020/07/30/Unity%E6%A1%86%E6%9E%B6/LBFramwork%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/07/30/Unity%E6%A1%86%E6%9E%B6/LBFramwork%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</id>
    <published>2020-07-30T06:40:08.000Z</published>
    <updated>2021-12-27T03:39:09.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LBFramework简介"><a href="#LBFramework简介" class="headerlink" title="LBFramework简介"></a>LBFramework简介</h1><p><font size=4><strong>单元测试环境： NSubstitute</strong></font><br><font size=4><strong>编写脚本环境： rider 2020.1.4</strong></font><br><font size=4><strong>Unity环境: unity2019.4.3f1(LTS)</strong></font>    </p><p>此篇文章记录笔者一步一步创建LBFramework框架，一步一步学习游戏框架。    </p><h1 id="LBUtils"><a href="#LBUtils" class="headerlink" title="LBUtils"></a>LBUtils</h1><h2 id="LBEditor"><a href="#LBEditor" class="headerlink" title="LBEditor"></a>LBEditor</h2><p>记录框架中编辑器的扩展  </p><h3 id="EditorModulizationPlatform-模块化编辑器结构"><a href="#EditorModulizationPlatform-模块化编辑器结构" class="headerlink" title="EditorModulizationPlatform    模块化编辑器结构"></a>EditorModulizationPlatform    模块化编辑器结构</h3><p>这是一个模块化编辑器结构<br>首先创建一个接口  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><pre><code>public interface IEditorPlatformModule&#123;    /// &lt;summary&gt;    /// 渲染 IMGUI    /// &lt;/summary&gt;    void OnGUI();&#125;public class EditorModuleContainer&#123;    /// &lt;summary&gt;    /// 用来缓存的模s块    /// &lt;/summary&gt;    private List&lt;object&gt; mInstances = new List&lt;object&gt;();    /// &lt;summary&gt;    /// 溶解（获取全部)    /// &lt;/summary&gt;    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public List&lt;T&gt; ResolveAll&lt;T&gt;()    &#123;        return mInstances.OfType&lt;T&gt;()            .ToList();    &#125;    public void Init()    &#123;        // 清空掉之前的实例        mInstances.Clear();        // 1.获取当前项目中所有的 assembly (可以理解为 代码编译好的 dll)        var assemblies = AppDomain.CurrentDomain.GetAssemblies();        // 2.获取编辑器环境(dll)        var editorAssembly = assemblies.First(assembly =&gt; assembly.FullName.StartsWith(&quot;Assembly-CSharp-Editor&quot;));        // 3.获取 IEditorPlatformModule 类型        var moduleType = typeof(IEditorPlatformModule);        mInstances = editorAssembly            // 获取所有的编辑器环境中的类型             .GetTypes()            // 过滤掉抽象类型（接口/抽象类)、和未实现 IEditorPlatformModule 的类型            .Where(type =&gt; moduleType.IsAssignableFrom(type) &amp;&amp; !type.IsAbstract)            // 获取类型的构造创建实例            .Select(type =&gt; type.GetConstructors().First().Invoke(null))            // 转换成 List&lt;IEditorPlatformModule&gt;            .ToList();    &#125;&#125;public class EditorModulizationPlatformEditor : EditorWindow&#123;    private EditorModulizationContainer mContainer;    /// &lt;summary&gt;    /// 打开窗口    /// &lt;/summary&gt;    [MenuItem(&quot;LBFramework/LBUtils/LBEditor&quot;)]    public static void Open()    &#123;        var editorPlatform = GetWindow&lt;EditorModulizationPlatformEditor&gt;();        editorPlatform.position = new Rect(            Screen.width / 2,            Screen.height * 2 / 3,            600,            500        );        // 初始化 Container        editorPlatform.mContainer = new EditorModulizationContainer();        editorPlatform.mContainer.Init();        editorPlatform.Show();    &#125;    private void OnGUI()    &#123;        // 渲染        mContainer.ResolveAll&lt;IEditorPlatformModule&gt;()            .ForEach(editorPlatformModule=&gt;editorPlatformModule.OnGUI());    &#125;&#125;</code></pre></details>调用的测试如下所示  <details><summary><font color=darkred>点击查看测试脚本详细内容</font></summary><pre><code>public class LBEditorTest:IEditorPlatformModule&#123;    public void OnGUI()    &#123;        GUILayout.Label(&quot;这个是一个新的模块&quot;, new GUIStyle()        &#123;            fontSize = 30        &#125;);        GUILayout.Button(&quot;LianBai&quot;);    &#125;&#125;</code></pre></details><h3 id="EditorCreatCShapTemp-编辑器扩展创建模板脚本"><a href="#EditorCreatCShapTemp-编辑器扩展创建模板脚本" class="headerlink" title="EditorCreatCShapTemp  编辑器扩展创建模板脚本"></a>EditorCreatCShapTemp  编辑器扩展创建模板脚本</h3><p>这是一个创建各种类型脚本的工具，笔者在写脚本的时候，因为Unity自带的创建脚本都是提供的模板，需要删除很多东西，所以笔者就自己写了一个工具用来创建脚本。  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><pre><code>public class EditorCreatScript&#123;    //获取选中的文件夹路径    public static string GetSelectedPathOrFallBack()    &#123;        string path = &quot;Assets&quot;;        foreach (UnityEngine.Object obj  in Selection.GetFiltered(typeof(UnityEngine.Object),SelectionMode.Assets))        &#123;            path = AssetDatabase.GetAssetPath(obj);            if (!string.IsNullOrEmpty(path) &amp;&amp; File.Exists(path))            &#123;                path = Path.GetDirectoryName(path);                break;            &#125;        &#125;        return path;    &#125;&#125;public //定义一个创建资源的Action类并实现其Action方法    class CraetEventCSScriptAsset : EndNameEditAction&#123;    public override void Action(int instanceId, string pathName, string resourceFile)    &#123;        //创建资源        UnityEngine.Object o = CreatScriptAssetFormTemplate(pathName, resourceFile);        //高亮显示该资源        ProjectWindowUtil.ShowCreatedAsset(o);    &#125;    internal static UnityEngine.Object CreatScriptAssetFormTemplate(string pathName, string resourcesFile)    &#123;        //获取创建资源的绝对路径        string fullName = Path.GetFullPath(pathName);        //读取本地模板        StreamReader streamReader = new StreamReader(resourcesFile);        string text = streamReader.ReadToEnd();        streamReader.Close();                    //获取文件名字        string fileName = Path.GetFileNameWithoutExtension(pathName);        //替换文件中的内容        text = text.Replace(&quot;#NAME&quot;,fileName);        bool encoderShouldEmitUTF8Identifier = true;        bool throwOnInvalidBytes = false;        UTF8Encoding uTF8Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier, throwOnInvalidBytes);        bool append = false;        //写入新文件        StreamWriter streamWriter = new StreamWriter(fullName, append, uTF8Encoding);        streamWriter.Write(text);        streamWriter.Close();                    //刷新本地资源        AssetDatabase.ImportAsset(pathName);        AssetDatabase.Refresh();        return AssetDatabase.LoadAssetAtPath(pathName, typeof(UnityEngine.Object));    &#125;&#125;</code></pre></details>调用的方法如下列代码所示  <details><summary><font color=darkred>点击查看测试脚本详细内容</font></summary><pre><code>public class EditorCreanScriptTest : EditorCreatScript&#123;    [MenuItem(&quot;Assets/Create/LBFCShap&quot;, false, 80)]    public static void CreatLBFCShap()    &#123;        ProjectWindowUtil.StartNameEditingIfProjectWindowExists(0,            ScriptableObject.CreateInstance&lt;CraetEventCSScriptAsset&gt;(),            GetSelectedPathOrFallBack()+&quot;/New Script.cs&quot;,            null,            &quot;Assets/LBFramework/LBUnitTest/&quot; +            &quot;Editor/CShapTemp/LBFCSTemp.txt&quot;         // 只需要在此文件夹下创建你需要的模板，命名与EventCSClass.cs一致就行        );    &#125;&#125;</code></pre></details><h2 id="AssemblyUtil的获取"><a href="#AssemblyUtil的获取" class="headerlink" title="AssemblyUtil的获取"></a>AssemblyUtil的获取</h2><p>这是一个收集AssemblyUtil获取部分的代码  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><pre><code>public class AssemblyUtil&#123;    public static Assembly EditorAssembly    &#123;        get        &#123;            // 1.获取当前项目中所有的 assembly (可以理解为 代码编译好的 dll)            var assemblies = AppDomain.CurrentDomain.GetAssemblies();            // 2.获取编辑器环境(dll)            var editorAssembly =                assemblies.First(assembly =&gt; assembly.FullName.StartsWith(&quot;Assembly-CSharp-Editor&quot;));            return editorAssembly;        &#125;    &#125;&#125;public static Assembly CShapAssembly&#123;    get    &#123;        // 1.获取当前项目中所有的 CShap assembly (可以理解为 代码编译好的 dll)        var assemblies = AppDomain.CurrentDomain.GetAssemblies();        // 2.获取编辑器环境(dll)        var cShapAssembly =            assemblies.First(assembly =&gt; assembly.FullName.StartsWith(&quot;Assembly-CSharp&quot;));        return cShapAssembly;    &#125;&#125;public static List&lt;Type&gt; GetEditoeAssemblyInstance&lt;Type&gt;()&#123;    return EditorAssembly        // 获取所有的编辑器环境中的类型         .GetTypes()        // 过滤掉抽象类型（接口/抽象类)、和未实现 Type 的类型        .Where(type =&gt; typeof(Type).IsAssignableFrom(type) &amp;&amp; !type.IsAbstract)        // 获取类型的构造创建实例        .Select(type =&gt; type.GetConstructors().First().Invoke(null))        // 转换成 List&lt;Type&gt;        .ToList()        .OfType&lt;Type&gt;()        .ToList();&#125;public static List&lt;Type&gt; GetCShapAssemblyInstance&lt;Type&gt;()&#123;    return CShapAssembly        // 获取所有的编辑器环境中的类型         .GetTypes()        // 过滤掉抽象类型（接口/抽象类)、和未实现 Type 的类型        .Where(type =&gt; typeof(Type).IsAssignableFrom(type) &amp;&amp; !type.IsAbstract)        // 获取类型的构造创建实例        .Select(type =&gt; type.GetConstructors().First().Invoke(null))        // 转换成 List&lt;Type&gt;        .ToList()        .OfType&lt;Type&gt;()        .ToList();&#125;</code></pre></details><h2 id="ResolutionCheck-屏幕检测"><a href="#ResolutionCheck-屏幕检测" class="headerlink" title="ResolutionCheck 屏幕检测"></a>ResolutionCheck 屏幕检测</h2><p>这个模块是一个屏幕检测的脚本，主要是用于检测是横屏竖屏的。  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><pre><code>public class ResolutionCheck&#123;    //判断是否横屏    public static bool IsLandScape    &#123;        get &#123; return Screen.width &gt; Screen.height; &#125;    &#125;        //Pad、Android 大部分平板的宽高比是 4:3    public static bool IsPad    &#123;        get &#123; return IsRatito(4,3);; &#125;    &#125;    //1280 / 720（一般安卓设备，结果为 1.777778） 还是 1136 / 640（iPhone 5s，结果为 1.775）    //或者是 1920 / 1080（iPhone 6p ，结果为 1.777778），它们都属于 16 ： 9 这个宽高比的范畴    public static bool IsPhone16_9    &#123;        get &#123; return IsRatito(16,9); &#125;    &#125;    public static bool IsRatito(float width, float height)    &#123;        var aspectRatio = IsLandScape            ? (float) Screen.width / Screen.height            : (float) Screen.height / Screen.width;        var destinationRatio = width / height;        return aspectRatio &gt; destinationRatio - 0.05f &amp;&amp; aspectRatio &lt; destinationRatio + 0.05f;    &#125;&#125;</code></pre></details><p>这个模块的单元测试如下列代码：  </p><details><summary><font color=darkred>点击查看测试脚本详细内容</font></summary><pre><code>public class ResolutionCheckTests&#123;    [Test]    public void ResolutionCheck_LandscapeTests()    &#123;        Debug.LogFormat(&quot;是否是横屏:&#123;0&#125;&quot;, ResolutionCheck.IsLandScape);        Assert.AreEqual(ResolutionCheck.IsLandScape, Screen.width &gt; Screen.height);    &#125;        [Test]    public void ResolutionCheck_4_3_Tests()    &#123;        Debug.LogFormat(&quot;是否是4:3分辨率？&#123;0&#125;&quot;, ResolutionCheck.IsPad);    &#125;        [Test]    public void ResolutionCheck_16_9_Tests()    &#123;        Debug.LogFormat(&quot;是否是16:9分辨率？&#123;0&#125;&quot;, ResolutionCheck.IsPhone16_9);    &#125;    [Test]    public void ResolutionCheck_Other_Tests()    &#123;        Debug.LogFormat(&quot;是否是750:1334分辨率？&#123;0&#125;&quot;, ResolutionCheck.IsRatito(750,1334));        Debug.LogFormat(&quot;是否是1024:768分辨率？&#123;0&#125;&quot;, ResolutionCheck.IsRatito(1024,768));    &#125;&#125;</code></pre></details><h2 id="CompExtend-组件扩展"><a href="#CompExtend-组件扩展" class="headerlink" title="CompExtend 组件扩展"></a>CompExtend 组件扩展</h2><p>这个模块主要用于扩展Unity中的Component,我们再为坐标赋值的时候，因为用的是struct，所以每次都要重新构造一个Vector3，因此可以扩展一下从而可以很简单的赋值。<br>这个模块是一个屏幕检测的脚本，主要是用于检测是横屏竖屏的。  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><pre><code>public static class CompExtend&#123;    //设置世界坐标X的值    public static T PositionX&lt;T&gt;(this T self, float x) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var position = transform.position;           //临时变量存储坐标信息        position.x = x;                                    //更改临时变量的坐标信息        transform.position = position;                    //重新给位置信息赋值        return self;    &#125;    //设置世界坐标Y的值    public static T PositionY&lt;T&gt;(this T self, float y) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var position = transform.position;           //临时变量存储坐标信息        position.y = y;                                    //更改临时变量的坐标信息        transform.position = position;                    //重新给位置信息赋值        return self;    &#125;    //设置世界坐标Z的值    public static T PositionZ&lt;T&gt;(this T self, float z) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var position = transform.position;           //临时变量存储坐标信息        position.z = z;                                    //更改临时变量的坐标信息        transform.position = position;                    //重新给位置信息赋值        return self;    &#125;    //设置世界坐标XY的值    public static T PositionXY&lt;T&gt;(this T self, float x,float y) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var position = transform.position;           //临时变量存储坐标信息        position.x = x;                                    //更改临时变量的坐标信息        position.y = y;                                            transform.position = position;                    //重新给位置信息赋值        return self;    &#125;    //设置世界坐标XZ的值    public static T PositionXZ&lt;T&gt;(this T self, float x,float z) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var position = transform.position;           //临时变量存储坐标信息        position.x = x;                                    //更改临时变量的坐标信息        position.z = z;                                            transform.position = position;                    //重新给位置信息赋值        return self;    &#125;    //设置世界坐标YZ的值    public static T PositionYZ&lt;T&gt;(this T self, float y,float z) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var position = transform.position;           //临时变量存储坐标信息        position.y = y;                                    //更改临时变量的坐标信息        position.z = z;                                            transform.position = position;                    //重新给位置信息赋值        return self;    &#125;    //设置本地坐标X的值    public static T LocalPositionX&lt;T&gt;(this T self, float x) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var localPosition = transform.localPosition;           //临时变量存储坐标信息        localPosition.x = x;                                    //更改临时变量的坐标信息        transform.localPosition = localPosition;                    //重新给位置信息赋值        return self;    &#125;    //设置本地坐标Y的值    public static T LocalPositionY&lt;T&gt;(this T self, float y) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var localPosition = transform.localPosition;           //临时变量存储坐标信息        localPosition.y = y;                                    //更改临时变量的坐标信息        transform.localPosition = localPosition;                    //重新给位置信息赋值        return self;    &#125;    //设置本地坐标Z的值    public static T LocalPositionZ&lt;T&gt;(this T self, float z) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var localPosition = transform.localPosition;           //临时变量存储坐标信息        localPosition.z = z;                                    //更改临时变量的坐标信息        transform.localPosition = localPosition;                    //重新给位置信息赋值        return self;    &#125;    //设置本地坐标XY的值    public static T LocalPositionXY&lt;T&gt;(this T self, float x,float y) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var localPosition = transform.localPosition;           //临时变量存储坐标信息        localPosition.x = x;                                    //更改临时变量的坐标信息        localPosition.y = y;                                            transform.localPosition = localPosition;                    //重新给位置信息赋值        return self;    &#125;    //设置本地坐标XZ的值    public static T LocalPositionXZ&lt;T&gt;(this T self, float x,float z) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var localPosition = transform.localPosition;           //临时变量存储坐标信息        localPosition.x = x;                                    //更改临时变量的坐标信息        localPosition.z = z;                                            transform.localPosition = localPosition;                    //重新给位置信息赋值        return self;    &#125;    //设置本地坐标YZ的值    public static T LocalPositionYZ&lt;T&gt;(this T self, float y,float z) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var localPosition = transform.localPosition;           //临时变量存储坐标信息        localPosition.y = y;                                    //更改临时变量的坐标信息        localPosition.z = z;                                            transform.localPosition = localPosition;                    //重新给位置信息赋值        return self;    &#125;    //Transfroam本地数据重置    public static T LocalIdentity&lt;T&gt;(this T self) where T : Component    &#123;        var transform = self.transform;        transform.localPosition = Vector3.zero;        transform.localRotation = Quaternion.identity;        transform.localScale = Vector3.one;        return self;    &#125;        //Transfroam世界数据重置    public static T Identity&lt;T&gt;(this T self) where T : Component    &#123;        var transform = self.transform;        transform.position = Vector3.zero;        transform.rotation = Quaternion.identity;        transform.localScale = Vector3.one;                return self;    &#125;        public static T Show&lt;T&gt;(this T self) where T : Component    &#123;        self.gameObject.SetActive(true);        return self;    &#125;    public static T Hide&lt;T&gt;(this T self) where T : Component    &#123;        self.gameObject.SetActive(false);        return self;    &#125;    public static GameObject Show(this GameObject self)    &#123;        self.SetActive(true);        return self;    &#125;    public static GameObject Hide(this GameObject self)    &#123;        self.SetActive(false);        return self;    &#125;&#125;</code></pre></details><p>调用的单元测试如下列脚本：  </p><details><summary><font color=darkred>点击查看测试脚本详细内容</font></summary><pre><code>public class CompExendTest&#123;    [Test]    public static void Extensions_AllTest()    &#123;        var gameObject = new GameObject();        gameObject.transform.PositionX(10);        Assert.AreEqual(gameObject.transform.position.x, 10);        gameObject.transform.PositionY(20);        Assert.AreEqual(gameObject.transform.position.y, 20);                gameObject.transform.PositionZ(30);        Assert.AreEqual(gameObject.transform.position.z, 30);        gameObject.transform.PositionXY(40,50);        Assert.AreEqual(gameObject.transform.position.x, 40);        Assert.AreEqual(gameObject.transform.position.y, 50);                gameObject.transform.PositionXZ(60,70);        Assert.AreEqual(gameObject.transform.position.x, 60);        Assert.AreEqual(gameObject.transform.position.z, 70);        gameObject.transform.PositionYZ(80,90);        Assert.AreEqual(gameObject.transform.position.y, 80);        Assert.AreEqual(gameObject.transform.position.z, 90);        gameObject.transform.LocalPositionX(100);        Assert.AreEqual(gameObject.transform.localPosition.x, 100);        gameObject.transform.LocalPositionY(110);        Assert.AreEqual(gameObject.transform.localPosition.y, 110);        gameObject.transform.LocalPositionZ(120);        Assert.AreEqual(gameObject.transform.localPosition.z, 120);        gameObject.transform.LocalPositionXY(130,140);        Assert.AreEqual(gameObject.transform.localPosition.x, 130);        Assert.AreEqual(gameObject.transform.localPosition.y, 140);                gameObject.transform.LocalPositionXZ(150,160);        Assert.AreEqual(gameObject.transform.localPosition.x, 150);        Assert.AreEqual(gameObject.transform.localPosition.z, 160);                gameObject.transform.LocalPositionYZ(170,180);        Assert.AreEqual(gameObject.transform.localPosition.y, 170);        Assert.AreEqual(gameObject.transform.localPosition.z, 180);        gameObject.transform.LocalIdentity();        Assert.AreEqual(gameObject.transform.localPosition, Vector3.zero);        Assert.AreEqual(gameObject.transform.localRotation,Quaternion.identity);        Assert.AreEqual(gameObject.transform.localScale,Vector3.one);                gameObject.transform.Identity();        Assert.AreEqual(gameObject.transform.position, Vector3.zero);        Assert.AreEqual(gameObject.transform.rotation,Quaternion.identity);        Assert.AreEqual(gameObject.transform.lossyScale,Vector3.one);        gameObject.Show();        Assert.AreEqual(gameObject.activeSelf, true);        gameObject.Hide();        Assert.AreEqual(gameObject.activeSelf, false);        // Transform 测试        gameObject.transform.Show();        Assert.AreEqual(gameObject.activeSelf, true);        gameObject.transform.Hide();        Assert.AreEqual(gameObject.activeSelf, false);        // Component 测试        var camera = gameObject.AddComponent&lt;Camera&gt;();        camera.Show();        Assert.AreEqual(gameObject.activeSelf, true);                camera.Hide();        Assert.AreEqual(gameObject.activeSelf, false);    &#125;&#125;</code></pre></details><h2 id="LBSingleton"><a href="#LBSingleton" class="headerlink" title="LBSingleton"></a>LBSingleton</h2><p>游戏中的单例是常用，但是每次单例都需要自己部分代码，这套结构可以快速制作单例脚本，只需要继承对应的虚类就行了。</p><p>单例的脚本如下  </p><details><summary><font color=darkred>点击查看测试脚本详细内容</font></summary><pre><code>using System;using System.Reflection;#if UNITY_5_6_OR_NEWERusing UnityEngine;using Object = UnityEngine.Object;#endifnamespace LBFramework.LBUtils&#123;    public interface ISingleton    &#123;        void OnInitSingleton();    &#125;    public abstract class Singleton&lt;T&gt; : ISingleton where T : Singleton&lt;T&gt;    &#123;        protected static T mInstance;        private static object mLock = new object();        //用来锁定，防止多线程问题        public static T Instabce        &#123;            get            &#123;                lock (mLock)                &#123;                    if (mInstance == null)                    &#123;                        mInstance = SingletonCreator.CreateSingleton&lt;T&gt;();                    &#125;                &#125;                return mInstance;            &#125;        &#125;        public void OnInitSingleton() &#123; &#125;    &#125;    public static class SingletonCreator    &#123;        public static T CreateSingleton&lt;T&gt;() where T : class, ISingleton        &#123;            // 获取私有构造函数            var ctors = typeof(T).GetConstructors(BindingFlags.Instance | BindingFlags.NonPublic);            // 获取无参构造函数            var ctor = Array.Find(ctors, c =&gt; c.GetParameters().Length == 0);            if (ctor == null)            &#123;                throw new Exception(&quot;Non-Public Constructor() not found! in &quot; + typeof(T));            &#125;            // 通过构造函数，常见实例            var retInstance = ctor.Invoke(null) as T;            retInstance.OnInitSingleton();            return retInstance;        &#125;    &#125;#if UNITY_5_6_OR_NEWER    [Obsolete]    public class QMonoSingletonPath : MonoSingletonPath    &#123;        public QMonoSingletonPath(string pathInHierarchy) : base(pathInHierarchy)        &#123;        &#125;    &#125;    //定义一个特性并控制定义特性的使用    [AttributeUsage(AttributeTargets.Class)]    public class MonoSingletonPath : Attribute    &#123;        private string mPathInHierarchy;        public MonoSingletonPath(string pathInHierarchy)        &#123;            mPathInHierarchy = pathInHierarchy;        &#125;        public string PathInHierarchy        &#123;            get &#123; return mPathInHierarchy; &#125;        &#125;    &#125;    public abstract class MonoSingleton&lt;T&gt; : MonoBehaviour, ISingleton where T : MonoSingleton&lt;T&gt;    &#123;        protected static T mInstance;        protected static bool mOnApplicationQuit = false;        public static T Instance        &#123;            get            &#123;                if (mInstance == null &amp;&amp; !mOnApplicationQuit)                &#123;                    mInstance = MonoSingletonCreator.CreateMonoSingleton&lt;T&gt;();                &#125;                return mInstance;            &#125;        &#125;        public virtual void OnInitSingleton() &#123; &#125;        public virtual void Dispose()        &#123;            if (MonoSingletonCreator.IsUnitTestMode)            &#123;                var curTrans = transform;                do                &#123;                    var parent = curTrans.parent;                    DestroyImmediate(curTrans.gameObject);                    curTrans = parent;                &#125; while (curTrans != null);                mInstance = null;            &#125;            else &#123; Destroy(gameObject); &#125;        &#125;        //应用退出前进行处理        protected virtual void OnApplicationQuit()        &#123;            mOnApplicationQuit = true;            if (mInstance == null) return;            Destroy(mInstance.gameObject);            mInstance = null;        &#125;        protected virtual void OnDestroy() &#123; mInstance = null; &#125;        //判断对象是否已经退出        public static bool IsApplicationQuit        &#123;            get &#123; return mOnApplicationQuit; &#125;        &#125;    &#125;    //创建单例    public static class MonoSingletonCreator    &#123;        public static bool IsUnitTestMode &#123; get; set; &#125;        public static T CreateMonoSingleton&lt;T&gt;() where T : MonoBehaviour, ISingleton        &#123;            T instance = null;            //判断是否需要创建            if (!IsUnitTestMode &amp;&amp; !Application.isPlaying) return instance;            instance = Object.FindObjectOfType&lt;T&gt;();            //如果已经存在了就初始化并且返回            if (instance != null)            &#123;                instance.OnInitSingleton();                return instance;            &#125;            //获取成员信息            MemberInfo info = typeof(T);            var attributes = info.GetCustomAttributes(true);            foreach (var atribute in attributes)            &#123;                var defineAttri = atribute as MonoSingletonPath;                if (defineAttri == null)                &#123;                    continue;                &#125;                instance = CreateComponentOnGameObject&lt;T&gt;(defineAttri.PathInHierarchy, true);                break;            &#125;            if (instance == null)            &#123;                var obj = new GameObject(typeof(T).Name);                if (!IsUnitTestMode)                    Object.DontDestroyOnLoad(obj);                instance = obj.AddComponent&lt;T&gt;();            &#125;            instance.OnInitSingleton();            return instance;        &#125;        private static T CreateComponentOnGameObject&lt;T&gt;(string path, bool dontDestroy) where T : MonoBehaviour        &#123;            var obj = FindGameObject(path, true, dontDestroy);            if (obj == null)            &#123;                obj = new GameObject(&quot;Singleton of &quot; + typeof(T).Name);                if (dontDestroy &amp;&amp; !IsUnitTestMode)                &#123;                    Object.DontDestroyOnLoad(obj);                &#125;            &#125;            return obj.AddComponent&lt;T&gt;();        &#125;        private static GameObject FindGameObject(string path, bool build, bool dontDestroy)        &#123;            if (string.IsNullOrEmpty(path))            &#123;                return null;            &#125;            var subPath = path.Split(&#39;/&#39;);            if (subPath == null || subPath.Length == 0)            &#123;                return null;            &#125;            return FindGameObject(null, subPath, 0, build, dontDestroy);        &#125;        private static GameObject FindGameObject(GameObject root, string[] subPath, int index, bool build,            bool dontDestroy)        &#123;            GameObject client = null;            if (root == null)            &#123;                client = GameObject.Find(subPath[index]);            &#125;            else            &#123;                var child = root.transform.Find(subPath[index]);                if (child != null)                &#123;                    client = child.gameObject;                &#125;            &#125;            if (client == null)            &#123;                if (build)                &#123;                    client = new GameObject(subPath[index]);                    if (root != null)                    &#123;                        client.transform.SetParent(root.transform);                    &#125;                    if (dontDestroy &amp;&amp; index == 0 &amp;&amp; !IsUnitTestMode)                    &#123;                        GameObject.DontDestroyOnLoad(client);                    &#125;                &#125;            &#125;            if (client == null)            &#123;                return null;            &#125;            return ++index == subPath.Length ? client : FindGameObject(client, subPath, index, build, dontDestroy);        &#125;    &#125;#endif&#125;</code></pre></details><p>普通单例的测试脚本如下：  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><pre><code>public class TestSingletonClass : Singleton&lt;TestSingletonClass&gt;&#123;    private TestSingletonClass()    &#123;            &#125;&#125;public class LBSingletonTest&#123;        [Test]    public void Test()    &#123;        TestSingletonClass objA = TestSingletonClass.Instabce;        TestSingletonClass objB = TestSingletonClass.Instabce;                Assert.AreSame(objA, objB);    &#125;&#125;</code></pre></details><h2 id="LBEventSystem-事件系统"><a href="#LBEventSystem-事件系统" class="headerlink" title="LBEventSystem 事件系统"></a>LBEventSystem 事件系统</h2><p>事件系统采用的是接口的形式，需要接收事件的类只需要继承对应的接口就可以了，然后实现对应的接口，然后通过接口来接收对应的事件ID，通过判断ID来实现对应的事件。  </p><p>事件系统对应的脚本如下：  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><p>脚本一(接口)：  </p><pre><code>//事件系统对应的接口public interface ILBEventHandler&#123;    void HandleEvent(int eventId, LBEventComArg arg = null);&#125;</code></pre><p>脚本二(数据)：</p><pre><code>//事件系统传输的数据public class LBEventComArg&#123;    #region 获取多参数类型    public bool TryGet&lt;T&gt;(out T t)    &#123;        LBEventOneArg&lt;T&gt; arg = this as LBEventOneArg&lt;T&gt;;        arg.Get(out t);        return true;    &#125;    public bool TryGet&lt;T,U&gt;(out T t,out U u)    &#123;        LBEventTwoArg&lt;T,U&gt; arg = this as LBEventTwoArg&lt;T,U&gt;;        arg.Get(out t,out u);        return true;    &#125;    public bool TryGet&lt;T,U,K&gt;(out T t,out U u,out K k)    &#123;        LBEventThreeArg&lt;T,U,K&gt; arg = this as LBEventThreeArg&lt;T,U,K&gt;;        arg.Get(out t,out u,out k);        return true;    &#125;    public bool TryGet&lt;T,U,K,I&gt;(out T t,out U u,out K k,out I i)    &#123;        LBEventFourArg&lt;T,U,K,I&gt; arg = this as LBEventFourArg&lt;T,U,K,I&gt;;        arg.Get(out t,out u,out k,out i);        return true;    &#125;    public bool TryGet&lt;T,U,K,I,W&gt;(out T t,out U u,out K k,out I i,out W w)    &#123;        LBEventFiveArg&lt;T,U,K,I,W&gt; arg = this as LBEventFiveArg&lt;T,U,K,I,W&gt;;        arg.Get(out t,out u,out k,out i,out w);        return true;    &#125;    #endregion&#125;#region  多参数数据类public class LBEventOneArg&lt;T&gt; : LBEventComArg&#123;    private T m_t;    public void Set(T t) &#123; m_t = t; &#125;    public void Get(out T t) &#123; t = m_t; &#125;&#125;public class LBEventTwoArg&lt;T,U&gt; : LBEventComArg&#123;    private T m_t; private U m_u;    public void Set(T t,U u) &#123; m_t = t; m_u = u; &#125;    public void Get(out T t,out U u) &#123; t = m_t; u = m_u; &#125;&#125;public class LBEventThreeArg&lt;T,U,K&gt; : LBEventComArg&#123;    private T m_t; private U m_u; private K m_k;    public void Set(T t,U u,K k) &#123; m_t = t; m_u = u; m_k = k; &#125;    public void Get(out T t,out U u,out K k) &#123; t = m_t; u = m_u; k = m_k; &#125;&#125;public class LBEventFourArg&lt;T,U,K,I&gt; : LBEventComArg&#123;    private T m_t; private U m_u; private K m_k; private I m_i;    public void Set(T t,U u,K k,I i) &#123; m_t = t; m_u = u; m_k = k; m_i = i; &#125;    public void Get(out T t,out U u,out K k,out I i) &#123; t = m_t; u = m_u; k = m_k; i = m_i; &#125;&#125;public class LBEventFiveArg&lt;T,U,K,I,W&gt; : LBEventComArg&#123;    private T m_t; private U m_u; private K m_k; private I m_i; private W m_w;    public void Set(T t,U u,K k,I i,W w) &#123; m_t = t; m_u = u; m_k = k; m_i = i; m_w = w; &#125;    public void Get(out T t,out U u,out K k,out I i,out W w) &#123; t = m_t; u = m_u; k = m_k; i = m_i; w = m_w; &#125;&#125;#endregion</code></pre><p>脚本三(通信)：</p><pre><code>//自定义事件委托类型public delegate void CustomEventHandler(LBEventComArg arg = null);public class LBEventDispatcher:Singleton&lt;LBEventDispatcher&gt;&#123;    private readonly Dictionary&lt;int, HashSet&lt;ILBEventHandler&gt;&gt; id2HandlerDict = new Dictionary&lt;int, HashSet&lt;ILBEventHandler&gt;&gt;();    private readonly Dictionary&lt;int, CustomEventHandler&gt; id2DeleDict = new Dictionary&lt;int, CustomEventHandler&gt;();    private LBEventDispatcher()    &#123;            &#125;    public void AddListener(int eventId, ILBEventHandler handler)    &#123;        if (!id2HandlerDict.TryGetValue(eventId, out HashSet&lt;ILBEventHandler&gt; handlerSet))            handlerSet = id2HandlerDict[eventId] = new HashSet&lt;ILBEventHandler&gt;();        handlerSet.Add(handler);    &#125;        public void AddListener(int eventId, CustomEventHandler eventHandleDele)    &#123;        if (id2DeleDict.TryGetValue(eventId, out CustomEventHandler eventDele))        &#123;            Delegate[] delegates = eventHandleDele.GetInvocationList();            if (Array.IndexOf(delegates, eventHandleDele) == -1)                eventDele += eventHandleDele;        &#125;        else            id2DeleDict.Add(eventId, eventHandleDele);    &#125;    public void SendEvent(int eventId)    &#123;        TiggerEvent(eventId,null);        //当函数参数不需要赋值的时候就赋值一个NULL,减少GC    &#125;    public void SendEvent&lt;T&gt;(int eventId, T arg1)    &#123;        //临时闯将将来可以换成对象池        LBEventOneArg&lt;T&gt; eventArg = new LBEventOneArg&lt;T&gt;();        eventArg.Set(arg1);        TiggerEvent(eventId,eventArg);        //如果用对象池，在这里就可以回收    &#125;    public void SendEvent&lt;T,U&gt;(int eventId, T arg1,U arg2)    &#123;        //临时闯将将来可以换成对象池        LBEventTwoArg&lt;T,U&gt; eventArg = new LBEventTwoArg&lt;T,U&gt;();        eventArg.Set(arg1,arg2);        TiggerEvent(eventId,eventArg);        //如果用对象池，在这里就可以回收    &#125;    public void SendEvent&lt;T,U,K&gt;(int eventId, T arg1,U arg2,K arg3)    &#123;        //临时闯将将来可以换成对象池        LBEventThreeArg&lt;T,U,K&gt; eventArg = new LBEventThreeArg&lt;T,U,K&gt;();        eventArg.Set(arg1,arg2,arg3);        TiggerEvent(eventId,eventArg);        //如果用对象池，在这里就可以回收    &#125;    public void SendEvent&lt;T,U,K,I&gt;(int eventId, T arg1,U arg2,K arg3,I arg4)    &#123;        //临时闯将将来可以换成对象池        LBEventFourArg&lt;T,U,K,I&gt; eventArg = new LBEventFourArg&lt;T,U,K,I&gt;();        eventArg.Set(arg1,arg2,arg3,arg4);        TiggerEvent(eventId,eventArg);        //如果用对象池，在这里就可以回收    &#125;        private void TiggerEvent(int eventId, LBEventComArg arg)    &#123;        if (id2HandlerDict.TryGetValue(eventId, out HashSet&lt;ILBEventHandler&gt; handlerSet))        &#123;            foreach (var handler in handlerSet)            &#123;                handler.HandleEvent(eventId, arg);            &#125;        &#125;        if (id2DeleDict.TryGetValue(eventId, out CustomEventHandler oldDele))        &#123;            oldDele.Invoke(arg);        &#125;    &#125;        public void RemoveListener(int eventId, ILBEventHandler handler)    &#123;        if (id2HandlerDict.TryGetValue(eventId, out HashSet&lt;ILBEventHandler&gt; handlerSet))        &#123;            id2HandlerDict[eventId].Remove(handler);        &#125;    &#125;    public void RemoveListener(int eventId, CustomEventHandler eventHandlerDele)    &#123;        if (id2DeleDict.TryGetValue(eventId, out CustomEventHandler oldDele))        &#123;            oldDele -= eventHandlerDele;            if (oldDele == null)                id2DeleDict.Remove(eventId);        &#125;    &#125;    public void Destruct()    &#123;        id2HandlerDict.Clear();        id2DeleDict.Clear();    &#125;&#125;</code></pre></details><p>事件系统的单元测试如下所示：  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><pre><code>public enum LBEventTestType&#123;    EventTestType = 100,&#125;public class LBEventSystemClass:ILBEventHandler&#123;    public int testValue = 5;        public void HandleEvent(int eventId, LBEventComArg arg = null)    &#123;        switch ((LBEventTestType)eventId)        &#123;            case LBEventTestType.EventTestType:                arg.TryGet(out testValue);                break;        &#125;    &#125;&#125;public class LBEventSystemTest&#123;    [Test]    public void EventTest()    &#123;        LBEventSystemClass testClass = new LBEventSystemClass();        LBEventDispatcher.Instabce.AddListener((int)LBEventTestType.EventTestType, testClass);        LBEventDispatcher.Instabce.SendEvent((int)LBEventTestType.EventTestType,10);                Assert.AreEqual(testClass.testValue,10);    &#125;&#125;</code></pre></details>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LBFramework简介&quot;&gt;&lt;a href=&quot;#LBFramework简介&quot; class=&quot;headerlink&quot; title=&quot;LBFramework简介&quot;&gt;&lt;/a&gt;LBFramework简介&lt;/h1&gt;&lt;p&gt;&lt;font size=4&gt;&lt;strong&gt;单元测试环</summary>
      
    
    
    
    <category term="Unity框架" scheme="http://yoursite.com/categories/Unity%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="LBFramework" scheme="http://yoursite.com/tags/LBFramework/"/>
    
  </entry>
  
  <entry>
    <title>git学习笔记</title>
    <link href="http://yoursite.com/2019/11/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/11/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-11-24T03:09:11.000Z</published>
    <updated>2021-12-27T03:39:09.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><ol><li><p>初始化仓库，可以将本地目录变成git可以管理的本地仓库  </p><pre><code> git init</code></pre></li><li><p>关联远程仓库，可以将本地仓库与远程仓库关联，切记是<strong>本地仓库</strong>，不是本地目录，可以先利用<strong>git init</strong>将本地目录编程本地仓库后再进行关联。  </p><pre><code> git remote add origin 仓库地址</code></pre></li><li><p>取消关联地址</p><pre><code> git remote rm origin</code></pre></li><li><p>将远程仓库与本地仓库同步合并，下列命令是合并master分支</p><pre><code> git pull --rebase origin master</code></pre></li><li><p>查看远程分支命令和查看本地分支</p><pre><code> git branch -a    //查看远程分支 git branch        //查看本地分支</code></pre></li><li><p>切换分支命令</p><pre><code> git checkout 分支名字</code></pre></li><li><p>查看仓库状态</p><pre><code> git status</code></pre></li><li><p>将工作区内容添加到缓存区</p><pre><code> git add .        //所有内容添加 git add            //选择内容添加</code></pre></li><li><p>缓存区内容提交到本地仓库区</p><pre><code> git commit -m &quot;提交注释&quot;</code></pre></li><li><p>把本地仓库代码内容推送到远程仓库  </p><pre><code>git push -u origin master</code></pre></li><li><p>查看日志(历史版本)</p><pre><code>git loggit reflog</code></pre></li><li><p>撤销修改<br>— 撤销文件在工作区的修改:  </p><pre><code>git checkout -- 文件名git checkout</code></pre><p>— 撤销文件在缓存区的修改:  </p><pre><code>git reset 文件名          # 撤销指定文件的git add操作，即在缓存区的修改git reset                # 撤销之前所有的git add操作，即在缓存区的修改</code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;git常用命令&quot;&gt;&lt;a href=&quot;#git常用命令&quot; class=&quot;headerlink&quot; title=&quot;git常用命令&quot;&gt;&lt;/a&gt;git常用命令&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;初始化仓库，可以将本地目录变成git可以管理的本地仓库  &lt;/p&gt;
&lt;pre&gt;&lt;c</summary>
      
    
    
    
    <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
</feed>
