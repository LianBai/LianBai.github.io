<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LianBai</title>
  
  <subtitle>手握日月摘星辰，世间无我这般人。</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-08-06T09:34:35.657Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LianBai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解决无法显示图床图片问题</title>
    <link href="http://yoursite.com/2023/08/06/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%BA%8A%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2023/08/06/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%BA%8A%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/</id>
    <published>2023-08-06T08:55:00.000Z</published>
    <updated>2023-08-06T09:34:35.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Hexo 博客中使用的图床无法访问，经查询是图床拦截问题，需要修改 referrer 信息。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li><p>找到博客文件中的 head.ejs 或 header.ejs，路径一般在 {博客路径}\themes\3-hexo\layout_partial\ 下。</p></li><li><p>在 <head> 标签中添加以下代码：</head></p> <meta name="referrer" content="no-referrer"></li></ol><p>这将禁用 referrer 信息，从而绕过图床的防盗链限制。</p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1691314374889-2023-8-617:32:55.png" alt="1691314374889-2023-8-617:32:55.png"></p><p>通过以上优化，可以使文章更加清晰易懂，让读者更容易理解和操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;Hexo 博客中使用的图床无法访问，经查询是图床拦截问题，需要修改 referrer 信息。&lt;/p&gt;
&lt;h2 id=&quot;解决方法&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="搭建博客" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客图床" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>Python杂文——PyCharm配置QT环境</title>
    <link href="http://yoursite.com/2023/08/06/Python%E6%9D%82%E6%96%87/Python%E6%9D%82%E6%96%87%E2%80%94%E2%80%94PyCharm%E9%85%8D%E7%BD%AEQT%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2023/08/06/Python%E6%9D%82%E6%96%87/Python%E6%9D%82%E6%96%87%E2%80%94%E2%80%94PyCharm%E9%85%8D%E7%BD%AEQT%E7%8E%AF%E5%A2%83/</id>
    <published>2023-08-06T07:07:46.000Z</published>
    <updated>2023-08-07T02:38:43.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装pyqt5对应的库"><a href="#安装pyqt5对应的库" class="headerlink" title="安装pyqt5对应的库"></a>安装pyqt5对应的库</h1><h2 id="使用PyCharm安装（方法一）"><a href="#使用PyCharm安装（方法一）" class="headerlink" title="使用PyCharm安装（方法一）"></a>使用PyCharm安装（方法一）</h2><h3 id="安装pyqt5库"><a href="#安装pyqt5库" class="headerlink" title="安装pyqt5库"></a>安装pyqt5库</h3><ol><li>打开 PyCharm，进入安装源位置：File -&gt; Settings -&gt; Project -&gt; Python Interpreter  </li><li>在搜索框中输入 pyqt5，点击安装  </li><li>在搜索框中输入 pyqt5-tools，点击安装<br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1691306206191-2023-8-615:16:46.png" alt="这是一张图片"></li></ol><h3 id="安装PyQt5-tool库"><a href="#安装PyQt5-tool库" class="headerlink" title="安装PyQt5-tool库"></a>安装PyQt5-tool库</h3><p>同样的方法搜索PyQt5-tool这个库进行安装即可  </p><h2 id="使用终端命令安装（方法二）"><a href="#使用终端命令安装（方法二）" class="headerlink" title="使用终端命令安装（方法二）"></a>使用终端命令安装（方法二）</h2><p>在终端中输入以下两个命令即可安装对应的库：</p><pre><code>pip install pyqt5  pip install pyqt5-tool  </code></pre><h1 id="配置QT-Designer-界面设计-和PyUIC-界面转代码"><a href="#配置QT-Designer-界面设计-和PyUIC-界面转代码" class="headerlink" title="配置QT Designer(界面设计)和PyUIC(界面转代码)"></a>配置QT Designer(界面设计)和PyUIC(界面转代码)</h1><h2 id="配置QT-Designer"><a href="#配置QT-Designer" class="headerlink" title="配置QT Designer"></a>配置QT Designer</h2><ol><li>打开 PyCharm，进入配置位置：File -&gt; Settings -&gt; Tools -&gt; External Tools</li><li>点击“+”号，弹出一个编辑配置的框</li><li>配置扩展工具的参数：  <blockquote><p><strong>Name</strong>: 自己随便起个名字，一般都是<strong>QT Designer</strong><br><strong>Program</strong>: designer.exe软件所在的路径，路径位置一般为：{python路径}\Lib\site-packages\qt5_applications\Qt\bin\designer.exe<br><strong>Working directory</strong>: <strong>$FileDir$</strong></p></blockquote></li></ol><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1691307145291-2023-8-615:32:26.png" alt="这是一张图片"></p><h2 id="配置PyUIC"><a href="#配置PyUIC" class="headerlink" title="配置PyUIC"></a>配置PyUIC</h2><ol><li>打开 PyCharm，进入配置位置：File -&gt; Settings -&gt; Tools -&gt; External Tools</li><li>点击“+”号，弹出一个编辑配置的框</li><li>配置扩展工具的参数： <blockquote><p>Name: 自己随便起个名字，一般都是<strong>配置PyUIC</strong><br> Program: python.exe软件所在的路径，路径位置一般为：{python路径}\python.exe<br> Arguments: $FileName$ -o $FileNameWithoutExtension$.py<br> Working directory: <strong>$FileDir$</strong></p></blockquote></li></ol><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1691375885378-2023-8-710:38:06.png" alt="1691375885378-2023-8-710:38:06.png"></p><h1 id="使用配置"><a href="#使用配置" class="headerlink" title="使用配置"></a>使用配置</h1><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1691307415934-2023-8-615:36:56.png" alt="这是一张图片">  </p><h2 id="制作界面"><a href="#制作界面" class="headerlink" title="制作界面"></a>制作界面</h2><p>点击上图编号①就可以打开编辑界面 UI 的编辑器了，也可以使用快捷键 Ctrl + Alt + Shift + D<br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1691307518635-2023-8-615:38:39.png" alt="这是一张图片">  </p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>制作好界面后，在 PyCharm 中选中刚才制作的 UI 文件，右键 -&gt; External Tools -&gt; PyUIC 即可生成对应的代码。<br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1691307659438-2023-8-615:41:00.png" alt="这是一张图片">  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装pyqt5对应的库&quot;&gt;&lt;a href=&quot;#安装pyqt5对应的库&quot; class=&quot;headerlink&quot; title=&quot;安装pyqt5对应的库&quot;&gt;&lt;/a&gt;安装pyqt5对应的库&lt;/h1&gt;&lt;h2 id=&quot;使用PyCharm安装（方法一）&quot;&gt;&lt;a href=&quot;#使</summary>
      
    
    
    
    <category term="Python杂文" scheme="http://yoursite.com/categories/Python%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——宏管理脚本</title>
    <link href="http://yoursite.com/2023/05/21/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%AE%8F%E7%AE%A1%E7%90%86%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2023/05/21/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%AE%8F%E7%AE%A1%E7%90%86%E8%84%9A%E6%9C%AC/</id>
    <published>2023-05-21T13:56:48.000Z</published>
    <updated>2023-05-21T14:18:02.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这是一个管理Unity宏设置的脚本工具，能快速的增删改查项目的脚本。<br>下面是效果图：<br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1684677675196-2023-5-2122:01:15.png"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="依赖的代码"><a href="#依赖的代码" class="headerlink" title="依赖的代码"></a>依赖的代码</h2><details>    <summary> ResCatalog </summary>  <pre><code>/// &lt;summary&gt;/// 资源路径/// &lt;/summary&gt;public static class ResCatalog&#123;    public const string DefaultRes = &quot;Library/unity default resources&quot;;    public const string Temporary = &quot;Assets/_Temporary&quot;;    public const string Library = &quot;Assets/_Library&quot;;&#125;</code></pre></details>  <details>    <summary> BuildTargetUtility </summary>  <pre><code>/// &lt;summary&gt;/// 构建的辅助工具/// &lt;/summary&gt;public class BuildTargetUtility&#123;    /// &lt;summary&gt;    /// 获取对应平台的组    /// &lt;/summary&gt;    /// &lt;param name=&quot;p&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static BuildTargetGroup PlatformToGroup(RuntimePlatform p)    &#123;        return p switch        &#123;            RuntimePlatform.OSXEditor =&gt; BuildTargetGroup.Standalone,            RuntimePlatform.OSXPlayer =&gt; BuildTargetGroup.Standalone,            RuntimePlatform.WindowsPlayer =&gt; BuildTargetGroup.Standalone,            RuntimePlatform.WindowsEditor =&gt; BuildTargetGroup.Standalone,            RuntimePlatform.IPhonePlayer =&gt; BuildTargetGroup.iOS,            RuntimePlatform.Android =&gt; BuildTargetGroup.Android,            RuntimePlatform.LinuxPlayer =&gt; BuildTargetGroup.Standalone,            RuntimePlatform.LinuxEditor =&gt; BuildTargetGroup.Standalone,            RuntimePlatform.WebGLPlayer =&gt; BuildTargetGroup.WebGL,            RuntimePlatform.PS4 =&gt; BuildTargetGroup.PS4,            RuntimePlatform.XboxOne =&gt; BuildTargetGroup.XboxOne,            RuntimePlatform.tvOS =&gt; BuildTargetGroup.tvOS,            RuntimePlatform.Switch =&gt; BuildTargetGroup.Switch,            _ =&gt; BuildTargetGroup.Unknown        &#125;;    &#125;&#125;</code></pre></details> <details>    <summary> AssetLibrary </summary>  <pre><code>/// &lt;summary&gt;/// 资源的Library/// &lt;/summary&gt;public static class AssetLibrary&#123;    /// &lt;summary&gt;    /// 判断文件是否存在    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static bool Exists(string path, bool temporary)    &#123;        return File.Exists(GetPath(path, temporary));    &#125;    /// &lt;summary&gt;    /// 获取文件的地址    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件名字&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;是否是临时文件&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static string GetPath(string path, bool temporary)    &#123;        return Path.Combine(temporary ? ResCatalog.Temporary : ResCatalog.Library, path);    &#125;    /// &lt;summary&gt;    /// 保存文件    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件地址&lt;/param&gt;    /// &lt;param name=&quot;text&quot;&gt;文件内容&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;是否是临时文件&lt;/param&gt;    public static void Save(string path, string text, bool temporary)    &#123;        WriteAllText(path, text, temporary);    &#125;    /// &lt;summary&gt;    /// 保存文件    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件地址&lt;/param&gt;    /// &lt;param name=&quot;bytes&quot;&gt;写入的字节&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;是否是临时资源&lt;/param&gt;    public static void Save(string path, byte[] bytes, bool temporary)    &#123;        WriteAllBytes(path, bytes, temporary);    &#125;    /// &lt;summary&gt;    /// 获取文件内的所有内容    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件地址&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;是否是临时文件&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static string GetString(string path, bool temporary)    &#123;        return File.ReadAllText(GetPath(path, temporary));    &#125;    /// &lt;summary&gt;    /// 获取文件的所有字节    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件地址&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;是否是临时资源&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static byte[] GetBytes(string path, bool temporary)    &#123;        return File.ReadAllBytes(GetPath(path, temporary));    &#125;    /// &lt;summary&gt;    /// 写入所有的字节    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件路径&lt;/param&gt;    /// &lt;param name=&quot;bytes&quot;&gt;写入字节&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;是否是临时资源&lt;/param&gt;    private static void WriteAllBytes(string path, byte[] bytes, bool temporary)    &#123;        var realPath = GetPath(path, temporary);        PathUtils.MakeDirectory(realPath);        File.WriteAllBytes(realPath, bytes);    &#125;    /// &lt;summary&gt;    /// 写入所有的文本内容    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件路径&lt;/param&gt;    /// &lt;param name=&quot;text&quot;&gt;写入字符串&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;是否是临时资源&lt;/param&gt;    private static void WriteAllText(string path, string text, bool temporary)    &#123;        var realPath = GetPath(path, temporary);        PathUtils.MakeDirectory(realPath);        File.WriteAllText(realPath, text);    &#125;&#125;</code></pre></details>  <details>    <summary> SymbolsUtility </summary>  <pre><code>/// &lt;summary&gt;/// 宏的辅助工具/// &lt;/summary&gt;public static class SymbolsUtility&#123;    /// &lt;summary&gt;    /// 设置宏    /// &lt;/summary&gt;    /// &lt;param name=&quot;symbols&quot;&gt;&lt;/param&gt;    public static void SetSymbols(params string[] symbols)    &#123;        var result = string.Join(&quot;;&quot;, symbols);        PlayerSettings.SetScriptingDefineSymbolsForGroup(BuildTargetGroup.Standalone, result);        PlayerSettings.SetScriptingDefineSymbolsForGroup(BuildTargetGroup.iOS, result);        PlayerSettings.SetScriptingDefineSymbolsForGroup(BuildTargetGroup.Android, result);    &#125;    /// &lt;summary&gt;    /// 获取所有的宏    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static string[] GetSymbols()    &#123;        var group = BuildTargetUtility.PlatformToGroup(Application.platform);        var symbols = PlayerSettings.GetScriptingDefineSymbolsForGroup(group);        return symbols.Split(&#39;;&#39;);    &#125;    /// &lt;summary&gt;    /// 增加宏    /// &lt;/summary&gt;    /// &lt;param name=&quot;symbols&quot;&gt;宏的组&lt;/param&gt;    public static void AddSymbols(params string[] symbols)    &#123;        SetSymbols(GetSymbols().Union(symbols).ToArray());    &#125;    /// &lt;summary&gt;    /// 移除宏    /// &lt;/summary&gt;    /// &lt;param name=&quot;symbols&quot;&gt;宏的组&lt;/param&gt;    public static void RemoveSymbols(params string[] symbols)    &#123;        SetSymbols(GetSymbols().Except(symbols).ToArray());    &#125;    /// &lt;summary&gt;    /// 判断是否拥有宏    /// &lt;/summary&gt;    /// &lt;param name=&quot;symbol&quot;&gt;宏的名字&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static bool HasSymbols(string symbol)    &#123;        return -1 != Array.IndexOf(GetSymbols(), symbol);    &#125;&#125;</code></pre></details> <h2 id="管理工具代码"><a href="#管理工具代码" class="headerlink" title="管理工具代码"></a>管理工具代码</h2><pre><code>internal class SymbolsManager : EditorWindow&#123;    /// &lt;summary&gt;    /// 宏的配置    /// &lt;/summary&gt;    public class SymbolsConfig    &#123;        /// &lt;summary&gt;        /// 宏的名字        /// &lt;/summary&gt;        public string name;        /// &lt;summary&gt;        /// 是否使用        /// &lt;/summary&gt;        [NonSerialized]        public bool used;    &#125;    /// &lt;summary&gt;    /// 宏的组    /// &lt;/summary&gt;    public class SymbolsGroup    &#123;        /// &lt;summary&gt;        /// 组的名字        /// &lt;/summary&gt;        public string name;        /// &lt;summary&gt;        /// 组的宏列表        /// &lt;/summary&gt;        public List&lt;SymbolsConfig&gt; list;        /// &lt;summary&gt;        /// 用于显示的List        /// &lt;/summary&gt;        [NonSerialized]        public ReorderableList reorderableList;        /// &lt;summary&gt;        /// 是否已经删除        /// &lt;/summary&gt;        [NonSerialized]        public bool deleted;    &#125;    /// &lt;summary&gt;    /// 组的列表    /// &lt;/summary&gt;    private List&lt;SymbolsGroup&gt; m_Groups;    /// &lt;summary&gt;    /// 宏管理窗口    /// &lt;/summary&gt;    [MenuItem(&quot;Tools/SymbolsManager&quot;, false)]    private static void OpenWindow()    &#123;        var window = GetWindow&lt;SymbolsManager&gt;(&quot;SymbolsManager&quot;);        window.minSize = new Vector2(350, 100);    &#125;    private void OnEnable()    &#123;        var path = GetSettingsFileName();        if (AssetLibrary.Exists(path, false))        &#123;            var text = AssetLibrary.GetString(path, false);            JsonUtils.ToObject(text, out m_Groups);            foreach (var group in m_Groups)            &#123;                if (null == group.list)                &#123;                    group.list = new List&lt;SymbolsConfig&gt;();                &#125;                else                &#123;                    foreach (var config in group.list)                    &#123;                        config.used = SymbolsUtility.HasSymbols(config.name);                    &#125;                &#125;            &#125;        &#125;        m_Groups ??= new List&lt;SymbolsGroup&gt;();    &#125;    /// &lt;summary&gt;    /// 绘制面板    /// &lt;/summary&gt;    private void OnGUI()    &#123;        for (var i = 0; i &lt; m_Groups.Count;)        &#123;            var group = m_Groups[i];            GUILayout.BeginVertical(EditorStyles.helpBox);            &#123;                if (null == group.reorderableList)                &#123;                    group.list ??= new List&lt;SymbolsConfig&gt;();                    group.reorderableList = new ReorderableList(group.list, typeof(SymbolsConfig))                    &#123;                        drawHeaderCallback = rect =&gt;                        &#123;                            var textRt = rect;                            textRt.width /= 2f;                            group.name = EditorGUI.TextField(textRt, group.name, EditorStyles.boldLabel);                            var btnRt = rect;                            btnRt.x = btnRt.xMax - Styles.closeButton.lineHeight;                            if (GUI.Button(btnRt, GUIContent.none, Styles.closeButton))                            &#123;                                if (EditorUtility.DisplayDialog(                                    &quot;提示&quot;, &quot;是否确认删除?&quot;, &quot;确认&quot;, &quot;取消&quot;))                                &#123;                                    group.deleted = true;                                &#125;                            &#125;                        &#125;,                        drawElementCallback = (rect, index, active, focused) =&gt;                        &#123;                            var item = group.list[index];                            var textRect = new Rect(                                rect.position + Vector2.up * 2,                                new Vector2(rect.width - 100, EditorGUIUtility.singleLineHeight));                            item.name = GUI.TextField(textRect, item.name)?.Trim();                            const int btnWidth = 80;                            var oldColor = GUI.color;                            GUI.color = SymbolsUtility.HasSymbols(item.name) ? Color.green : Color.red;                            var btnRect = new Rect(                                rect.position + Vector2.up + Vector2.right * (rect.width - btnWidth),                                new Vector2(btnWidth, EditorGUIUtility.singleLineHeight));                            item.used = GUI.Toggle(btnRect, item.used,                                item.used ? Styles.used : Styles.unused,                                EditorStyles.toolbarButton);                            GUI.color = oldColor;                        &#125;,                        elementHeight = 22,                    &#125;;                &#125;                group.reorderableList.DoLayoutList();                GUILayout.BeginHorizontal();                GUILayout.FlexibleSpace();                if (GUILayout.Button(Styles.apply, GUILayout.Height(30), GUILayout.Width(100)))                &#123;                    foreach (var config in group.list)                    &#123;                        if (config.used)                        &#123;                            SymbolsUtility.AddSymbols(config.name);                        &#125;                        else                        &#123;                            SymbolsUtility.RemoveSymbols(config.name);                        &#125;                    &#125;                    AssetDatabase.SaveAssets();                    AssetDatabase.Refresh();                &#125;                GUILayout.FlexibleSpace();                GUILayout.EndHorizontal();                GUILayout.Space(5);            &#125;            GUILayout.EndVertical();            if (group.deleted)            &#123;                m_Groups.RemoveAt(i);            &#125;            else            &#123;                ++i;            &#125;        &#125;        //        GUILayout.BeginHorizontal();        GUILayout.FlexibleSpace();        if (GUILayout.Button(Styles.addGroup, GUILayout.Height(30), GUILayout.Width(200)))        &#123;            m_Groups.Add(new SymbolsGroup            &#123;                name = Styles.customName,                list = new List&lt;SymbolsConfig&gt;()            &#125;);        &#125;        GUILayout.FlexibleSpace();        GUILayout.EndHorizontal();        var e = Event.current;        if (e.keyCode == KeyCode.S &amp;&amp; e.type == EventType.KeyUp)        &#123;            e.Use();            Save();        &#125;    &#125;    /// &lt;summary&gt;    /// 销毁的时候保存    /// &lt;/summary&gt;    private void OnDisable()    &#123;        Save();    &#125;    /// &lt;summary&gt;    /// 保存    /// &lt;/summary&gt;    private void Save()    &#123;        JsonResolver.NotSerializeDefault = true;        var text = JsonUtils.ToPrettyString(m_Groups);        AssetLibrary.Save(GetSettingsFileName(), text, false);        JsonResolver.NotSerializeDefault = false;    &#125;    /// &lt;summary&gt;    /// 序列化Json文件的名字，采用 “类名Settings.json”格式    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    private string GetSettingsFileName()    &#123;        return $&quot;&#123;GetType().Name&#125;Settings.json&quot;;    &#125;    #region 显示风格Style    /// &lt;summary&gt;    /// 编辑器的风格    /// &lt;/summary&gt;    private static class Styles    &#123;        /// &lt;summary&gt;        /// 已经使用        /// &lt;/summary&gt;        public static GUIContent used;        /// &lt;summary&gt;        /// 未使用        /// &lt;/summary&gt;        public static GUIContent unused;        /// &lt;summary&gt;        /// 应用        /// &lt;/summary&gt;        public static GUIContent apply;        /// &lt;summary&gt;        /// 新增分组        /// &lt;/summary&gt;        public static GUIContent addGroup;        /// &lt;summary&gt;        /// 自定义名称(点击修改)        /// &lt;/summary&gt;        public static string customName;        /// &lt;summary&gt;        /// WinBtnClose        /// &lt;/summary&gt;        public static GUIStyle closeButton;        static Styles()        &#123;            used = new GUIContent(&quot;已使用&quot;);            unused = new GUIContent(&quot;未使用&quot;);            apply = new GUIContent(&quot;应用&quot;);            addGroup = new GUIContent(&quot;新增分组&quot;);            customName = &quot;自定义名称(点击修改)&quot;;            closeButton = new GUIStyle(&quot;WinBtnClose&quot;);        &#125;    &#125;    #endregion&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;这是一个管理Unity宏设置的脚本工具，能快速的增删改查项目的脚本。&lt;br&gt;下面是效果图：&lt;br&gt;&lt;img src=&quot;https://git</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity杂文——脚本创建辅助ScriptBuilder</title>
    <link href="http://yoursite.com/2023/05/17/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%84%9A%E6%9C%AC%E5%88%9B%E5%BB%BA%E8%BE%85%E5%8A%A9ScriptBuilder/"/>
    <id>http://yoursite.com/2023/05/17/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%84%9A%E6%9C%AC%E5%88%9B%E5%BB%BA%E8%BE%85%E5%8A%A9ScriptBuilder/</id>
    <published>2023-05-16T16:38:43.000Z</published>
    <updated>2023-05-16T17:09:33.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一个辅助快速生成需要的C#脚本的脚本。主要是快速生成引用，命名空间，类和方法一些。</p><h1 id="脚本和解析"><a href="#脚本和解析" class="headerlink" title="脚本和解析"></a>脚本和解析</h1><pre><code>public class ScriptBuilder&#123;    /// &lt;summary&gt;    /// 脚本的字符串    /// &lt;/summary&gt;    private StringBuilder m_Builder = new StringBuilder();    /// &lt;summary&gt;    /// 空白地字符串    /// &lt;/summary&gt;    private StringBuilder m_Blank = new StringBuilder();    /// &lt;summary&gt;    /// 用于判断是否在方法内生成脚本    /// &lt;/summary&gt;    public bool MarkInMethod &#123; get; set; &#125;    /// &lt;summary&gt;    /// 增加一行数据    /// &lt;/summary&gt;    /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;    public void AppendLine(string message)    &#123;        m_Builder.Append(m_Blank);        m_Builder.AppendLine(message);    &#125;    /// &lt;summary&gt;    /// 开始增加空白    /// &lt;/summary&gt;    private void BeginBlank()    &#123;        m_Blank.Append(&#39;\t&#39;);    &#125;    /// &lt;summary&gt;    /// 结束增加空白    /// &lt;/summary&gt;    private void EndBlank()    &#123;        m_Blank.Remove(m_Blank.Length - 1, 1);    &#125;    /// &lt;summary&gt;    ///开始增加命名空间    /// &lt;/summary&gt;    /// &lt;param name=&quot;name&quot;&gt;命名空间的名字&lt;/param&gt;    public void BeginNamespace(string name)    &#123;        BeginBrace($&quot;namespace &#123;name&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 结束增加命名空间    /// &lt;/summary&gt;    public void EndNamespace()    &#123;        EndBrace();    &#125;    /// &lt;summary&gt;    /// 开始增加类    /// &lt;/summary&gt;    /// &lt;param name=&quot;modifier&quot;&gt;类的修饰字符串&lt;/param&gt;    /// &lt;param name=&quot;className&quot;&gt;类的名字&lt;/param&gt;    /// &lt;param name=&quot;superclass&quot;&gt;继承类的名字&lt;/param&gt;    public void BeginClass(string modifier, string className, string superclass)    &#123;        BeginBrace($&quot;public &#123;modifier&#125; class &#123;className&#125; : &#123;superclass&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 开始增加类    /// &lt;/summary&gt;    /// &lt;param name=&quot;modifier&quot;&gt;类的修饰字符串&lt;/param&gt;    /// &lt;param name=&quot;className&quot;&gt;类的名字&lt;/param&gt;    public void BeginClass(string modifier, string className)    &#123;        BeginBrace($&quot;public &#123;modifier&#125; class &#123;className&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 开始增加类    /// &lt;/summary&gt;    /// &lt;param name=&quot;className&quot;&gt;类的名字&lt;/param&gt;    public void BeginClass(string className)    &#123;        BeginBrace($&quot;public class &#123;className&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 结束类    /// &lt;/summary&gt;    public void EndClass()    &#123;        EndBrace();    &#125;    /// &lt;summary&gt;    /// 开始增加方法    /// &lt;/summary&gt;    /// &lt;param name=&quot;method&quot;&gt;方法名&lt;/param&gt;    /// &lt;param name=&quot;permission&quot;&gt;访问权限&lt;/param&gt;    /// &lt;param name=&quot;returnType&quot;&gt;返回类型&lt;/param&gt;    /// &lt;param name=&quot;modifier&quot;&gt;修饰符&lt;/param&gt;    public void BeginMethod(string method, string permission = &quot;public&quot;, string returnType = &quot;void&quot;,        string modifier = &quot;&quot;)    &#123;        MarkInMethod = true;        BeginBrace(string.IsNullOrEmpty(modifier)            ? $&quot;&#123;permission&#125; &#123;returnType&#125; &#123;method&#125;&quot;            : $&quot;&#123;permission&#125; &#123;modifier&#125; &#123;returnType&#125; &#123;method&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 结束方法    /// &lt;/summary&gt;    public void EndMethod()    &#123;        EndBrace();        MarkInMethod = false;    &#125;    /// &lt;summary&gt;    /// 开始属性    /// &lt;/summary&gt;    /// &lt;param name=&quot;property&quot;&gt;属性名字&lt;/param&gt;    public void BeginProperty(string property)    &#123;        BeginBrace(property);    &#125;    /// &lt;summary&gt;    /// 结束属性    /// &lt;/summary&gt;    public void EndProperty()    &#123;        EndBrace();    &#125;    /// &lt;summary&gt;    /// 大括号的开始    /// &lt;/summary&gt;    /// &lt;param name=&quot;code&quot;&gt;&lt;/param&gt;    public void BeginBrace(string code)    &#123;        AppendLine($&quot;&#123;code&#125;&quot;);        AppendLine(&quot;&#123;&quot;);        BeginBlank();    &#125;    /// &lt;summary&gt;    /// 结束大括号    /// &lt;/summary&gt;    public void EndBrace()    &#123;        EndBlank();        AppendLine(&quot;&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 开始字段    /// &lt;/summary&gt;    /// &lt;param name=&quot;code&quot;&gt;Field的名字&lt;/param&gt;    public void BeginField(string code)    &#123;        AppendLine($&quot;&#123;code&#125;&quot;);        AppendLine(&quot;&#123;&quot;);        BeginBlank();    &#125;    /// &lt;summary&gt;    /// 结束字段    /// &lt;/summary&gt;    public void EndField()    &#123;        EndBlank();        AppendLine(&quot;&#125;;&quot;);    &#125;    /// &lt;summary&gt;    /// 开始Region    /// &lt;/summary&gt;    /// &lt;param name=&quot;name&quot;&gt;Region的名字&lt;/param&gt;    public void BeginRegion(string name)    &#123;        AppendLine($&quot;#region &#123;name&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 结束Region    /// &lt;/summary&gt;    public void EndRegion()    &#123;        AppendLine(&quot;#endregion&quot;);    &#125;    /// &lt;summary&gt;    /// 转成字符串    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public override string ToString()    &#123;        return m_Builder.ToString();    &#125;&#125;</code></pre><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>上述方法就是辅助的脚本，下面是举例调用方法作为参考  </p><pre><code>// 获取类脚本的路径var scriptPath = AssetDatabase.GUIDToAssetPath(kGUID);var sb = new ScriptBuilder();sb.BeginNamespace(typeof(StorageKeyConst).Namespace);sb.BeginClass(&quot;static&quot;, &quot;StorageKeyConst&quot;);if (DataStorageEditorTools.Instance.DataStorageEditorDataRootList.Count &gt; 0)&#123;    sb.BeginRegion(&quot;RootKeys&quot;);    sb.AppendLine(string.Empty);    AddListScripts(sb, DataStorageEditorTools.Instance.DataStorageEditorDataRootList);    sb.AppendLine(string.Empty);    sb.EndRegion();    sb.AppendLine(string.Empty);&#125;if (DataStorageEditorTools.Instance.DataStorageEditorDataList.Count &gt; 0)&#123;    sb.BeginRegion(&quot;Keys&quot;);    sb.AppendLine(string.Empty);    AddListScripts(sb, DataStorageEditorTools.Instance.DataStorageEditorDataList);    sb.AppendLine(string.Empty);    sb.EndRegion();&#125;sb.EndClass();sb.EndNamespace();File.WriteAllText(scriptPath, sb.ToString(), Encoding.UTF8);AssetDatabase.SaveAssets();AssetDatabase.Refresh();</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;一个辅助快速生成需要的C#脚本的脚本。主要是快速生成引用，命名空间，类和方法一些。&lt;/p&gt;
&lt;h1 id=&quot;脚本和解析&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity杂文——阿拉伯数字转罗马数字</title>
    <link href="http://yoursite.com/2022/12/29/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2022/12/29/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</id>
    <published>2022-12-29T09:40:31.000Z</published>
    <updated>2023-06-03T05:16:35.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在游戏开发中，美术人员有时需要将一些数字转换为罗马数字。本文介绍了一种将阿拉伯数字转换为罗马数字的方法，可以帮助美术人员快速完成转换。如果您是游戏开发人员或对数字转换感兴趣，本文也会对您有所帮助。 </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>/// &lt;summary&gt;/// 数字转罗马数字/// &lt;/summary&gt;/// &lt;param name=&quot;num&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string IntToRoman(int num)&#123;    var res = string.Empty;    var val = new List&lt;int&gt; &#123; 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 &#125;;    var str = new List&lt;string&gt; &#123; &quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot; &#125;;    for(var i = 0;i &lt; val.Count; ++i)    &#123;        while(num &gt;= val[i])        &#123;            num -= val[i];            res += str[i];        &#125;    &#125;    return res;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在游戏开发中，美术人员有时需要将一些数字转换为罗马数字。本文介绍了一种将阿拉伯数字转换为罗马数字的方法，可以帮助美术人员快速完成转换。如果您</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="字符串处理" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——编辑器Foldout右键菜单</title>
    <link href="http://yoursite.com/2022/12/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E5%99%A8Foldout%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/"/>
    <id>http://yoursite.com/2022/12/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E5%99%A8Foldout%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/</id>
    <published>2022-12-28T03:09:37.000Z</published>
    <updated>2022-12-28T03:18:14.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在用编辑器开发工具的时候，我们经常会用到折叠的Foldout，这里就不对Foldout做详细的介绍了，本文主要分享如何对Foldout做一个扩展，笔者在开发中常常需要的一个右键菜单的功能，这样我们就可以添加很多功能而不需要增加按钮，右键选择对应的菜单就行了。  </p><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/FoldoutRightClick-2022-12-2811:17:09.gif"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>var rect = GUILayoutUtility.GetRect(EditorGUIUtility.fieldWidth, EditorGUIUtility.fieldWidth, 18f, 18f,    EditorStyles.foldout);m_IsFoldout = EditorGUI.Foldout(rect, m_IsFoldout, &quot;标题&quot;);CreateNewGenericMenu(rect, new List&lt;string&gt; &#123; &quot;方法一&quot;, &quot;方法二&quot;, &quot;方法三&quot; &#125;, new List&lt;Action&gt;&#123;    (() =&gt; &#123;Debug.LogError(&quot;1&quot;);&#125;),    (() =&gt; &#123;Debug.LogError(&quot;2&quot;);&#125;),    (() =&gt; &#123;Debug.LogError(&quot;3&quot;);&#125;),&#125;);/// &lt;summary&gt;/// 绘制右键菜单/// &lt;/summary&gt;/// &lt;param name=&quot;btnRect&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;menuName&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;menuIsOn&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;menuCallBack&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public GenericMenu CreateNewGenericMenu(Rect btnRect, List&lt;string&gt; menuName, List&lt;Action&gt; menuCallBack,    List&lt;bool&gt; menuIsOn = null)&#123;    var menu = new GenericMenu();    var index = 0;    foreach (var action in menuCallBack)    &#123;        menu.AddItem(new GUIContent(menuName[index]), menuIsOn != null &amp;&amp; menuIsOn[index],            () =&gt; &#123; action?.Invoke(); &#125;);        index++;    &#125;    if (Event.current.button == 1 &amp;&amp; Event.current.type == EventType.MouseDown &amp;&amp;        btnRect.Contains(Event.current.mousePosition))    &#123;        menu.ShowAsContext();    &#125;    return menu;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在用编辑器开发工具的时候，我们经常会用到折叠的Foldout，这里就不对Foldout做详细的介绍了，本文主要分享如何对Foldout做一个</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——UI点击穿透</title>
    <link href="http://yoursite.com/2022/12/17/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UI%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F/"/>
    <id>http://yoursite.com/2022/12/17/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UI%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F/</id>
    <published>2022-12-17T02:11:15.000Z</published>
    <updated>2022-12-17T02:19:25.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>当UI打开一个小的提示tip的时候，常见的需求是点击其他任意地方就关闭tip，这个功能很常见，空白出响应点击，监听到就关闭tip，这里会发现一个问题，我们并不能响应tip面板底下的其他按钮，这样玩家在操作的时候就需要先关掉tip，然后再点一下按钮，这往往不是策划想要的，所以我们需要在点击空白处关闭的时候同时响应底下的按钮，这个时候就需要点击穿透事件。  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>using System.Collections.Generic;using UnityEngine;using UnityEngine.EventSystems;namespace ZHEngine.UI&#123;    public sealed class UTouchPass : MonoBehaviour, IPointerClickHandler,    IMoveHandler,IPointerDownHandler, IPointerUpHandler,IPointerEnterHandler,ISelectHandler, IDeselectHandler    , ISubmitHandler, IInitializePotentialDragHandler, IBeginDragHandler, IEndDragHandler, IDragHandler, IScrollHandler    &#123;        private GameObject CacheGameObject;        private readonly List&lt;RaycastResult&gt; result = new List&lt;RaycastResult&gt;();        public void OnPointerClick(PointerEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.pointerClickHandler);        &#125;        public void OnPointerDown(PointerEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.pointerDownHandler);            if (Input.GetButtonDown(&quot;Submit&quot;))               ExecuteEvents.Execute(eventData.pointerCurrentRaycast.gameObject, eventData, ExecuteEvents.submitHandler);        &#125;        public void OnPointerUp(PointerEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.pointerUpHandler);        &#125;        public void OnPointerEnter(PointerEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.pointerEnterHandler);        &#125;        public void OnSelect(BaseEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.selectHandler);        &#125;        public void OnDeselect(BaseEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.deselectHandler);        &#125;        public void OnSubmit(BaseEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.submitHandler);        &#125;        public void OnMove(AxisEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.moveHandler);        &#125;        public void OnInitializePotentialDrag(PointerEventData eventData)        &#123;            CacheGameObject = PassEvent(eventData, ExecuteEvents.initializePotentialDrag);        &#125;        public void OnBeginDrag(PointerEventData eventData)        &#123;             PassEvent(eventData, ExecuteEvents.beginDragHandler);        &#125;        public void OnDrag(PointerEventData eventData)        &#123;            ExecuteEvents.Execute(CacheGameObject, eventData, ExecuteEvents.dragHandler);        &#125;        public void OnEndDrag(PointerEventData eventData)        &#123;            ExecuteEvents.Execute(CacheGameObject, eventData, ExecuteEvents.endDragHandler);            CacheGameObject = null;        &#125;        public void OnScroll(PointerEventData eventData)        &#123;            ExecuteEvents.Execute(CacheGameObject, eventData, ExecuteEvents.scrollHandler);        &#125;        private GameObject PassEvent&lt;T&gt;(BaseEventData data, ExecuteEvents.EventFunction&lt;T&gt; function) where T : IEventSystemHandler        &#123;            if (data is PointerEventData eventData)            &#123;                var pointerGo = eventData.pointerCurrentRaycast.gameObject                    ? eventData.pointerCurrentRaycast.gameObject                    : eventData.pointerDrag;                EventSystem.current.RaycastAll(eventData, result);                foreach (var item in result)                &#123;                    var go = item.gameObject;                    if (go != null &amp;&amp; go != pointerGo)                    &#123;                        var executeGo = ExecuteEvents.GetEventHandler&lt;T&gt;(go);                        if (executeGo)                        &#123;                            if (executeGo.TryGetComponent&lt;UTouchPass&gt;(out var __))                                return null;                            ExecuteEvents.Execute(executeGo, data, function);                            return executeGo;                        &#125;                        else                        &#123;                            if(go.TryGetComponent&lt;UnityEngine.UI.Graphic&gt;(out var com))                            &#123;                                if (com.raycastTarget) return null;                            &#125;                        &#125;                    &#125;                &#125;            &#125;            return null;        &#125;    &#125;&#125;</code></pre><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.xuanyusong.com/archives/4773">Unity3D研究院之UI完整透下事件（一百二十二）——雨松MOMO</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;当UI打开一个小的提示tip的时候，常见的需求是点击其他任意地方就关闭tip，这个功能很常见，空白出响应点击，监听到就关闭tip，这里会发现</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="UI" scheme="http://yoursite.com/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——编辑器下拉多选菜单</title>
    <link href="http://yoursite.com/2022/09/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8B%E6%8B%89%E5%A4%9A%E9%80%89%E8%8F%9C%E5%8D%95/"/>
    <id>http://yoursite.com/2022/09/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8B%E6%8B%89%E5%A4%9A%E9%80%89%E8%8F%9C%E5%8D%95/</id>
    <published>2022-09-27T16:10:39.000Z</published>
    <updated>2022-09-27T16:37:18.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>游戏编辑器工具开发中会经常遇到下拉菜单的需求，笔者也遇到了一种特殊的下拉菜单，是下拉后可以多选的菜单，于是笔者便记录下这种特殊菜单的开发脚本。</p><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/20220928_003131-2022-9-2800:34:48.gif">  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><pre><code>public enum DropdownMultiType&#123;    [InspectorName(&quot;无&quot;)] None = 0,    Everything = ~0,    [InspectorName(&quot;类型一&quot;)] Type1 = 1 &lt;&lt; 1,    [InspectorName(&quot;类型二&quot;)] Type2 = 1 &lt;&lt;2,    [InspectorName(&quot;类型三&quot;)] Type3 = 1&lt;&lt;3&#125;</code></pre><h2 id="调用脚本"><a href="#调用脚本" class="headerlink" title="调用脚本"></a>调用脚本</h2><pre><code>m_DropdownMultiType = (DropdownMultiType)EditorGUILayout.EnumFlagsField(m_DropdownMultiType, GUILayout.Width(120))；EditorGUILayout.LabelField($&quot;Type1：&#123;m_DropdownMultiType.HasFlag(DropdownMultiType.Type1)&#125;&quot;);EditorGUILayout.LabelField($&quot;Type2：&#123;m_DropdownMultiType.HasFlag(DropdownMultiType.Type2)&#125;&quot;);EditorGUILayout.LabelField($&quot;Type3：&#123;m_DropdownMultiType.HasFlag(DropdownMultiType.Type3)&#125;&quot;);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;游戏编辑器工具开发中会经常遇到下拉菜单的需求，笔者也遇到了一种特殊的下拉菜单，是下拉后可以多选的菜单，于是笔者便记录下这种特殊菜单的开发脚本</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>常用Python文件处理脚本</title>
    <link href="http://yoursite.com/2022/09/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%B8%B8%E7%94%A8Python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2022/09/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%B8%B8%E7%94%A8Python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/</id>
    <published>2022-09-11T14:50:02.000Z</published>
    <updated>2022-09-11T15:21:42.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Unity打包经常会用一些文件的复制粘贴到一些文件到自己指定的SDK目录，一开始我们使用的是bat脚本，但是笔者发现这个脚本没办法在打包机（MAC）上使用，于是笔者便想到了python脚本来实现。  </p><h1 id="引用的库"><a href="#引用的库" class="headerlink" title="引用的库"></a>引用的库</h1><pre><code>import sysimport osimport jsonimport shutil</code></pre><h1 id="利用json配置需要控制的文件或者文件夹"><a href="#利用json配置需要控制的文件或者文件夹" class="headerlink" title="利用json配置需要控制的文件或者文件夹"></a>利用json配置需要控制的文件或者文件夹</h1><pre><code>&#123;    &quot;remdir&quot;:[        &quot;data/libs/&quot;,        &quot;data/src/main/assets/&quot;        ],    &quot;copydir&quot;:[        &quot;../xarchive/android/unityLibrary/libs/&quot;,        &quot;../xarchive/android/unityLibrary/    ]&#125;</code></pre><h1 id="参数读取"><a href="#参数读取" class="headerlink" title="参数读取"></a>参数读取</h1><pre><code>if (len(sys.argv) &gt; 1):    isPAD = sys.argv[1]if(isPAD == &quot;0&quot;)    ...</code></pre><p>命令执行python脚本的时候通过读取<strong>sys.argv</strong>便可以读取到自己传入的参数，这里需要注意的是读取的都是字符串，所以笔者在读数字0的时候需要用到**”0”**。  </p><h1 id="读取Config配置文件（json）"><a href="#读取Config配置文件（json）" class="headerlink" title="读取Config配置文件（json）"></a>读取Config配置文件（json）</h1><pre><code>configFilePath = &quot;config.json&quot;;with open(configFilePath,&#39;r&#39;) as load_f:    load_dict = json.load(load_f)</code></pre><h1 id="删除目录文件或者文件夹"><a href="#删除目录文件或者文件夹" class="headerlink" title="删除目录文件或者文件夹"></a>删除目录文件或者文件夹</h1><pre><code>def path_remove(removepath):    for remdirPath in removepath:        try:            if os.path.exists(remdirPath):                if os.path.isdir(remdirPath):                    shutil.rmtree(remdirPath)                else:                    os.remove(remdirPath)                print(&quot;Remove Success: &quot;+remdirPath)        except OSError as e:            print(&quot;Error: %s : %s&quot; % (remdirPath, e.strerror))</code></pre><h1 id="复制文件或者文件夹到指定目录"><a href="#复制文件或者文件夹到指定目录" class="headerlink" title="复制文件或者文件夹到指定目录"></a>复制文件或者文件夹到指定目录</h1><pre><code>def proc_copy(old_path, new_path):    if os.path.exists(old_path):        if os.path.isdir(old_path):            shutil.copytree(old_path, new_path)        elif os.path.isfile(old_path):            shutil.copyfile(old_path, new_path)        print(&quot;Copy Success: &quot; + old_path)    else:        print(&quot;NOT FOUND: &#123;&#125;&quot;.format(old_path))def path_copy(copydir, pastedir):    for index in range(len(copydir)):        if os.path.exists(pastedir[index]):            if os.path.isdir(pastedir[index]):                shutil.rmtree(pastedir[index])        proc_copy(copydir[index],pastedir[index])</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Unity打包经常会用一些文件的复制粘贴到一些文件到自己指定的SDK目录，一开始我们使用的是bat脚本，但是笔者发现这个脚本没办法在打包机（</summary>
      
    
    
    
    <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——Android设备唯一标识</title>
    <link href="http://yoursite.com/2022/09/02/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Android%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86/"/>
    <id>http://yoursite.com/2022/09/02/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Android%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86/</id>
    <published>2022-09-02T09:18:27.000Z</published>
    <updated>2022-09-03T08:59:13.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>获取设备唯一标识的方法。</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>引用库的github地址：<a href="https://github.com/gzu-liyujiang/Android_CN_OAID/tree/master"><font color="steelblue" size="5">Android_CN_OAID</font></a><br>在Android最外层的bundel.gradle里添加下面依赖  </p><pre><code>allprojects &#123;    repositories &#123;        &#39;&#39;&#39;        maven &#123; url &#39;https://www.jitpack.io&#39; &#125;        ...    &#125;&#125;</code></pre><p>在app或者library的bundel.gradle添加下面依赖  </p><pre><code>dependencies &#123;implementation &#39;com.github.gzu-liyujiang:Android_CN_OAID:&lt;version&gt;&#39;&#125;</code></pre><p><version>这里换成自己需要的版本</version></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="引用的库的初始化"><a href="#引用的库的初始化" class="headerlink" title="引用的库的初始化"></a>引用的库的初始化</h2><p>在Application或者Active的onCreate里添加下面代码：  </p><pre><code>@Overridepublic void onCreate() &#123;    super.onCreate();    if (privacyPolicyAgreed) &#123;        ...        DeviceIdentifier.register(&lt;Application&gt;);        ...    &#125;&#125;</code></pre><p><Application>这里替换成自己程序的application</Application></p><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>需要的变量： </p><pre><code>//设备唯一标识private static String deviceId;//设备唯一标识文件名字private static String deviceIdFileName = &quot;all_in_sdk&quot;;//设备唯一标识缓存关键字keyprivate static String deviceIdKey = &quot;DeviceId&quot;;//设备唯一标识正则private static final Pattern ANDROID_ID_PATTERN = Pattern.compile(&quot;^[0-9a-fA-F]&#123;16&#125;$&quot;);</code></pre><p>获取的方法：</p><pre><code>//获取设备的唯一标识public static String GetDeviceID() &#123;    if(m_Activity == null)&#123;        m_Activity = UnityPlayer.currentActivity;    &#125;    Application application = m_Activity.getApplication();    if (application == null)        return &quot;&quot;;    if (deviceId != null)        return deviceId;    deviceId = getSPValue((Context)application, deviceIdKey);    if (!TextUtils.isEmpty(deviceId))        return deviceId;    deviceId = getAndroidIdAsDeviceId((Context)application);    if (!TextUtils.isEmpty(deviceId)) &#123;        saveSPValue((Context)application, deviceIdKey, deviceId);        return deviceId;    &#125;    deviceId = generateSoftDeviceId();    if (!TextUtils.isEmpty(deviceId)) &#123;        saveSPValue((Context)application, deviceIdKey, deviceId);        return deviceId;    &#125;    return deviceId;&#125;private static String getSPValue(Context paramContext, String paramString) &#123;    SharedPreferences sharedPreferences = paramContext.getSharedPreferences(deviceIdFileName, 0);    return sharedPreferences.getString(paramString, null);&#125;private static String getAndroidIdAsDeviceId(Context paramContext) &#123;    String str;    if(DeviceID.supportedOAID(m_Activity))    &#123;        str = DeviceIdentifier.getOAID(m_Activity);        if (isLegalAndroidId(str, true))            return str;    &#125;    str = DeviceIdentifier.getAndroidID(m_Activity);    if (isLegalAndroidId(str, true))        return str;    str = DeviceIdentifier.getIMEI(m_Activity);    if (isLegalAndroidId(str, true))        return str;    str = DeviceIdentifier.getWidevineID();    if (isLegalAndroidId(str, true))        return str;    str = DeviceIdentifier.getPseudoID();    if (isLegalAndroidId(str, true))        return str;    str = DeviceIdentifier.getGUID(m_Activity);    if (isLegalAndroidId(str, true))        return str;    return null;&#125;private static String generateSoftDeviceId() &#123;    String str1 = Build.SERIAL;    String str2 = !TextUtils.isEmpty(str1) ? str1 : &quot;NA&quot;;    try &#123;        long l1 = 1152921504606846976L;        long l2 = randomLong(Long.MAX_VALUE - l1) + l1;        return String.format(&quot;%1$s_%2$s&quot;, new Object[] &#123; Long.toHexString(l2), str2 &#125;);    &#125; catch (Throwable throwable) &#123;        return String.format(&quot;%1$s_%2$s&quot;, new Object[] &#123; &quot;NA&quot; + Long.toHexString(System.currentTimeMillis()), str2 &#125;);    &#125;&#125;private static void saveSPValue(Context paramContext, String paramString1, String paramString2) &#123;    SharedPreferences sharedPreferences = paramContext.getSharedPreferences(deviceIdFileName, 0);    sharedPreferences.edit().putString(paramString1, paramString2).apply();&#125;private static long randomLong(long paramLong) &#123;    if (Build.VERSION.SDK_INT &gt;= 21)        return ThreadLocalRandom.current().nextLong(paramLong);    return (long)((new Random()).nextDouble() * (paramLong - 1L));&#125;private static boolean isLegalAndroidId(String paramString, boolean paramBoolean) &#123;    if (paramBoolean)        return (!TextUtils.isEmpty(paramString) &amp;&amp; ANDROID_ID_PATTERN                .matcher(paramString).find());    return (!TextUtils.isEmpty(paramString) &amp;&amp; ANDROID_ID_PATTERN            .matcher(paramString).find());&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;获取设备唯一标识的方法。&lt;/p&gt;
&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——UI父节点随子节点自适应</title>
    <link href="http://yoursite.com/2022/08/24/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UI%E7%88%B6%E8%8A%82%E7%82%B9%E9%9A%8F%E5%AD%90%E8%8A%82%E7%82%B9%E8%87%AA%E9%80%82%E5%BA%94/"/>
    <id>http://yoursite.com/2022/08/24/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UI%E7%88%B6%E8%8A%82%E7%82%B9%E9%9A%8F%E5%AD%90%E8%8A%82%E7%82%B9%E8%87%AA%E9%80%82%E5%BA%94/</id>
    <published>2022-08-24T11:56:54.000Z</published>
    <updated>2022-08-24T12:11:41.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在UI的开发过程中，经常会遇到Image随子节点的文字变化自动缩放，就是拿Image当背景。笔者遇到这种问题每次都是利用Layout+Content Size Fitter来完成的，笔者想了想每次都要加两个组件，并且Layout只用到了随自己点自适应的功能，于是笔者便想办法把两个功能合成一个脚本来实现需求，于是便有了下面的脚本。  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>代码如下： </p><pre><code>using System;using UnityEngine;using UnityEngine.EventSystems;using UnityEngine.UI;/// &lt;summary&gt;/// 未完成，暂时别用/// &lt;/summary&gt;[AddComponentMenu(&quot;Layout/Rect Transform Fitter&quot;, 142)][ExecuteAlways][RequireComponent(typeof(RectTransform))]public class RectTransformFit : UIBehaviour, ILayoutGroup&#123;    [SerializeField] protected RectTransform m_RectChildren;    [SerializeField] protected RectOffset m_Padding = new RectOffset();    [SerializeField] protected TextAnchor m_ChildAlignment = TextAnchor.UpperLeft;    [SerializeField] protected bool m_ChildControlWidth = false;    [SerializeField] protected bool m_ChildControlHeight = false;    [SerializeField] protected ContentSizeFitter.FitMode m_HorizontalFit = ContentSizeFitter.FitMode.Unconstrained;    [SerializeField] protected ContentSizeFitter.FitMode m_VerticalFit = ContentSizeFitter.FitMode.Unconstrained;    public RectOffset padding    &#123;        get =&gt; m_Padding;        set =&gt; SetProperty(ref m_Padding, value);    &#125;    public TextAnchor childAlignment &#123; get =&gt; m_ChildAlignment;        set =&gt; SetProperty(ref m_ChildAlignment, value);    &#125;    public bool childControlWidth    &#123;        get =&gt; m_ChildControlWidth;        set =&gt; SetProperty(ref m_ChildControlWidth, value);    &#125;    public bool childControlHeight    &#123;        get =&gt; m_ChildControlHeight;        set =&gt; SetProperty(ref m_ChildControlHeight, value);    &#125;    public ContentSizeFitter.FitMode horizontalFit    &#123;        get =&gt; m_HorizontalFit;        set        &#123;            if (SetPropertyUtility.SetStruct(ref m_HorizontalFit, value)) SetDirty();        &#125;    &#125;    public ContentSizeFitter.FitMode verticalFit    &#123;        get =&gt; m_VerticalFit;        set        &#123;            if (SetPropertyUtility.SetStruct(ref m_VerticalFit, value)) SetDirty();        &#125;    &#125;    [NonSerialized] private RectTransform m_Rect;    protected RectTransform rectTransform    &#123;        get        &#123;            if (m_Rect == null)                m_Rect = GetComponent&lt;RectTransform&gt;();            return m_Rect;        &#125;    &#125;#pragma warning disable 649    private DrivenRectTransformTracker m_Tracker;#pragma warning restore 649    private void OnEnable()    &#123;        m_Rect ??= GetComponent&lt;RectTransform&gt;();        SetDirty();    &#125;    protected override void OnRectTransformDimensionsChange()    &#123;        SetDirty();    &#125;    protected override void OnDisable()    &#123;        m_Tracker.Clear();        base.OnDisable();    &#125;    /// &lt;summary&gt;    /// Calculate and apply the horizontal component of the size to the RectTransform    /// &lt;/summary&gt;    public void SetLayoutHorizontal()    &#123;        m_Tracker.Clear();        if (m_RectChildren == null || !m_ChildControlWidth)        &#123;            SetDirty();            return;        &#125;        HandleSelfFittingAlongAxis(0, m_RectChildren);    &#125;    /// &lt;summary&gt;    /// Calculate and apply the vertical component of the size to the RectTransform    /// &lt;/summary&gt;    public void SetLayoutVertical()    &#123;        if (m_RectChildren == null || !m_ChildControlHeight)        &#123;            SetDirty();            return;        &#125;        HandleSelfFittingAlongAxis(1, m_RectChildren);    &#125;    private void HandleSelfFittingAlongAxis(int axis, RectTransform rectChild)    &#123;        if (rectChild == null) return;        var fitting = (axis == 0 ? horizontalFit : verticalFit);        if (fitting == ContentSizeFitter.FitMode.Unconstrained)        &#123;            // Keep a reference to the tracked transform, but don&#39;t control its properties:            m_Tracker.Add(this, rectChild, DrivenTransformProperties.None);            return;        &#125;        m_Tracker.Add(this, rectChild,            (axis == 0 ? DrivenTransformProperties.SizeDeltaX : DrivenTransformProperties.SizeDeltaY));        // Set size to min or preferred size        rectChild.SetSizeWithCurrentAnchors((RectTransform.Axis)axis,            fitting == ContentSizeFitter.FitMode.MinSize                ? LayoutUtility.GetMinSize(rectChild, axis)                : LayoutUtility.GetPreferredSize(rectChild, axis));        SetDirty();    &#125;    /// &lt;summary&gt;    /// Helper method used to set a given property if it has changed.    /// &lt;/summary&gt;    /// &lt;param name=&quot;currentValue&quot;&gt;A reference to the member value.&lt;/param&gt;    /// &lt;param name=&quot;newValue&quot;&gt;The new value.&lt;/param&gt;    protected void SetProperty&lt;T&gt;(ref T currentValue, T newValue)    &#123;        if ((currentValue == null &amp;&amp; newValue == null) || (currentValue != null &amp;&amp; currentValue.Equals(newValue)))            return;        currentValue = newValue;        SetDirty();    &#125;    protected void SetDirty()    &#123;        if (!IsActive())            return;        RefreshRect();        LayoutRebuilder.MarkLayoutForRebuild(m_RectChildren);        LayoutRebuilder.MarkLayoutForRebuild(m_Rect);    &#125;    public void RefreshRect()    &#123;        if (m_RectChildren == null) return;        Vector2 anchoredPos;        var childSize = m_RectChildren.sizeDelta;        var width = childSize.x + padding.left + padding.right;        var height = childSize.y + padding.top + padding.bottom;        var rectSize = rectTransform.sizeDelta;        if (horizontalFit != ContentSizeFitter.FitMode.Unconstrained &amp;&amp;            verticalFit != ContentSizeFitter.FitMode.Unconstrained)        &#123;            rectTransform.sizeDelta = new Vector2(width, height);        &#125;        else if (horizontalFit != ContentSizeFitter.FitMode.Unconstrained)        &#123;            rectTransform.sizeDelta = new Vector2(width, rectSize.y);        &#125;        else if (verticalFit != ContentSizeFitter.FitMode.Unconstrained)        &#123;            rectTransform.sizeDelta = new Vector2(rectSize.x, height);        &#125;        rectSize = rectTransform.sizeDelta;        var oldPos = rectTransform.anchoredPosition;        var oldPivot = rectTransform.pivot;        switch (m_ChildAlignment)        &#123;            case TextAnchor.UpperLeft:                rectTransform.pivot = new Vector2(0, 1);                anchoredPos = new Vector2(padding.left, -padding.top);                break;            case TextAnchor.UpperCenter:                rectTransform.pivot = new Vector2(0.5f, 1);                anchoredPos = new Vector2(0, -padding.top);                break;            case TextAnchor.UpperRight:                rectTransform.pivot = new Vector2(1, 1);                anchoredPos = new Vector2(-padding.right, -padding.top);                break;            case TextAnchor.MiddleLeft:                rectTransform.pivot = new Vector2(0, 0.5f);                anchoredPos = new Vector2(padding.left, 0);                break;            case TextAnchor.MiddleCenter:                rectTransform.pivot = new Vector2(0.5f, 0);                anchoredPos = new Vector2(0, 0);                break;            case TextAnchor.MiddleRight:                rectTransform.pivot = new Vector2(1, 0);                anchoredPos = new Vector2(-padding.right, 0);                break;            case TextAnchor.LowerLeft:                rectTransform.pivot = new Vector2(0, 0);                anchoredPos = new Vector2(padding.left, padding.bottom);                break;            case TextAnchor.LowerCenter:                rectTransform.pivot = new Vector2(0.5f, 0);                anchoredPos = new Vector2(0, padding.bottom);                break;            case TextAnchor.LowerRight:                rectTransform.pivot = new Vector2(1, 0);                anchoredPos = new Vector2(-padding.right, padding.bottom);                break;            default:                throw new ArgumentOutOfRangeException();        &#125;        var pivot = rectTransform.pivot;        rectTransform.anchoredPosition = new Vector2(oldPos.x + rectSize.x * (pivot.x - oldPivot.x),            oldPos.y + rectSize.y * (pivot.y - oldPivot.y));        m_RectChildren.anchorMax = pivot;        m_RectChildren.anchorMin = pivot;        m_RectChildren.pivot = pivot;        m_RectChildren.anchoredPosition = anchoredPos;    &#125;#if UNITY_EDITOR    protected override void OnValidate()    &#123;        SetDirty();    &#125;#endif&#125;</code></pre><h1 id="需要支持的脚本（源码抄来的SetPropertyUtility）"><a href="#需要支持的脚本（源码抄来的SetPropertyUtility）" class="headerlink" title="需要支持的脚本（源码抄来的SetPropertyUtility）"></a>需要支持的脚本（源码抄来的SetPropertyUtility）</h1><pre><code>using System;using System.Collections.Generic;using UnityEngine;internal static class SetPropertyUtility&#123;    private const float Tolerance = 0.000001f;                 //通过此值判断值是否发生变化    public static bool SetColor(ref Color currentValue, Color newValue)    &#123;        if (Math.Abs(currentValue.r - newValue.r) &lt; Tolerance &amp;&amp;            Math.Abs(currentValue.g - newValue.g) &lt; Tolerance &amp;&amp;            Math.Abs(currentValue.b - newValue.b) &lt; Tolerance &amp;&amp;            Math.Abs(currentValue.a - newValue.a) &lt; Tolerance)            return false;        currentValue = newValue;        return true;    &#125;    public static bool SetStruct&lt;T&gt;(ref T currentValue, T newValue) where T : struct    &#123;        if (EqualityComparer&lt;T&gt;.Default.Equals(currentValue, newValue))            return false;        currentValue = newValue;        return true;    &#125;    public static bool SetClass&lt;T&gt;(ref T currentValue, T newValue) where T : class    &#123;        if ((currentValue == null &amp;&amp; newValue == null) || (currentValue != null &amp;&amp; currentValue.Equals(newValue)))            return false;        currentValue = newValue;        return true;    &#125;&#125;</code></pre><h1 id="编辑器显示Editor代码"><a href="#编辑器显示Editor代码" class="headerlink" title="编辑器显示Editor代码"></a>编辑器显示Editor代码</h1><p>代码如下： </p><pre><code>using System;using UnityEditor;using UnityEditor.UI;using UnityEngine;[CustomEditor(typeof(RectTransformFit))]public class RectTransformFitEditor : SelfControllerEditor&#123;    SerializedProperty m_Padding;    SerializedProperty m_ChildAlignment;    SerializedProperty m_RectChildren;    SerializedProperty m_HorizontalFit;    SerializedProperty m_VerticalFit;    SerializedProperty m_ChildControlWidth;    SerializedProperty m_ChildControlHeight;    protected void OnEnable()    &#123;        m_Padding = serializedObject.FindProperty(&quot;m_Padding&quot;);        m_ChildAlignment = serializedObject.FindProperty(&quot;m_ChildAlignment&quot;);        m_RectChildren = serializedObject.FindProperty(&quot;m_RectChildren&quot;);        m_ChildControlWidth = serializedObject.FindProperty(&quot;m_ChildControlWidth&quot;);        m_ChildControlHeight = serializedObject.FindProperty(&quot;m_ChildControlHeight&quot;);        m_HorizontalFit = serializedObject.FindProperty(&quot;m_HorizontalFit&quot;);        m_VerticalFit = serializedObject.FindProperty(&quot;m_VerticalFit&quot;);    &#125;    public override void OnInspectorGUI()    &#123;        serializedObject.Update();        EditorGUILayout.PropertyField(m_Padding, true);        EditorGUILayout.PropertyField(m_ChildAlignment, true);        EditorGUILayout.PropertyField(m_RectChildren, true);        Rect rect = EditorGUILayout.GetControlRect();        rect = EditorGUI.PrefixLabel(rect, -1, EditorGUIUtility.TrTextContent(&quot;Control Child Size&quot;));        rect.width = Mathf.Max(50, (rect.width - 4) / 3);        EditorGUIUtility.labelWidth = 50;        ToggleLeft(rect, m_ChildControlWidth, EditorGUIUtility.TrTextContent(&quot;Width&quot;));        rect.x += rect.width + 2;        ToggleLeft(rect, m_ChildControlHeight, EditorGUIUtility.TrTextContent(&quot;Height&quot;));        EditorGUIUtility.labelWidth = 0;        EditorGUILayout.PropertyField(m_HorizontalFit, true);        EditorGUILayout.PropertyField(m_VerticalFit, true);        serializedObject.ApplyModifiedProperties();    &#125;    void ToggleLeft(Rect position, SerializedProperty property, GUIContent label)    &#123;        bool toggle = property.boolValue;        EditorGUI.showMixedValue = property.hasMultipleDifferentValues;        EditorGUI.BeginChangeCheck();        int oldIndent = EditorGUI.indentLevel;        EditorGUI.indentLevel = 0;        toggle = EditorGUI.ToggleLeft(position, label, toggle);        EditorGUI.indentLevel = oldIndent;        if (EditorGUI.EndChangeCheck())        &#123;            property.boolValue = property.hasMultipleDifferentValues || !property.boolValue;        &#125;        EditorGUI.showMixedValue = false;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在UI的开发过程中，经常会遇到Image随子节点的文字变化自动缩放，就是拿Image当背景。笔者遇到这种问题每次都是利用Layout+Con</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="UGUI" scheme="http://yoursite.com/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>hexo图床图片无法显示</title>
    <link href="http://yoursite.com/2022/08/20/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/hexo%E5%9B%BE%E5%BA%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2022/08/20/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/hexo%E5%9B%BE%E5%BA%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/</id>
    <published>2022-08-20T10:05:02.000Z</published>
    <updated>2022-08-20T10:15:38.397Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>今天更新自己博客的时候发现新博客的图片都无法显示，这个听说只存在于没有域名的博客中，笔者因为没有域名，所以不清除是不是。  </p><blockquote><p>图床：gitee<br>博客：github+hexo<br>原因猜测：gitee开始对图床进行限制，没有域名的博客也访问不到图床的图片  </p></blockquote><p>#解决方法 </p><h2 id="方法一（不推荐）"><a href="#方法一（不推荐）" class="headerlink" title="方法一（不推荐）"></a>方法一（不推荐）</h2><p>最快捷的解决方案就是再自己博客的文章开头加上下面代码   </p><pre><code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</code></pre><p>看下面举例  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1660990253369-2022-8-2018:10:54.png"></p><h2 id="方法二（推荐）"><a href="#方法二（推荐）" class="headerlink" title="方法二（推荐）"></a>方法二（推荐）</h2><p>在自己播放的主题文件加里直接加上就不需要了，具体路径：<br>拿3-hexo主题举例：<br>在**…\themes\3-hexo\layout_partial\header.ejs**文件里加入刚才的代码，如下：  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1660990452909-2022-8-2018:14:13.png">  </p><p>其他主题文件在类似位置：<strong>hexo\themes...\layout_partial\head.ejs</strong><br>其他主题的文件名字应该叫：<strong>head.ejs</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;今天更新自己博客的时候发现新博客的图片都无法显示</summary>
      
    
    
    
    <category term="搭建博客" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="hexo博客" scheme="http://yoursite.com/tags/hexo%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——Unity的Animation无法播放</title>
    <link href="http://yoursite.com/2022/08/20/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Unity%E7%9A%84Animation%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE/"/>
    <id>http://yoursite.com/2022/08/20/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Unity%E7%9A%84Animation%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE/</id>
    <published>2022-08-20T06:57:28.000Z</published>
    <updated>2022-08-20T09:52:46.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>笔者再开发过程中，有个功能需求是在游戏中移动Camera，笔者采用了两种方式，第一种是K动画用动画播放，另一种是用曲线表示运动节奏直线运动。第二种方式和本文无关，主要阐述第一种方式在播放Animation的时候无法播放的问题。  </p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者采用的是Animation的方式播放动画，笔者并未采用Animator，是在游戏中进行动态添加Animation组件，然后根据资源名字动态加载动画资源进行播放，下面是案例代码：  </p><pre><code>public float LookAtAnim(string animName)&#123;    if (!m_Transfrom.TryGetComponent(out Animation animation))    &#123;        animation = m_Transfrom.gameObject.AddComponent&lt;Animation&gt;();    &#125;    var clip = animation.GetClip(animName);    if (clip == null)    &#123;        clip = ResManager.LoadAsset&lt;AnimationClip&gt;(animName);        animation.AddClip(clip, animName);    &#125;    animation.clip = clip;    animation.Play(animName);    return clip.length;&#125;</code></pre><p>但是笔者在运行过程中发现编辑器并不能正常播放动画，通过断点调试，笔者发现在添加动画clip的时候并不能添加到Animation的clip列表里，于是笔者通过各种百度，谷歌等搜索发现需要打开Animation的legacy，修改后的代码如下：</p><pre><code>public float LookAtAnim(string animName)&#123;    ...    if (clip == null)    &#123;        clip = ResManager.LoadAsset&lt;AnimationClip&gt;(animName);        clip.legacy = true;        animation.AddClip(clip, animName);    &#125;    ...&#125;</code></pre><p>这时候动画播放正常了，但是笔者打包成apk后，在模拟器上依旧无法正常播放，笔者打印日志发现动画都正常添加了，于是笔者便尝试解决问题。  </p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>笔者思考**clip.legacy &#x3D; true;**这行代码的作用，于是笔者发现有可能是动画的问题，首先打开inspector的debug模式   </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1660979445735-2022-8-2015:10:46.png"><br>然后发现有些动画的Legacy是打开的，有些是关闭的，于是笔者都手动打开了  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1660979791351-2022-8-2015:16:31.png"><br>发现模拟器依旧没办法播放，最后发现真机上只需要把这个关闭就可以了。<br>笔者最终抛弃了Animation的方法，因为还需要手动加载资源，笔者采用了Animator的方式进行播放。代码如下：  </p><pre><code>/// &lt;summary&gt;/// 播放相机动画/// &lt;/summary&gt;/// &lt;param name=&quot;animName&quot;&gt;动画名字&lt;/param&gt;public float LookAtAnim(string animName)&#123;    SetAnimatorVisible(true);    m_Animator.Play(animName);    return (from animationClip in m_Animator.runtimeAnimatorController.animationClips        where animationClip.name == animName        select animationClip.length).FirstOrDefault();&#125;public void SetAnimatorVisible(bool visible)&#123;    if (m_Animator != null &amp;&amp; m_Animator.enabled == visible) return;    if(visible)    &#123;        if(m_Animator == null)        &#123;            m_Animator = m_Transfrom.gameObject.AddComponent&lt;Animator&gt;();            m_Animator.runtimeAnimatorController =                ResManager.LoadAsset&lt;RuntimeAnimatorController&gt;(TableGlobal.CameraController);        &#125;        else        &#123;            m_Animator.enabled = true;        &#125;    &#125;    else if (m_Animator != null)    &#123;        m_Animator.DOKill();        m_Animator.enabled = false;    &#125;&#125;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>切记要把动画资源的Legacy关闭，否则Animator也无法播放动画片段</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;笔者再开发过程中，有个功能需求是在游戏中移动Camera，笔者采用了两种方式，第一种是K动画用动画播放，另一种是用曲线表示运动节奏直线运动。</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Animation" scheme="http://yoursite.com/tags/Animation/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——根据条件禁用编辑器菜单</title>
    <link href="http://yoursite.com/2022/03/24/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E7%A6%81%E7%94%A8%E7%BC%96%E8%BE%91%E5%99%A8%E8%8F%9C%E5%8D%95/"/>
    <id>http://yoursite.com/2022/03/24/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E7%A6%81%E7%94%A8%E7%BC%96%E8%BE%91%E5%99%A8%E8%8F%9C%E5%8D%95/</id>
    <published>2022-03-24T06:20:07.000Z</published>
    <updated>2022-08-20T09:54:08.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>unity编辑器扩展菜单功能是我们开发中经常使用的，笔者在开发过程中想在特定条件下在启用指定的菜单，不满足条件的时候就禁用菜单，于是笔者找到了解决的办法。  </p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><pre><code>[MenuItem(&quot;Assets/MyMenuTest&quot;, false, 81)]public static void MyMenuTest()&#123;    //菜单执行事件&#125;[MenuItem(&quot;Assets/MyMenuTest&quot;, true)]public static bool IsShowMyMenu()&#123;    //获取自己的条件并return条件即可    return false;&#125;</code></pre><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1648103657696-2022-3-2414:34:18.png">  </p><p>只需要保证MenuItem的菜单路径一样的，把第二个参数改为true代表的是否是控制一个验证函数，根据自己的条件进行返回即可控制。   </p><p>下面是官网给的参数设置<br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1648103567771-2022-3-2414:32:48.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;unity编辑器扩展菜单功能是我们开发中经常使用的，笔者在开发过程中想在特定条件下在启用指定的菜单，不满足条件的时候就禁用菜单，于是笔者找到</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——自动创建asset资源文件</title>
    <link href="http://yoursite.com/2022/03/21/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BAasset%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2022/03/21/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BAasset%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/</id>
    <published>2022-03-21T06:36:13.000Z</published>
    <updated>2022-03-21T06:51:04.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Unity保存数据的方式有很多，比如我们经常用的json，xml和Txt，笔者今天讲到的是另外一种保存方式，asset文件，这个是unity提供的一种新的保存数据的方式，笔者也是刚使用没多久，这里就不详细进行介绍了，笔者今天主要是介绍一键自动创建对应的asset文件。  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code> public class CreateAssetEditor&#123;    [MenuItem(&quot;Assets/Create/CreateAsset&quot;,false,81)]    public static void OnCreateAsset()    &#123;        foreach (var guid in Selection.assetGUIDs)        &#123;            var path = AssetDatabase.GUIDToAssetPath(guid);            var pathSplit = path.Split(&#39;/&#39;);            var className = pathSplit[pathSplit.Length - 1].Replace(&quot;.cs&quot;, &quot;&quot;);            var classType = GetClassByClassName(className);            var assetPath = path.Replace(&quot;.cs&quot;, &quot;.asset&quot;);            if (File.Exists(assetPath))            &#123;                LBLogWrapper.Error(&quot;创建失败，资源已经存在&quot;);            &#125;            else if (classType != null)             &#123;                var classInst = ScriptableObject.CreateInstance(classType);                AssetDatabase.CreateAsset(classInst,assetPath);            &#125;            else            &#123;                LBLogWrapper.Error(&quot;创建失败，脚本不可创建&quot;);            &#125;        &#125;    &#125;        [MenuItem(&quot;Assets/Create/CreateAsset&quot;,true)]    private static bool IsValidateFun()    &#123;        return (from guid in Selection.assetGUIDs            select AssetDatabase.GUIDToAssetPath(guid)            into path            select path.Split(&#39;/&#39;)            into pathSplit            select pathSplit[pathSplit.Length - 1]).Any(className =&gt; className.Contains(&quot;.cs&quot;));    &#125;    /// &lt;summary&gt;    /// 通过类名获取对应的类    /// &lt;/summary&gt;    /// &lt;param name=&quot;className&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    private static Type GetClassByClassName(string className)    &#123;        var allAssemblies = AppDomain.CurrentDomain.GetAssemblies();        return allAssemblies.SelectMany(assembly =&gt; assembly.GetTypes()).FirstOrDefault(type =&gt;            type.Name == className &amp;&amp; type.IsSubclassOf(typeof(ScriptableObject)));    &#125;&#125;</code></pre><p>脚本的原理很简单，就是获取当前选择的脚本，判断是否可以创建asset文件，如果可以就是通过类名获取对应的类对象和，这里需要注意的是，<font color="red">文件名字必须等于类名</font>，然后通过类名获取对应的类型，就可以生成对应的asset文件了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Unity保存数据的方式有很多，比如我们经常用的json，xml和Txt，笔者今天讲到的是另外一种保存方式，asset文件，这个是unity</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="asset" scheme="http://yoursite.com/tags/asset/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——通过类名获取对应的Type</title>
    <link href="http://yoursite.com/2022/03/11/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E7%B1%BB%E5%90%8D%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E7%9A%84Type/"/>
    <id>http://yoursite.com/2022/03/11/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E7%B1%BB%E5%90%8D%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E7%9A%84Type/</id>
    <published>2022-03-11T07:36:03.000Z</published>
    <updated>2022-03-11T08:06:58.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者在编辑器开发过程中遇到一个问题，笔者想通过一个类的名字获取对应的类的Type然后再做一系列的操作，但是笔者发现无法直接获取，于是笔者通过不断的尝试通过下面的方法获取到了，如果有更好的方法欢迎告诉笔者。  </p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>话不多说，先上代码：  </p><pre><code>[MenuItem(&quot;Assets/GetType&quot;,false,81)]public static void GetClassTypeByClassTypeName()&#123;    const string className = &quot;TestScripts&quot;;    //方法一（在同一程序集内并且非自身Class才能获取到）    var type = Type.GetType(className);    Debug.LogError(type);        var allAssemblies = AppDomain.CurrentDomain.GetAssemblies();        //方法二（有特殊情况会获取不到，笔者没找到获取不到的原因）    type = allAssemblies.Select(assembly =&gt; assembly.GetType(className)).FirstOrDefault(assembly =&gt; assembly != null);    Debug.LogError(type);        //方法三（如果存在类重名的情况有概率获取错误，可以通过路径做限制）    type = allAssemblies.SelectMany(assembly =&gt; assembly.GetTypes()).FirstOrDefault(type1 =&gt; type1.Name == className);    Debug.LogError(type);&#125;</code></pre><p>运行结果如下  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1646985481130-2022-3-1115:58:02.png">  </p><p>方法一和方法二的获取条件都有限制，因此笔者建议使用方法三进行获取。  </p><h1 id="获取方式讲解"><a href="#获取方式讲解" class="headerlink" title="获取方式讲解"></a>获取方式讲解</h1><p>方法一是直接在当前程序集进行获取的。<br>方法二是通过遍历当前程序的所有程序集，然后通过程序集直接GetType进行获取<br>方法三是类似于方法二，得到所有的程序集再遍历程序集中的Type，判断名字是否相同来得到对应的Type</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;笔者在编辑器开发过程中遇到一个问题，笔者想通过一个类的名字获取对应的类的Type然后再做一系列的操作，但是笔者发现无法直接获取，于是笔者通过</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="C#反射" scheme="http://yoursite.com/tags/C-%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——按行删除字符串</title>
    <link href="http://yoursite.com/2022/03/10/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2022/03/10/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-03-10T09:02:29.000Z</published>
    <updated>2022-03-10T09:07:58.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>笔者在项目开发过程中需要做一个聊天的假数据显示，是用于demo的，于是笔者就直接用string字符串来模拟显示的数据，但是当聊天内容过多的时候就需要删除历史的聊天内容，于是笔者就想按照行数删除字符串，发现string并不包含这种接口，于是写下了下面的代码。  </p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><pre><code>private static string DeleteStrLine(string text, int startLine, int lineCount)&#123;    var curIndex = 0;    int? remStartIndex = null;    var sum = 1;    while (sum &lt; startLine + lineCount)     &#123;        if (sum == startLine) remStartIndex = curIndex;                curIndex = text.IndexOf(&quot;\n&quot;, curIndex, StringComparison.Ordinal);        if (curIndex &lt; 0)        &#123;            curIndex = text.Length;            break;        &#125;        curIndex++;        sum++;    &#125;    if (remStartIndex == null)    &#123;        return text;    &#125;    text = text.Remove(remStartIndex.Value, curIndex - remStartIndex.Value);    return text;&#125;</code></pre><p>上述代码是笔者的解决方案，原理很简单，遍历查找字符串的换行字符**”\n”**,然后记录下索引，根据传入的需要删除的行数找到对应的索引，最后使用Remove函数按照开始和结束的索引进行删除。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;笔者在项目开发过程中需要做一个聊天的假数据显示，是用于demo的，于是笔者就直接用string字符串来模拟显示的数据，但是当聊天内容过多的时</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>StarUML使用笔记</title>
    <link href="http://yoursite.com/2022/03/04/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/StarUML%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/03/04/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/StarUML%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-04T07:46:19.000Z</published>
    <updated>2022-03-10T07:01:11.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图操作菜单"><a href="#图操作菜单" class="headerlink" title="图操作菜单"></a>图操作菜单</h1><h2 id="Add-Diagram"><a href="#Add-Diagram" class="headerlink" title="Add Diagram"></a>Add Diagram</h2><pre><code>Class Diagram                   类图Package Diagram                 包图Object Diagram                  对象图Composite Structure Diagram     复合结构图Component Diagram               组件图Deployment Diagram              展开图Use Case Diagram                用例图Sequence Diagram                时序图Communication Diagram           交流图Statechart Diagram              状态图Activity Diagram                活动图Profile DiagramER Diagram                      E-R图Flowchart Diagram               流程图Data Flow Diagram               数据流程图</code></pre><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><pre><code>Tempalate Parameter     模板参数Attribute               属性Port                    端口Operation               操作Reception               接待Class                   类Interface               接口Signal                  信号DataType                数据类型PrimitiveType           原始类型Enumeration             枚举Artifact                工件Component               组件Node                    节点UseCaseActorInformationItemCollaborationInteraction             交互State Machine           状态机Activity                活动Opaque Behavior         不透明树Constraint              约束Requirement             要求Block                   块Value Type              数值类型Interface Block         接口块Constraint Block        约束快Tag                     标签</code></pre><h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1646381948452-2022-3-416:19:09.png">   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图操作菜单&quot;&gt;&lt;a href=&quot;#图操作菜单&quot; class=&quot;headerlink&quot; title=&quot;图操作菜单&quot;&gt;&lt;/a&gt;图操作菜单&lt;/h1&gt;&lt;h2 id=&quot;Add-Diagram&quot;&gt;&lt;a href=&quot;#Add-Diagram&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="个人笔记" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity杂文——String按行删除</title>
    <link href="http://yoursite.com/2022/03/03/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94string%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4/"/>
    <id>http://yoursite.com/2022/03/03/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94string%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4/</id>
    <published>2022-03-03T07:19:36.000Z</published>
    <updated>2022-03-04T02:16:15.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在unity开发过程中，如果一个string字符串有多行，如果我们想删除前面一行或者多行应该如何操作？  </p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><pre><code>private static string DeleteStrLine(string text, int startLine, int lineCount)&#123;    var curIndex = 0;    int? remStartIndex = null;    var sum = 1;    while (sum &lt; startLine + lineCount)     &#123;        if (sum == startLine) remStartIndex = curIndex;                curIndex = text.IndexOf(&quot;\n&quot;, curIndex, StringComparison.Ordinal);        if (curIndex &lt; 0)        &#123;            curIndex = text.Length;            break;        &#125;        curIndex++;        sum++;    &#125;    if (remStartIndex == null)    &#123;        return text;    &#125;    text = text.Remove(remStartIndex.Value, curIndex - remStartIndex.Value);    return text;&#125;</code></pre><p>思路就是通过<strong>IndexOf</strong>函数遍历找到需要删除的行对应的”\n”(换行)的索引，然后再通过<strong>Remove</strong>函数对开始和结束的索引进行删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;在unity开发过程中，如果一个string字符串有多行，如果我们想删除前面一行或者多行应该如何操作？  &lt;/p&gt;
&lt;h1 id=&quot;解决方案</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Unity笔记</title>
    <link href="http://yoursite.com/2022/03/03/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Unity%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/03/03/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Unity%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-03T07:14:26.000Z</published>
    <updated>2022-03-18T08:43:22.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p><strong>[Conditional(“XXX”)]</strong>: 指定XXX宏下进行编译<br><strong>[RuntimeInitializeOnLoadMethod]</strong>:游戏运行是就执行的方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;特性&quot;&gt;&lt;a href=&quot;#特性&quot; class=&quot;headerlink&quot; title=&quot;特性&quot;&gt;&lt;/a&gt;特性&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;[Conditional(“XXX”)]&lt;/strong&gt;: 指定XXX宏下进行编译&lt;br&gt;&lt;strong&gt;[Runtime</summary>
      
    
    
    
    <category term="个人笔记" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Unity" scheme="http://yoursite.com/tags/Unity/"/>
    
  </entry>
  
</feed>
