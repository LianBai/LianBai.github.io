<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LianBai</title>
  
  <subtitle>手握日月摘星辰，世间无我这般人。</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-09-17T12:48:28.533Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LianBai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python杂文——CShap脚本生成辅助工具</title>
    <link href="http://yoursite.com/2023/09/17/Python%E6%9D%82%E6%96%87/Python%E6%9D%82%E6%96%87%E2%80%94%E2%80%94CShap%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2023/09/17/Python%E6%9D%82%E6%96%87/Python%E6%9D%82%E6%96%87%E2%80%94%E2%80%94CShap%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/</id>
    <published>2023-09-17T12:42:54.000Z</published>
    <updated>2023-09-17T12:48:28.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文介绍了一个用于辅助生成C#脚本的Python工具。该工具可以帮助用户快速生成C#脚本，并提供了一些常用的代码生成方法。  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>import osclass CSScriptBuilder(list):    BlackNum = 0    def Append(self, message):        if self.BlackNum &gt; 0:            self.append(&#39;\t&#39; * self.BlackNum)        self.append(message)    def AppendEnter(self):        self.Append(&#39;\n&#39;)    def AppendLine(self, message):        if len(self) &gt; 0:            self.append(&#39;\n&#39;)        if self.BlackNum &gt; 0:            self.append(&#39;\t&#39; * self.BlackNum)        self.append(message)    def AppendEmptyLine(self):        self.AppendLine(&#39;&#39;)    def AppendUsing(self, namespace):        self.AppendLine(f&#39;using &#123;namespace&#125;;&#39;)    def BeginNamespace(self, namespace):        self.AppendLine(f&#39;namespace &#123;namespace&#125;&#39;)        self.BeginBrace()    def EndNamespace(self):        self.EndBrace()    def BeginClass(self, className, modifier=&quot;public&quot;, superclass=None):        if superclass is not None:            self.AppendLine(f&#39;&#123;modifier&#125; class &#123;className&#125; : &#123;superclass&#125;&#39;)        else:            self.AppendLine(f&#39;&#123;modifier&#125; class &#123;className&#125;&#39;)        self.BeginBrace()    def EndClass(self):        self.EndBrace()    def BeginStruct(self, structName, modifier=&quot;public&quot;):        self.AppendLine(f&#39;&#123;modifier&#125; struct &#123;structName&#125;&#39;)        self.BeginBrace()    def EndStruct(self):        self.EndBrace()    def BeginEnum(self, enumName, modifier=&quot;public&quot;):        self.AppendLine(f&#39;&#123;modifier&#125; enum &#123;enumName&#125;&#39;)        self.BeginBrace()    def EndEnum(self):        self.EndBrace()    def AppendEnumField(self, fieldName, fieldValue):        self.AppendLine(f&#39;&#123;fieldName&#125; = &#123;fieldValue&#125;,&#39;)    def BeginInterface(self, interfaceName, modifier=&quot;public&quot;):        self.AppendLine(f&#39;&#123;modifier&#125; interface &#123;interfaceName&#125;&#39;)        self.BeginBrace()    def EndInterface(self):        self.EndBrace()    def AppendInterfaceMethod(self, methodName, returnType=&#39;void&#39;, parameters=&#39;&#39;):        self.AppendLine(f&#39;&#123;returnType&#125; &#123;methodName&#125;(&#123;parameters&#125;);&#39;)    def AppendField(self, propertyName, propertyType, modifier=&quot;public&quot;, init=&#39;&#39;):        if len(init) &gt; 0:            self.AppendLine(f&#39;&#123;modifier&#125; &#123;propertyType&#125; &#123;propertyName&#125; = &#123;init&#125;;&#39;)        else:            self.AppendLine(f&#39;&#123;modifier&#125; &#123;propertyType&#125; &#123;propertyName&#125;;&#39;)    def AppendProperty(self, propertyName, propertyType, field=None, modifier=&quot;public&quot;):        if field is not None:            self.AppendLine(f&#39;&#123;modifier&#125; &#123;propertyType&#125; &#123;propertyName&#125; =&gt; &#123;field&#125;;&#39;)        else:            self.AppendLine(f&#39;&#123;modifier&#125; &#123;propertyType&#125; &#123;propertyName&#125; &#123;&#123; get; set; &#125;&#125;&#39;)    def BeginProperty(self, propertyName, propertyType, modifier=&quot;public&quot;):        self.AppendLine(f&#39;&#123;modifier&#125; &#123;propertyType&#125; &#123;propertyName&#125;&#39;)        self.BeginBrace()    def EndProperty(self):        self.EndBrace()    def BeginMethod(self, methodName, modifier=&quot;public&quot;, returnType=&#39;void&#39;, parameters=&#39;&#39;):        self.AppendLine(f&#39;&#123;modifier&#125; &#123;returnType&#125; &#123;methodName&#125;(&#123;parameters&#125;)&#39;)        self.BeginBrace()    def BeginConstructionMethod(self, methodName, modifier=&quot;public&quot;, parameters=&#39;&#39;):        self.AppendLine(f&#39;&#123;modifier&#125; &#123;methodName&#125;(&#123;parameters&#125;)&#39;)        self.BeginBrace()    def EndMethod(self):        self.EndBrace()    def BeginIf(self, condition):        self.AppendLine(f&#39;if (&#123;condition&#125;)&#39;)        self.BeginBrace()    def BeginElif(self, condition):        self.AppendLine(f&#39;else if (&#123;condition&#125;)&#39;)        self.BeginBrace()    def EndIf(self):        self.EndBrace()    def BeginWhile(self, condition):        self.AppendLine(f&#39;while (&#123;condition&#125;)&#39;)        self.BeginBrace()    def EndWhile(self):        self.EndBrace()    def BeginTry(self):        self.AppendLine(&#39;try&#39;)        self.BeginBrace()    def EndTry(self):        self.EndBrace()    def BeginCatch(self, exceptionType):        self.AppendLine(f&#39;catch (&#123;exceptionType&#125;)&#39;)        self.BeginBrace()    def EndCatch(self):        self.EndBrace()    def BeginBlank(self):        self.BlackNum += 1    def EndBlank(self):        self.BlackNum -= 1    def BeginBrace(self):        self.AppendLine(&#39;&#123;&#39;)        self.BeginBlank()    def EndBrace(self):        self.EndBlank()        self.AppendLine(&#39;&#125;&#39;)    def BeginRegion(self, regionName):        self.AppendLine(f&#39;#region &#123;regionName&#125;&#39;)        self.AppendEmptyLine()    def EndRegion(self):        self.AppendEmptyLine()        self.AppendLine(&#39;#endregion&#39;)        self.AppendEmptyLine()    def ToString(self):        return &#39;&#39;.join(self)    def GenerateScript(self, fileName, isDefPath=True):        fileName = fileName.replace(&#39;.cs&#39;, &#39;&#39;)        if isDefPath:            fileName = os.path.join(ScriptsPath, fileName)        with open(f&#39;&#123;fileName&#125;.cs&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:            f.write(self.ToString())</code></pre><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><pre><code>def CreateTableManagerCs():    script = CSScriptBuilder()    script.AppendUsing(&#39;System.Collections.Generic&#39;)    script.AppendUsing(&#39;UnityEngine&#39;)    script.BeginNamespace(TableLoadAssembly)    script.BeginInterface(&#39;ITable&#39;, &#39;public&#39;)    script.AppendInterfaceMethod(&#39;Dispose&#39;)    script.EndInterface()    script.AppendEmptyLine()    script.BeginClass(&#39;TableManager&#39;, &#39;public static&#39;)    script.AppendField(&#39;s_Inited&#39;, &#39;bool&#39;, &#39;private static&#39;)    script.AppendField(&#39;s_Cached&#39;, &#39;List&lt;ITable&gt;&#39;, &#39;private static&#39;, &#39;new List&lt;ITable&gt;()&#39;)    # 添加方法    script.AppendEmptyLine()    script.BeginMethod(&quot;Add&quot;, parameters=&quot;ITable table&quot;)    script.AppendLine(&quot;Debug.Assert(s_Inited, \&quot;add but TableManager not init \&quot;);&quot;)    script.AppendLine(&quot;s_Cached.Add(table);&quot;)    script.EndMethod()    script.AppendEmptyLine()    script.BeginMethod(&quot;Remove&quot;, parameters=&quot;ITable table&quot;)    script.AppendLine(&quot;Debug.Assert(s_Inited, \&quot;remove but TableManager not init\&quot;);&quot;)    script.AppendLine(&quot;if (s_Cached.Remove(table))&quot;)    script.BeginBrace()    script.AppendLine(&quot;table.Dispose();&quot;)    script.EndBrace()    script.EndMethod()    script.AppendEmptyLine()    script.BeginMethod(&quot;Init&quot;)    script.AppendLine(&quot;Debug.Assert(!s_Inited, \&quot;TableManager already init\&quot;);&quot;)    script.AppendLine(&quot;s_Inited = true;&quot;)    script.EndMethod()    script.AppendEmptyLine()    script.BeginMethod(&quot;UnInit&quot;)    script.AppendLine(&quot;Debug.Assert(s_Inited, \&quot;TableManager not init\&quot;);&quot;)    script.AppendLine(&quot;s_Inited = false;&quot;)    script.AppendLine(&quot;foreach (var table in s_Cached)&quot;)    script.BeginBrace()    script.AppendLine(&quot;table.Dispose();&quot;)    script.EndBrace()    script.AppendLine(&quot;s_Cached.Clear();&quot;)    script.EndMethod()    script.EndClass()    script.EndNamespace()    script.GenerateScript(os.path.join(ScriptsPath, &#39;TableManager&#39;))</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上是本文介绍的C#脚本生成辅助工具的代码示例。工具的核心是一个名为CSScriptBuilder的类，它继承自list，并提供了一系列用于生成C#脚本的方法。</p><p>通过使用这个工具，用户可以更加方便地生成C#脚本，提高开发效率。</p><p>希望本文对您理解这个工具的用途和使用方法有所帮助。如果您有任何问题或建议，欢迎留言讨论。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;本文介绍了一个用于辅助生成C#脚本的Python工具。该工具可以帮助用户快速生成C#脚本，并提供了一些常用的代码生成方法。  &lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="Python杂文" scheme="http://yoursite.com/categories/Python%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>个人作品展示</title>
    <link href="http://yoursite.com/2023/09/04/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E4%BD%9C%E5%93%81%E5%B1%95%E7%A4%BA/"/>
    <id>http://yoursite.com/2023/09/04/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E4%BD%9C%E5%93%81%E5%B1%95%E7%A4%BA/</id>
    <published>2023-09-04T02:35:34.000Z</published>
    <updated>2023-09-17T13:20:57.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity参与项目"><a href="#Unity参与项目" class="headerlink" title="Unity参与项目"></a>Unity参与项目</h1><h2 id="Game-Of-Honor"><a href="#Game-Of-Honor" class="headerlink" title="Game Of Honor"></a>Game Of Honor</h2><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1694956179652-2023-9-1721:09:40.png" alt="1694956179652-2023-9-1721:09:40.png">  </p><h1 id="Unity工具"><a href="#Unity工具" class="headerlink" title="Unity工具"></a>Unity工具</h1><h2 id="布NPC和怪物编辑器"><a href="#布NPC和怪物编辑器" class="headerlink" title="布NPC和怪物编辑器"></a>布NPC和怪物编辑器</h2><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/20230917_210529-2023-9-1721:06:52.gif" alt="20230917_210529-2023-9-1721:06:52.gif">  </p><h2 id="UI动画编辑器"><a href="#UI动画编辑器" class="headerlink" title="UI动画编辑器"></a>UI动画编辑器</h2><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/20230917_211925-2023-9-1721:20:32.gif" alt="20230917_211925-2023-9-1721:20:32.gif">  </p><h1 id="Python工具"><a href="#Python工具" class="headerlink" title="Python工具"></a>Python工具</h1><p><a href="https://github.com/LianBai/PyTools.git"><strong>仓库地址</strong></a>  </p><h2 id="C-工程配置导表工具"><a href="#C-工程配置导表工具" class="headerlink" title="C#工程配置导表工具"></a>C#工程配置导表工具</h2><p><a href="https://github.com/LianBai/PyTools.git"><strong>仓库地址</strong></a>的Excel2Bytes目录  </p><h2 id="项目工具"><a href="#项目工具" class="headerlink" title="项目工具"></a>项目工具</h2><details>    <summary> 点击展开 </summary> <h3 id="演示视频"><a href="#演示视频" class="headerlink" title="演示视频"></a>演示视频</h3><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/20230904_100721-2023-9-410:36:14.gif" alt="20230904_100721-2023-9-410:36:14.gif"></p><h3 id="工具截图"><a href="#工具截图" class="headerlink" title="工具截图"></a>工具截图</h3><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1693795113797-2023-9-410:38:34.png" alt="1693795113797-2023-9-410:38:34.png"><br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1693795142194-2023-9-410:39:03.png" alt="1693795142194-2023-9-410:39:03.png"><br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1693795157340-2023-9-410:39:18.png" alt="1693795157340-2023-9-410:39:18.png"><br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1693795175142-2023-9-410:39:35.png" alt="1693795175142-2023-9-410:39:35.png"><br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1693795225733-2023-9-410:40:26.png" alt="1693795225733-2023-9-410:40:26.png">  </p></details>  <h2 id="博客工具"><a href="#博客工具" class="headerlink" title="博客工具"></a>博客工具</h2><details>    <summary> 点击展开 </summary> <p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1693795268866-2023-9-410:41:09.png" alt="1693795268866-2023-9-410:41:09.png">  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1693795304153-2023-9-410:41:45.png" alt="1693795304153-2023-9-410:41:45.png">  </p></details> ]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Unity参与项目&quot;&gt;&lt;a href=&quot;#Unity参与项目&quot; class=&quot;headerlink&quot; title=&quot;Unity参与项目&quot;&gt;&lt;/a&gt;Unity参与项目&lt;/h1&gt;&lt;h2 id=&quot;Game-Of-Honor&quot;&gt;&lt;a href=&quot;#Game-Of-Hono</summary>
      
    
    
    
    <category term="个人笔记" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="个人笔记" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——Editor的Tree</title>
    <link href="http://yoursite.com/2023/09/02/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Editor%E7%9A%84Tree/"/>
    <id>http://yoursite.com/2023/09/02/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Editor%E7%9A%84Tree/</id>
    <published>2023-09-02T07:23:59.000Z</published>
    <updated>2023-09-02T07:53:12.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文介绍了一种用于编辑器开发过程中树形结构数据进行渲染的辅助脚本。</p><h1 id="TreeElementGUI"><a href="#TreeElementGUI" class="headerlink" title="TreeElementGUI"></a>TreeElementGUI</h1><p>TreeElementGUI是树形结构元素渲染的基类，包含了节点深度、父节点、子节点、节点名字、节点ID等属性，并且提供了无参构造函数和有参构造函数。 </p><details>    <summary> TreeElementGUI </summary>  <pre><code>/// &lt;summary&gt;/// 树结构的元素/// &lt;/summary&gt;public abstract class TreeElementGUI&#123;    private int m_ID;    private string m_Name;    private int m_Depth;    [NonSerialized] private TreeElementGUI m_Parent;    [NonSerialized] private List&lt;TreeElementGUI&gt; m_Children;    /// &lt;summary&gt;    /// 深度    /// &lt;/summary&gt;    public int Depth    &#123;        get =&gt; m_Depth;        set =&gt; m_Depth = value;    &#125;    /// &lt;summary&gt;    /// 父节点    /// &lt;/summary&gt;    public TreeElementGUI Parent    &#123;        get =&gt; m_Parent;        set =&gt; m_Parent = value;    &#125;    /// &lt;summary&gt;    /// 子节点    /// &lt;/summary&gt;    public List&lt;TreeElementGUI&gt; Children    &#123;        get =&gt; m_Children;        set =&gt; m_Children = value;    &#125;        /// &lt;summary&gt;    /// 是否有子节点    /// &lt;/summary&gt;    public bool HasChildren =&gt; m_Children != null &amp;&amp; m_Children.Count &gt; 0;    /// &lt;summary&gt;    /// 节点名字    /// &lt;/summary&gt;    public string Name    &#123;        get =&gt; m_Name;        set =&gt; m_Name = value;    &#125;    /// &lt;summary&gt;    /// 节点ID    /// &lt;/summary&gt;    public int Id    &#123;        get =&gt; m_ID;        set =&gt; m_ID = value;    &#125;    /// &lt;summary&gt;    /// 无参构造函数    /// &lt;/summary&gt;    protected TreeElementGUI() :this(-1, -1, &quot;&quot;)    &#123;            &#125;    /// &lt;summary&gt;    /// 有参构造函数    /// &lt;/summary&gt;    /// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;depth&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt;    protected TreeElementGUI(int id, int depth, string name)    &#123;        m_Name = name;        m_ID = id;        m_Depth = depth;    &#125;    public abstract void OnGUI(Rect rect, int columnIndex);    public abstract bool IsMatchSearch(string search);&#125;</code></pre></details><h1 id="TreeViewItemGUI"><a href="#TreeViewItemGUI" class="headerlink" title="TreeViewItemGUI"></a>TreeViewItemGUI<T></T></h1><p>TreeViewItemGUI<T>是节点元素显示的类，继承自TreeViewItem，并且包含了一个泛型参数T，其中T必须是TreeElementGUI的子类。TreeViewItemGUI<T>包含了一个Data属性，用于获取节点元素的数据，同时提供了OnGUI和IsMatchSearch方法，用于在UI上绘制节点元素和进行搜索匹配。  </T></T></p><details>    <summary> TreeViewItemGUI<T> </T></summary>   <pre><code>/// &lt;summary&gt;/// 树结构编辑器显示/// &lt;/summary&gt;/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;public class TreeViewItemGUI&lt;T&gt; : TreeViewItem where T : TreeElementGUI&#123;    private readonly T m_Data;    public T Data =&gt; m_Data;    public TreeViewItemGUI(int id, int depth, string displayName, T data) : base(id, depth, displayName)    &#123;        m_Data = data;    &#125;    public void OnGUI(Rect rect, int columnIndex)    &#123;        m_Data.OnGUI(rect, columnIndex);    &#125;    public bool IsMatchSearch(string search)    &#123;        return m_Data.IsMatchSearch(search);    &#125;&#125;</code></pre></details><h1 id="TreeGUIUtility"><a href="#TreeGUIUtility" class="headerlink" title="TreeGUIUtility"></a>TreeGUIUtility</h1><p>TreeGUIUtility是一个用于编辑器开发过程中树形结构数据进行渲染的辅助脚本。该脚本包含了一些常用的方法，可以帮助开发者处理树形结构数据。  </p><p>其中，TreeToList<T>方法可以将树形结构数据转换为列表形式，Find<T>方法可以在树形结构数据中查找符合条件的节点元素，ListToTree<T>方法可以将列表形式的数据转换为树形结构数据，ValidateDepthValues<T>方法可以检查列表中的深度值是否合法，UpdateDepthValues<T>方法可以更新树形结构数据中的深度值，FindCommonAncestorsWithinList<T>方法可以查找列表中共同的祖先节点。   </T></T></T></T></T></T></p><details>    <summary> TreeGUIUtility<T> </T></summary>  <pre><code>public static class TreeGUIUtility&#123;    public static void TreeToList&lt;T&gt;(T root, IList&lt;T&gt; result) where T : TreeElementGUI    &#123;        if (result == null)            throw new NullReferenceException(&quot;The input &#39;IList&lt;T&gt; result&#39; list is null&quot;);        result.Clear();        var stack = new Stack&lt;T&gt;();        stack.Push(root);        while (stack.Count &gt; 0)        &#123;            var current = stack.Pop();            result.Add(current);            if (current.Children != null &amp;&amp; current.Children.Count &gt; 0)            &#123;                for (var i = current.Children.Count - 1; i &gt;= 0; i--)                &#123;                    stack.Push((T)current.Children[i]);                &#125;            &#125;        &#125;    &#125;        public static T Find&lt;T&gt;(T root, Func&lt;T, bool&gt; comparer) where T : TreeElementGUI    &#123;        var stack = new Stack&lt;T&gt;();        stack.Push(root);        while (stack.Count &gt; 0)        &#123;            var current = stack.Pop();            if(root != current &amp;&amp; comparer(current))            &#123;                return current;            &#125;            if (current.Children != null &amp;&amp; current.Children.Count &gt; 0)            &#123;                for (var i = current.Children.Count - 1; i &gt;= 0; i--)                &#123;                    stack.Push((T)current.Children[i]);                &#125;            &#125;        &#125;        return null;    &#125;    /// &lt;summary&gt;    /// List转成树结构    /// &lt;/summary&gt;    /// &lt;param name=&quot;list&quot;&gt;&lt;/param&gt;    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static T ListToTree&lt;T&gt;(IList&lt;T&gt; list) where T : TreeElementGUI    &#123;        // 验证深度的值        ValidateDepthValues(list);        // 清理状态        foreach (var element in list)        &#123;            element.Parent = null;            element.Children = null;        &#125;        // 设置子节点和父节点        for (var parentIndex = 0; parentIndex &lt; list.Count; parentIndex++)        &#123;            var parent = list[parentIndex];            var alreadyHasValidChildren = parent.Children != null;            if (alreadyHasValidChildren)                continue;            var parentDepth = parent.Depth;            var childCount = 0;            // Count children based depth value, we are looking at children until it&#39;s the same depth as this object            for (var i = parentIndex + 1; i &lt; list.Count; i++)            &#123;                if (list[i].Depth == parentDepth + 1)                    childCount++;                if (list[i].Depth &lt;= parentDepth)                    break;            &#125;            // Fill child array            List&lt;TreeElementGUI&gt; childList = null;            if (childCount != 0)            &#123;                childList = new List&lt;TreeElementGUI&gt;(childCount); // Allocate once                childCount = 0;                for (var i = parentIndex + 1; i &lt; list.Count; i++)                &#123;                    if (list[i].Depth == parentDepth + 1)                    &#123;                        list[i].Parent = parent;                        childList.Add(list[i]);                        childCount++;                    &#125;                    if (list[i].Depth &lt;= parentDepth)                        break;                &#125;            &#125;            parent.Children = childList;        &#125;        return list[0];    &#125;    /// &lt;summary&gt;    /// 检查List的深度值    /// &lt;/summary&gt;    /// &lt;param name=&quot;list&quot;&gt;&lt;/param&gt;    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;    /// &lt;exception cref=&quot;ArgumentException&quot;&gt;&lt;/exception&gt;    public static void ValidateDepthValues&lt;T&gt;(IList&lt;T&gt; list) where T : TreeElementGUI    &#123;        if (list.Count == 0)            throw new ArgumentException(&quot;list should have items, count is 0, check before calling ValidateDepthValues&quot;, nameof(list));        if (list[0].Depth != -1)            throw new ArgumentException(&quot;list item at index 0 should have a depth of -1 (since this should be the hidden root of the tree). Depth is: &quot; + list[0].Depth, nameof(list));        for (var i = 0; i &lt; list.Count - 1; i++)        &#123;            var depth = list[i].Depth;            var nextDepth = list[i + 1].Depth;            if (nextDepth &gt; depth &amp;&amp; nextDepth - depth &gt; 1)                throw new ArgumentException(string.Format(&quot;Invalid depth info in input list. Depth cannot increase more than 1 per row. Index &#123;0&#125; has depth &#123;1&#125; while index &#123;2&#125; has depth &#123;3&#125;&quot;, i, depth, i + 1, nextDepth));        &#125;        for (var i = 1; i &lt; list.Count; ++i)            if (list[i].Depth &lt; 0)                throw new ArgumentException(&quot;Invalid depth value for item at index &quot; + i + &quot;. Only the first item (the root) should have depth below 0.&quot;);        if (list.Count &gt; 1 &amp;&amp; list[1].Depth != 0)            throw new ArgumentException(&quot;Input list item at index 1 is assumed to have a depth of 0&quot;, nameof(list));    &#125;    /// &lt;summary&gt;    /// 更新深度值    /// &lt;/summary&gt;    /// &lt;param name=&quot;root&quot;&gt;&lt;/param&gt;    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;    /// &lt;exception cref=&quot;ArgumentNullException&quot;&gt;&lt;/exception&gt;    public static void UpdateDepthValues&lt;T&gt;(T root) where T : TreeElementGUI    &#123;        if (root == null)            throw new ArgumentNullException(nameof(root), &quot;The root is null&quot;);        if (!root.HasChildren)            return;        var stack = new Stack&lt;TreeElementGUI&gt;();        stack.Push(root);        while (stack.Count &gt; 0)        &#123;            var current = stack.Pop();            if (current.Children != null)            &#123;                foreach (var child in current.Children)                &#123;                    child.Depth = current.Depth + 1;                    stack.Push(child);                &#125;            &#125;        &#125;    &#125;    /// &lt;summary&gt;    /// 判断是否是子节点    /// &lt;/summary&gt;    /// &lt;param name=&quot;child&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;elements&quot;&gt;&lt;/param&gt;    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;    /// &lt;returns&gt;&lt;/returns&gt;    static bool IsChildOf&lt;T&gt;(T child, IList&lt;T&gt; elements) where T : TreeElementGUI    &#123;        while (child != null)        &#123;            child = (T)child.Parent;            if (elements.Contains(child))                return true;        &#125;        return false;    &#125;    /// &lt;summary&gt;    /// 查找共同的祖先节点    /// &lt;/summary&gt;    /// &lt;param name=&quot;elements&quot;&gt;&lt;/param&gt;    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static IList&lt;T&gt; FindCommonAncestorsWithinList&lt;T&gt;(IList&lt;T&gt; elements) where T : TreeElementGUI    &#123;        if (elements.Count == 1)            return new List&lt;T&gt;(elements);        var result = new List&lt;T&gt;(elements);        result.RemoveAll(g =&gt; IsChildOf(g, elements));        return result;    &#125;&#125;</code></pre></details><h1 id="TreeGUIModel"><a href="#TreeGUIModel" class="headerlink" title="TreeGUIModel"></a>TreeGUIModel<T></T></h1><p>TreeGUIModel<T>是一个用于管理树形结构数据的类，包含了增加、移除、移动、清空、更新等方法，可以帮助开发者更方便地处理树形结构数据。  </T></p><details>    <summary> TreeGUIModel<T> </T></summary>  <pre><code>public class TreeGUIModel&lt;T&gt; where T : TreeElementGUI, new()&#123;    private T m_Root;    private int m_MaxID;    private bool m_IsDirty;    public T Root =&gt; m_Root;    public event Action&lt;T&gt; added;    public event Action&lt;T&gt; removed;    public int Count =&gt; m_Root.Children.Count;    public bool IsDirty =&gt; m_IsDirty;    public TreeGUIModel()    &#123;        m_Root = new T        &#123;            Id = GenerateUniqueID(), Depth = -1, Name = $&quot;&#123;typeof(T).Name&#125; - Root&quot;,            Children = new List&lt;TreeElementGUI&gt;()        &#125;;        m_IsDirty = true;    &#125;    /// &lt;summary&gt;    /// 根据id查找元素    /// &lt;/summary&gt;    /// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public T Find(int id)    &#123;        return (T)m_Root.Children.FirstOrDefault(element =&gt; element.Id == id);    &#125;    /// &lt;summary&gt;    /// 自动生成唯一ID    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public int GenerateUniqueID()    &#123;        return ++m_MaxID;    &#125;    /// &lt;summary&gt;    /// 获得所有的子节点    /// &lt;/summary&gt;    /// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public IList&lt;int&gt; GetAncestors(int id)    &#123;        var parents = new List&lt;int&gt;();        var item = Find(id);        if (item != null)        &#123;            while (item.Parent != null)            &#123;                parents.Add(item.Parent.Id);                item = (T)item.Parent;            &#125;        &#125;        return parents;    &#125;    /// &lt;summary&gt;    /// 获得有子节点的所有子节点    /// &lt;/summary&gt;    /// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public IList&lt;int&gt; GetDescendantsThatHaveChildren(int id)    &#123;        var searchFromThis = Find(id);        return searchFromThis != null ? GetParentsBelowStackBased(searchFromThis) : new List&lt;int&gt;();    &#125;    /// &lt;summary&gt;    /// 获得基于栈的所有子节点    /// &lt;/summary&gt;    /// &lt;param name=&quot;searchFromThis&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    private IList&lt;int&gt; GetParentsBelowStackBased(TreeElementGUI searchFromThis)    &#123;        var stack = new Stack&lt;TreeElementGUI&gt;();        stack.Push(searchFromThis);        var parentsBelow = new List&lt;int&gt;();        while (stack.Count &gt; 0)        &#123;            var current = stack.Pop();            if (current.HasChildren)            &#123;                parentsBelow.Add(current.Id);                foreach (var T in current.Children)                &#123;                    stack.Push(T);                &#125;            &#125;        &#125;        return parentsBelow;    &#125;    /// &lt;summary&gt;    /// 移除元素    /// &lt;/summary&gt;    /// &lt;param name=&quot;elementID&quot;&gt;&lt;/param&gt;    public void RemoveElements(int elementID)    &#123;        var elements = m_Root.Children.Where(element =&gt; element.Id == elementID).Cast&lt;T&gt;().ToArray();        RemoveElements(elements);    &#125;    /// &lt;summary&gt;    /// 移除元素    /// &lt;/summary&gt;    /// &lt;param name=&quot;elementIDs&quot;&gt;&lt;/param&gt;    public void RemoveElements(IList&lt;int&gt; elementIDs)    &#123;        var elements = m_Root.Children.Where(element =&gt; elementIDs.Contains(element.Id)).Cast&lt;T&gt;().ToArray();        RemoveElements(elements);    &#125;    /// &lt;summary&gt;    /// 移除元素    /// &lt;/summary&gt;    /// &lt;param name=&quot;elements&quot;&gt;&lt;/param&gt;    public void RemoveElements(IList&lt;T&gt; elements)    &#123;        var commonAncestors = TreeGUIUtility.FindCommonAncestorsWithinList(elements);        foreach (var element in commonAncestors)        &#123;            element.Parent.Children.Remove(element);            element.Parent = null;            removed?.Invoke(element);        &#125;        SetDirty();    &#125;    /// &lt;summary&gt;    /// 增加元素    /// &lt;/summary&gt;    /// &lt;param name=&quot;elements&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;parent&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;insertPosition&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;isNew&quot;&gt;&lt;/param&gt;    /// &lt;exception cref=&quot;ArgumentNullException&quot;&gt;&lt;/exception&gt;    public void AddElements(IList&lt;T&gt; elements, TreeElementGUI parent, int insertPosition, bool isNew = false)    &#123;        if (elements == null)            throw new ArgumentNullException(nameof(elements), &quot;elements is null&quot;);        if (elements.Count == 0)            throw new ArgumentNullException(nameof(elements), &quot;elements Count is 0: nothing to add&quot;);        if (parent == null)            throw new ArgumentNullException(nameof(parent), &quot;parent is null&quot;);        parent.Children ??= new List&lt;TreeElementGUI&gt;();        parent.Children.InsertRange(insertPosition, elements);        foreach (var element in elements)        &#123;            element.Parent = parent;            element.Depth = parent.Depth + 1;            TreeGUIUtility.UpdateDepthValues(element);            if(isNew)            &#123;                added?.Invoke(element);            &#125;        &#125;        SetDirty();    &#125;    /// &lt;summary&gt;    /// 增加元素    /// &lt;/summary&gt;    /// &lt;param name=&quot;root&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;isNew&quot;&gt;&lt;/param&gt;    public void AddElement(T root, bool isNew = false)    &#123;        root.Id = GenerateUniqueID();        root.Depth = -1;        root.Parent = m_Root;        m_Root.Children.Add(root);        if(isNew)        &#123;            added?.Invoke(root);        &#125;        SetDirty();    &#125;    /// &lt;summary&gt;    /// 增加元素    /// &lt;/summary&gt;    /// &lt;param name=&quot;element&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;parent&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;insertPosition&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;isNew&quot;&gt;&lt;/param&gt;    public void AddElement(T element, T parent, int insertPosition, bool isNew = false)    &#123;        parent.Children ??= new List&lt;TreeElementGUI&gt;();        parent.Children.Insert(insertPosition, element);        element.Parent = parent;        TreeGUIUtility.UpdateDepthValues(parent);        if (isNew)        &#123;            added?.Invoke(element);        &#125;        SetDirty();    &#125;    /// &lt;summary&gt;    /// 移动元素    /// &lt;/summary&gt;    /// &lt;param name=&quot;parentElement&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;insertionIndex&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;elements&quot;&gt;&lt;/param&gt;    /// &lt;exception cref=&quot;ArgumentException&quot;&gt;&lt;/exception&gt;    public void MoveElements(TreeElementGUI parentElement, int insertionIndex, List&lt;TreeElementGUI&gt; elements)    &#123;        if (insertionIndex &lt; 0)            throw new ArgumentException(&quot;Invalid input: insertionIndex is -1, client needs to decide what index elements should be reparented at&quot;);        // Invalid reparenting input        if (parentElement == null)            return;        // We are moving items so we adjust the insertion index to accomodate that any items above the insertion index is removed before inserting        if (insertionIndex &gt; 0)            insertionIndex -= parentElement.Children.GetRange(0, insertionIndex).Count(elements.Contains);        // Remove draggedItems from their parents        foreach (var draggedItem in elements)        &#123;            draggedItem.Parent.Children.Remove(draggedItem);    // remove from old parent            draggedItem.Parent = parentElement;                 // set new parent        &#125;        parentElement.Children ??= new List&lt;TreeElementGUI&gt;();        // Insert dragged items under new parent        parentElement.Children.InsertRange(insertionIndex, elements);        TreeGUIUtility.UpdateDepthValues(Root);        SetDirty();    &#125;    /// &lt;summary&gt;    /// 标记为脏    /// &lt;/summary&gt;    private void SetDirty()    &#123;        m_IsDirty = true;    &#125;    /// &lt;summary&gt;    /// 清理    /// &lt;/summary&gt;    public void Clear()    &#123;        m_Root.Children.Clear();        SetDirty();    &#125;    /// &lt;summary&gt;    /// 更新    /// &lt;/summary&gt;    internal void Update()    &#123;        m_IsDirty = true;    &#125;&#125;</code></pre></details><h1 id="TreeViewWithGUIModel"><a href="#TreeViewWithGUIModel" class="headerlink" title="TreeViewWithGUIModel"></a>TreeViewWithGUIModel<T></T></h1><p>TreeViewWithGUIModel<T>是一个抽象类，继承自TreeView，用于在编辑器中渲染树形结构数据。该类包含了一些常用的方法，可以帮助开发者处理树形结构数据。  </T></p><p>该类还包含了一些属性，用于控制树形结构数据的外观和行高等。  </p><p>TreeViewWithGUIModel<T>类的子类可以通过实现抽象方法来自定义树形结构数据的渲染和行为。  </T></p><details>    <summary> TreeViewWithGUIModel<T> </T></summary>  <pre><code>public abstract class TreeViewWithGUIModel&lt;T&gt; : TreeView where  T : TreeElementGUI, new()&#123;    protected TreeGUIModel&lt;T&gt; m_TreeModel;    private readonly List&lt;TreeViewItem&gt; m_Rows = new List&lt;TreeViewItem&gt;(100);    public bool ShowAlternatingRowBackgrounds    &#123;        get =&gt; showAlternatingRowBackgrounds;        set =&gt; showAlternatingRowBackgrounds = value;    &#125;    public bool ShowBorder    &#123;        get =&gt; showBorder;        set =&gt; showBorder = value;    &#125;    public float RowHeight    &#123;        get =&gt; rowHeight;        set =&gt; rowHeight = value;    &#125;    protected TreeViewWithGUIModel(TreeViewState state, TreeGUIModel&lt;T&gt; model) : base(state)    &#123;        Init(model);    &#125;    protected TreeViewWithGUIModel(TreeViewState state, MultiColumnHeader multiColumnHeader, TreeGUIModel&lt;T&gt; model) : base(state, multiColumnHeader)    &#123;        Init(model);        multiColumnHeader.sortingChanged += OnSortingChanged;    &#125;    private void Init(TreeGUIModel&lt;T&gt; model)    &#123;        m_TreeModel = model;    &#125;    private void OnSortingChanged(MultiColumnHeader _multiColumnHeader)    &#123;        SortIfNeeded(rootItem, m_Rows);    &#125;    private void SortIfNeeded(TreeViewItem root, List&lt;TreeViewItem&gt; rows)    &#123;        if( null == multiColumnHeader) return;        if ( rows.Count &lt;= 1)            return;        if (multiColumnHeader.sortedColumnIndex == -1)        &#123;            return; // No column to sort for (just use the order the data are in)        &#125;        // Sort the roots of the existing tree items        rootItem.children = SortByMultipleColumns(rows);        TreeToList(root, rows);        Repaint();    &#125;    public static void TreeToList(TreeViewItem root, IList&lt;TreeViewItem&gt; result)    &#123;        if (root == null)            throw new NullReferenceException(&quot;root&quot;);        if (result == null)            throw new NullReferenceException(&quot;result&quot;);        result.Clear();        if (root.children == null)            return;        var stack = new Stack&lt;TreeViewItem&gt;();        for (var i = root.children.Count - 1; i &gt;= 0; i--)            stack.Push(root.children[i]);        while (stack.Count &gt; 0)        &#123;            var current = stack.Pop();            result.Add(current);            if (current.hasChildren &amp;&amp; current.children[0] != null)            &#123;                for (var i = current.children.Count - 1; i &gt;= 0; i--)                &#123;                    stack.Push(current.children[i]);                &#125;            &#125;        &#125;    &#125;    protected override TreeViewItem BuildRoot()    &#123;        return null == m_TreeModel.Root            ? new TreeViewItemGUI&lt;T&gt;(0, -1, &quot;Root&quot;, null)            : new TreeViewItemGUI&lt;T&gt;(m_TreeModel.Root.Id, -1, m_TreeModel.Root.Name, m_TreeModel.Root);    &#125;    protected override bool DoesItemMatchSearch(TreeViewItem item, string search)    &#123;        var target = (TreeViewItemGUI&lt;T&gt;)item;        return target.IsMatchSearch(search);    &#125;    protected override void RowGUI(RowGUIArgs args)    &#123;        var item = (TreeViewItemGUI&lt;T&gt;) args.item;        if (null == multiColumnHeader)        &#123;            item.OnGUI(args.rowRect, 0);        &#125;        else        &#123;            var columns = args.GetNumVisibleColumns();            for (var i = 0; i &lt; columns; i++)            &#123;                var rt = args.GetCellRect(i);                CenterRectUsingSingleLineHeight(ref rt);                item.OnGUI(rt, args.GetColumn(i));            &#125;        &#125;    &#125;    protected override IList&lt;TreeViewItem&gt; BuildRows(TreeViewItem root)    &#123;        m_Rows.Clear();        if (m_TreeModel.Root == null)        &#123;            return m_Rows;        &#125;        if (hasSearch)        &#123;            Search(m_TreeModel.Root, searchString, m_Rows);        &#125;        else if (m_TreeModel.Root.HasChildren)        &#123;            AddChildrenRecursive(root, m_TreeModel.Root, 0, m_Rows);        &#125;        SortIfNeeded(root, m_Rows);        return m_Rows;    &#125;    private void AddChildrenRecursive(TreeViewItem root, T parent, int depth, IList&lt;TreeViewItem&gt; newRows)    &#123;        foreach (var treeElement in parent.Children)        &#123;            var child = (T) treeElement;            var item = new TreeViewItemGUI&lt;T&gt;(child.Id, depth, child.Name, child);            newRows.Add(item);            root.AddChild(item);            if (child.HasChildren)            &#123;                if (IsExpanded(child.Id))                &#123;                    AddChildrenRecursive(item, child, depth + 1, newRows);                &#125;                else                &#123;                    item.children = CreateChildListForCollapsedParent();                &#125;            &#125;        &#125;    &#125;    private void Search(T searchFromThis, string search, List&lt;TreeViewItem&gt; result)    &#123;        if (string.IsNullOrEmpty(search))            throw new ArgumentException(&quot;Invalid search: cannot be null or empty&quot;, nameof(search));        var stack = new Stack&lt;T&gt;();        foreach (var element in searchFromThis.Children)            stack.Push((T)element);        while (stack.Count &gt; 0)        &#123;            var current = stack.Pop();            // Matches search?            if (current.IsMatchSearch(search))            &#123;                result.Add(new TreeViewItemGUI&lt;T&gt;(current.Id, 0, current.Name, current));            &#125;            if (current.Children != null &amp;&amp; current.Children.Count &gt; 0)            &#123;                foreach (var element in current.Children)                &#123;                    stack.Push((T)element);                &#125;            &#125;        &#125;        SortSearchResult(result);    &#125;    public override IList&lt;TreeViewItem&gt; GetRows()    &#123;        return m_Rows;    &#125;    protected virtual void SortSearchResult(List&lt;TreeViewItem&gt; rows)    &#123;        // sort by displayName by default, can be overriden for multColumn solutions        rows.Sort((x, y) =&gt; EditorUtility.NaturalCompare(x.displayName, y.displayName));    &#125;    protected virtual List&lt;TreeViewItem&gt; SortByMultipleColumns(List&lt;TreeViewItem&gt; children)    &#123;        return children;    &#125;    public Rect DoLayout(params GUILayoutOption[] options)    &#123;        if(m_TreeModel.IsDirty)        &#123;            m_TreeModel.Update();            Reload();        &#125;        GUILayout.BeginVertical();        var rect = GUILayoutUtility.GetRect(GUIContent.none,                                           GUIStyle.none,                                           options);        OnGUI(rect);        GUILayout.EndVertical();        return rect;    &#125;&#125;</code></pre></details>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;本文介绍了一种用于编辑器开发过程中树形结构数据进行渲染的辅助脚本。&lt;/p&gt;
&lt;h1 id=&quot;TreeElementGUI&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Unity编辑器" scheme="http://yoursite.com/tags/Unity%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——FPS计算并显示</title>
    <link href="http://yoursite.com/2023/08/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94FPS%E8%AE%A1%E7%AE%97%E5%B9%B6%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2023/08/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94FPS%E8%AE%A1%E7%AE%97%E5%B9%B6%E6%98%BE%E7%A4%BA/</id>
    <published>2023-08-30T08:48:17.000Z</published>
    <updated>2023-08-30T08:54:48.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自制游戏FPS显示工具"><a href="#自制游戏FPS显示工具" class="headerlink" title="自制游戏FPS显示工具"></a>自制游戏FPS显示工具</h1><p>在游戏开发中，FPS（Frames Per Second）是一个非常重要的指标，它可以反映出游戏的流畅度和性能。为了帮助开发者更好地优化游戏性能，我们可以使用一个自制的游戏FPS显示工具，实时显示当前的帧率。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>以下是自制的游戏FPS显示工具的代码实现：  </p><pre><code>public class FPSUtils : MonoBehaviour&#123;    #region 实例化        private static FPSUtils s_FPS = null;    /// &lt;summary&gt;    /// 实例化一个FPS单位    /// &lt;/summary&gt;    /// &lt;param name=&quot;parent&quot;&gt;&lt;/param&gt;    public static void CreateInstance(GameObject parent = null)    &#123;        if (s_FPS != null) return;        var go = new GameObject(&quot;FPS&quot;);        s_FPS = go.AddComponent&lt;FPSUtils&gt;();        if (null == parent)        &#123;            DontDestroyOnLoad(go);        &#125;        else        &#123;            go.SetParent(parent);            go.SetAsFirstSibling();        &#125;    &#125;    /// &lt;summary&gt;    /// 销毁一个FPS单位    /// &lt;/summary&gt;    public static void DestroyInstance()    &#123;        if (null != s_FPS)        &#123;            Destroy(s_FPS.gameObject);            s_FPS = null;        &#125;    &#125;    #endregion    #region FPS统计    /// &lt;summary&gt;    /// 是否显示FPS    /// &lt;/summary&gt;    private bool m_IsShowFPS = true;    /// &lt;summary&gt;    /// 帧数计算刷新时间（s）    /// &lt;/summary&gt;    private const float m_ShowTime = 1f;    /// &lt;summary&gt;    /// 当前时间    /// &lt;/summary&gt;    private float m_CurTime = 0f;    /// &lt;summary&gt;    /// 当前帧数    /// &lt;/summary&gt;    private static int m_Frames = 0;    /// &lt;summary&gt;    /// 临时FPS    /// &lt;/summary&gt;    private int m_TempFPS = 0;    /// &lt;summary&gt;    /// 帧数变化比较容忍度    /// &lt;/summary&gt;    private const int TOLERANCE = 5;    /// &lt;summary&gt;    /// 当前FPS    /// &lt;/summary&gt;    private int m_CurFPS;    /// &lt;summary&gt;    /// 当前显示的帧数    /// &lt;/summary&gt;    private int m_CurShowFPS;    /// &lt;summary&gt;    /// 品质当前时间    /// &lt;/summary&gt;    private float m_QualityCurTime = 0f;    /// &lt;summary&gt;    /// 品质的容忍度    /// &lt;/summary&gt;    private const int m_TotalTime = 10;    /// &lt;summary&gt;    /// 帧数容忍度    /// &lt;/summary&gt;    private const int m_MaxFrameCount = 200;    /// &lt;summary&gt;    /// 最小FPS容忍度    /// &lt;/summary&gt;    private const int m_MinFPS = 10;        /// &lt;summary&gt;    /// 当前最小帧数    /// &lt;/summary&gt;    private int m_CurMinFrmCount = 0;    private void Update()    &#123;        m_CurTime += Time.unscaledDeltaTime;        m_Frames++;        m_CurFPS = (int)(1.0f / Time.unscaledDeltaTime);        if (m_CurTime &gt;= m_ShowTime)        &#123;            m_CurShowFPS = (int)(m_Frames / m_CurTime);            if (Math.Abs(m_CurShowFPS - m_TempFPS) &gt; TOLERANCE)            &#123;                m_TempFPS = m_CurShowFPS;            &#125;            m_CurTime = 0;            m_Frames = 0;        &#125;    &#125;    private void FixedUpdate()    &#123;        m_QualityCurTime += Time.unscaledDeltaTime;        if (m_QualityCurTime &gt;= m_TotalTime)        &#123;            m_CurMinFrmCount = 0;            m_QualityCurTime = 0;        &#125;        if (m_CurFPS &gt;= m_MinFPS) return;        m_CurMinFrmCount++;        if (m_CurMinFrmCount &gt; m_MaxFrameCount)        &#123;            //检测到帧率过低，可以做切换品质的功能        &#125;    &#125;    /// &lt;summary&gt;    /// 绘制FPS    /// &lt;/summary&gt;    private void OnGUI()    &#123;        if (m_IsShowFPS)        &#123;            var fpsStr = $&quot;FPS:&#123;m_CurShowFPS&#125;&quot;;            GUI.Label(new Rect(0, 0, 100, 20), fpsStr);        &#125;    &#125;    #endregion&#125;</code></pre><h1 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h1><p>以上代码中，FPSUtils类继承自MonoBehaviour，用于实现FPS统计和显示。  </p><p>首先，定义了一个静态的CreateInstance方法，用于创建一个FPSUtils实例。在该方法中，首先判断是否已经存在一个FPSUtils实例，如果存在则直接返回。如果不存在，则创建一个新的GameObject对象，并将FPSUtils组件添加到该对象上。如果指定了parent参数，则将新创建的对象设置为该parent对象的第一个子对象，否则将其设置为不会被销毁的对象。  </p><p>然后，定义了一个静态的DestroyInstance方法，用于销毁FPSUtils实例。在该方法中，首先判断是否存在FPSUtils实例，如果存在则销毁该实例，并将其设置为null。  </p><p>接下来，定义了一些用于FPS统计的变量，包括是否显示FPS、帧数计算刷新时间、当前时间、当前帧数、临时FPS、帧数变化比较容忍度、当前FPS、当前显示的帧数、品质当前时间、品质的容忍度、帧数容忍度、最小FPS容忍度、当前最小帧数等。  </p><p>然后，在Update方法中，每帧更新当前时间、帧数和当前FPS。如果当前时间超过了帧数计算刷新时间，则计算当前显示的帧数，并将临时FPS设置为当前显示的帧数。在计算当前显示的帧数时，如果当前显示的帧数与临时FPS的差值超过了帧数变化比较容忍度，则将临时FPS设置为当前显示的帧数，并将当前时间和帧数重置为0。  </p><p>在FixedUpdate方法中，每帧更新品质当前时间和当前最小帧数。如果当前FPS大于等于最小FPS，则直接返回。如果当前FPS小于最小FPS，则将当前最小帧数加1。如果当前最小帧数超过了帧数容忍度，则可以做一些切换品质的功能。  </p><p>最后，在OnGUI方法中，如果需要显示FPS，则绘制当前显示的帧数。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自制游戏FPS显示工具&quot;&gt;&lt;a href=&quot;#自制游戏FPS显示工具&quot; class=&quot;headerlink&quot; title=&quot;自制游戏FPS显示工具&quot;&gt;&lt;/a&gt;自制游戏FPS显示工具&lt;/h1&gt;&lt;p&gt;在游戏开发中，FPS（Frames Per Second）是一个非常</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Unity" scheme="http://yoursite.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Python杂文——Label文字自适应大小</title>
    <link href="http://yoursite.com/2023/08/19/Python%E6%9D%82%E6%96%87/Python%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Label%E6%96%87%E5%AD%97%E8%87%AA%E9%80%82%E5%BA%94%E5%A4%A7%E5%B0%8F/"/>
    <id>http://yoursite.com/2023/08/19/Python%E6%9D%82%E6%96%87/Python%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Label%E6%96%87%E5%AD%97%E8%87%AA%E9%80%82%E5%BA%94%E5%A4%A7%E5%B0%8F/</id>
    <published>2023-08-19T03:50:43.000Z</published>
    <updated>2023-08-19T05:13:37.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PyQt5中Label自适应大小的实现"><a href="#PyQt5中Label自适应大小的实现" class="headerlink" title="PyQt5中Label自适应大小的实现"></a>PyQt5中Label自适应大小的实现</h1><p>在PyQt5中，我们经常需要在widget中添加label来显示文本信息。但是，由于文本长度和label大小的不确定性，有时候会出现文本显示不全或者字体过小难以阅读的问题。本文将介绍如何使用Python编写脚本来实现label的自适应大小。  </p><h1 id="单行文本的自适应"><a href="#单行文本的自适应" class="headerlink" title="单行文本的自适应"></a>单行文本的自适应</h1><p>对于单行文本，我们可以使用以下脚本来实现自适应大小：  </p><pre><code>def AutoSingleLabelFontSize(label):    # 创建一个QFont对象    font = label.font()    # 计算字体大小的范围    fm = QFontMetrics(font)    min_size = 1    max_size = 20    # 二分查找适应的字体大小    low, high = min_size, max_size    while low &lt;= high:        mid = (low + high) // 2        font.setPointSize(mid)        fm = QFontMetrics(font)        rect = fm.boundingRect(label.text())        if rect.width() &lt;= label.width():            low = mid + 1        else:            high = mid - 1    # 设置QLabel的字体    font.setPointSize(high)    label.setFont(font)</code></pre><p>这个脚本使用二分查找来适应字体大小。我们可以通过调整min_size和max_size参数来控制字体大小的范围。  </p><h1 id="多行文本自适应"><a href="#多行文本自适应" class="headerlink" title="多行文本自适应"></a>多行文本自适应</h1><p>对于多行文本，我们可以使用以下脚本来实现自适应大小：  </p><pre><code>def AutoMultipleLabelFontSize(label):    # 创建一个QFont对象    font = label.font()    # 计算字体大小的范围    fm = QFontMetrics(font)    min_size = 1    max_size = 20    # 二分查找适应的字体大小    low, high = min_size, max_size    while low &lt;= high:        mid = (low + high) // 2        font.setPointSize(mid)        fm = QFontMetrics(font)        rect = fm.boundingRect(label.rect(), Qt.TextWordWrap, label.text())        if rect.width() &lt;= label.width() and rect.height() &lt;= label.height():            low = mid + 1        else:            high = mid - 1    # 设置QLabel的字体    font.setPointSize(high)    label.setFont(font)</code></pre><p>这个脚本与单行文本的脚本类似，但是我们可以通过word_wrap参数来控制文本是否自动换行。</p><p>以上就是使用Python编写的label自适应大小的脚本。希望这篇文章能够帮助您解决label大小自适应的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PyQt5中Label自适应大小的实现&quot;&gt;&lt;a href=&quot;#PyQt5中Label自适应大小的实现&quot; class=&quot;headerlink&quot; title=&quot;PyQt5中Label自适应大小的实现&quot;&gt;&lt;/a&gt;PyQt5中Label自适应大小的实现&lt;/h1&gt;&lt;p&gt;在P</summary>
      
    
    
    
    <category term="Python杂文" scheme="http://yoursite.com/categories/Python%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>解决无法显示图床图片问题</title>
    <link href="http://yoursite.com/2023/08/06/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%BA%8A%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2023/08/06/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%BA%8A%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/</id>
    <published>2023-08-06T08:55:00.000Z</published>
    <updated>2023-08-06T09:34:35.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Hexo 博客中使用的图床无法访问，经查询是图床拦截问题，需要修改 referrer 信息。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li><p>找到博客文件中的 head.ejs 或 header.ejs，路径一般在 {博客路径}\themes\3-hexo\layout_partial\ 下。</p></li><li><p>在 <head> 标签中添加以下代码：</head></p> <meta name="referrer" content="no-referrer"></li></ol><p>这将禁用 referrer 信息，从而绕过图床的防盗链限制。</p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1691314374889-2023-8-617:32:55.png" alt="1691314374889-2023-8-617:32:55.png"></p><p>通过以上优化，可以使文章更加清晰易懂，让读者更容易理解和操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;Hexo 博客中使用的图床无法访问，经查询是图床拦截问题，需要修改 referrer 信息。&lt;/p&gt;
&lt;h2 id=&quot;解决方法&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="搭建博客" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客图床" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>Python杂文——PyCharm配置QT环境</title>
    <link href="http://yoursite.com/2023/08/06/Python%E6%9D%82%E6%96%87/Python%E6%9D%82%E6%96%87%E2%80%94%E2%80%94PyCharm%E9%85%8D%E7%BD%AEQT%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2023/08/06/Python%E6%9D%82%E6%96%87/Python%E6%9D%82%E6%96%87%E2%80%94%E2%80%94PyCharm%E9%85%8D%E7%BD%AEQT%E7%8E%AF%E5%A2%83/</id>
    <published>2023-08-06T07:07:46.000Z</published>
    <updated>2023-08-07T02:38:43.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装pyqt5对应的库"><a href="#安装pyqt5对应的库" class="headerlink" title="安装pyqt5对应的库"></a>安装pyqt5对应的库</h1><h2 id="使用PyCharm安装（方法一）"><a href="#使用PyCharm安装（方法一）" class="headerlink" title="使用PyCharm安装（方法一）"></a>使用PyCharm安装（方法一）</h2><h3 id="安装pyqt5库"><a href="#安装pyqt5库" class="headerlink" title="安装pyqt5库"></a>安装pyqt5库</h3><ol><li>打开 PyCharm，进入安装源位置：File -&gt; Settings -&gt; Project -&gt; Python Interpreter  </li><li>在搜索框中输入 pyqt5，点击安装  </li><li>在搜索框中输入 pyqt5-tools，点击安装<br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1691306206191-2023-8-615:16:46.png" alt="这是一张图片"></li></ol><h3 id="安装PyQt5-tool库"><a href="#安装PyQt5-tool库" class="headerlink" title="安装PyQt5-tool库"></a>安装PyQt5-tool库</h3><p>同样的方法搜索PyQt5-tool这个库进行安装即可  </p><h2 id="使用终端命令安装（方法二）"><a href="#使用终端命令安装（方法二）" class="headerlink" title="使用终端命令安装（方法二）"></a>使用终端命令安装（方法二）</h2><p>在终端中输入以下两个命令即可安装对应的库：</p><pre><code>pip install pyqt5  pip install pyqt5-tool  </code></pre><h1 id="配置QT-Designer-界面设计-和PyUIC-界面转代码"><a href="#配置QT-Designer-界面设计-和PyUIC-界面转代码" class="headerlink" title="配置QT Designer(界面设计)和PyUIC(界面转代码)"></a>配置QT Designer(界面设计)和PyUIC(界面转代码)</h1><h2 id="配置QT-Designer"><a href="#配置QT-Designer" class="headerlink" title="配置QT Designer"></a>配置QT Designer</h2><ol><li>打开 PyCharm，进入配置位置：File -&gt; Settings -&gt; Tools -&gt; External Tools</li><li>点击“+”号，弹出一个编辑配置的框</li><li>配置扩展工具的参数：  <blockquote><p><strong>Name</strong>: 自己随便起个名字，一般都是<strong>QT Designer</strong><br><strong>Program</strong>: designer.exe软件所在的路径，路径位置一般为：{python路径}\Lib\site-packages\qt5_applications\Qt\bin\designer.exe<br><strong>Working directory</strong>: <strong>$FileDir$</strong></p></blockquote></li></ol><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1691307145291-2023-8-615:32:26.png" alt="这是一张图片"></p><h2 id="配置PyUIC"><a href="#配置PyUIC" class="headerlink" title="配置PyUIC"></a>配置PyUIC</h2><ol><li>打开 PyCharm，进入配置位置：File -&gt; Settings -&gt; Tools -&gt; External Tools</li><li>点击“+”号，弹出一个编辑配置的框</li><li>配置扩展工具的参数： <blockquote><p>Name: 自己随便起个名字，一般都是<strong>配置PyUIC</strong><br> Program: python.exe软件所在的路径，路径位置一般为：{python路径}\python.exe<br> Arguments: $FileName$ -o $FileNameWithoutExtension$.py<br> Working directory: <strong>$FileDir$</strong></p></blockquote></li></ol><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1691375885378-2023-8-710:38:06.png" alt="1691375885378-2023-8-710:38:06.png"></p><h1 id="使用配置"><a href="#使用配置" class="headerlink" title="使用配置"></a>使用配置</h1><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1691307415934-2023-8-615:36:56.png" alt="这是一张图片">  </p><h2 id="制作界面"><a href="#制作界面" class="headerlink" title="制作界面"></a>制作界面</h2><p>点击上图编号①就可以打开编辑界面 UI 的编辑器了，也可以使用快捷键 Ctrl + Alt + Shift + D<br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1691307518635-2023-8-615:38:39.png" alt="这是一张图片">  </p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>制作好界面后，在 PyCharm 中选中刚才制作的 UI 文件，右键 -&gt; External Tools -&gt; PyUIC 即可生成对应的代码。<br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1691307659438-2023-8-615:41:00.png" alt="这是一张图片">  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装pyqt5对应的库&quot;&gt;&lt;a href=&quot;#安装pyqt5对应的库&quot; class=&quot;headerlink&quot; title=&quot;安装pyqt5对应的库&quot;&gt;&lt;/a&gt;安装pyqt5对应的库&lt;/h1&gt;&lt;h2 id=&quot;使用PyCharm安装（方法一）&quot;&gt;&lt;a href=&quot;#使</summary>
      
    
    
    
    <category term="Python杂文" scheme="http://yoursite.com/categories/Python%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——宏管理脚本</title>
    <link href="http://yoursite.com/2023/05/21/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%AE%8F%E7%AE%A1%E7%90%86%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2023/05/21/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%AE%8F%E7%AE%A1%E7%90%86%E8%84%9A%E6%9C%AC/</id>
    <published>2023-05-21T13:56:48.000Z</published>
    <updated>2023-05-21T14:18:02.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这是一个管理Unity宏设置的脚本工具，能快速的增删改查项目的脚本。<br>下面是效果图：<br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1684677675196-2023-5-2122:01:15.png"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="依赖的代码"><a href="#依赖的代码" class="headerlink" title="依赖的代码"></a>依赖的代码</h2><details>    <summary> ResCatalog </summary>  <pre><code>/// &lt;summary&gt;/// 资源路径/// &lt;/summary&gt;public static class ResCatalog&#123;    public const string DefaultRes = &quot;Library/unity default resources&quot;;    public const string Temporary = &quot;Assets/_Temporary&quot;;    public const string Library = &quot;Assets/_Library&quot;;&#125;</code></pre></details>  <details>    <summary> BuildTargetUtility </summary>  <pre><code>/// &lt;summary&gt;/// 构建的辅助工具/// &lt;/summary&gt;public class BuildTargetUtility&#123;    /// &lt;summary&gt;    /// 获取对应平台的组    /// &lt;/summary&gt;    /// &lt;param name=&quot;p&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static BuildTargetGroup PlatformToGroup(RuntimePlatform p)    &#123;        return p switch        &#123;            RuntimePlatform.OSXEditor =&gt; BuildTargetGroup.Standalone,            RuntimePlatform.OSXPlayer =&gt; BuildTargetGroup.Standalone,            RuntimePlatform.WindowsPlayer =&gt; BuildTargetGroup.Standalone,            RuntimePlatform.WindowsEditor =&gt; BuildTargetGroup.Standalone,            RuntimePlatform.IPhonePlayer =&gt; BuildTargetGroup.iOS,            RuntimePlatform.Android =&gt; BuildTargetGroup.Android,            RuntimePlatform.LinuxPlayer =&gt; BuildTargetGroup.Standalone,            RuntimePlatform.LinuxEditor =&gt; BuildTargetGroup.Standalone,            RuntimePlatform.WebGLPlayer =&gt; BuildTargetGroup.WebGL,            RuntimePlatform.PS4 =&gt; BuildTargetGroup.PS4,            RuntimePlatform.XboxOne =&gt; BuildTargetGroup.XboxOne,            RuntimePlatform.tvOS =&gt; BuildTargetGroup.tvOS,            RuntimePlatform.Switch =&gt; BuildTargetGroup.Switch,            _ =&gt; BuildTargetGroup.Unknown        &#125;;    &#125;&#125;</code></pre></details> <details>    <summary> AssetLibrary </summary>  <pre><code>/// &lt;summary&gt;/// 资源的Library/// &lt;/summary&gt;public static class AssetLibrary&#123;    /// &lt;summary&gt;    /// 判断文件是否存在    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static bool Exists(string path, bool temporary)    &#123;        return File.Exists(GetPath(path, temporary));    &#125;    /// &lt;summary&gt;    /// 获取文件的地址    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件名字&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;是否是临时文件&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static string GetPath(string path, bool temporary)    &#123;        return Path.Combine(temporary ? ResCatalog.Temporary : ResCatalog.Library, path);    &#125;    /// &lt;summary&gt;    /// 保存文件    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件地址&lt;/param&gt;    /// &lt;param name=&quot;text&quot;&gt;文件内容&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;是否是临时文件&lt;/param&gt;    public static void Save(string path, string text, bool temporary)    &#123;        WriteAllText(path, text, temporary);    &#125;    /// &lt;summary&gt;    /// 保存文件    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件地址&lt;/param&gt;    /// &lt;param name=&quot;bytes&quot;&gt;写入的字节&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;是否是临时资源&lt;/param&gt;    public static void Save(string path, byte[] bytes, bool temporary)    &#123;        WriteAllBytes(path, bytes, temporary);    &#125;    /// &lt;summary&gt;    /// 获取文件内的所有内容    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件地址&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;是否是临时文件&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static string GetString(string path, bool temporary)    &#123;        return File.ReadAllText(GetPath(path, temporary));    &#125;    /// &lt;summary&gt;    /// 获取文件的所有字节    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件地址&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;是否是临时资源&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static byte[] GetBytes(string path, bool temporary)    &#123;        return File.ReadAllBytes(GetPath(path, temporary));    &#125;    /// &lt;summary&gt;    /// 写入所有的字节    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件路径&lt;/param&gt;    /// &lt;param name=&quot;bytes&quot;&gt;写入字节&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;是否是临时资源&lt;/param&gt;    private static void WriteAllBytes(string path, byte[] bytes, bool temporary)    &#123;        var realPath = GetPath(path, temporary);        PathUtils.MakeDirectory(realPath);        File.WriteAllBytes(realPath, bytes);    &#125;    /// &lt;summary&gt;    /// 写入所有的文本内容    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件路径&lt;/param&gt;    /// &lt;param name=&quot;text&quot;&gt;写入字符串&lt;/param&gt;    /// &lt;param name=&quot;temporary&quot;&gt;是否是临时资源&lt;/param&gt;    private static void WriteAllText(string path, string text, bool temporary)    &#123;        var realPath = GetPath(path, temporary);        PathUtils.MakeDirectory(realPath);        File.WriteAllText(realPath, text);    &#125;&#125;</code></pre></details>  <details>    <summary> SymbolsUtility </summary>  <pre><code>/// &lt;summary&gt;/// 宏的辅助工具/// &lt;/summary&gt;public static class SymbolsUtility&#123;    /// &lt;summary&gt;    /// 设置宏    /// &lt;/summary&gt;    /// &lt;param name=&quot;symbols&quot;&gt;&lt;/param&gt;    public static void SetSymbols(params string[] symbols)    &#123;        var result = string.Join(&quot;;&quot;, symbols);        PlayerSettings.SetScriptingDefineSymbolsForGroup(BuildTargetGroup.Standalone, result);        PlayerSettings.SetScriptingDefineSymbolsForGroup(BuildTargetGroup.iOS, result);        PlayerSettings.SetScriptingDefineSymbolsForGroup(BuildTargetGroup.Android, result);    &#125;    /// &lt;summary&gt;    /// 获取所有的宏    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static string[] GetSymbols()    &#123;        var group = BuildTargetUtility.PlatformToGroup(Application.platform);        var symbols = PlayerSettings.GetScriptingDefineSymbolsForGroup(group);        return symbols.Split(&#39;;&#39;);    &#125;    /// &lt;summary&gt;    /// 增加宏    /// &lt;/summary&gt;    /// &lt;param name=&quot;symbols&quot;&gt;宏的组&lt;/param&gt;    public static void AddSymbols(params string[] symbols)    &#123;        SetSymbols(GetSymbols().Union(symbols).ToArray());    &#125;    /// &lt;summary&gt;    /// 移除宏    /// &lt;/summary&gt;    /// &lt;param name=&quot;symbols&quot;&gt;宏的组&lt;/param&gt;    public static void RemoveSymbols(params string[] symbols)    &#123;        SetSymbols(GetSymbols().Except(symbols).ToArray());    &#125;    /// &lt;summary&gt;    /// 判断是否拥有宏    /// &lt;/summary&gt;    /// &lt;param name=&quot;symbol&quot;&gt;宏的名字&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static bool HasSymbols(string symbol)    &#123;        return -1 != Array.IndexOf(GetSymbols(), symbol);    &#125;&#125;</code></pre></details> <h2 id="管理工具代码"><a href="#管理工具代码" class="headerlink" title="管理工具代码"></a>管理工具代码</h2><pre><code>internal class SymbolsManager : EditorWindow&#123;    /// &lt;summary&gt;    /// 宏的配置    /// &lt;/summary&gt;    public class SymbolsConfig    &#123;        /// &lt;summary&gt;        /// 宏的名字        /// &lt;/summary&gt;        public string name;        /// &lt;summary&gt;        /// 是否使用        /// &lt;/summary&gt;        [NonSerialized]        public bool used;    &#125;    /// &lt;summary&gt;    /// 宏的组    /// &lt;/summary&gt;    public class SymbolsGroup    &#123;        /// &lt;summary&gt;        /// 组的名字        /// &lt;/summary&gt;        public string name;        /// &lt;summary&gt;        /// 组的宏列表        /// &lt;/summary&gt;        public List&lt;SymbolsConfig&gt; list;        /// &lt;summary&gt;        /// 用于显示的List        /// &lt;/summary&gt;        [NonSerialized]        public ReorderableList reorderableList;        /// &lt;summary&gt;        /// 是否已经删除        /// &lt;/summary&gt;        [NonSerialized]        public bool deleted;    &#125;    /// &lt;summary&gt;    /// 组的列表    /// &lt;/summary&gt;    private List&lt;SymbolsGroup&gt; m_Groups;    /// &lt;summary&gt;    /// 宏管理窗口    /// &lt;/summary&gt;    [MenuItem(&quot;Tools/SymbolsManager&quot;, false)]    private static void OpenWindow()    &#123;        var window = GetWindow&lt;SymbolsManager&gt;(&quot;SymbolsManager&quot;);        window.minSize = new Vector2(350, 100);    &#125;    private void OnEnable()    &#123;        var path = GetSettingsFileName();        if (AssetLibrary.Exists(path, false))        &#123;            var text = AssetLibrary.GetString(path, false);            JsonUtils.ToObject(text, out m_Groups);            foreach (var group in m_Groups)            &#123;                if (null == group.list)                &#123;                    group.list = new List&lt;SymbolsConfig&gt;();                &#125;                else                &#123;                    foreach (var config in group.list)                    &#123;                        config.used = SymbolsUtility.HasSymbols(config.name);                    &#125;                &#125;            &#125;        &#125;        m_Groups ??= new List&lt;SymbolsGroup&gt;();    &#125;    /// &lt;summary&gt;    /// 绘制面板    /// &lt;/summary&gt;    private void OnGUI()    &#123;        for (var i = 0; i &lt; m_Groups.Count;)        &#123;            var group = m_Groups[i];            GUILayout.BeginVertical(EditorStyles.helpBox);            &#123;                if (null == group.reorderableList)                &#123;                    group.list ??= new List&lt;SymbolsConfig&gt;();                    group.reorderableList = new ReorderableList(group.list, typeof(SymbolsConfig))                    &#123;                        drawHeaderCallback = rect =&gt;                        &#123;                            var textRt = rect;                            textRt.width /= 2f;                            group.name = EditorGUI.TextField(textRt, group.name, EditorStyles.boldLabel);                            var btnRt = rect;                            btnRt.x = btnRt.xMax - Styles.closeButton.lineHeight;                            if (GUI.Button(btnRt, GUIContent.none, Styles.closeButton))                            &#123;                                if (EditorUtility.DisplayDialog(                                    &quot;提示&quot;, &quot;是否确认删除?&quot;, &quot;确认&quot;, &quot;取消&quot;))                                &#123;                                    group.deleted = true;                                &#125;                            &#125;                        &#125;,                        drawElementCallback = (rect, index, active, focused) =&gt;                        &#123;                            var item = group.list[index];                            var textRect = new Rect(                                rect.position + Vector2.up * 2,                                new Vector2(rect.width - 100, EditorGUIUtility.singleLineHeight));                            item.name = GUI.TextField(textRect, item.name)?.Trim();                            const int btnWidth = 80;                            var oldColor = GUI.color;                            GUI.color = SymbolsUtility.HasSymbols(item.name) ? Color.green : Color.red;                            var btnRect = new Rect(                                rect.position + Vector2.up + Vector2.right * (rect.width - btnWidth),                                new Vector2(btnWidth, EditorGUIUtility.singleLineHeight));                            item.used = GUI.Toggle(btnRect, item.used,                                item.used ? Styles.used : Styles.unused,                                EditorStyles.toolbarButton);                            GUI.color = oldColor;                        &#125;,                        elementHeight = 22,                    &#125;;                &#125;                group.reorderableList.DoLayoutList();                GUILayout.BeginHorizontal();                GUILayout.FlexibleSpace();                if (GUILayout.Button(Styles.apply, GUILayout.Height(30), GUILayout.Width(100)))                &#123;                    foreach (var config in group.list)                    &#123;                        if (config.used)                        &#123;                            SymbolsUtility.AddSymbols(config.name);                        &#125;                        else                        &#123;                            SymbolsUtility.RemoveSymbols(config.name);                        &#125;                    &#125;                    AssetDatabase.SaveAssets();                    AssetDatabase.Refresh();                &#125;                GUILayout.FlexibleSpace();                GUILayout.EndHorizontal();                GUILayout.Space(5);            &#125;            GUILayout.EndVertical();            if (group.deleted)            &#123;                m_Groups.RemoveAt(i);            &#125;            else            &#123;                ++i;            &#125;        &#125;        //        GUILayout.BeginHorizontal();        GUILayout.FlexibleSpace();        if (GUILayout.Button(Styles.addGroup, GUILayout.Height(30), GUILayout.Width(200)))        &#123;            m_Groups.Add(new SymbolsGroup            &#123;                name = Styles.customName,                list = new List&lt;SymbolsConfig&gt;()            &#125;);        &#125;        GUILayout.FlexibleSpace();        GUILayout.EndHorizontal();        var e = Event.current;        if (e.keyCode == KeyCode.S &amp;&amp; e.type == EventType.KeyUp)        &#123;            e.Use();            Save();        &#125;    &#125;    /// &lt;summary&gt;    /// 销毁的时候保存    /// &lt;/summary&gt;    private void OnDisable()    &#123;        Save();    &#125;    /// &lt;summary&gt;    /// 保存    /// &lt;/summary&gt;    private void Save()    &#123;        JsonResolver.NotSerializeDefault = true;        var text = JsonUtils.ToPrettyString(m_Groups);        AssetLibrary.Save(GetSettingsFileName(), text, false);        JsonResolver.NotSerializeDefault = false;    &#125;    /// &lt;summary&gt;    /// 序列化Json文件的名字，采用 “类名Settings.json”格式    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    private string GetSettingsFileName()    &#123;        return $&quot;&#123;GetType().Name&#125;Settings.json&quot;;    &#125;    #region 显示风格Style    /// &lt;summary&gt;    /// 编辑器的风格    /// &lt;/summary&gt;    private static class Styles    &#123;        /// &lt;summary&gt;        /// 已经使用        /// &lt;/summary&gt;        public static GUIContent used;        /// &lt;summary&gt;        /// 未使用        /// &lt;/summary&gt;        public static GUIContent unused;        /// &lt;summary&gt;        /// 应用        /// &lt;/summary&gt;        public static GUIContent apply;        /// &lt;summary&gt;        /// 新增分组        /// &lt;/summary&gt;        public static GUIContent addGroup;        /// &lt;summary&gt;        /// 自定义名称(点击修改)        /// &lt;/summary&gt;        public static string customName;        /// &lt;summary&gt;        /// WinBtnClose        /// &lt;/summary&gt;        public static GUIStyle closeButton;        static Styles()        &#123;            used = new GUIContent(&quot;已使用&quot;);            unused = new GUIContent(&quot;未使用&quot;);            apply = new GUIContent(&quot;应用&quot;);            addGroup = new GUIContent(&quot;新增分组&quot;);            customName = &quot;自定义名称(点击修改)&quot;;            closeButton = new GUIStyle(&quot;WinBtnClose&quot;);        &#125;    &#125;    #endregion&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;这是一个管理Unity宏设置的脚本工具，能快速的增删改查项目的脚本。&lt;br&gt;下面是效果图：&lt;br&gt;&lt;img src=&quot;https://git</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity杂文——脚本创建辅助ScriptBuilder</title>
    <link href="http://yoursite.com/2023/05/17/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%84%9A%E6%9C%AC%E5%88%9B%E5%BB%BA%E8%BE%85%E5%8A%A9ScriptBuilder/"/>
    <id>http://yoursite.com/2023/05/17/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%84%9A%E6%9C%AC%E5%88%9B%E5%BB%BA%E8%BE%85%E5%8A%A9ScriptBuilder/</id>
    <published>2023-05-16T16:38:43.000Z</published>
    <updated>2023-05-16T17:09:33.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一个辅助快速生成需要的C#脚本的脚本。主要是快速生成引用，命名空间，类和方法一些。</p><h1 id="脚本和解析"><a href="#脚本和解析" class="headerlink" title="脚本和解析"></a>脚本和解析</h1><pre><code>public class ScriptBuilder&#123;    /// &lt;summary&gt;    /// 脚本的字符串    /// &lt;/summary&gt;    private StringBuilder m_Builder = new StringBuilder();    /// &lt;summary&gt;    /// 空白地字符串    /// &lt;/summary&gt;    private StringBuilder m_Blank = new StringBuilder();    /// &lt;summary&gt;    /// 用于判断是否在方法内生成脚本    /// &lt;/summary&gt;    public bool MarkInMethod &#123; get; set; &#125;    /// &lt;summary&gt;    /// 增加一行数据    /// &lt;/summary&gt;    /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;    public void AppendLine(string message)    &#123;        m_Builder.Append(m_Blank);        m_Builder.AppendLine(message);    &#125;    /// &lt;summary&gt;    /// 开始增加空白    /// &lt;/summary&gt;    private void BeginBlank()    &#123;        m_Blank.Append(&#39;\t&#39;);    &#125;    /// &lt;summary&gt;    /// 结束增加空白    /// &lt;/summary&gt;    private void EndBlank()    &#123;        m_Blank.Remove(m_Blank.Length - 1, 1);    &#125;    /// &lt;summary&gt;    ///开始增加命名空间    /// &lt;/summary&gt;    /// &lt;param name=&quot;name&quot;&gt;命名空间的名字&lt;/param&gt;    public void BeginNamespace(string name)    &#123;        BeginBrace($&quot;namespace &#123;name&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 结束增加命名空间    /// &lt;/summary&gt;    public void EndNamespace()    &#123;        EndBrace();    &#125;    /// &lt;summary&gt;    /// 开始增加类    /// &lt;/summary&gt;    /// &lt;param name=&quot;modifier&quot;&gt;类的修饰字符串&lt;/param&gt;    /// &lt;param name=&quot;className&quot;&gt;类的名字&lt;/param&gt;    /// &lt;param name=&quot;superclass&quot;&gt;继承类的名字&lt;/param&gt;    public void BeginClass(string modifier, string className, string superclass)    &#123;        BeginBrace($&quot;public &#123;modifier&#125; class &#123;className&#125; : &#123;superclass&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 开始增加类    /// &lt;/summary&gt;    /// &lt;param name=&quot;modifier&quot;&gt;类的修饰字符串&lt;/param&gt;    /// &lt;param name=&quot;className&quot;&gt;类的名字&lt;/param&gt;    public void BeginClass(string modifier, string className)    &#123;        BeginBrace($&quot;public &#123;modifier&#125; class &#123;className&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 开始增加类    /// &lt;/summary&gt;    /// &lt;param name=&quot;className&quot;&gt;类的名字&lt;/param&gt;    public void BeginClass(string className)    &#123;        BeginBrace($&quot;public class &#123;className&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 结束类    /// &lt;/summary&gt;    public void EndClass()    &#123;        EndBrace();    &#125;    /// &lt;summary&gt;    /// 开始增加方法    /// &lt;/summary&gt;    /// &lt;param name=&quot;method&quot;&gt;方法名&lt;/param&gt;    /// &lt;param name=&quot;permission&quot;&gt;访问权限&lt;/param&gt;    /// &lt;param name=&quot;returnType&quot;&gt;返回类型&lt;/param&gt;    /// &lt;param name=&quot;modifier&quot;&gt;修饰符&lt;/param&gt;    public void BeginMethod(string method, string permission = &quot;public&quot;, string returnType = &quot;void&quot;,        string modifier = &quot;&quot;)    &#123;        MarkInMethod = true;        BeginBrace(string.IsNullOrEmpty(modifier)            ? $&quot;&#123;permission&#125; &#123;returnType&#125; &#123;method&#125;&quot;            : $&quot;&#123;permission&#125; &#123;modifier&#125; &#123;returnType&#125; &#123;method&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 结束方法    /// &lt;/summary&gt;    public void EndMethod()    &#123;        EndBrace();        MarkInMethod = false;    &#125;    /// &lt;summary&gt;    /// 开始属性    /// &lt;/summary&gt;    /// &lt;param name=&quot;property&quot;&gt;属性名字&lt;/param&gt;    public void BeginProperty(string property)    &#123;        BeginBrace(property);    &#125;    /// &lt;summary&gt;    /// 结束属性    /// &lt;/summary&gt;    public void EndProperty()    &#123;        EndBrace();    &#125;    /// &lt;summary&gt;    /// 大括号的开始    /// &lt;/summary&gt;    /// &lt;param name=&quot;code&quot;&gt;&lt;/param&gt;    public void BeginBrace(string code)    &#123;        AppendLine($&quot;&#123;code&#125;&quot;);        AppendLine(&quot;&#123;&quot;);        BeginBlank();    &#125;    /// &lt;summary&gt;    /// 结束大括号    /// &lt;/summary&gt;    public void EndBrace()    &#123;        EndBlank();        AppendLine(&quot;&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 开始字段    /// &lt;/summary&gt;    /// &lt;param name=&quot;code&quot;&gt;Field的名字&lt;/param&gt;    public void BeginField(string code)    &#123;        AppendLine($&quot;&#123;code&#125;&quot;);        AppendLine(&quot;&#123;&quot;);        BeginBlank();    &#125;    /// &lt;summary&gt;    /// 结束字段    /// &lt;/summary&gt;    public void EndField()    &#123;        EndBlank();        AppendLine(&quot;&#125;;&quot;);    &#125;    /// &lt;summary&gt;    /// 开始Region    /// &lt;/summary&gt;    /// &lt;param name=&quot;name&quot;&gt;Region的名字&lt;/param&gt;    public void BeginRegion(string name)    &#123;        AppendLine($&quot;#region &#123;name&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 结束Region    /// &lt;/summary&gt;    public void EndRegion()    &#123;        AppendLine(&quot;#endregion&quot;);    &#125;    /// &lt;summary&gt;    /// 转成字符串    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public override string ToString()    &#123;        return m_Builder.ToString();    &#125;&#125;</code></pre><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>上述方法就是辅助的脚本，下面是举例调用方法作为参考  </p><pre><code>// 获取类脚本的路径var scriptPath = AssetDatabase.GUIDToAssetPath(kGUID);var sb = new ScriptBuilder();sb.BeginNamespace(typeof(StorageKeyConst).Namespace);sb.BeginClass(&quot;static&quot;, &quot;StorageKeyConst&quot;);if (DataStorageEditorTools.Instance.DataStorageEditorDataRootList.Count &gt; 0)&#123;    sb.BeginRegion(&quot;RootKeys&quot;);    sb.AppendLine(string.Empty);    AddListScripts(sb, DataStorageEditorTools.Instance.DataStorageEditorDataRootList);    sb.AppendLine(string.Empty);    sb.EndRegion();    sb.AppendLine(string.Empty);&#125;if (DataStorageEditorTools.Instance.DataStorageEditorDataList.Count &gt; 0)&#123;    sb.BeginRegion(&quot;Keys&quot;);    sb.AppendLine(string.Empty);    AddListScripts(sb, DataStorageEditorTools.Instance.DataStorageEditorDataList);    sb.AppendLine(string.Empty);    sb.EndRegion();&#125;sb.EndClass();sb.EndNamespace();File.WriteAllText(scriptPath, sb.ToString(), Encoding.UTF8);AssetDatabase.SaveAssets();AssetDatabase.Refresh();</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;一个辅助快速生成需要的C#脚本的脚本。主要是快速生成引用，命名空间，类和方法一些。&lt;/p&gt;
&lt;h1 id=&quot;脚本和解析&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity杂文——阿拉伯数字转罗马数字</title>
    <link href="http://yoursite.com/2022/12/29/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2022/12/29/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</id>
    <published>2022-12-29T09:40:31.000Z</published>
    <updated>2023-06-03T05:16:35.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在游戏开发中，美术人员有时需要将一些数字转换为罗马数字。本文介绍了一种将阿拉伯数字转换为罗马数字的方法，可以帮助美术人员快速完成转换。如果您是游戏开发人员或对数字转换感兴趣，本文也会对您有所帮助。 </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>/// &lt;summary&gt;/// 数字转罗马数字/// &lt;/summary&gt;/// &lt;param name=&quot;num&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string IntToRoman(int num)&#123;    var res = string.Empty;    var val = new List&lt;int&gt; &#123; 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 &#125;;    var str = new List&lt;string&gt; &#123; &quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot; &#125;;    for(var i = 0;i &lt; val.Count; ++i)    &#123;        while(num &gt;= val[i])        &#123;            num -= val[i];            res += str[i];        &#125;    &#125;    return res;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在游戏开发中，美术人员有时需要将一些数字转换为罗马数字。本文介绍了一种将阿拉伯数字转换为罗马数字的方法，可以帮助美术人员快速完成转换。如果您</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="字符串处理" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——编辑器Foldout右键菜单</title>
    <link href="http://yoursite.com/2022/12/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E5%99%A8Foldout%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/"/>
    <id>http://yoursite.com/2022/12/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E5%99%A8Foldout%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/</id>
    <published>2022-12-28T03:09:37.000Z</published>
    <updated>2022-12-28T03:18:14.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在用编辑器开发工具的时候，我们经常会用到折叠的Foldout，这里就不对Foldout做详细的介绍了，本文主要分享如何对Foldout做一个扩展，笔者在开发中常常需要的一个右键菜单的功能，这样我们就可以添加很多功能而不需要增加按钮，右键选择对应的菜单就行了。  </p><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/FoldoutRightClick-2022-12-2811:17:09.gif"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>var rect = GUILayoutUtility.GetRect(EditorGUIUtility.fieldWidth, EditorGUIUtility.fieldWidth, 18f, 18f,    EditorStyles.foldout);m_IsFoldout = EditorGUI.Foldout(rect, m_IsFoldout, &quot;标题&quot;);CreateNewGenericMenu(rect, new List&lt;string&gt; &#123; &quot;方法一&quot;, &quot;方法二&quot;, &quot;方法三&quot; &#125;, new List&lt;Action&gt;&#123;    (() =&gt; &#123;Debug.LogError(&quot;1&quot;);&#125;),    (() =&gt; &#123;Debug.LogError(&quot;2&quot;);&#125;),    (() =&gt; &#123;Debug.LogError(&quot;3&quot;);&#125;),&#125;);/// &lt;summary&gt;/// 绘制右键菜单/// &lt;/summary&gt;/// &lt;param name=&quot;btnRect&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;menuName&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;menuIsOn&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;menuCallBack&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public GenericMenu CreateNewGenericMenu(Rect btnRect, List&lt;string&gt; menuName, List&lt;Action&gt; menuCallBack,    List&lt;bool&gt; menuIsOn = null)&#123;    var menu = new GenericMenu();    var index = 0;    foreach (var action in menuCallBack)    &#123;        menu.AddItem(new GUIContent(menuName[index]), menuIsOn != null &amp;&amp; menuIsOn[index],            () =&gt; &#123; action?.Invoke(); &#125;);        index++;    &#125;    if (Event.current.button == 1 &amp;&amp; Event.current.type == EventType.MouseDown &amp;&amp;        btnRect.Contains(Event.current.mousePosition))    &#123;        menu.ShowAsContext();    &#125;    return menu;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在用编辑器开发工具的时候，我们经常会用到折叠的Foldout，这里就不对Foldout做详细的介绍了，本文主要分享如何对Foldout做一个</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——UI点击穿透</title>
    <link href="http://yoursite.com/2022/12/17/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UI%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F/"/>
    <id>http://yoursite.com/2022/12/17/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UI%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F/</id>
    <published>2022-12-17T02:11:15.000Z</published>
    <updated>2022-12-17T02:19:25.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>当UI打开一个小的提示tip的时候，常见的需求是点击其他任意地方就关闭tip，这个功能很常见，空白出响应点击，监听到就关闭tip，这里会发现一个问题，我们并不能响应tip面板底下的其他按钮，这样玩家在操作的时候就需要先关掉tip，然后再点一下按钮，这往往不是策划想要的，所以我们需要在点击空白处关闭的时候同时响应底下的按钮，这个时候就需要点击穿透事件。  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>using System.Collections.Generic;using UnityEngine;using UnityEngine.EventSystems;namespace ZHEngine.UI&#123;    public sealed class UTouchPass : MonoBehaviour, IPointerClickHandler,    IMoveHandler,IPointerDownHandler, IPointerUpHandler,IPointerEnterHandler,ISelectHandler, IDeselectHandler    , ISubmitHandler, IInitializePotentialDragHandler, IBeginDragHandler, IEndDragHandler, IDragHandler, IScrollHandler    &#123;        private GameObject CacheGameObject;        private readonly List&lt;RaycastResult&gt; result = new List&lt;RaycastResult&gt;();        public void OnPointerClick(PointerEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.pointerClickHandler);        &#125;        public void OnPointerDown(PointerEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.pointerDownHandler);            if (Input.GetButtonDown(&quot;Submit&quot;))               ExecuteEvents.Execute(eventData.pointerCurrentRaycast.gameObject, eventData, ExecuteEvents.submitHandler);        &#125;        public void OnPointerUp(PointerEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.pointerUpHandler);        &#125;        public void OnPointerEnter(PointerEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.pointerEnterHandler);        &#125;        public void OnSelect(BaseEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.selectHandler);        &#125;        public void OnDeselect(BaseEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.deselectHandler);        &#125;        public void OnSubmit(BaseEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.submitHandler);        &#125;        public void OnMove(AxisEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.moveHandler);        &#125;        public void OnInitializePotentialDrag(PointerEventData eventData)        &#123;            CacheGameObject = PassEvent(eventData, ExecuteEvents.initializePotentialDrag);        &#125;        public void OnBeginDrag(PointerEventData eventData)        &#123;             PassEvent(eventData, ExecuteEvents.beginDragHandler);        &#125;        public void OnDrag(PointerEventData eventData)        &#123;            ExecuteEvents.Execute(CacheGameObject, eventData, ExecuteEvents.dragHandler);        &#125;        public void OnEndDrag(PointerEventData eventData)        &#123;            ExecuteEvents.Execute(CacheGameObject, eventData, ExecuteEvents.endDragHandler);            CacheGameObject = null;        &#125;        public void OnScroll(PointerEventData eventData)        &#123;            ExecuteEvents.Execute(CacheGameObject, eventData, ExecuteEvents.scrollHandler);        &#125;        private GameObject PassEvent&lt;T&gt;(BaseEventData data, ExecuteEvents.EventFunction&lt;T&gt; function) where T : IEventSystemHandler        &#123;            if (data is PointerEventData eventData)            &#123;                var pointerGo = eventData.pointerCurrentRaycast.gameObject                    ? eventData.pointerCurrentRaycast.gameObject                    : eventData.pointerDrag;                EventSystem.current.RaycastAll(eventData, result);                foreach (var item in result)                &#123;                    var go = item.gameObject;                    if (go != null &amp;&amp; go != pointerGo)                    &#123;                        var executeGo = ExecuteEvents.GetEventHandler&lt;T&gt;(go);                        if (executeGo)                        &#123;                            if (executeGo.TryGetComponent&lt;UTouchPass&gt;(out var __))                                return null;                            ExecuteEvents.Execute(executeGo, data, function);                            return executeGo;                        &#125;                        else                        &#123;                            if(go.TryGetComponent&lt;UnityEngine.UI.Graphic&gt;(out var com))                            &#123;                                if (com.raycastTarget) return null;                            &#125;                        &#125;                    &#125;                &#125;            &#125;            return null;        &#125;    &#125;&#125;</code></pre><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.xuanyusong.com/archives/4773">Unity3D研究院之UI完整透下事件（一百二十二）——雨松MOMO</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;当UI打开一个小的提示tip的时候，常见的需求是点击其他任意地方就关闭tip，这个功能很常见，空白出响应点击，监听到就关闭tip，这里会发现</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="UI" scheme="http://yoursite.com/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——编辑器下拉多选菜单</title>
    <link href="http://yoursite.com/2022/09/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8B%E6%8B%89%E5%A4%9A%E9%80%89%E8%8F%9C%E5%8D%95/"/>
    <id>http://yoursite.com/2022/09/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8B%E6%8B%89%E5%A4%9A%E9%80%89%E8%8F%9C%E5%8D%95/</id>
    <published>2022-09-27T16:10:39.000Z</published>
    <updated>2022-09-27T16:37:18.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>游戏编辑器工具开发中会经常遇到下拉菜单的需求，笔者也遇到了一种特殊的下拉菜单，是下拉后可以多选的菜单，于是笔者便记录下这种特殊菜单的开发脚本。</p><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/20220928_003131-2022-9-2800:34:48.gif">  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><pre><code>public enum DropdownMultiType&#123;    [InspectorName(&quot;无&quot;)] None = 0,    Everything = ~0,    [InspectorName(&quot;类型一&quot;)] Type1 = 1 &lt;&lt; 1,    [InspectorName(&quot;类型二&quot;)] Type2 = 1 &lt;&lt;2,    [InspectorName(&quot;类型三&quot;)] Type3 = 1&lt;&lt;3&#125;</code></pre><h2 id="调用脚本"><a href="#调用脚本" class="headerlink" title="调用脚本"></a>调用脚本</h2><pre><code>m_DropdownMultiType = (DropdownMultiType)EditorGUILayout.EnumFlagsField(m_DropdownMultiType, GUILayout.Width(120))；EditorGUILayout.LabelField($&quot;Type1：&#123;m_DropdownMultiType.HasFlag(DropdownMultiType.Type1)&#125;&quot;);EditorGUILayout.LabelField($&quot;Type2：&#123;m_DropdownMultiType.HasFlag(DropdownMultiType.Type2)&#125;&quot;);EditorGUILayout.LabelField($&quot;Type3：&#123;m_DropdownMultiType.HasFlag(DropdownMultiType.Type3)&#125;&quot;);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;游戏编辑器工具开发中会经常遇到下拉菜单的需求，笔者也遇到了一种特殊的下拉菜单，是下拉后可以多选的菜单，于是笔者便记录下这种特殊菜单的开发脚本</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>常用Python文件处理脚本</title>
    <link href="http://yoursite.com/2022/09/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%B8%B8%E7%94%A8Python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2022/09/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%B8%B8%E7%94%A8Python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/</id>
    <published>2022-09-11T14:50:02.000Z</published>
    <updated>2022-09-11T15:21:42.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Unity打包经常会用一些文件的复制粘贴到一些文件到自己指定的SDK目录，一开始我们使用的是bat脚本，但是笔者发现这个脚本没办法在打包机（MAC）上使用，于是笔者便想到了python脚本来实现。  </p><h1 id="引用的库"><a href="#引用的库" class="headerlink" title="引用的库"></a>引用的库</h1><pre><code>import sysimport osimport jsonimport shutil</code></pre><h1 id="利用json配置需要控制的文件或者文件夹"><a href="#利用json配置需要控制的文件或者文件夹" class="headerlink" title="利用json配置需要控制的文件或者文件夹"></a>利用json配置需要控制的文件或者文件夹</h1><pre><code>&#123;    &quot;remdir&quot;:[        &quot;data/libs/&quot;,        &quot;data/src/main/assets/&quot;        ],    &quot;copydir&quot;:[        &quot;../xarchive/android/unityLibrary/libs/&quot;,        &quot;../xarchive/android/unityLibrary/    ]&#125;</code></pre><h1 id="参数读取"><a href="#参数读取" class="headerlink" title="参数读取"></a>参数读取</h1><pre><code>if (len(sys.argv) &gt; 1):    isPAD = sys.argv[1]if(isPAD == &quot;0&quot;)    ...</code></pre><p>命令执行python脚本的时候通过读取<strong>sys.argv</strong>便可以读取到自己传入的参数，这里需要注意的是读取的都是字符串，所以笔者在读数字0的时候需要用到**”0”**。  </p><h1 id="读取Config配置文件（json）"><a href="#读取Config配置文件（json）" class="headerlink" title="读取Config配置文件（json）"></a>读取Config配置文件（json）</h1><pre><code>configFilePath = &quot;config.json&quot;;with open(configFilePath,&#39;r&#39;) as load_f:    load_dict = json.load(load_f)</code></pre><h1 id="删除目录文件或者文件夹"><a href="#删除目录文件或者文件夹" class="headerlink" title="删除目录文件或者文件夹"></a>删除目录文件或者文件夹</h1><pre><code>def path_remove(removepath):    for remdirPath in removepath:        try:            if os.path.exists(remdirPath):                if os.path.isdir(remdirPath):                    shutil.rmtree(remdirPath)                else:                    os.remove(remdirPath)                print(&quot;Remove Success: &quot;+remdirPath)        except OSError as e:            print(&quot;Error: %s : %s&quot; % (remdirPath, e.strerror))</code></pre><h1 id="复制文件或者文件夹到指定目录"><a href="#复制文件或者文件夹到指定目录" class="headerlink" title="复制文件或者文件夹到指定目录"></a>复制文件或者文件夹到指定目录</h1><pre><code>def proc_copy(old_path, new_path):    if os.path.exists(old_path):        if os.path.isdir(old_path):            shutil.copytree(old_path, new_path)        elif os.path.isfile(old_path):            shutil.copyfile(old_path, new_path)        print(&quot;Copy Success: &quot; + old_path)    else:        print(&quot;NOT FOUND: &#123;&#125;&quot;.format(old_path))def path_copy(copydir, pastedir):    for index in range(len(copydir)):        if os.path.exists(pastedir[index]):            if os.path.isdir(pastedir[index]):                shutil.rmtree(pastedir[index])        proc_copy(copydir[index],pastedir[index])</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Unity打包经常会用一些文件的复制粘贴到一些文件到自己指定的SDK目录，一开始我们使用的是bat脚本，但是笔者发现这个脚本没办法在打包机（</summary>
      
    
    
    
    <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——Android设备唯一标识</title>
    <link href="http://yoursite.com/2022/09/02/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Android%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86/"/>
    <id>http://yoursite.com/2022/09/02/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Android%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86/</id>
    <published>2022-09-02T09:18:27.000Z</published>
    <updated>2022-09-03T08:59:13.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>获取设备唯一标识的方法。</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>引用库的github地址：<a href="https://github.com/gzu-liyujiang/Android_CN_OAID/tree/master"><font color="steelblue" size="5">Android_CN_OAID</font></a><br>在Android最外层的bundel.gradle里添加下面依赖  </p><pre><code>allprojects &#123;    repositories &#123;        &#39;&#39;&#39;        maven &#123; url &#39;https://www.jitpack.io&#39; &#125;        ...    &#125;&#125;</code></pre><p>在app或者library的bundel.gradle添加下面依赖  </p><pre><code>dependencies &#123;implementation &#39;com.github.gzu-liyujiang:Android_CN_OAID:&lt;version&gt;&#39;&#125;</code></pre><p><version>这里换成自己需要的版本</version></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="引用的库的初始化"><a href="#引用的库的初始化" class="headerlink" title="引用的库的初始化"></a>引用的库的初始化</h2><p>在Application或者Active的onCreate里添加下面代码：  </p><pre><code>@Overridepublic void onCreate() &#123;    super.onCreate();    if (privacyPolicyAgreed) &#123;        ...        DeviceIdentifier.register(&lt;Application&gt;);        ...    &#125;&#125;</code></pre><p><Application>这里替换成自己程序的application</Application></p><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>需要的变量： </p><pre><code>//设备唯一标识private static String deviceId;//设备唯一标识文件名字private static String deviceIdFileName = &quot;all_in_sdk&quot;;//设备唯一标识缓存关键字keyprivate static String deviceIdKey = &quot;DeviceId&quot;;//设备唯一标识正则private static final Pattern ANDROID_ID_PATTERN = Pattern.compile(&quot;^[0-9a-fA-F]&#123;16&#125;$&quot;);</code></pre><p>获取的方法：</p><pre><code>//获取设备的唯一标识public static String GetDeviceID() &#123;    if(m_Activity == null)&#123;        m_Activity = UnityPlayer.currentActivity;    &#125;    Application application = m_Activity.getApplication();    if (application == null)        return &quot;&quot;;    if (deviceId != null)        return deviceId;    deviceId = getSPValue((Context)application, deviceIdKey);    if (!TextUtils.isEmpty(deviceId))        return deviceId;    deviceId = getAndroidIdAsDeviceId((Context)application);    if (!TextUtils.isEmpty(deviceId)) &#123;        saveSPValue((Context)application, deviceIdKey, deviceId);        return deviceId;    &#125;    deviceId = generateSoftDeviceId();    if (!TextUtils.isEmpty(deviceId)) &#123;        saveSPValue((Context)application, deviceIdKey, deviceId);        return deviceId;    &#125;    return deviceId;&#125;private static String getSPValue(Context paramContext, String paramString) &#123;    SharedPreferences sharedPreferences = paramContext.getSharedPreferences(deviceIdFileName, 0);    return sharedPreferences.getString(paramString, null);&#125;private static String getAndroidIdAsDeviceId(Context paramContext) &#123;    String str;    if(DeviceID.supportedOAID(m_Activity))    &#123;        str = DeviceIdentifier.getOAID(m_Activity);        if (isLegalAndroidId(str, true))            return str;    &#125;    str = DeviceIdentifier.getAndroidID(m_Activity);    if (isLegalAndroidId(str, true))        return str;    str = DeviceIdentifier.getIMEI(m_Activity);    if (isLegalAndroidId(str, true))        return str;    str = DeviceIdentifier.getWidevineID();    if (isLegalAndroidId(str, true))        return str;    str = DeviceIdentifier.getPseudoID();    if (isLegalAndroidId(str, true))        return str;    str = DeviceIdentifier.getGUID(m_Activity);    if (isLegalAndroidId(str, true))        return str;    return null;&#125;private static String generateSoftDeviceId() &#123;    String str1 = Build.SERIAL;    String str2 = !TextUtils.isEmpty(str1) ? str1 : &quot;NA&quot;;    try &#123;        long l1 = 1152921504606846976L;        long l2 = randomLong(Long.MAX_VALUE - l1) + l1;        return String.format(&quot;%1$s_%2$s&quot;, new Object[] &#123; Long.toHexString(l2), str2 &#125;);    &#125; catch (Throwable throwable) &#123;        return String.format(&quot;%1$s_%2$s&quot;, new Object[] &#123; &quot;NA&quot; + Long.toHexString(System.currentTimeMillis()), str2 &#125;);    &#125;&#125;private static void saveSPValue(Context paramContext, String paramString1, String paramString2) &#123;    SharedPreferences sharedPreferences = paramContext.getSharedPreferences(deviceIdFileName, 0);    sharedPreferences.edit().putString(paramString1, paramString2).apply();&#125;private static long randomLong(long paramLong) &#123;    if (Build.VERSION.SDK_INT &gt;= 21)        return ThreadLocalRandom.current().nextLong(paramLong);    return (long)((new Random()).nextDouble() * (paramLong - 1L));&#125;private static boolean isLegalAndroidId(String paramString, boolean paramBoolean) &#123;    if (paramBoolean)        return (!TextUtils.isEmpty(paramString) &amp;&amp; ANDROID_ID_PATTERN                .matcher(paramString).find());    return (!TextUtils.isEmpty(paramString) &amp;&amp; ANDROID_ID_PATTERN            .matcher(paramString).find());&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;获取设备唯一标识的方法。&lt;/p&gt;
&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——UI父节点随子节点自适应</title>
    <link href="http://yoursite.com/2022/08/24/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UI%E7%88%B6%E8%8A%82%E7%82%B9%E9%9A%8F%E5%AD%90%E8%8A%82%E7%82%B9%E8%87%AA%E9%80%82%E5%BA%94/"/>
    <id>http://yoursite.com/2022/08/24/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UI%E7%88%B6%E8%8A%82%E7%82%B9%E9%9A%8F%E5%AD%90%E8%8A%82%E7%82%B9%E8%87%AA%E9%80%82%E5%BA%94/</id>
    <published>2022-08-24T11:56:54.000Z</published>
    <updated>2022-08-24T12:11:41.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在UI的开发过程中，经常会遇到Image随子节点的文字变化自动缩放，就是拿Image当背景。笔者遇到这种问题每次都是利用Layout+Content Size Fitter来完成的，笔者想了想每次都要加两个组件，并且Layout只用到了随自己点自适应的功能，于是笔者便想办法把两个功能合成一个脚本来实现需求，于是便有了下面的脚本。  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>代码如下： </p><pre><code>using System;using UnityEngine;using UnityEngine.EventSystems;using UnityEngine.UI;/// &lt;summary&gt;/// 未完成，暂时别用/// &lt;/summary&gt;[AddComponentMenu(&quot;Layout/Rect Transform Fitter&quot;, 142)][ExecuteAlways][RequireComponent(typeof(RectTransform))]public class RectTransformFit : UIBehaviour, ILayoutGroup&#123;    [SerializeField] protected RectTransform m_RectChildren;    [SerializeField] protected RectOffset m_Padding = new RectOffset();    [SerializeField] protected TextAnchor m_ChildAlignment = TextAnchor.UpperLeft;    [SerializeField] protected bool m_ChildControlWidth = false;    [SerializeField] protected bool m_ChildControlHeight = false;    [SerializeField] protected ContentSizeFitter.FitMode m_HorizontalFit = ContentSizeFitter.FitMode.Unconstrained;    [SerializeField] protected ContentSizeFitter.FitMode m_VerticalFit = ContentSizeFitter.FitMode.Unconstrained;    public RectOffset padding    &#123;        get =&gt; m_Padding;        set =&gt; SetProperty(ref m_Padding, value);    &#125;    public TextAnchor childAlignment &#123; get =&gt; m_ChildAlignment;        set =&gt; SetProperty(ref m_ChildAlignment, value);    &#125;    public bool childControlWidth    &#123;        get =&gt; m_ChildControlWidth;        set =&gt; SetProperty(ref m_ChildControlWidth, value);    &#125;    public bool childControlHeight    &#123;        get =&gt; m_ChildControlHeight;        set =&gt; SetProperty(ref m_ChildControlHeight, value);    &#125;    public ContentSizeFitter.FitMode horizontalFit    &#123;        get =&gt; m_HorizontalFit;        set        &#123;            if (SetPropertyUtility.SetStruct(ref m_HorizontalFit, value)) SetDirty();        &#125;    &#125;    public ContentSizeFitter.FitMode verticalFit    &#123;        get =&gt; m_VerticalFit;        set        &#123;            if (SetPropertyUtility.SetStruct(ref m_VerticalFit, value)) SetDirty();        &#125;    &#125;    [NonSerialized] private RectTransform m_Rect;    protected RectTransform rectTransform    &#123;        get        &#123;            if (m_Rect == null)                m_Rect = GetComponent&lt;RectTransform&gt;();            return m_Rect;        &#125;    &#125;#pragma warning disable 649    private DrivenRectTransformTracker m_Tracker;#pragma warning restore 649    private void OnEnable()    &#123;        m_Rect ??= GetComponent&lt;RectTransform&gt;();        SetDirty();    &#125;    protected override void OnRectTransformDimensionsChange()    &#123;        SetDirty();    &#125;    protected override void OnDisable()    &#123;        m_Tracker.Clear();        base.OnDisable();    &#125;    /// &lt;summary&gt;    /// Calculate and apply the horizontal component of the size to the RectTransform    /// &lt;/summary&gt;    public void SetLayoutHorizontal()    &#123;        m_Tracker.Clear();        if (m_RectChildren == null || !m_ChildControlWidth)        &#123;            SetDirty();            return;        &#125;        HandleSelfFittingAlongAxis(0, m_RectChildren);    &#125;    /// &lt;summary&gt;    /// Calculate and apply the vertical component of the size to the RectTransform    /// &lt;/summary&gt;    public void SetLayoutVertical()    &#123;        if (m_RectChildren == null || !m_ChildControlHeight)        &#123;            SetDirty();            return;        &#125;        HandleSelfFittingAlongAxis(1, m_RectChildren);    &#125;    private void HandleSelfFittingAlongAxis(int axis, RectTransform rectChild)    &#123;        if (rectChild == null) return;        var fitting = (axis == 0 ? horizontalFit : verticalFit);        if (fitting == ContentSizeFitter.FitMode.Unconstrained)        &#123;            // Keep a reference to the tracked transform, but don&#39;t control its properties:            m_Tracker.Add(this, rectChild, DrivenTransformProperties.None);            return;        &#125;        m_Tracker.Add(this, rectChild,            (axis == 0 ? DrivenTransformProperties.SizeDeltaX : DrivenTransformProperties.SizeDeltaY));        // Set size to min or preferred size        rectChild.SetSizeWithCurrentAnchors((RectTransform.Axis)axis,            fitting == ContentSizeFitter.FitMode.MinSize                ? LayoutUtility.GetMinSize(rectChild, axis)                : LayoutUtility.GetPreferredSize(rectChild, axis));        SetDirty();    &#125;    /// &lt;summary&gt;    /// Helper method used to set a given property if it has changed.    /// &lt;/summary&gt;    /// &lt;param name=&quot;currentValue&quot;&gt;A reference to the member value.&lt;/param&gt;    /// &lt;param name=&quot;newValue&quot;&gt;The new value.&lt;/param&gt;    protected void SetProperty&lt;T&gt;(ref T currentValue, T newValue)    &#123;        if ((currentValue == null &amp;&amp; newValue == null) || (currentValue != null &amp;&amp; currentValue.Equals(newValue)))            return;        currentValue = newValue;        SetDirty();    &#125;    protected void SetDirty()    &#123;        if (!IsActive())            return;        RefreshRect();        LayoutRebuilder.MarkLayoutForRebuild(m_RectChildren);        LayoutRebuilder.MarkLayoutForRebuild(m_Rect);    &#125;    public void RefreshRect()    &#123;        if (m_RectChildren == null) return;        Vector2 anchoredPos;        var childSize = m_RectChildren.sizeDelta;        var width = childSize.x + padding.left + padding.right;        var height = childSize.y + padding.top + padding.bottom;        var rectSize = rectTransform.sizeDelta;        if (horizontalFit != ContentSizeFitter.FitMode.Unconstrained &amp;&amp;            verticalFit != ContentSizeFitter.FitMode.Unconstrained)        &#123;            rectTransform.sizeDelta = new Vector2(width, height);        &#125;        else if (horizontalFit != ContentSizeFitter.FitMode.Unconstrained)        &#123;            rectTransform.sizeDelta = new Vector2(width, rectSize.y);        &#125;        else if (verticalFit != ContentSizeFitter.FitMode.Unconstrained)        &#123;            rectTransform.sizeDelta = new Vector2(rectSize.x, height);        &#125;        rectSize = rectTransform.sizeDelta;        var oldPos = rectTransform.anchoredPosition;        var oldPivot = rectTransform.pivot;        switch (m_ChildAlignment)        &#123;            case TextAnchor.UpperLeft:                rectTransform.pivot = new Vector2(0, 1);                anchoredPos = new Vector2(padding.left, -padding.top);                break;            case TextAnchor.UpperCenter:                rectTransform.pivot = new Vector2(0.5f, 1);                anchoredPos = new Vector2(0, -padding.top);                break;            case TextAnchor.UpperRight:                rectTransform.pivot = new Vector2(1, 1);                anchoredPos = new Vector2(-padding.right, -padding.top);                break;            case TextAnchor.MiddleLeft:                rectTransform.pivot = new Vector2(0, 0.5f);                anchoredPos = new Vector2(padding.left, 0);                break;            case TextAnchor.MiddleCenter:                rectTransform.pivot = new Vector2(0.5f, 0);                anchoredPos = new Vector2(0, 0);                break;            case TextAnchor.MiddleRight:                rectTransform.pivot = new Vector2(1, 0);                anchoredPos = new Vector2(-padding.right, 0);                break;            case TextAnchor.LowerLeft:                rectTransform.pivot = new Vector2(0, 0);                anchoredPos = new Vector2(padding.left, padding.bottom);                break;            case TextAnchor.LowerCenter:                rectTransform.pivot = new Vector2(0.5f, 0);                anchoredPos = new Vector2(0, padding.bottom);                break;            case TextAnchor.LowerRight:                rectTransform.pivot = new Vector2(1, 0);                anchoredPos = new Vector2(-padding.right, padding.bottom);                break;            default:                throw new ArgumentOutOfRangeException();        &#125;        var pivot = rectTransform.pivot;        rectTransform.anchoredPosition = new Vector2(oldPos.x + rectSize.x * (pivot.x - oldPivot.x),            oldPos.y + rectSize.y * (pivot.y - oldPivot.y));        m_RectChildren.anchorMax = pivot;        m_RectChildren.anchorMin = pivot;        m_RectChildren.pivot = pivot;        m_RectChildren.anchoredPosition = anchoredPos;    &#125;#if UNITY_EDITOR    protected override void OnValidate()    &#123;        SetDirty();    &#125;#endif&#125;</code></pre><h1 id="需要支持的脚本（源码抄来的SetPropertyUtility）"><a href="#需要支持的脚本（源码抄来的SetPropertyUtility）" class="headerlink" title="需要支持的脚本（源码抄来的SetPropertyUtility）"></a>需要支持的脚本（源码抄来的SetPropertyUtility）</h1><pre><code>using System;using System.Collections.Generic;using UnityEngine;internal static class SetPropertyUtility&#123;    private const float Tolerance = 0.000001f;                 //通过此值判断值是否发生变化    public static bool SetColor(ref Color currentValue, Color newValue)    &#123;        if (Math.Abs(currentValue.r - newValue.r) &lt; Tolerance &amp;&amp;            Math.Abs(currentValue.g - newValue.g) &lt; Tolerance &amp;&amp;            Math.Abs(currentValue.b - newValue.b) &lt; Tolerance &amp;&amp;            Math.Abs(currentValue.a - newValue.a) &lt; Tolerance)            return false;        currentValue = newValue;        return true;    &#125;    public static bool SetStruct&lt;T&gt;(ref T currentValue, T newValue) where T : struct    &#123;        if (EqualityComparer&lt;T&gt;.Default.Equals(currentValue, newValue))            return false;        currentValue = newValue;        return true;    &#125;    public static bool SetClass&lt;T&gt;(ref T currentValue, T newValue) where T : class    &#123;        if ((currentValue == null &amp;&amp; newValue == null) || (currentValue != null &amp;&amp; currentValue.Equals(newValue)))            return false;        currentValue = newValue;        return true;    &#125;&#125;</code></pre><h1 id="编辑器显示Editor代码"><a href="#编辑器显示Editor代码" class="headerlink" title="编辑器显示Editor代码"></a>编辑器显示Editor代码</h1><p>代码如下： </p><pre><code>using System;using UnityEditor;using UnityEditor.UI;using UnityEngine;[CustomEditor(typeof(RectTransformFit))]public class RectTransformFitEditor : SelfControllerEditor&#123;    SerializedProperty m_Padding;    SerializedProperty m_ChildAlignment;    SerializedProperty m_RectChildren;    SerializedProperty m_HorizontalFit;    SerializedProperty m_VerticalFit;    SerializedProperty m_ChildControlWidth;    SerializedProperty m_ChildControlHeight;    protected void OnEnable()    &#123;        m_Padding = serializedObject.FindProperty(&quot;m_Padding&quot;);        m_ChildAlignment = serializedObject.FindProperty(&quot;m_ChildAlignment&quot;);        m_RectChildren = serializedObject.FindProperty(&quot;m_RectChildren&quot;);        m_ChildControlWidth = serializedObject.FindProperty(&quot;m_ChildControlWidth&quot;);        m_ChildControlHeight = serializedObject.FindProperty(&quot;m_ChildControlHeight&quot;);        m_HorizontalFit = serializedObject.FindProperty(&quot;m_HorizontalFit&quot;);        m_VerticalFit = serializedObject.FindProperty(&quot;m_VerticalFit&quot;);    &#125;    public override void OnInspectorGUI()    &#123;        serializedObject.Update();        EditorGUILayout.PropertyField(m_Padding, true);        EditorGUILayout.PropertyField(m_ChildAlignment, true);        EditorGUILayout.PropertyField(m_RectChildren, true);        Rect rect = EditorGUILayout.GetControlRect();        rect = EditorGUI.PrefixLabel(rect, -1, EditorGUIUtility.TrTextContent(&quot;Control Child Size&quot;));        rect.width = Mathf.Max(50, (rect.width - 4) / 3);        EditorGUIUtility.labelWidth = 50;        ToggleLeft(rect, m_ChildControlWidth, EditorGUIUtility.TrTextContent(&quot;Width&quot;));        rect.x += rect.width + 2;        ToggleLeft(rect, m_ChildControlHeight, EditorGUIUtility.TrTextContent(&quot;Height&quot;));        EditorGUIUtility.labelWidth = 0;        EditorGUILayout.PropertyField(m_HorizontalFit, true);        EditorGUILayout.PropertyField(m_VerticalFit, true);        serializedObject.ApplyModifiedProperties();    &#125;    void ToggleLeft(Rect position, SerializedProperty property, GUIContent label)    &#123;        bool toggle = property.boolValue;        EditorGUI.showMixedValue = property.hasMultipleDifferentValues;        EditorGUI.BeginChangeCheck();        int oldIndent = EditorGUI.indentLevel;        EditorGUI.indentLevel = 0;        toggle = EditorGUI.ToggleLeft(position, label, toggle);        EditorGUI.indentLevel = oldIndent;        if (EditorGUI.EndChangeCheck())        &#123;            property.boolValue = property.hasMultipleDifferentValues || !property.boolValue;        &#125;        EditorGUI.showMixedValue = false;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在UI的开发过程中，经常会遇到Image随子节点的文字变化自动缩放，就是拿Image当背景。笔者遇到这种问题每次都是利用Layout+Con</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="UGUI" scheme="http://yoursite.com/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>hexo图床图片无法显示</title>
    <link href="http://yoursite.com/2022/08/20/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/hexo%E5%9B%BE%E5%BA%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2022/08/20/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/hexo%E5%9B%BE%E5%BA%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/</id>
    <published>2022-08-20T10:05:02.000Z</published>
    <updated>2022-08-20T10:15:38.397Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>今天更新自己博客的时候发现新博客的图片都无法显示，这个听说只存在于没有域名的博客中，笔者因为没有域名，所以不清除是不是。  </p><blockquote><p>图床：gitee<br>博客：github+hexo<br>原因猜测：gitee开始对图床进行限制，没有域名的博客也访问不到图床的图片  </p></blockquote><p>#解决方法 </p><h2 id="方法一（不推荐）"><a href="#方法一（不推荐）" class="headerlink" title="方法一（不推荐）"></a>方法一（不推荐）</h2><p>最快捷的解决方案就是再自己博客的文章开头加上下面代码   </p><pre><code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</code></pre><p>看下面举例  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1660990253369-2022-8-2018:10:54.png"></p><h2 id="方法二（推荐）"><a href="#方法二（推荐）" class="headerlink" title="方法二（推荐）"></a>方法二（推荐）</h2><p>在自己播放的主题文件加里直接加上就不需要了，具体路径：<br>拿3-hexo主题举例：<br>在**…\themes\3-hexo\layout_partial\header.ejs**文件里加入刚才的代码，如下：  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1660990452909-2022-8-2018:14:13.png">  </p><p>其他主题文件在类似位置：<strong>hexo\themes...\layout_partial\head.ejs</strong><br>其他主题的文件名字应该叫：<strong>head.ejs</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;今天更新自己博客的时候发现新博客的图片都无法显示</summary>
      
    
    
    
    <category term="搭建博客" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="hexo博客" scheme="http://yoursite.com/tags/hexo%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——Unity的Animation无法播放</title>
    <link href="http://yoursite.com/2022/08/20/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Unity%E7%9A%84Animation%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE/"/>
    <id>http://yoursite.com/2022/08/20/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Unity%E7%9A%84Animation%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE/</id>
    <published>2022-08-20T06:57:28.000Z</published>
    <updated>2022-08-20T09:52:46.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>笔者再开发过程中，有个功能需求是在游戏中移动Camera，笔者采用了两种方式，第一种是K动画用动画播放，另一种是用曲线表示运动节奏直线运动。第二种方式和本文无关，主要阐述第一种方式在播放Animation的时候无法播放的问题。  </p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者采用的是Animation的方式播放动画，笔者并未采用Animator，是在游戏中进行动态添加Animation组件，然后根据资源名字动态加载动画资源进行播放，下面是案例代码：  </p><pre><code>public float LookAtAnim(string animName)&#123;    if (!m_Transfrom.TryGetComponent(out Animation animation))    &#123;        animation = m_Transfrom.gameObject.AddComponent&lt;Animation&gt;();    &#125;    var clip = animation.GetClip(animName);    if (clip == null)    &#123;        clip = ResManager.LoadAsset&lt;AnimationClip&gt;(animName);        animation.AddClip(clip, animName);    &#125;    animation.clip = clip;    animation.Play(animName);    return clip.length;&#125;</code></pre><p>但是笔者在运行过程中发现编辑器并不能正常播放动画，通过断点调试，笔者发现在添加动画clip的时候并不能添加到Animation的clip列表里，于是笔者通过各种百度，谷歌等搜索发现需要打开Animation的legacy，修改后的代码如下：</p><pre><code>public float LookAtAnim(string animName)&#123;    ...    if (clip == null)    &#123;        clip = ResManager.LoadAsset&lt;AnimationClip&gt;(animName);        clip.legacy = true;        animation.AddClip(clip, animName);    &#125;    ...&#125;</code></pre><p>这时候动画播放正常了，但是笔者打包成apk后，在模拟器上依旧无法正常播放，笔者打印日志发现动画都正常添加了，于是笔者便尝试解决问题。  </p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>笔者思考**clip.legacy &#x3D; true;**这行代码的作用，于是笔者发现有可能是动画的问题，首先打开inspector的debug模式   </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1660979445735-2022-8-2015:10:46.png"><br>然后发现有些动画的Legacy是打开的，有些是关闭的，于是笔者都手动打开了  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1660979791351-2022-8-2015:16:31.png"><br>发现模拟器依旧没办法播放，最后发现真机上只需要把这个关闭就可以了。<br>笔者最终抛弃了Animation的方法，因为还需要手动加载资源，笔者采用了Animator的方式进行播放。代码如下：  </p><pre><code>/// &lt;summary&gt;/// 播放相机动画/// &lt;/summary&gt;/// &lt;param name=&quot;animName&quot;&gt;动画名字&lt;/param&gt;public float LookAtAnim(string animName)&#123;    SetAnimatorVisible(true);    m_Animator.Play(animName);    return (from animationClip in m_Animator.runtimeAnimatorController.animationClips        where animationClip.name == animName        select animationClip.length).FirstOrDefault();&#125;public void SetAnimatorVisible(bool visible)&#123;    if (m_Animator != null &amp;&amp; m_Animator.enabled == visible) return;    if(visible)    &#123;        if(m_Animator == null)        &#123;            m_Animator = m_Transfrom.gameObject.AddComponent&lt;Animator&gt;();            m_Animator.runtimeAnimatorController =                ResManager.LoadAsset&lt;RuntimeAnimatorController&gt;(TableGlobal.CameraController);        &#125;        else        &#123;            m_Animator.enabled = true;        &#125;    &#125;    else if (m_Animator != null)    &#123;        m_Animator.DOKill();        m_Animator.enabled = false;    &#125;&#125;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>切记要把动画资源的Legacy关闭，否则Animator也无法播放动画片段</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;笔者再开发过程中，有个功能需求是在游戏中移动Camera，笔者采用了两种方式，第一种是K动画用动画播放，另一种是用曲线表示运动节奏直线运动。</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Animation" scheme="http://yoursite.com/tags/Animation/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——根据条件禁用编辑器菜单</title>
    <link href="http://yoursite.com/2022/03/24/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E7%A6%81%E7%94%A8%E7%BC%96%E8%BE%91%E5%99%A8%E8%8F%9C%E5%8D%95/"/>
    <id>http://yoursite.com/2022/03/24/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E7%A6%81%E7%94%A8%E7%BC%96%E8%BE%91%E5%99%A8%E8%8F%9C%E5%8D%95/</id>
    <published>2022-03-24T06:20:07.000Z</published>
    <updated>2022-08-20T09:54:08.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>unity编辑器扩展菜单功能是我们开发中经常使用的，笔者在开发过程中想在特定条件下在启用指定的菜单，不满足条件的时候就禁用菜单，于是笔者找到了解决的办法。  </p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><pre><code>[MenuItem(&quot;Assets/MyMenuTest&quot;, false, 81)]public static void MyMenuTest()&#123;    //菜单执行事件&#125;[MenuItem(&quot;Assets/MyMenuTest&quot;, true)]public static bool IsShowMyMenu()&#123;    //获取自己的条件并return条件即可    return false;&#125;</code></pre><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1648103657696-2022-3-2414:34:18.png">  </p><p>只需要保证MenuItem的菜单路径一样的，把第二个参数改为true代表的是否是控制一个验证函数，根据自己的条件进行返回即可控制。   </p><p>下面是官网给的参数设置<br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1648103567771-2022-3-2414:32:48.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;unity编辑器扩展菜单功能是我们开发中经常使用的，笔者在开发过程中想在特定条件下在启用指定的菜单，不满足条件的时候就禁用菜单，于是笔者找到</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——自动创建asset资源文件</title>
    <link href="http://yoursite.com/2022/03/21/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BAasset%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2022/03/21/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BAasset%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/</id>
    <published>2022-03-21T06:36:13.000Z</published>
    <updated>2022-03-21T06:51:04.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Unity保存数据的方式有很多，比如我们经常用的json，xml和Txt，笔者今天讲到的是另外一种保存方式，asset文件，这个是unity提供的一种新的保存数据的方式，笔者也是刚使用没多久，这里就不详细进行介绍了，笔者今天主要是介绍一键自动创建对应的asset文件。  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code> public class CreateAssetEditor&#123;    [MenuItem(&quot;Assets/Create/CreateAsset&quot;,false,81)]    public static void OnCreateAsset()    &#123;        foreach (var guid in Selection.assetGUIDs)        &#123;            var path = AssetDatabase.GUIDToAssetPath(guid);            var pathSplit = path.Split(&#39;/&#39;);            var className = pathSplit[pathSplit.Length - 1].Replace(&quot;.cs&quot;, &quot;&quot;);            var classType = GetClassByClassName(className);            var assetPath = path.Replace(&quot;.cs&quot;, &quot;.asset&quot;);            if (File.Exists(assetPath))            &#123;                LBLogWrapper.Error(&quot;创建失败，资源已经存在&quot;);            &#125;            else if (classType != null)             &#123;                var classInst = ScriptableObject.CreateInstance(classType);                AssetDatabase.CreateAsset(classInst,assetPath);            &#125;            else            &#123;                LBLogWrapper.Error(&quot;创建失败，脚本不可创建&quot;);            &#125;        &#125;    &#125;        [MenuItem(&quot;Assets/Create/CreateAsset&quot;,true)]    private static bool IsValidateFun()    &#123;        return (from guid in Selection.assetGUIDs            select AssetDatabase.GUIDToAssetPath(guid)            into path            select path.Split(&#39;/&#39;)            into pathSplit            select pathSplit[pathSplit.Length - 1]).Any(className =&gt; className.Contains(&quot;.cs&quot;));    &#125;    /// &lt;summary&gt;    /// 通过类名获取对应的类    /// &lt;/summary&gt;    /// &lt;param name=&quot;className&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    private static Type GetClassByClassName(string className)    &#123;        var allAssemblies = AppDomain.CurrentDomain.GetAssemblies();        return allAssemblies.SelectMany(assembly =&gt; assembly.GetTypes()).FirstOrDefault(type =&gt;            type.Name == className &amp;&amp; type.IsSubclassOf(typeof(ScriptableObject)));    &#125;&#125;</code></pre><p>脚本的原理很简单，就是获取当前选择的脚本，判断是否可以创建asset文件，如果可以就是通过类名获取对应的类对象和，这里需要注意的是，<font color="red">文件名字必须等于类名</font>，然后通过类名获取对应的类型，就可以生成对应的asset文件了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Unity保存数据的方式有很多，比如我们经常用的json，xml和Txt，笔者今天讲到的是另外一种保存方式，asset文件，这个是unity</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="asset" scheme="http://yoursite.com/tags/asset/"/>
    
  </entry>
  
</feed>
