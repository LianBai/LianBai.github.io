<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LianBai</title>
  
  <subtitle>手握日月摘星辰，世间无我这般人。</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-12-27T03:39:09.484Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LianBai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2021/12/27/hello-world/"/>
    <id>http://yoursite.com/2021/12/27/hello-world/</id>
    <published>2021-12-27T03:39:09.484Z</published>
    <updated>2021-12-27T03:39:09.484Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Unity杂文——海外开发踩坑笔记</title>
    <link href="http://yoursite.com/2021/07/09/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%B5%B7%E5%A4%96%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/07/09/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%B5%B7%E5%A4%96%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</id>
    <published>2021-07-09T10:25:32.000Z</published>
    <updated>2021-12-27T03:39:09.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><h2 id="Gradle版本问题"><a href="#Gradle版本问题" class="headerlink" title="Gradle版本问题"></a>Gradle版本问题</h2><p>本地打包的大部分错误都是因为这个问题，这是因为笔者接入的SDK自定义了gradle的插件版本，这个再unity本身其实已经定义过了，但是自己是可以通过修改build.gradle进行修改的。查看unity本身gradel的插件版本的路径是：Editor\Data\PlaybackEngines\AndroidPlayer\Tools\GradleTemplates\baseProjectTemplate.gradle,以2019.4.28版本为例，里面代码为：  </p><pre><code>// GENERATED BY UNITY. REMOVE THIS COMMENT TO PREVENT OVERWRITING WHEN EXPORTING AGAINallprojects &#123;    buildscript &#123;        ***        dependencies &#123;            ***            classpath &#39;com.android.tools.build:gradle:3.4.0&#39;            **BUILD_SCRIPT_DEPS**        &#125;    &#125;    ***&#125;***</code></pre><p>如上图，可以看到插件版本为3.4.0，如果unity里本身修改了baseProjectTemplate.gradle就按照修改后的来，这个文件夹内所有的gradle和properties都是默认的，如果程序里修改就按照程序里的来。修改的方法在Editor–&gt;ProjectSettings–&gt;Player–&gt;Publishing Settings，如下图所示：  </p><p>  <img src="https://file.liangxiegame.com/f69ca480-57fe-4313-8391-4318b1cead9a.png" alt="image.png">   </p><p>如上图，其实就是对应编辑器文件夹下的gradle文件，如果打勾就会在pluging/Android文件夹下生成对应的文件，就可以直接修改，不再按照unity默认的来，就可以修改配置了。</p><p>经过上面的介绍已经知道如何查看并修改unity的gradle插件版本，下面就是修改对应的gradle版本。首先打开Editor–&gt;Preference–&gt;External Tools就可以看到Android的打包环境配置。  </p><p><img src="https://file.liangxiegame.com/13b80d7b-6dd0-4fdd-8199-82222a81d8e2.png" alt="image.png">   </p><p>2020版本以后的Unity是默认路径下就自己配置好环境，选择默认就可以，但是依旧可能会存在环境不存在或者版本不对，所以可以自己配置，这样修改也方便。这里有需要特别关注的一点也是大部分打包失败的原因，就是gradle的版本和对应的插件版本是有对照关系的，必须对照上才能正常打包。对应关系如下图：  </p><p><img src="https://file.liangxiegame.com/10319033-5e95-4d83-a544-060a7ff6cac3.png" alt="image.png">   </p><p>只要配置好对应的关系就行了。  </p><h2 id="NDK版本问题"><a href="#NDK版本问题" class="headerlink" title="NDK版本问题"></a>NDK版本问题</h2><p>在打包的时候也遇到了NDK版本不对无法打包的问题，打包失败会提示打包需要的版本，下载对应的版本即可，笔者打包的时候需要的是版本19，但是下载19版本依旧无法打包，这是因为版本的小版本依旧对不上，这里可以不用找对应的小版本，只要对应的大版本一样，在自己ndk安装目录下，找到source.properties文件，编辑文件，如下，修改对应的<strong>Pkg.Revision</strong>即可。  </p><pre><code>Pkg.Desc = Android NDKPkg.Revision = 19.0.5232133</code></pre><h2 id="maven仓库下载问题"><a href="#maven仓库下载问题" class="headerlink" title="maven仓库下载问题"></a>maven仓库下载问题</h2><p>这个问题是打包的时候并没有找到对应的maven仓库，笔者接入的SDK需要的maven都写在了launcherTemplate文件里，但是打包的时候并没有找到仓库，这是因为maven的仓库应该写在mainTemplate文件里，在launcherTemplate文件里可能会存在没有下载到的情况。  </p><h2 id="API版本问题API"><a href="#API版本问题API" class="headerlink" title="API版本问题API"></a>API版本问题API</h2><p>这里牵扯到两个API的版本，分别是minSdkVersion和targetSdkVersion，打包的时候会报错版本问题，这里只需要在Editor–&gt;ProjectSettings–&gt;Player–&gt;Other Settings里修改对应的Minimum API Level和Target API Level，修改到要求的版本或者更高的版本即可。  </p><p><img src="https://file.liangxiegame.com/8f76046e-d068-4e4a-a7f0-09db7505453d.png" alt="image.png">   </p><h2 id="APK-obb分包无法运行问题"><a href="#APK-obb分包无法运行问题" class="headerlink" title="APK+obb分包无法运行问题"></a>APK+obb分包无法运行问题</h2><p>因为Google商店对上传的apk有内存限制，要求是100M以内，这里推荐使用的是APk+OBB进行分包，根据最新的要求是要求使用AAB包，这里先介绍APK+OBB的分包遇到的问题。  </p><p>分开打包的方法是Editor–&gt;ProjectSettings–&gt;Player–&gt;Publishing Settings里，勾选上最下面的Split Application Binary。 </p><p><img src="https://file.liangxiegame.com/1ce243b5-e799-4710-a446-0e141fc2a4c1.png" alt="image.png">    </p><p>这个是可以代码控制的：  </p><pre><code>PlayerSettings.Android.useAPKExpansionFiles = true;</code></pre><p>分包后如何在手机上运行呢，这里只需要安装分包后的APK，然后在手机上运行，发现第一次运行不成功，这是因为资源都在OBB中，所以无法正常运行，这里只需要吧自己的OBB改好名字放在对应的文件夹就行了。然后再运行就可以了。   </p><p>文件夹地址：手机目录\Android\obb&quot;APP的包名”<br>OBB文件的名字: main.安卓内部版本号.APP包名.obb (举例：main.102.com.XXX.XXX.XXX.obb)</p><h2 id="打包AAB报错-FileNotFoundException-Temp-launcher-aab-does-not-exist"><a href="#打包AAB报错-FileNotFoundException-Temp-launcher-aab-does-not-exist" class="headerlink" title="打包AAB报错:FileNotFoundException: Temp...\launcher.aab does not exist"></a>打包AAB报错:FileNotFoundException: Temp...\launcher.aab does not exist</h2><p>打包aab的方法就是打开File–&gt;Build Settings的面板，然后勾选上Build AppBundle(Google Play)再进行打包就可以了。  </p><p><img src="https://file.liangxiegame.com/09a6726f-1fd1-4805-be17-d0bbb3ad5481.png" alt="image.png">   </p><p>这个报错网上查了一下原因，说的是因为gradle版本过高，导致unity内部逻辑出错的问题。笔者的gradle的版本确实比unity自带的版本过高，于是利用网上给的解决方案解决了。解决方法是在launcher的gradle的defaultConfig里添加下面代码，笔者不导出安卓工程于是就在launcherTemplate的defaultConfig里添加了下列的代码。  </p><pre><code>defaultConfig &#123;    ***    //打包abb的话需要这个    tasks.whenTaskAdded &#123;        task -&gt;        if (task.name.startsWith(&quot;bundle&quot;)) &#123;                   def renameTaskName = &quot;rename$&#123;task.name.capitalize()&#125;Aab&quot;            def flavor = task.name.substring(&quot;bundle&quot;.length()).uncapitalize()            tasks.create(renameTaskName, Copy) &#123;                       def path = &quot;$&#123;buildDir&#125;/outputs/bundle/$&#123;flavor&#125;/&quot;                from(path)                include &quot;launcher-release.aab&quot;                destinationDir file(&quot;$&#123;buildDir&#125;/outputs/bundle/$&#123;flavor&#125;/&quot;)                rename &quot;launcher-release.aab&quot;, &quot;launcher.aab&quot;            &#125;                 task.finalizedBy(renameTaskName)        &#125;    &#125;&#125;</code></pre><h2 id="AAB格式手机安装方法"><a href="#AAB格式手机安装方法" class="headerlink" title="AAB格式手机安装方法"></a>AAB格式手机安装方法</h2><p>首先需要把aab格式的安装包解析成apks格式的安装包，在解析的时候需要一个jar的包，这个jar包是bundletool-all-1.6.1，版本不要求一定是1.6.1，解析的方法是下面CMD的命令：  </p><pre><code>java -jar &lt;bundletool.jar的路径&gt; build-apks --bundle=&lt;.aab文件的路径&gt; --output=&lt;输出.apks的路径&gt; --ks=&lt;打包.aab文件时的秘钥文件路径，如果.aab文件时没有使用秘钥则可以省去秘钥环节的配置&gt; --ks-pass=pass:&lt;秘钥密码&gt; --ks-key-alias=&lt;秘钥别名&gt; --key-pass=pass:&lt;秘钥别名密码&gt; --device-spec=&lt;要输出的目标sdkVersion的APK的json配置文件路径&gt;</code></pre><p>举例：  </p><pre><code>java -jar C:\Users\XX\Desktop\bundletool-all-1.0.0.jar build-apks --bundle=C:\Users\XX\Desktop\test23.aab --output=C:\Users\XX\Desktop\test23.apks --ks=G:\Client\Trunk\key\user.keystore --ks-pass=pass:abcdef --ks-key-alias=yunzhong --key-pass=pass:abcdef --device-spec=C:\Users\XX\Desktop\config.json</code></pre><p>然后手机链接电脑，打开调试模式，接着调用CMD的安装命令：  </p><pre><code>java -jar C:\Users\XX\Desktop\bundletool-all-1.6.1.jar install-apks --apks=C:\Users\XX\Desktop\test23.apks  </code></pre><p>安装结束后手机上就存在自己需要的安装包了。  </p><h2 id="报错Illegal-usage-of-unity-detected-shutdown-unity"><a href="#报错Illegal-usage-of-unity-detected-shutdown-unity" class="headerlink" title="报错Illegal usage of unity detected, shutdown unity"></a>报错Illegal usage of unity detected, shutdown unity</h2><p>分包之后笔者运行发现APP直接闪退，看了半天日志最后发现了一句报错是Illegal usage of unity detected, shutdown unity。笔者使用的是unity2019.4.26f1c1(中国版，以后的中国版本后面都会有个c)。通过百度发现Unity中国版2019.4版本再分割obb编译的时候会导致这个错误，其他版本还没试过，不知道会不会有这个问题。发现只需要使用国际版本即可。  </p><h2 id="报错DSL-element-‘useProguard’-is-obsolete-and-will-be-removed-soon-Use-‘android-enableR8’-in-gradle-pro"><a href="#报错DSL-element-‘useProguard’-is-obsolete-and-will-be-removed-soon-Use-‘android-enableR8’-in-gradle-pro" class="headerlink" title="报错DSL element ‘useProguard’ is obsolete and will be removed soon. Use ‘android.enableR8’ in gradle.pro"></a>报错DSL element ‘useProguard’ is obsolete and will be removed soon. Use ‘android.enableR8’ in gradle.pro</h2><p>出现这个警告是因为build.gradle里配置了 ‘useProguard’属性，而这个属性将很快被移除，使用‘android.enableR8’来代替。这里只需要在gradleTemplate.properties文件后面添加下面一句话就可以了： </p><pre><code>android.enableR8 = true</code></pre><h2 id="报错自己定义的Application丢失"><a href="#报错自己定义的Application丢失" class="headerlink" title="报错自己定义的Application丢失"></a>报错自己定义的Application丢失</h2><p>打包后出现自己写的Application脚本丢失，这个大部分是因为AndroidManifest没有配置自己的Application，配置方法这里就不多做介绍，网上很多介绍。笔者这里遇到的并不是因为没有配置，是因为笔者接入的SDK是继承的MultiDexApplication，这里需要注意的是如果您的 minSdkVersion 设为 21 或更高版本，系统会默认启用 MultiDex，并且您不需要 MultiDex 库。<br>不过，如果您的 minSdkVersion 设为 20 或更低版本，您必须使用 MultiDex 库并对应用项目进行以下修改：</p><pre><code>android &#123;    defaultConfig &#123;        ...        multiDexEnabled true    &#125;    ...&#125;dependencies &#123;    implementation &quot;androidx.multidex:multidex:2.0.1&quot;&#125;</code></pre><p>此时重新编译打包后发现果然打包出多个dex文件，在安卓6.0上测试完美运行，并且用360加固以后5.0以上都能正常运行。<br>但是坑来了 ：在5.0，5.1系统上一运行就奔溃！<br>后来知道在高版本系统上使用art支持多dex，而低版本dalvik默认先加载主dex，如果启动时需要的类不在主dex内就会报错ClassNotFoundException。 解压apk发现里面有上百个dex文件，一般不会拆分如此多，百度查阅后得知：<br>对于dex 的–multi-dex 选项设置与预编译的library工程有冲突,如果你的应用中包含引用的lirary工程,需要将预编译设置为false:<br>在 build.gradle中添加  </p><pre><code>dexOptions&#123;    preDexLibraries = false&#125;</code></pre><h1 id="SDK遇到问题"><a href="#SDK遇到问题" class="headerlink" title="SDK遇到问题"></a>SDK遇到问题</h1><h2 id="华为手机出现水滴屏无法适配的问题"><a href="#华为手机出现水滴屏无法适配的问题" class="headerlink" title="华为手机出现水滴屏无法适配的问题"></a>华为手机出现水滴屏无法适配的问题</h2><p>笔者的项目要求手机在遇到水滴屏或者刘海屏的时候，上面显示黑条不进行渲染就可以，笔者查了一下unity的设置方法，发现只需要不勾选Editor–&gt;ProjectSettings–&gt;Resolution and Presentation里的Render outside safe area即可。  </p><p><img src="https://file.liangxiegame.com/45f3375d-4006-40a8-a599-3efb2978e578.png" alt="image.png">   </p><p>但是笔者发现APP在某个测试的华为手机上依旧渲染了，最后发现是接入的SDK里设置了华为手机的屏幕渲染。在华为手机Android8.0的适配方案是在AndroidManfiest里面添加下面的话即可，笔者发现接入的SDK设置了这个，于是去掉就没有问题了。  </p><pre><code>&lt;meta-data android:name=&quot;android.notch_support&quot; android:value=&quot;true&quot;/&gt; </code></pre><p>这里列举一下小米手机的适配方案是：  </p><pre><code>&lt;meta-data android:name=&quot;notch.config&quot; android:value=&quot;portrait|landscape&quot;/&gt;</code></pre><h2 id="如何修改build-gradle"><a href="#如何修改build-gradle" class="headerlink" title="如何修改build.gradle"></a>如何修改build.gradle</h2><p>关于对Android的gradle的脚本进行修改，其实上面已经介绍了。Pluging/Android文件夹下的XXXTemplate对应的其实就是导出android工程下的build.gradle，修改对应的Template就是修改对应的build.gradle。  </p><h2 id="如何添加Android需要的java脚本"><a href="#如何添加Android需要的java脚本" class="headerlink" title="如何添加Android需要的java脚本"></a>如何添加Android需要的java脚本</h2><p>首先导出一个安卓工程，然后用AndroidStudio打开导出的Android工程，然后直接在安卓工程里写对应的脚本，脚本完成后直接复制到unity工程中pluging下Android文件夹下面。这里因为每次都要复制文件，所以笔者写了一个脚本直接一键复制所有的bat脚本。脚本内容如下：  </p><pre><code>@echo offset filePath=unityLibrary\src\main\java\com\ksset targetFilePath=..\..\project\Assets\Plugins\Androidfor /R %filePath% %%i in (*.java) do (    xcopy /y /c /h /r %%i %targetFilePath%    echo %%i)pause</code></pre><p>后来发现每次改好脚本后，还需要找到这个bat文件执行，于是笔者简化了这个步骤，笔者添加了一个unity的编辑器脚本，用于执行这个bat文件。脚本内容如下：  </p><pre><code>public static void SyncAndroidJava2()&#123;    var filepath = FileEditorTools.FormatPath(Application.dataPath + &quot;/../../android/AndroidBDSDK_R/&quot;);    RunBat(&quot;CopyJavaScripts.bat&quot;, &quot;&quot;, filepath);&#125;//cmd是执行的脚本的名字    args是参数，可以直接设置为“”        workingDir是执行bat文件所在文件夹路径public static System.Diagnostics.Process CreateShellExProcess(string cmd, string args, string workingDir = &quot;&quot;)&#123;    var pStartInfo = new System.Diagnostics.ProcessStartInfo(cmd);    pStartInfo.Arguments = args;    pStartInfo.CreateNoWindow = false;    pStartInfo.UseShellExecute = true;    pStartInfo.RedirectStandardError = false;    pStartInfo.RedirectStandardInput = false;    pStartInfo.RedirectStandardOutput = false;    if (!string.IsNullOrEmpty(workingDir))        pStartInfo.WorkingDirectory = workingDir;    return System.Diagnostics.Process.Start(pStartInfo);&#125;public static void RunBat(string batfile, string args, string workingDir = &quot;&quot;)&#123;    var p = CreateShellExProcess(batfile, args, workingDir);    p.Close();&#125;</code></pre><p>在执行bat脚本的时候笔者发现，自己完全可以写一个复制用的脚本，就不需要再依靠bat脚本进行执行。脚本如下：<br>    public static void SyncAndroidJava()<br>    {<br>        var filepath = FileEditorTools.FormatPath(Application.dataPath + “/../../android/AndroidBDSDK_R/unityLibrary/src/main/java/com/ks/“);            //需要复制的java文件所在的文件夹<br>        var folderpath = Application.dataPath + “/Plugins/Android/“;            //复制到的文件位置<br>        var filelist = FileEditorTools.GetallFile(filepath, “.java”);</p><pre><code>    var curcount = 0;    var sumcount = filelist.Count;        EditorUtility.DisplayProgressBar(&quot;同步Android的Java脚本&quot;, &quot;开始复制文字...&quot;, 0);    foreach (var javafile in filelist)    &#123;        EditorUtility.DisplayProgressBar(&quot;复制文件&quot;, javafile.FullName, (float)curcount / sumcount);        // 判断目标目录是否存在如果不存在则新建        try        &#123;            FileEditorTools.CopyFileToFolder(javafile,folderpath);        &#125;        catch (Exception e)        &#123;            Debug.LogError(e);            EditorUtility.ClearProgressBar();            return;        &#125;        Debug.Log(javafile.FullName);        curcount++;    &#125;    EditorUtility.ClearProgressBar();&#125;public class FileEditorTools&#123;    // 文件列表    private static List&lt;FileInfo&gt; _FileList = new List&lt;FileInfo&gt;();        #region   公有方法    /// &lt;summary&gt;    /// 获得目录下所有文件或指定文件类型文件(包含所有子文件夹)    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件夹路径&lt;/param&gt;    /// &lt;param name=&quot;extName&quot;&gt;扩展名可以多个 例如[.mp4] [.mp3] [.wma] 等&lt;/param&gt;    /// &lt;returns&gt;List&lt;FileInfo&gt;&lt;/returns&gt;    public static List&lt;FileInfo&gt; GetallFile(string path, string extName)    &#123;        //检查目录是否存在        if (!string.IsNullOrWhiteSpace(path))        &#123;            if (Directory.Exists(path))            &#123;                GetallfilesOfDir(path, extName);            &#125;            else            &#123;                Directory.CreateDirectory(path);            &#125;        &#125;        else        &#123;            //注意这里的EverydayLog.Write()是我自定义的日志文件，可以根据需要保留或删除            Debug.LogError(&quot;GetAllFileOfFolder/GetallFile()/存储视频文件的路径为空，请检查！！！&quot; );        &#125;        return _FileList;    &#125;    public static void CopyFileToFolder(FileInfo fileinfo,string fildername)    &#123;        var destfilename = FormatPath(fildername+fileinfo.Name);        File.Copy(fileinfo.FullName, destfilename, true);    &#125;        public static string FormatPath(string path)    &#123;        path = path.Replace(&quot;/&quot;, &quot;\\&quot;);        if (Application.platform == RuntimePlatform.OSXEditor)            path = path.Replace(&quot;\\&quot;, &quot;/&quot;);        return path;    &#125;    #endregion        #region   私有方法    /// &lt;summary&gt;    /// 递归获取指定类型文件,包含子文件夹    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;指定文件夹的路径&lt;/param&gt;    /// &lt;param name=&quot;extName&quot;&gt;文件拓展名&lt;/param&gt;    private static void GetallfilesOfDir(string path, string extName)    &#123;        try        &#123;            string[] dir = Directory.GetDirectories(path); //文件夹列表               DirectoryInfo fdir = new DirectoryInfo(path);            FileInfo[] file = fdir.GetFiles();            if (file.Length != 0 || dir.Length != 0) //当前目录文件或文件夹不为空                               &#123;                foreach (FileInfo f in file) //显示当前目录所有文件                   &#123;                    if (extName.ToLower().IndexOf(f.Extension.ToLower()) &gt;= 0)                    &#123;                        _FileList.Add(f);                    &#125;                &#125;                foreach (string d in dir)                &#123;                    GetallfilesOfDir(d, extName);//递归                   &#125;            &#125;        &#125;        catch (Exception ex)        &#123;            //注意这里的EverydayLog.Write()是我自定义的日志文件，可以根据需要保留或删除            Debug.LogError(&quot;/GetAllFileOfFolder()/GetallfilesOfDir()/获取指定路径：&quot;+path+&quot;   下的文件失败！！！，错误信息=&quot;+ex.Message);        &#125;    &#125;    #endregion    &#125;</code></pre><h2 id="设备唯一标识"><a href="#设备唯一标识" class="headerlink" title="设备唯一标识"></a>设备唯一标识</h2><p>这里的设备唯一标识一开始笔者用的是设备的OAID，后来发现有些设备并不能获取到设别的OAID，并且换位的手机如果打开了”关闭广告追踪“，那么获取的OAID所以这个并不能作为设别的唯一标识，网上有很多进行多数据拼接的方法，于是笔者从自己公司的SDK摘取了或者设备唯一标识的方法，这是一个比较简单的方法，就是先获取设备的androidID，如果获取不到就会自己保存一个数据到文件里，然后每次从文件里读取就行了。  </p><pre><code>private static String deviceId;public String GetDeviceID() &#123;    Application yourApplicatoin = this;            //这里只是举个例子，这里需要大家获取一下自己的Application    if (yourApplicatoin.getApplicationContext() == null) //这里是获取Application的实例，如果没有就可以直接返回空        return &quot;&quot;;    else &#123;        String var1;        if ((var1 = deviceId) != null)            //先判断deviceID是否已经赋值过了，如果已经赋值就直接返回就行了            return var1;        else &#123;            deviceId = getSPValue(yourApplicatoin, &quot;DeviceId&quot;);    //如果没有就先从文件里获取一下            if (!TextUtils.isEmpty(deviceId)) &#123;                    //如果获取到了就直接返回                return deviceId;            &#125; else &#123;                deviceId = getAndroidIdAsDeviceId(yourApplicatoin);    //如果文件里没有就先尝试获取一下androidID作为设备唯一标识                if (!TextUtils.isEmpty(deviceId)) &#123;                    //获取到了就进行保存并返回这个标识                    saveSPValue(yourApplicatoin, &quot;DeviceId&quot;, deviceId);                        return deviceId;                &#125; else &#123;                    deviceId = generateSoftDeviceId();                //如果没有获取到就通过自己的混合加密方式进行缓存                    if (!TextUtils.isEmpty(deviceId)) &#123;                //如果不为空就保存然后返回标识                        saveSPValue(yourApplicatoin, &quot;DeviceId&quot;, deviceId);                        return deviceId;                    &#125; else &#123;                                        //如果都没获取到就是特殊情况，直接返回                        return deviceId;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="保存DeviceID到文件里"><a href="#保存DeviceID到文件里" class="headerlink" title="保存DeviceID到文件里"></a>保存DeviceID到文件里</h2><p>通过getSharedPreferences方法将deviceid保存到文件里。</p><pre><code>private static void saveSPValue(Context mycontext, String datakey, String datavalue) &#123;    mycontext.getSharedPreferences(&quot;myappsdkdeviceid&quot;, 0).edit().putString(&quot;datakey&quot;, datavalue).apply();&#125;</code></pre><p>myappsdkdeviceid是文件名字，datakey是保存的关键字名字，然后datavalue是储存的值，就是我们要储存的deviceid。  </p><h2 id="从文件里获取DeviceID"><a href="#从文件里获取DeviceID" class="headerlink" title="从文件里获取DeviceID"></a>从文件里获取DeviceID</h2><pre><code>private static String getSPValue(Context mycontext, String datakey) &#123;    return var0.getSharedPreferences(&quot;myappsdkdeviceid&quot;, 0).getString(datakey, (String)null);&#125;</code></pre><p>myappsdkdeviceid是文件名字，datakey是保存的关键字名字。 </p><h2 id="获取设备的AndroidID"><a href="#获取设备的AndroidID" class="headerlink" title="获取设备的AndroidID"></a>获取设备的AndroidID</h2><pre><code>private static String getAndroidIdAsDeviceId(Context mycontext) &#123;    String andid = Settings.Secure.getString(mycontext.getContentResolver(), &quot;android_id&quot;);    //获取设备的AndroidID    return isLegalAndroidId(andid) ? &quot;ANDROID_&quot; + andid : null;                //如果符合条件就添加前缀，不符合就返回空&#125;private static final Pattern ANDROID_ID_PATTERN = Pattern.compile(&quot;^[0-9a-fA-F]&#123;16&#125;$&quot;);private static boolean isLegalAndroidId(String andid) &#123;                                return !TextUtils.isEmpty(andid) &amp;&amp; ANDROID_ID_PATTERN.matcher(andid).find();&#125;</code></pre><p>第二个函数是判断获得到的android是否不为空并且符合正则表达式的规则  </p><h2 id="自定义的设备唯一标识"><a href="#自定义的设备唯一标识" class="headerlink" title="自定义的设备唯一标识"></a>自定义的设备唯一标识</h2><pre><code>private static long randomLong(long var0) &#123;    return Build.VERSION.SDK_INT &gt;= 21 ? ThreadLocalRandom.current().nextLong(var0) : (long)((new Random()).nextDouble() * (double)(var0 - 1L));&#125;private static String generateSoftDeviceId() &#123;    String arg0  = Build.SERIAL;            //首先获取序列号    if (TextUtils.isEmpty(arg0)) &#123;            //如果没有获取到序列化就赋值为&quot;NA&quot;        arg0 = &quot;NA&quot;;    &#125;    long arg1 = 2564562216496361285L;        //设置两个随机的long型的数据    long arg2 = 8545649582269949258L;    arg2 = randomLong(arg2);        //获取一个随机数，获取失败就调回去重新获取    arg1 += arg2;    String var8 = &quot;ANDROID_%1$s_%2$s&quot;;        //设置一下格式    Object[] arg3 = new Object[2];    arg3[0] = Long.toHexString(arg1);        //设置第一个参数    try &#123;        arg3[1] = arg0;                        //设置第二个参数        return String.format(var8, arg3);    &#125; catch (Throwable var3) &#123;    &#125;    Object[] arg4;                            //如果上述存在问题就根据时间设置一个随机数    Object[] arg5 = arg4 = new Object[2];    arg5[0] = &quot;NA&quot; + Long.toHexString(System.currentTimeMillis());    arg5[1] = arg0;    return String.format(&quot;ANDROID_%1$s_%2$s&quot;, arg4);&#125;</code></pre><h1 id="AWS-亚马逊-的CDN上传"><a href="#AWS-亚马逊-的CDN上传" class="headerlink" title="AWS(亚马逊)的CDN上传"></a>AWS(亚马逊)的CDN上传</h1><h2 id="网页上传"><a href="#网页上传" class="headerlink" title="网页上传"></a>网页上传</h2><p>这种上传方式就是访问网页，然后按照需求把自己需要上传的文件上传到对应网页的进行上传。  </p><h2 id="自动上传"><a href="#自动上传" class="headerlink" title="自动上传"></a>自动上传</h2><p>笔者采用的是利用python环境然后写的bat脚本进行上传。  </p><h2 id="Python环境配置"><a href="#Python环境配置" class="headerlink" title="Python环境配置"></a>Python环境配置</h2><p>首先需要在Python虚拟环境中安装 AWS CLI  </p><pre><code>$ pip install awscli</code></pre><p>这里介绍一个python比较好的版本管理工具，可以管理本地多版本的python。<a href="https://www.jianshu.com/p/d66fce9a7bdc"><font color=steelblue size=3>pyenv</font></a>   </p><h2 id="aws版本查看"><a href="#aws版本查看" class="headerlink" title="aws版本查看"></a>aws版本查看</h2><pre><code>$ aws --version</code></pre><p><img src="https://file.liangxiegame.com/12c0d1cf-5a76-4322-bbb6-55654310b33d.png" alt="image.png">   </p><h2 id="更新aws"><a href="#更新aws" class="headerlink" title="更新aws"></a>更新aws</h2><pre><code>$ aws install awscli --upgrade</code></pre><h2 id="卸载aws"><a href="#卸载aws" class="headerlink" title="卸载aws"></a>卸载aws</h2><pre><code>$ pip uninstall awscli  </code></pre><h2 id="配置AWS-CLI"><a href="#配置AWS-CLI" class="headerlink" title="配置AWS CLI"></a>配置AWS CLI</h2><pre><code>$ aws configureAWS Access Key ID [None]: *******AWS Secret Access Key [None]: *******Default region name [None]: us-east-2Default output format [None]: json</code></pre><p>这里分辨需要填上对应的参数，上面的ID和Key就是自己页面申请aws给提供的。下面的json也只输出的格式，这里最关键的其实是<strong>Default region name</strong>，这里并不是随便填的，而是填上aws终端节点对应的区域代码。  </p><p><img src="https://file.liangxiegame.com/63176da0-0361-49ed-8413-00163af95287.png" alt="image.png">   </p><p>这里其实会再打开终端的目录生成一个.aws文件夹，里面会有config和credentials两个文件就是我们的配置文件了。  </p><h2 id="aws与s3配合使用"><a href="#aws与s3配合使用" class="headerlink" title="aws与s3配合使用"></a>aws与s3配合使用</h2><p>想要使用aws cli上传文件需要与s3配合使用。  </p><h3 id="列举自己的库"><a href="#列举自己的库" class="headerlink" title="列举自己的库"></a>列举自己的库</h3><pre><code>$ aws s3 ls  </code></pre><h3 id="列举库中文件夹内容"><a href="#列举库中文件夹内容" class="headerlink" title="列举库中文件夹内容"></a>列举库中文件夹内容</h3><pre><code>$ aws s3 ls s3://my-bucket  </code></pre><h3 id="上传文件到s3的库"><a href="#上传文件到s3的库" class="headerlink" title="上传文件到s3的库"></a>上传文件到s3的库</h3><pre><code>$aws s3 cp my-file s3://my-bucket/my-folder</code></pre><p>如果每次都使用上面的命令传输文件还是比较麻烦的，所以笔者自己写了一个简单的bat脚本，可以更方便的上传文件  </p><pre><code>@echo offset filePath=..\resource\cdnfileroot\resource\packres\default-pack\android-defaultset cdnPath=s3://cyber-era-cdn/resource/packres/default-pack/android-defaultcall cd %filePath%for %%i in (*.zip) do (    call aws s3 cp %%i %cdnPath%/%%i    echo %%i)pause</code></pre><h1 id="海外文本替换"><a href="#海外文本替换" class="headerlink" title="海外文本替换"></a>海外文本替换</h1><h2 id="提取Prefab中文字到表里"><a href="#提取Prefab中文字到表里" class="headerlink" title="提取Prefab中文字到表里"></a>提取Prefab中文字到表里</h2><p>这里是把prefab上的文字全部提取到一个自定定义的Language表里。首先需要读取自定义的Language表里的数据，这是为了去重用的。然后加载本地所有的prefab，再遍历prefab所有的节点，然后判断是否包含Text的组件，如果包含文字就把文字记录在自己的字典中。在放进字典中是需要排重的。<br>加载Prefab的代码  </p><pre><code>private static void doLoadPrefab(bool clearText,bool onlyFindText = false)        //两个参数分别是是否清除Text组件和是否之查找文本，下面会有详细介绍&#123;    ...    if (string.IsNullOrEmpty(ExportExcel.excelFolder))        //接下来是查找自己的需要导入的表，不存在就创建一个新的表    &#123;        excelPath = EditorUtility.OpenFilePanel(&quot;选择SVN中的ProgramLanguage表&quot;,&quot;&quot;,&quot;&quot;);    &#125;    else    &#123;        excelPath = ExportExcel.excelFolder + &quot;/ProgramLanguage.xlsx&quot;;    &#125;    if (!string.IsNullOrEmpty(excelPath))    &#123;        ReadExcel();                                        //进行读取加载表格        LoadAllPrefabText(clearText,onlyFindText);            //进行加载所有prefab的文本内容        if (clearText)                                        //如果是清除文本组件的就只是需要清除字典        &#123;            textDesAddDic.Clear();        &#125;        else                                                //如果不是清除的就把读取内容写入到表格中        &#123;            WroadExcel();        &#125;    &#125;&#125;</code></pre><p>读取Language代码如下:  </p><pre><code>private static int exKey;private static string exValue;public static void ReadExcel()&#123;    var attrArr = File.GetAttributes(excelPath);            //这个是获取表格的属性，因为有些表格可能是只读属性，需要修改    File.SetAttributes(excelPath, FileAttributes.Normal);    //把表格的属性设置成普通属性，这样就一定能写入了，之所以不是去掉只读属性是因为只是单独修改可读属性不知道为何还是不能写入，就先设置为普通的属性了    textDesDic.Clear();                                        //清空自己的字典    excelFile = new FileInfo(excelPath);                    //接着就是获取表格文件    using (ExcelPackage excelPackage = new ExcelPackage(excelFile))        //下面就是循环读取表格内容然后写入到字典中    &#123;        var worksheet = excelPackage.Workbook.Worksheets[1];        for (int i = startRow; i &lt;= worksheet.Dimension.End.Row; i++)        &#123;            exKey = worksheet.Cells[i, keyColumn].GetValue&lt;int&gt;();            exValue = worksheet.Cells[i, valueVolumn].GetValue&lt;string&gt;();            startTextIndex = Mathf.Max(exKey, startTextIndex);            textDesDic.Add(exKey, exValue);        &#125;    &#125;    textDesAddDic.Clear();                                    //接着就是把第二个增加的字典清空，是为了记录新增的文字    File.SetAttributes(excelPath, attrArr);                    //然后就是把文件属性设置为原来的属性&#125;</code></pre><p>写入Language和读取类似，只是把原来的遍历读取变成遍历新增字典，然后一行一行写入。代码如下:  </p><pre><code>public static void WroadExcel()&#123;    var attrArr = File.GetAttributes(excelPath);    File.SetAttributes(excelPath, FileAttributes.Normal);    excelFile = new FileInfo(excelPath);    using (ExcelPackage excelPackage = new ExcelPackage(excelFile))    &#123;        var worksheet = excelPackage.Workbook.Worksheets[1];        var curRow = worksheet.Dimension.End.Row;        foreach (var textdespair in textDesAddDic)        &#123;            worksheet.Cells[++curRow, keyColumn].Value = textdespair.Key;            worksheet.Cells[curRow, valueVolumn].Value = textdespair.Value;        &#125;                excelPackage.Save();                                //保存表    &#125;        File.SetAttributes(excelPath, attrArr);        textDesAddDic.Clear();&#125;</code></pre><p>加载prefab中的Text文本，代码如下:  </p><pre><code>static StringBuilder newTexts = new StringBuilder();public static void LoadAllPrefabText(bool isClearText,bool onlyFindTxt = false)&#123;    newTexts.Clear();                            //清空字符串    textDesAddDic.Clear();                        //清空新增的字典    var sdirs =GetAllPrefabFiles();                //获取Prefab的存在文件夹    EditorUtility.DisplayProgressBar(&quot;Progress&quot;, &quot;LoadPrefabTxtDes...&quot;, 0);        //打开一个进度掉，为了方便查看加载进度使用    var asstIds = AssetDatabase.FindAssets(&quot;t:Prefab&quot;, sdirs);                    //得到所有Prefab的资源    int count = 0;                                //初始化加载的进度    for (int i = 0; i &lt; asstIds.Length; i++)    //循环遍历一下自己加载出来的prefab    &#123;        string path = AssetDatabase.GUIDToAssetPath(asstIds[i]);            //得到prefab资源的路径        //Debug.LogError(&quot;try deal with path &quot;+path);                                var pfb = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(path);            //根据路径加载对应的prefab        var texts = pfb.GetComponentsInChildren&lt;Text&gt;(true);                //得到prefab上所有节点的Text组件        if (texts == null || texts.Length &lt;= 0)                                //如果不存在就跳过，遍历到下一个prefab        &#123;            //Debug.LogError(&quot;asset no texts: &quot;+path);            continue;        &#125;        foreach (var item in texts)                                            //遍历prefab中的Text组件        &#123;            textDes = item.text;                                            //获取组件上的文字            if (textDes.IsNullOrWhitespace())                                //如果文字为空就跳过到下一个                continue;                        var langTextComp = item.gameObject.GetComponent&lt;MutiLangText&gt;();//获取Text文本上的脚本，自己写的替换文本的脚本            if (langTextComp &amp;&amp; onlyFindTxt)                                //如果存在脚本并且只是查找文本，说明已经添加过就可以直接跳过了            &#123;                continue;                //Debug.LogError(&quot;has Added MutiText: &quot;+item.name);            &#125;            bool addComP = false;                                            //标记是否增加组件为false            if (isClearText)                                                //判断是否需要清除自己的替换语言脚本            &#123;                if (!textDesDic.ContainsValue(textDes))                        //判断表里是否已经存在文本                &#123;                    item.text = &quot;&quot;;                                            //如果不存在就先清除文字                    if (langTextComp)                                        //如果不存在自己的脚本就一并删除                    &#123;                        //TODO  remove  comp                        DestroyImmediate(langTextComp);                    &#125;                &#125;                else                                                        //如果表里存在就从字典里获取到表里的ID                &#123;                    curDesId = textDesDic.Where(q =&gt; q.Value == textDes).Select(q =&gt; q.Key).ToArray()[0];                    addComP = true;                                            //标记需要增加组件                &#125;            &#125;            else                                                            //如果不是清除文本            &#123;                if (onlyFindTxt)                                            //如果只是查找文本                &#123;                    if (!textDesDic.ContainsValue(textDes))                    //如果字典中不存在就记录下来                    &#123;                        newTexts.AppendLine(textDes);                    &#125;                    continue;                &#125;                if (!textDesDic.ContainsValue(textDes))                        //如果字典中不存在，就往字典中添加，并且在新增字典中增加                &#123;                    textDesDic.Add(++startTextIndex, textDes);                    textDesAddDic.Add(startTextIndex,textDes);                    curDesId = startTextIndex;                &#125;                else                                                        //如果存在就记录下来文本对应的ID                &#123;                    curDesId = textDesDic.Where(q =&gt; q.Value == textDes).Select(q =&gt; q.Key).ToArray()[0];                &#125;                                if(!langTextComp)                                            //如果并没有增加切换语言脚本就标记需要增加脚本                &#123;                    addComP = true;                &#125;            &#125;            if (addComP &amp;&amp; !langTextComp)                                    //如果需要增加并且组件不存在，就增加一下自己的脚本                    &#123;                langTextComp = item.gameObject.AddComponent&lt;MutiLangText&gt;();                langTextComp.baseText = item;            &#125;                        if (langTextComp)                                                //如果存在组件就更新一下ID                langTextComp.languageID = curDesId;        &#125;        PrefabUtility.SavePrefabAsset(pfb, out bool success);                //修改完毕保存prefab就可以了        if (success)                                                        //记录加载进度，然后更新进度条        &#123;            count++;        &#125;        EditorUtility.DisplayProgressBar(&quot;LoadPrefabTxtDes Progress&quot;, pfb.name, count / (float)asstIds.Length);    &#125;    if (newTexts.Length &gt; 0)                                                //如果有新增的文字就记录下来    &#123;        Debug.LogError(&quot;write new text: &quot;+newTexts.Length);        File.WriteAllText(ExportExcel.excelFolder + &quot;/newText.txt&quot;,newTexts.ToString());    &#125;    EditorUtility.ClearProgressBar();                                        //结束之后清除加载进度条&#125;</code></pre><p>获取Prefab文件路径的代码：  </p><pre><code>private static string[] GetAllPrefabFiles()&#123;    string sdir = &quot;Assets/XXX/XXX&quot;;    List&lt;string&gt; sdirlist = new List&lt;string&gt;();    sdirlist.Add(sdir);    sdirlist.Add(&quot;Assets/Resources/RootPrefab&quot;);       return sdirlist.ToArray();    &#125;</code></pre><h2 id="查找代码中的中文"><a href="#查找代码中的中文" class="headerlink" title="查找代码中的中文"></a>查找代码中的中文</h2><p>因为一开始没有考虑到会做海外，并且写的代码不规范，所以存在一部分中文是在代码里。这部分中文代码是不好查找的，所以写了一个小脚本，可以快速标记到中文代码的位置，这个脚本可以解决大部分，但是仍旧是存在找不到的问题的。下面来看代码:  </p><p>首先会打开一个面板用来选择代码脚本所在的文件路径</p><pre><code>[MenuItem(&quot;Tools/ReplaceText/FindScriptsLanguage&quot;)]public static void Pack()&#123;    Rect wr = new Rect(300, 400, 400, 100);    FindChineseWindow window = (FindChineseWindow)EditorWindow.GetWindowWithRect(typeof(FindChineseWindow), wr, true, &quot;查找项目中的中文字符&quot;);    window.Show();&#125;public class FindChineseWindow : EditorWindow&#123;    private ArrayList csList = new ArrayList();    private int eachFrameFind = 4;    private int currentIndex = 0;    private bool isBeginUpdate = false;    private string outputText;    public string filePath = &quot;/Scripts&quot;;    private string strForShader = &quot;&quot;;    //这个是需要忽略检测的文件夹    private List&lt;string&gt; ingoreFileInfoDirNameList = new List&lt;string&gt; &#123;&quot;GMConsole&quot;, &quot;LogicWorld&quot;, &quot;NetWork&quot;, &quot;SDK&quot;&#125;;    //这个是需要忽略的代码文件名    private List&lt;string&gt; ingoreFileInfoNameList = new List&lt;string&gt; &#123;&quot;LocalLanguage&quot;&#125;;    //这个是需要忽略的代码包含的字符串    private List&lt;string&gt; ingoreScriptesDesList = new List&lt;string&gt; &#123;&quot;Debug&quot;, &quot;LogWrapper&quot;, &quot;Tooltip&quot;, &quot;throw new&quot;&#125;;    //获取需要检测的文件    private void GetAllFile(DirectoryInfo dir)    &#123;        FileInfo[] allFile = dir.GetFiles();        foreach (FileInfo fi in allFile)        &#123;            if (ingoreFileInfoDirNameList.Where(str =&gt; fi.DirectoryName.Contains(str)).Count() &gt; 0)                 continue;            if (ingoreFileInfoNameList.Where(str =&gt; fi.Name.Contains(str)).Count() &gt; 0)                 continue;            if (fi.FullName.IndexOf(&quot;.meta&quot;) == -1 &amp;&amp; fi.FullName.IndexOf(&quot;.cs&quot;) != -1)            &#123;                csList.Add(fi.DirectoryName + &quot;/&quot; + fi.Name);            &#125;        &#125;        DirectoryInfo[] allDir = dir.GetDirectories();        foreach (DirectoryInfo d in allDir)        //遍历子文件夹        &#123;            GetAllFile(d);        &#125;    &#125;    public void OnGUI()            //面板显示的代码    &#123;        filePath = EditorGUILayout.TextField(&quot;路径：&quot;, filePath);        //输入路径        EditorGUILayout.Space();        EditorGUILayout.Space();        if (GUILayout.Button(&quot;开始遍历目录&quot;))                                //显示的按钮        &#123;            csList.Clear();            DirectoryInfo d = new DirectoryInfo(Application.dataPath + filePath);    //从绝对路径读取文件            GetAllFile(d);                                                //获取所有的文件            //GetAllFile(d);            outputText = &quot;游戏内代码文件的数量：&quot; + csList.Count;            isBeginUpdate = true;            outputText = &quot;开始遍历项目&quot;;        &#125;        GUILayout.Label(outputText, EditorStyles.boldLabel);    &#125;    private bool HasChinese(string str)                //这是个判断是否是中文的方法    &#123;        return Regex.IsMatch(str, @&quot;[\u4e00-\u9fa5]&quot;);    &#125;    private Regex regex = new Regex(&quot;\&quot;[^\&quot;]*\&quot;&quot;);    private void printChinese(string path)            //开始输出中文文字所在位置    &#123;        if (File.Exists(path))        &#123;            string[] fileContents = File.ReadAllLines(path, Encoding.Default);            int count = fileContents.Length;            for (int i = 0; i &lt; count; i++)            &#123;                string printStr = fileContents[i].Trim();                if (printStr.IndexOf(&quot;//&quot;) == 0) //说明是注释                    continue;                if (ingoreScriptesDesList.Where(str =&gt; printStr.Contains(str)).Count() &gt; 0) //说明是需要排除的代码                    continue;                MatchCollection matches = regex.Matches(printStr);                foreach (Match match in matches)                &#123;                    if (HasChinese(match.Value))                    &#123;                        string[] fullPath = path.Split(&#39;/&#39;);                        path = fullPath[fullPath.Length - 1];                        Debug.Log(&quot;路径:&quot; + path + &quot; 行数:&quot; + i + &quot; 内容:&quot; + printStr);                        break;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;打包&quot;&gt;&lt;a href=&quot;#打包&quot; class=&quot;headerlink&quot; title=&quot;打包&quot;&gt;&lt;/a&gt;打包&lt;/h1&gt;&lt;h2 id=&quot;Gradle版本问题&quot;&gt;&lt;a href=&quot;#Gradle版本问题&quot; class=&quot;headerlink&quot; title=&quot;Gradl</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="海外Google" scheme="http://yoursite.com/tags/%E6%B5%B7%E5%A4%96Google/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——基于UGUI实现性能更好的圆形Image</title>
    <link href="http://yoursite.com/2021/04/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EUGUI%E5%AE%9E%E7%8E%B0%E6%80%A7%E8%83%BD%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%9C%86%E5%BD%A2Image/"/>
    <id>http://yoursite.com/2021/04/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EUGUI%E5%AE%9E%E7%8E%B0%E6%80%A7%E8%83%BD%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%9C%86%E5%BD%A2Image/</id>
    <published>2021-04-30T03:00:36.000Z</published>
    <updated>2021-12-27T03:39:09.483Z</updated>
    
    <content type="html"><![CDATA[<p>参考博客地址：<a href="https://www.cnblogs.com/leoin2012/p/6425089.html">https://www.cnblogs.com/leoin2012/p/6425089.html</a>  </p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在我们开发游戏过程中，会经常使用Mask来进行图片的裁剪，但是笔者在使用Mask进行裁剪的时候发现锯齿特别严重，因此笔者选择了利用shader进行图形遮罩，详情请看<a href="https://lianbai.github.io/2021/04/20/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UGUI%E5%9F%BA%E4%BA%8E%E5%9B%BE%E9%9B%86%E7%9A%84shader%E9%81%AE%E7%BD%A9/">Unity杂文——UGUI基于图集的shader遮罩</a>。<br>笔者虽然已经利用shader做好了遮罩并应用项目中的，但是在笔者在学习UGUI优化的时候发现Mask不仅有锯齿，也会增加两个DrawCall，因为Mask会把自己和子节点都和外面分开，不会进行合批，这样mask越多，DrawCall就会比较严重，笔者利用Shader进行遮罩虽然也会多一个DrawCall，但是相同的材质会进行合批，<br>裁剪随然已经改好了，但是笔者发现了不会增加DrawCall的方法。  </p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>我们在屏幕上看到的图形是GPU渲染出来的，而GPU渲染的最小单位是三角面片，我们从Unity的Scence场景中，切换视图方式为WireFrame或者Shader Wireframe都可以明显看到图片是三角形组成的，而我们要制作出圆形的Image可以利用多个等腰三角形，这样就可以拼接成看似圆形的Image，三角形数量越多就越像圆形。如下图：  </p><p><img src="https://file.liangxiegame.com/fc913a59-b938-4129-8c69-fc299a3ba79b.png" alt="image.png">   </p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>首先我们需要自己重写Image，我们要自己实现画图，我们首先查看Image的原码：  </p><pre><code>public class Image : MaskableGraphic, ISerializationCallbackReceiver, ILayoutElement, ICanvasRaycastFilter</code></pre><p>我们可以看到Image继承了MaskableGraphic，并且实现了ISerializationCallbackReceiver、ILayoutElement、ICanvasRaycastFilter的接口。最关键的其实是MaskableGraphic类，因为这个类主要是负责画图的，我们可以很简单的看到MaskableGraphic类其实继承了Graphic类，在这个类里面有个OnPopulateMesh函数，这个函数就是我们需要重写的函数。<br>当UI元素生成顶点数据时就会调用OnPopulateMesh函数，我们只需要继承这个函数并且将原来的顶带你数据清除，改写成我们自己设置的圆形的顶带你数据，这样我们就可以画我们需要的圆形了。<br>由于在Unity中，继承UnityEngine基类的派生类并不能在Inspector面板里显示参数，笔者在制作圆形的Image的时候肯定要设置一些可调节的参数，这样可以应用到更多的场景中，因为笔者就像参考博客一样新建一个BaseImage类去继承Image类，然后自己再写一个CircleImage类去继承BaseImage类，这样我们把可调节的变量放在CircleImage类中，这样就可以通过面板调节参数了。<font color=red>(原Image源码有近千行代码，BaseImage对其进行了部分精简，只支持Simple Image Type，并去掉了eventAlphaThreshold的相关代码。经过删减，得到一个百行代码的BaseImage类，精简版Image就完成了。)</font>  </p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>完整代码在最后面，因为内容过多，笔者就先写代码分析，您可以先复制最后的完整代码到工程里，然后自己对着代码一步一步进行。  </p><h3 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h3><p>笔者首先介绍一下笔者设置的允许调节的参数，参数描述都在代码中，代码如下：  </p><pre><code>[Tooltip(&quot;圆形的半径&quot;)][Range(0, 1)]public float fillRadius = 1f;[Tooltip(&quot;UV缩放比例&quot;)][Range(0, 1)]public float UVScale = 1f;[Tooltip(&quot;圆形的中心点&quot;)]public Vector2 fillCenter = new Vector2(0.5f, 0.5f);[Tooltip(&quot;圆形或扇形填充比例&quot;)][Range(0, 1)]public float fillPercent = 1f;[Tooltip(&quot;是否填充圆形&quot;)]public bool fill = true;[Tooltip(&quot;圆环宽度&quot;)]public float thickness = 5;[Tooltip(&quot;圆形&quot;)][Range(3, 100)]public int segements = 20;        //填充三角形数量</code></pre><p>在OnPopulateMesh函数中，函数的参数VertexHelper就是原来图片的顶带你信息，因为我们要重写这些顶点信息，所以我们要清空vh。在我们设置自己的顶点的信息之前，我们需要获得UV信息，获取方法就是DataUtility.GetOuterUV(overrideSprite)。  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    Vector4 uv = overrideSprite != null ? DataUtility.GetOuterUV(overrideSprite) : Vector4.zero;    float uvCenterX = (uv.x + uv.z) * (0.5f + (fillCenter.x - 0.5f) * (uv.z - uv.x));    float uvCenterY = (uv.y + uv.w) * (0.5f + (fillCenter.y - 0.5f) * (uv.w - uv.y));    float uvScaleX = (uv.z - uv.x) / tw  * fillRadius * UVScale;    float uvScaleY = (uv.w - uv.y) / th  * fillRadius * UVScale;    ...&#125;</code></pre><p>在设置的属性中我们有一个变量segements就是我们需要的三角形数量，正如原理将的，三角形数量越多，越像圆形，但是顶点数据就越多，影响性能，所以我们设置这个参数可以根据需求设置数量，然后我们知道数量后就可以算出顶点的夹角，然后面片数segements与填充比例fillPercent相乘，就知道要用多少个面片来显示圆形/扇形  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    //算出每个面片的顶点夹角，面片数segements与填充比例fillPercent相乘，就知道要用多少个面片来显示圆形/扇形    float degreeDelta = (float)(2 * Mathf.PI / segements);    int curSegements = (int)(segements * fillPercent);    ...&#125;</code></pre><p>我们可以通过RectTransform获取原图矩形的宽高，笔者这里也添加了一个可以调整的参数圆形半径个圆环宽度，圆环宽度是用来做圆环形状显示的，圆形半径其实就是原图的宽高乘以圆的半径就行了，这里圆的半径其实是一个比例，把原图的比作为1。  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    //通过RectTransform获取矩形宽高，计算出半径    float tw = rectTransform.rect.width * fillRadius;    float th = rectTransform.rect.height * fillRadius;    float outerRadius = rectTransform.pivot.x * tw;    float innerRadius = rectTransform.pivot.x * tw - thickness;    ...&#125;</code></pre><p>已经有了半径，夹角信息，根据圆形点坐标公式(radius * cosA,radius * sinA)可以算出顶点坐标，每次迭代新建UIVertex，将求出的坐标，color，uv等参数传入，再将UIVertex传给VertexHelper。重复迭代n次，VertexHelper就获得了多边形顶点及圆心点信息了。  这里笔者也设置了参数，UV的缩放和圆的中心点，也是为了适应更多的场景</p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    float uvCenterX = (uv.x + uv.z) * (0.5f + (fillCenter.x - 0.5f) * (uv.z - uv.x));    float uvCenterY = (uv.y + uv.w) * (0.5f + (fillCenter.y - 0.5f) * (uv.w - uv.y));    float uvScaleX = (uv.z - uv.x) / tw  * fillRadius * UVScale;    float uvScaleY = (uv.w - uv.y) / th  * fillRadius * UVScale;    float curDegree = 0;    UIVertex uiVertex;    int verticeCount;    int triangleCount;    Vector2 curVertice;    curVertice = Vector2.zero;    verticeCount = curSegements + 1;    uiVertex = new UIVertex();    uiVertex.color = color;    uiVertex.position = curVertice;    uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);    vh.AddVert(uiVertex);    for (int i = 1; i &lt; verticeCount; i++)    &#123;        float cosA = Mathf.Cos(curDegree);        float sinA = Mathf.Sin(curDegree);        curVertice = new Vector2(cosA * outerRadius, sinA * outerRadius);        curDegree += degreeDelta;        uiVertex = new UIVertex();        uiVertex.color = color;        uiVertex.position = curVertice;        uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);        vh.AddVert(uiVertex);        outterVertices.Add(curVertice);    &#125;    ...&#125;</code></pre><p>虽然已经传入了所有的顶带你信息，但是GPU还不知道顶点信息之间的关系，不知道顶带你分成了多少个三角形片面，所以还需要把三角形的信息告诉GPU,这里有一个VertexHelper的接口就是**AddTriangle(int idx0, int idx1, int idx2)**来接受三角形信息。<br>接口的传入参数并不是UIVertex类型，而是int类型的索引值。哪来的索引？还记得之前往VertexHelper传入了一堆顶点吗？按照传入顺序，第一个顶点，索引记为0，依次类推。每次传入三个顶点的索引，就记录下了一个三角形。  </p><blockquote><p>需要注意，GPU 默认是做backface culling(背面剔除)的，GPU只渲染正对屏幕的三角面片，当GPU认为某个三角面片是背对屏幕时，直接丢弃该三角面片，不做渲染。那么GPU怎么判断我们传入的某个三角形是正对屏幕，还是背对屏幕？答案是通过三个顶点的时针顺序，当三个顶点是呈顺时针时，判定为正对屏幕；呈逆时针时，判定为背对屏幕。</p></blockquote><p><img src="https://file.liangxiegame.com/f83adeb0-049d-413a-b538-e8a2cab10a6c.png" alt="image.png"></p><p>VertexHelper收到的第一个顶点是圆心，且算法是按逆时针方向，迭代计算出的多边形顶点，并依次传给VertexHelper。因此按(i, 0, i+1)(i&gt;=1)的规律取索引，就可以保证顶点顺序是顺时针的。  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    triangleCount = curSegements*3;    for (int i = 0, vIdx = 1; i &lt; triangleCount - 3; i += 3, vIdx++)    &#123;        vh.AddTriangle(vIdx, 0, vIdx+1);    &#125;    if (fillPercent == 1)    &#123;        //首尾顶点相连        vh.AddTriangle(verticeCount - 1, 0, 1);    &#125;    ...&#125;</code></pre><p>到此我们的圆形算是绘制完成了，但是观测我们的变量可以看出，笔者还支持了圆环的绘制  </p><h3 id="圆环"><a href="#圆环" class="headerlink" title="圆环"></a>圆环</h3><p>圆环的情况稍微复杂：顶点集没有圆心顶点了，只有内环、外环顶点；三角形集也不是简单的切饼式分割，采用一种比较直观的三角形划分，让内外环相邻的顶点类似一根鞋带那样互相连接，来划分三角形。  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    float uvCenterX = (uv.x + uv.z) * (0.5f + (fillCenter.x - 0.5f) * (uv.z - uv.x));    float uvCenterY = (uv.y + uv.w) * (0.5f + (fillCenter.y - 0.5f) * (uv.w - uv.y));    float uvScaleX = (uv.z - uv.x) / tw  * fillRadius * UVScale;    float uvScaleY = (uv.w - uv.y) / th  * fillRadius * UVScale;    float curDegree = 0;    UIVertex uiVertex;    int verticeCount;    int triangleCount;    Vector2 curVertice;    curVertice = Vector2.zero;    verticeCount = curSegements + 1;    uiVertex = new UIVertex();    uiVertex.color = color;    uiVertex.position = curVertice;    uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);    vh.AddVert(uiVertex);     verticeCount = curSegements*2;    for (int i = 0; i &lt; verticeCount; i += 2)    &#123;        float cosA = Mathf.Cos(curDegree);        float sinA = Mathf.Sin(curDegree);        curDegree += degreeDelta;        curVertice = new Vector3(cosA * innerRadius, sinA * innerRadius);        uiVertex = new UIVertex();        uiVertex.color = color;        uiVertex.position = curVertice;        uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);        vh.AddVert(uiVertex);        innerVertices.Add(curVertice);        curVertice = new Vector3(cosA * outerRadius, sinA * outerRadius);        uiVertex = new UIVertex();        uiVertex.color = color;        uiVertex.position = curVertice;        uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);        vh.AddVert(uiVertex);        outterVertices.Add(curVertice);    &#125;    ...&#125;</code></pre><h3 id="点击判断"><a href="#点击判断" class="headerlink" title="点击判断"></a>点击判断</h3><p>传统的UGUI的Image的点击判断是只要在矩形内点击，不管是不是透明，都认定为点击到了，笔者从网上学习了一套更好的判断点击的方法，利用的是<strong>Ray-Crossing算法</strong>。Ray-Crossing算法大概思路是从指定点p发出一条射线，与多边形相交，假若交点个数是奇数，说明点p落在多边形内，交点个数为偶数说明点p在多边形外。<br>射线选取哪个方向并没有限制，但为了实现起来方便，考虑屏幕点击点为点p，向水平方向右侧发出射线的情况，那么顶点v1,v2组成的线段与射线若有交点q，则点q必定满足两个条件：</p><blockquote><p>v2.y &lt; q.y = p.y &gt; v1.y<br>p.x &lt; q.x  </p></blockquote><p>我们根据这两个条件，逐一跟多边形线段求交点，并统计交点个数，最后判断奇偶即可得知点击点是否在圆形内。  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    public override bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)    &#123;        Sprite sprite = overrideSprite;        if (sprite == null)            return true;        Vector2 local;        RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, screenPoint, eventCamera, out local);        return Contains(local, outterVertices, innerVertices);    &#125;        private bool Contains(Vector2 p, List&lt;Vector3&gt; outterVertices, List&lt;Vector3&gt; innerVertices)    &#123;        var crossNumber = 0;        if(!fill)            RayCrossing(p, innerVertices, ref crossNumber);//检测内环        RayCrossing(p, outterVertices, ref crossNumber);//检测外环        return (crossNumber &amp; 1) == 1;    &#125;        /// &lt;summary&gt;    /// 使用RayCrossing算法判断点击点是否在封闭多边形里    /// &lt;/summary&gt;    /// &lt;param name=&quot;p&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;vertices&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;crossNumber&quot;&gt;&lt;/param&gt;    private void RayCrossing(Vector2 p, List&lt;Vector3&gt; vertices, ref int crossNumber)    &#123;        for (int i = 0, count = vertices.Count; i &lt; count; i++)        &#123;            var v1 = vertices[i];            var v2 = vertices[(i + 1) % count];            //点击点水平线必须与两顶点线段相交            if (((v1.y &lt;= p.y) &amp;&amp; (v2.y &gt; p.y))                || ((v1.y &gt; p.y) &amp;&amp; (v2.y &lt;= p.y)))            &#123;                //只考虑点击点右侧方向，点击点水平线与线段相交，且交点x &gt; 点击点x，则crossNumber+1                if (p.x &lt; v1.x + (p.y - v1.y) / (v2.y - v1.y) * (v2.x - v1.x))                &#123;                    crossNumber += 1;                &#125;            &#125;        &#125;    &#125;    ...&#125;</code></pre><p>###SetNativeSize<br>SetNativeSize的实现比较简单，只要把宽高设置图片的高度就行了。</p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    public override void SetNativeSize()    &#123;        if (activeSprite != null)        &#123;            float w = activeSprite.rect.width / pixelsPerUnit;            float h = activeSprite.rect.height / pixelsPerUnit;            rectTransform.anchorMax = rectTransform.anchorMin;            rectTransform.sizeDelta = new Vector2(w, h);            SetAllDirty();        &#125;    &#125;    ...&#125;</code></pre><p>在这里笔者遇到了一个问题，就是我们怎么能像Image那样调用这个方法呢，笔者参考了Image的原码，Imnage是有一个专门的Editor脚本设置面板显示的，于是笔者就写了一个CircleImageEditor的脚本来控制。只需要脚本继承GraphicEditor，然后通过[CustomEditor(typeof(CircleImage))]标签就可以实现脚本的控制了。  </p><pre><code>[CustomEditor(typeof(CircleImage))]public class CircleImageEditor : GraphicEditor&#123;    public override void OnInspectorGUI() &#123;        DrawDefaultInspector();                CircleImage myScript = (CircleImage)target;        EditorGUILayout.BeginHorizontal();        &#123;            GUILayout.Space(EditorGUIUtility.labelWidth);            if (GUILayout.Button(&quot;Set Native Size&quot;, EditorStyles.miniButtonRight))            &#123;                myScript.SetNativeSize();            &#125;        &#125;        EditorGUILayout.EndHorizontal();    &#125;&#125;</code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>笔者在制作BaseImage的时候并没有继承MaskableGraphic而是自己复制了一份到BaseMaskableGraphic类中，这是因为笔者不喜欢脚本在Inspector面面板中显示m_OnCullStateChanged这个事件，因此笔者复制了一份，只是把这个变量变成了私有，就不在面板显示，如果不介意面板的了可以继续继承MaskableGraphic。</p><h3 id="BaseImage"><a href="#BaseImage" class="headerlink" title="BaseImage"></a>BaseImage</h3><pre><code>public class BaseImage : BaseMaskableGraphic,ISerializationCallbackReceiver, ILayoutElement, ICanvasRaycastFilter&#123;    [FormerlySerializedAs(&quot;m_Frame&quot;)]    [SerializeField]    private Sprite m_Sprite;        //私有的sorite，内部调用，防止外部修改    //对外公开的sprite属性    public Sprite sprite    &#123;        get &#123; return m_Sprite; &#125;        set&#123;if (SetPropertyUtilityExt.SetClass(ref m_Sprite, value)) SetAllDirty();&#125;    &#125;    [NonSerialized]    private Sprite m_OverrideSprite;        protected BaseImage()    &#123;        useLegacyMeshGeneration = false;    &#125;    public Sprite overrideSprite    &#123;        get &#123; return m_OverrideSprite == null ? sprite : m_OverrideSprite; &#125;        set        &#123;            if (SetPropertyUtilityExt.SetClass(ref m_OverrideSprite, value)) SetAllDirty();        &#125;    &#125;    /// &lt;summary&gt;    /// Image&#39;s texture comes from the UnityEngine.Image.    /// &lt;/summary&gt;    public override Texture mainTexture    &#123;        get        &#123;            return overrideSprite == null ? s_WhiteTexture : overrideSprite.texture;        &#125;    &#125;    public Sprite activeSprite &#123; get &#123; return overrideSprite != null ? overrideSprite : sprite; &#125; &#125;            public float pixelsPerUnit    &#123;        get        &#123;            float spritePixelsPerUnit = 100;            if (sprite)                spritePixelsPerUnit = sprite.pixelsPerUnit;            float referencePixelsPerUnit = 100;            if (canvas)                referencePixelsPerUnit = canvas.referencePixelsPerUnit;            return spritePixelsPerUnit / referencePixelsPerUnit;        &#125;    &#125;            /// &lt;summary&gt;    /// 子类需要重写该方法来自定义Image形状    /// &lt;/summary&gt;    /// &lt;param name=&quot;vh&quot;&gt;&lt;/param&gt;    protected override void OnPopulateMesh(VertexHelper vh)    &#123;        base.OnPopulateMesh(vh);    &#125;    #region ISerializationCallbackReceiver        public void OnBeforeSerialize()    &#123;    &#125;    public void OnAfterDeserialize()    &#123;    &#125;        #endregion    #region ILayoutElement    public virtual void CalculateLayoutInputHorizontal() &#123; &#125;    public virtual void CalculateLayoutInputVertical() &#123; &#125;    public virtual float minWidth &#123; get &#123; return 0; &#125; &#125;    public virtual float preferredWidth    &#123;        get        &#123;            if (overrideSprite == null)                return 0;            return overrideSprite.rect.size.x / pixelsPerUnit;        &#125;    &#125;    public virtual float flexibleWidth &#123; get &#123; return -1; &#125; &#125;    public virtual float minHeight &#123; get &#123; return 0; &#125; &#125;    public virtual float preferredHeight    &#123;        get        &#123;            if (overrideSprite == null)                return 0;            return overrideSprite.rect.size.y / pixelsPerUnit;        &#125;    &#125;    public virtual float flexibleHeight &#123; get &#123; return -1; &#125; &#125;    public virtual int layoutPriority &#123; get &#123; return 0; &#125; &#125;    #endregion        #region ICanvasRaycastFilter    public virtual bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)    &#123;        return true;    &#125;    #endregion&#125;</code></pre><h3 id="CircleImage"><a href="#CircleImage" class="headerlink" title="CircleImage"></a>CircleImage</h3><pre><code>[AddComponentMenu(&quot;UI/Circle Image&quot;)]public class CircleImage : BaseImage&#123;    [Tooltip(&quot;圆形的半径&quot;)]    [Range(0, 1)]    public float fillRadius = 1f;    [Tooltip(&quot;UV缩放比例&quot;)]    [Range(0, 1)]    public float UVScale = 1f;    [Tooltip(&quot;圆形的中心点&quot;)]    public Vector2 fillCenter = new Vector2(0.5f, 0.5f);    [Tooltip(&quot;圆形或扇形填充比例&quot;)]    [Range(0, 1)]    public float fillPercent = 1f;    [Tooltip(&quot;是否填充圆形&quot;)]    public bool fill = true;    [Tooltip(&quot;圆环宽度&quot;)]    public float thickness = 5;    [Tooltip(&quot;圆形&quot;)]    [Range(3, 100)]    public int segements = 20;    private List&lt;Vector3&gt; innerVertices;    private List&lt;Vector3&gt; outterVertices;    void Awake()    &#123;        innerVertices = new List&lt;Vector3&gt;();        outterVertices = new List&lt;Vector3&gt;();    &#125;        // Update is called once per frame    void Update () &#123;        if(!fill)            this.thickness = (float)Mathf.Clamp(this.thickness, 0, rectTransform.rect.width / 2);    &#125;    protected override void OnPopulateMesh(VertexHelper vh)    &#123;        vh.Clear();        innerVertices.Clear();        outterVertices.Clear();        //算出每个面片的顶点夹角，面片数segements与填充比例fillPercent相乘，就知道要用多少个面片来显示圆形/扇形        float degreeDelta = (float)(2 * Mathf.PI / segements);        int curSegements = (int)(segements * fillPercent);        //通过RectTransform获取矩形宽高，计算出半径        float tw = rectTransform.rect.width * fillRadius;        float th = rectTransform.rect.height * fillRadius;        float outerRadius = rectTransform.pivot.x * tw;        float innerRadius = rectTransform.pivot.x * tw - thickness;        Vector4 uv = overrideSprite != null ? DataUtility.GetOuterUV(overrideSprite) : Vector4.zero;        float uvCenterX = (uv.x + uv.z) * (0.5f + (fillCenter.x - 0.5f) * (uv.z - uv.x));        float uvCenterY = (uv.y + uv.w) * (0.5f + (fillCenter.y - 0.5f) * (uv.w - uv.y));        float uvScaleX = (uv.z - uv.x) / tw  * fillRadius * UVScale;        float uvScaleY = (uv.w - uv.y) / th  * fillRadius * UVScale;        float curDegree = 0;        UIVertex uiVertex;        int verticeCount;        int triangleCount;        Vector2 curVertice;        if (fill) //圆形        &#123;            curVertice = Vector2.zero;            verticeCount = curSegements + 1;            uiVertex = new UIVertex();            uiVertex.color = color;            uiVertex.position = curVertice;            uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);            vh.AddVert(uiVertex);            for (int i = 1; i &lt; verticeCount; i++)            &#123;                float cosA = Mathf.Cos(curDegree);                float sinA = Mathf.Sin(curDegree);                curVertice = new Vector2(cosA * outerRadius, sinA * outerRadius);                curDegree += degreeDelta;                uiVertex = new UIVertex();                uiVertex.color = color;                uiVertex.position = curVertice;                uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);                vh.AddVert(uiVertex);                outterVertices.Add(curVertice);            &#125;            triangleCount = curSegements*3;            for (int i = 0, vIdx = 1; i &lt; triangleCount - 3; i += 3, vIdx++)            &#123;                vh.AddTriangle(vIdx, 0, vIdx+1);            &#125;            if (fillPercent == 1)            &#123;                //首尾顶点相连                vh.AddTriangle(verticeCount - 1, 0, 1);            &#125;        &#125;        else//圆环        &#123;            verticeCount = curSegements*2;            for (int i = 0; i &lt; verticeCount; i += 2)            &#123;                float cosA = Mathf.Cos(curDegree);                float sinA = Mathf.Sin(curDegree);                curDegree += degreeDelta;                curVertice = new Vector3(cosA * innerRadius, sinA * innerRadius);                uiVertex = new UIVertex();                uiVertex.color = color;                uiVertex.position = curVertice;                uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);                vh.AddVert(uiVertex);                innerVertices.Add(curVertice);                curVertice = new Vector3(cosA * outerRadius, sinA * outerRadius);                uiVertex = new UIVertex();                uiVertex.color = color;                uiVertex.position = curVertice;                uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);                vh.AddVert(uiVertex);                outterVertices.Add(curVertice);            &#125;            triangleCount = curSegements*3*2;            for (int i = 0, vIdx = 0; i &lt; triangleCount - 6; i += 6, vIdx += 2)            &#123;                vh.AddTriangle(vIdx+1, vIdx, vIdx+3);                vh.AddTriangle(vIdx, vIdx + 2, vIdx + 3);            &#125;            if (fillPercent == 1)            &#123;                //首尾顶点相连                vh.AddTriangle(verticeCount - 1, verticeCount - 2, 1);                vh.AddTriangle(verticeCount - 2, 0, 1);            &#125;        &#125;    &#125;        public override bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)    &#123;        Sprite sprite = overrideSprite;        if (sprite == null)            return true;        Vector2 local;        RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, screenPoint, eventCamera, out local);        return Contains(local, outterVertices, innerVertices);    &#125;        private bool Contains(Vector2 p, List&lt;Vector3&gt; outterVertices, List&lt;Vector3&gt; innerVertices)    &#123;        var crossNumber = 0;        if(!fill)            RayCrossing(p, innerVertices, ref crossNumber);//检测内环        RayCrossing(p, outterVertices, ref crossNumber);//检测外环        return (crossNumber &amp; 1) == 1;    &#125;        /// &lt;summary&gt;    /// 使用RayCrossing算法判断点击点是否在封闭多边形里    /// &lt;/summary&gt;    /// &lt;param name=&quot;p&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;vertices&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;crossNumber&quot;&gt;&lt;/param&gt;    private void RayCrossing(Vector2 p, List&lt;Vector3&gt; vertices, ref int crossNumber)    &#123;        for (int i = 0, count = vertices.Count; i &lt; count; i++)        &#123;            var v1 = vertices[i];            var v2 = vertices[(i + 1) % count];            //点击点水平线必须与两顶点线段相交            if (((v1.y &lt;= p.y) &amp;&amp; (v2.y &gt; p.y))                || ((v1.y &gt; p.y) &amp;&amp; (v2.y &lt;= p.y)))            &#123;                //只考虑点击点右侧方向，点击点水平线与线段相交，且交点x &gt; 点击点x，则crossNumber+1                if (p.x &lt; v1.x + (p.y - v1.y) / (v2.y - v1.y) * (v2.x - v1.x))                &#123;                    crossNumber += 1;                &#125;            &#125;        &#125;    &#125;            /// &lt;summary&gt;    /// Adjusts the image size to make it pixel-perfect.    /// &lt;/summary&gt;    /// &lt;remarks&gt;    /// This means setting the Images RectTransform.sizeDelta to be equal to the Sprite dimensions.    /// &lt;/remarks&gt;    public override void SetNativeSize()    &#123;        if (activeSprite != null)        &#123;            float w = activeSprite.rect.width / pixelsPerUnit;            float h = activeSprite.rect.height / pixelsPerUnit;            rectTransform.anchorMax = rectTransform.anchorMin;            rectTransform.sizeDelta = new Vector2(w, h);            SetAllDirty();        &#125;    &#125;&#125;</code></pre><h3 id="CircleImageEditor"><a href="#CircleImageEditor" class="headerlink" title="CircleImageEditor"></a>CircleImageEditor</h3><pre><code>[CustomEditor(typeof(CircleImage))]public class CircleImageEditor : GraphicEditor&#123;    public override void OnInspectorGUI() &#123;        DrawDefaultInspector();                CircleImage myScript = (CircleImage)target;        EditorGUILayout.BeginHorizontal();        &#123;            GUILayout.Space(EditorGUIUtility.labelWidth);            if (GUILayout.Button(&quot;Set Native Size&quot;, EditorStyles.miniButtonRight))            &#123;                myScript.SetNativeSize();            &#125;        &#125;        EditorGUILayout.EndHorizontal();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考博客地址：&lt;a href=&quot;https://www.cnblogs.com/leoin2012/p/6425089.html&quot;&gt;https://www.cnblogs.com/leoin2012/p/6425089.html&lt;/a&gt;  &lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="UGUI" scheme="http://yoursite.com/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——UGUI基于图集的shader遮罩</title>
    <link href="http://yoursite.com/2021/04/20/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UGUI%E5%9F%BA%E4%BA%8E%E5%9B%BE%E9%9B%86%E7%9A%84shader%E9%81%AE%E7%BD%A9/"/>
    <id>http://yoursite.com/2021/04/20/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UGUI%E5%9F%BA%E4%BA%8E%E5%9B%BE%E9%9B%86%E7%9A%84shader%E9%81%AE%E7%BD%A9/</id>
    <published>2021-04-20T06:25:21.000Z</published>
    <updated>2021-12-27T03:39:09.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Unity开发过程中，为了节省图，经常会做一些图形的遮罩，笔者开发UI使用的是UGUI遮罩，用过UGUI的Mask做遮罩的应该都知道，UGUI的mask做遮罩有很明显的锯齿，于是笔者就从网上学习一套shader做的遮罩，但是仅仅是shader做的遮罩虽然效果很好，但是在正式开发中，为了优化性能，大部分图片都是会打成图集的，这时候shader中的UV就不是我们想要的UV了，这时候就需要做一些修改了。所以本文是基于图集的shader遮罩。</p><h1 id="普通的shader遮罩"><a href="#普通的shader遮罩" class="headerlink" title="普通的shader遮罩"></a>普通的shader遮罩</h1><p><img src="https://file.liangxiegame.com/e2f8acff-6e17-45c0-8bd1-ec8027772385.png" alt="image.png"> </p><p>上图左边是普通的UGUI的正常mask，右边是shader写的遮罩，边缘锯齿比较很明显。</p><h2 id="shader代码"><a href="#shader代码" class="headerlink" title="shader代码"></a>shader代码</h2><pre><code>Shader &quot;ImageMask01&quot;&#123;    Properties    &#123;        [PerRendererData] _MainTex (&quot;Sprite Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Mask (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;         _Color (&quot;Tint&quot;, Color) = (1,1,1,1)        _StencilComp(&quot;Stencil Comparison&quot;, Float) = 8        _Stencil(&quot;Stencil ID&quot;, Float) = 0        _StencilOp(&quot;Stencil Operation&quot;, Float) = 0        _StencilWriteMask(&quot;Stencil Write Mask&quot;, Float) = 255        _StencilReadMask(&quot;Stencil Read Mask&quot;, Float) = 255        _ColorMask(&quot;Color Mask&quot;, Float) = 15    &#125;    SubShader    &#123;        Tags        &#123;            &quot;Queue&quot;=&quot;Transparent&quot;            &quot;IgnoreProjector&quot;=&quot;True&quot;            &quot;RenderType&quot;=&quot;Transparent&quot;            &quot;PreviewType&quot;=&quot;Plane&quot;            &quot;CanUseSpriteAtlas&quot;=&quot;True&quot;        &#125;        Stencil        &#123;            Ref [_Stencil]            Comp [_StencilComp]            Pass [_StencilOp]            ReadMask [_StencilReadMask]            WriteMask [_StencilWriteMask]        &#125;        Cull Off        Lighting Off        ZWrite Off        ZTest [unity_GUIZTestMode]        Blend SrcAlpha OneMinusSrcAlpha        ColorMask [_ColorMask]        Pass        &#123;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #pragma target 2.0            #include &quot;UnityCG.cginc&quot;            #include &quot;UnityUI.cginc&quot;            #pragma multi_compile_local _ UNITY_UI_CLIP_RECT            #pragma multi_compile_local _ UNITY_UI_ALPHACLIP            struct appdata_t            &#123;                fixed2 uv : TEXCOORD0;                float4 vertex   : POSITION;                float4 color    : COLOR;            &#125;;            struct v2f            &#123;                fixed2 uv : TEXCOORD0;                float4 vertex   : SV_POSITION;                fixed4 color    : COLOR;            &#125;;            sampler2D _MainTex;            fixed4 _Color;            sampler2D _Mask;            v2f vert(appdata_t IN)            &#123;                v2f OUT;                OUT.vertex = UnityObjectToClipPos(IN.vertex);                OUT.uv = IN.uv;                OUT.color = IN.color * _Color;#ifdef PIXELSNAP_ON                OUT.vertex = UnityPixelSnap(OUT.vertex);#endif                return OUT;            &#125;            fixed4 frag(v2f IN) : SV_Target            &#123;                fixed4 color = tex2D(_MainTex, IN.uv) * IN.color;                fixed4 mask = tex2D(_Mask, IN.uv);                color.a *= mask.a;                return color;            &#125;        ENDCG        &#125;    &#125;&#125;</code></pre><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>上述代码虽然多，但是大部分都是通用的固定写法，包含一些shader支持UGUI的mask的写法，这里就不要进行讲解了，我们来看看我们shader做mask的关键代码。</p><pre><code>Properties&#123;    ...    _Mask (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;     ...&#125;</code></pre><p>在Properties主要是把我们需要遮罩的形状放进去，这里需要注意的是需要遮罩的部分图片必须不透明，因为在做遮罩的时候是读取这个图片的透明度来判断是否需要进行遮罩的。也就是下面的代码：</p><pre><code>fixed4 frag(v2f IN) : SV_Target&#123;    fixed4 color = tex2D(_MainTex, IN.uv) * IN.color;    fixed4 mask = tex2D(_Mask, IN.uv);    color.a *= mask.a;    return color;&#125;</code></pre><p>逐片源操作的时候来进行读取来遮罩显示。</p><h1 id="基于图集的遮罩"><a href="#基于图集的遮罩" class="headerlink" title="基于图集的遮罩"></a>基于图集的遮罩</h1><p>虽然上述已经实现了遮罩，但是在假如我们需要遮罩的图片是在图集上，会发现我们的遮罩会出现错误，不遮罩或者遮罩的不对，这是因为shader在读取图片的UV坐标的时候读取的并不是0<del>1而是图片在图集中的坐标，所以根据坐标进行遮罩是不行的。<br>解决方案就是需要把遮罩的坐标转成0</del>1的坐标，这样就可以判断是否需要遮罩了。<br>虽然我们有了解决方案，但是我们如何在shader中获取图片在图集的坐标呢，笔者的解决方案是利用一个C#的脚本，把图片坐标传递给shader。</p><h2 id="Shader新的代码"><a href="#Shader新的代码" class="headerlink" title="Shader新的代码"></a>Shader新的代码</h2><pre><code>Properties&#123;    ...    _Mask (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;     _UvRect (&quot;UvRect&quot;, Vector) = (0, 0, 1, 1)    ...&#125;</code></pre><p>上述是Properties中的代码，可以看出和普通的相比多了一个_UvRect参数，是用来保存图片在图集中的坐标的。  </p><pre><code>fixed4 frag(v2f IN) : SV_Target&#123;    fixed4 color = tex2D(_MainTex, IN.uv) * IN.color;        float2 temuv = float2((IN.uv.x - _UvRect.x)/(_UvRect.z - _UvRect.x),(IN.uv.y - _UvRect.y)/(_UvRect.w - _UvRect.y));    fixed4 mask = tex2D(_Mask, temuv);    color.a *= mask.a;    return color;&#125;</code></pre><p>在判断是否遮罩的时候，可以看到笔者关键性的代码，就是teamuv的赋值，算法很简单，知道图片四个角在图集的UV坐标，就是_UvRect参数，然后**(IN.uv.x - _UvRect.x)<strong>和</strong>(IN.uv.y - _UvRect.y)**就为了计算图片距离图片原点坐标的差值，也就是坐标系的坐标，他们在分别除以他们坐在的长度就转换成新的UV坐标了，其实就是图片本身的UV坐标了，然后就可以和普通的shader一样计算了。  </p><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C#代码"></a>C#代码</h2><pre><code>public class RefreshUVRect : MonoBehaviour&#123;    private Material material;    private Image img;    // Start is called before the first frame update    void Start()    &#123;        img = GetComponent&lt;Image&gt;();        material = img.material;        Refresh();    &#125;    public void Refresh()    &#123;        if (img)        &#123;            Vector4 uvRect = UnityEngine.Sprites.DataUtility.GetOuterUV(img.overrideSprite);            material.SetVector(&quot;_UvRect&quot;, uvRect);        &#125;    &#125;&#125;</code></pre><p>C#的代码比较简单，就是获取一下材质，然后把图片四个角的UV坐标传递给材质，<strong>UnityEngine.Sprites.DataUtility.GetOuterUV</strong>这个方法就是获取UV的边界坐标。<br><font color=red size=4>特别提醒一下，遮罩后编辑器模式下是错误的，因为获取的还是图片坐标，运行状态下观看就是正确的了</font></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在Unity开发过程中，为了节省图，经常会做一些图形的遮罩，笔者开发UI使用的是UGUI遮罩，用过UGUI的Mask做遮罩的应该都知道，UG</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="UGUI" scheme="http://yoursite.com/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——UGUI中粒子的遮罩与裁剪</title>
    <link href="http://yoursite.com/2021/04/19/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UGUI%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E9%81%AE%E7%BD%A9%E4%B8%8E%E8%A3%81%E5%89%AA/"/>
    <id>http://yoursite.com/2021/04/19/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UGUI%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E9%81%AE%E7%BD%A9%E4%B8%8E%E8%A3%81%E5%89%AA/</id>
    <published>2021-04-19T02:48:13.000Z</published>
    <updated>2021-12-27T03:39:09.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Unity开发中，在使用UGUI的mask的时候，如果子节点存在粒子特效，发现mask并不能裁剪粒子，比如笔者在开发中，有一个滑动列表，列表中的button上面存在按钮特效，在滑动的时候滑动的mask并不能裁剪粒子，因此笔者从网上找到了一些解决方案，并应用了一下，用着还可以。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>粒子的裁剪是用shader制作的，但是仅仅用shader是并不能满足需求的，因为特效有可能是会动的，这样剪裁区域就会发生变化，所以需要一个脚本把裁剪的区域传递给shader，然后shader在进行裁剪处理。  </p><h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C#代码"></a>C#代码</h1><pre><code>public class TailorParticle : MonoBehaviour&#123;    private Material material;    private Mask mask;    private RectMask2D rectmask2d;    public void Start()    &#123;        material = GetComponentInChildren&lt;ParticleSystem&gt;().GetComponent&lt;Renderer&gt;().material;        mask = GetComponentInParent&lt;Mask&gt;();        rectmask2d = GetComponentInParent&lt;RectMask2D&gt;();        SetClip();        //如果运行时裁剪区域不会发生改变，可以注释掉下面这句代码        var scrollrecct = GetComponentInParent&lt;ScrollRect&gt;();        if (scrollrecct)        &#123;            scrollrecct.onValueChanged.AddListener(v =&gt; &#123; SetClip(); &#125;);        &#125;    &#125;    private bool isMask;    private Vector3[] corners = new Vector3[4];    private Vector3[] cornerstemp = new Vector3[4];    public void SetClip()    &#123;        //获取到需要裁剪的区域        isMask = false;        if (mask)         &#123;            mask.GetComponent&lt;RectTransform&gt;().GetWorldCorners(corners);            isMask = true;        &#125;        if(rectmask2d)        &#123;            rectmask2d.GetComponent&lt;RectTransform&gt;().GetWorldCorners(cornerstemp);            if (isMask)            &#123;                corners[0].x = Mathf.Min(corners[0].x, cornerstemp[0].x);                corners[0].y = Mathf.Min(corners[0].y, cornerstemp[0].y);                corners[2].x = Mathf.Max(corners[2].x, cornerstemp[2].x);                corners[2].y = Mathf.Max(corners[2].y, cornerstemp[2].y);            &#125;            else            &#123;                isMask = true;            &#125;        &#125;        if (material &amp;&amp; isMask)        &#123;            //将裁剪区域传入到Shader中            material.SetFloat(&quot;_MinX&quot;, corners[0].x);            material.SetFloat(&quot;_MinY&quot;, corners[0].y);            material.SetFloat(&quot;_MaxX&quot;, corners[2].x);            material.SetFloat(&quot;_MaxY&quot;, corners[2].y);        &#125;    &#125;&#125;</code></pre><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><pre><code>material = GetComponentInChildren&lt;ParticleSystem&gt;().GetComponent&lt;Renderer&gt;().material;mask = GetComponentInParent&lt;Mask&gt;();rectmask2d = GetComponentInParent&lt;RectMask2D&gt;();SetClip();//如果运行时裁剪区域不会发生改变，可以注释掉下面这句代码var scrollrecct = GetComponentInParent&lt;ScrollRect&gt;();if (scrollrecct)&#123;    scrollrecct.onValueChanged.AddListener(v =&gt; &#123; SetClip(); &#125;);&#125;</code></pre><p>首先我们先看Start函数中，material是获取子节点的粒子特效的材质(如果粒子多了可以自己扩展成组)，mask是获取父节点的Mask遮罩，rectmask2d和mask一样是获取父节点的RectMask2D组件，笔者之所以获取RectMask2D这个组件是因为笔者有些裁剪是用这个做的。接着就是进行裁剪函数，这里后面介绍。正常的裁剪到这里就结束了，但是我们如果想裁剪区域进行动态变化，那我们就要进行动态刷新shader，笔者这里只是简单的用ScrollRect进行举例，大家可以根据自己的项目进行监听。只要当变化的时候刷新一下裁剪就行了。  </p><pre><code>isMask = false;if (mask) &#123;    mask.GetComponent&lt;RectTransform&gt;().GetWorldCorners(corners);    isMask = true;&#125;if(rectmask2d)&#123;    rectmask2d.GetComponent&lt;RectTransform&gt;().GetWorldCorners(cornerstemp);    if (isMask)    &#123;        corners[0].x = Mathf.Min(corners[0].x, cornerstemp[0].x);        corners[0].y = Mathf.Min(corners[0].y, cornerstemp[0].y);        corners[2].x = Mathf.Max(corners[2].x, cornerstemp[2].x);        corners[2].y = Mathf.Max(corners[2].y, cornerstemp[2].y);    &#125;    else    &#123;        isMask = true;    &#125;&#125;</code></pre><p>接着我们来看一下裁剪的代码，首先是标记不需要裁剪，只有当父节点存在Mask的时候才进行裁剪，然后就是获取父节点的剪裁区域，笔者这里是把两个Mask进行融合，获取最小的范围，这里可以根据自己的需求进行变化，然后就是关键性的代码  </p><pre><code>if (material &amp;&amp; isMask)&#123;    //将裁剪区域传入到Shader中    material.SetFloat(&quot;_MinX&quot;, corners[0].x);    material.SetFloat(&quot;_MinY&quot;, corners[0].y);    material.SetFloat(&quot;_MaxX&quot;, corners[2].x);    material.SetFloat(&quot;_MaxY&quot;, corners[2].y);&#125;</code></pre><p>这里就是将剪裁区域传递给次材质的shader，然后shader进行裁剪。</p><h1 id="Shader关键代码"><a href="#Shader关键代码" class="headerlink" title="Shader关键代码"></a>Shader关键代码</h1><pre><code>Properties &#123;        ...    _MinX (&quot;Min X&quot;, Float) = -10    _MaxX (&quot;Max X&quot;, Float) = 10    _MinY (&quot;Min Y&quot;, Float) = -10    _MaxY (&quot;Max Y&quot;, Float) = 10&#125;SubShader &#123;    Pass &#123;        ...        float _MinX;        float _MaxX;        float _MinY;        float _MaxY;                ...        float4 frag(VertexOutput i) : COLOR &#123;                        ...                    c.a *= (i.vpos.x &gt;= _MinX );               c.a *= (i.vpos.x &lt;= _MaxX);            c.a *= (i.vpos.y &gt;= _MinY);            c.a *= (i.vpos.y &lt;= _MaxY);            c.rgb *= c.a;            return c;        &#125;        ...    &#125;&#125;</code></pre><p>shader的代码也比较简单，就是将传过来的区域进行判断，如果在区域内据显示，如果超出区域就将颜色的透明度设置为0，也就看不见了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在Unity开发中，在使用UGUI的mask的时候，如果子节点存在粒子特效，发现mask并不能裁剪粒子，比如笔者在开发中，有一个滑动列表，列</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="UGUI" scheme="http://yoursite.com/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>LBFramwork框架搭建</title>
    <link href="http://yoursite.com/2020/07/30/Unity%E6%A1%86%E6%9E%B6/LBFramwork%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/07/30/Unity%E6%A1%86%E6%9E%B6/LBFramwork%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</id>
    <published>2020-07-30T06:40:08.000Z</published>
    <updated>2021-12-27T03:39:09.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LBFramework简介"><a href="#LBFramework简介" class="headerlink" title="LBFramework简介"></a>LBFramework简介</h1><p><font size=4><strong>单元测试环境： NSubstitute</strong></font><br><font size=4><strong>编写脚本环境： rider 2020.1.4</strong></font><br><font size=4><strong>Unity环境: unity2019.4.3f1(LTS)</strong></font>    </p><p>此篇文章记录笔者一步一步创建LBFramework框架，一步一步学习游戏框架。    </p><h1 id="LBUtils"><a href="#LBUtils" class="headerlink" title="LBUtils"></a>LBUtils</h1><h2 id="LBEditor"><a href="#LBEditor" class="headerlink" title="LBEditor"></a>LBEditor</h2><p>记录框架中编辑器的扩展  </p><h3 id="EditorModulizationPlatform-模块化编辑器结构"><a href="#EditorModulizationPlatform-模块化编辑器结构" class="headerlink" title="EditorModulizationPlatform    模块化编辑器结构"></a>EditorModulizationPlatform    模块化编辑器结构</h3><p>这是一个模块化编辑器结构<br>首先创建一个接口  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><pre><code>public interface IEditorPlatformModule&#123;    /// &lt;summary&gt;    /// 渲染 IMGUI    /// &lt;/summary&gt;    void OnGUI();&#125;public class EditorModuleContainer&#123;    /// &lt;summary&gt;    /// 用来缓存的模s块    /// &lt;/summary&gt;    private List&lt;object&gt; mInstances = new List&lt;object&gt;();    /// &lt;summary&gt;    /// 溶解（获取全部)    /// &lt;/summary&gt;    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public List&lt;T&gt; ResolveAll&lt;T&gt;()    &#123;        return mInstances.OfType&lt;T&gt;()            .ToList();    &#125;    public void Init()    &#123;        // 清空掉之前的实例        mInstances.Clear();        // 1.获取当前项目中所有的 assembly (可以理解为 代码编译好的 dll)        var assemblies = AppDomain.CurrentDomain.GetAssemblies();        // 2.获取编辑器环境(dll)        var editorAssembly = assemblies.First(assembly =&gt; assembly.FullName.StartsWith(&quot;Assembly-CSharp-Editor&quot;));        // 3.获取 IEditorPlatformModule 类型        var moduleType = typeof(IEditorPlatformModule);        mInstances = editorAssembly            // 获取所有的编辑器环境中的类型             .GetTypes()            // 过滤掉抽象类型（接口/抽象类)、和未实现 IEditorPlatformModule 的类型            .Where(type =&gt; moduleType.IsAssignableFrom(type) &amp;&amp; !type.IsAbstract)            // 获取类型的构造创建实例            .Select(type =&gt; type.GetConstructors().First().Invoke(null))            // 转换成 List&lt;IEditorPlatformModule&gt;            .ToList();    &#125;&#125;public class EditorModulizationPlatformEditor : EditorWindow&#123;    private EditorModulizationContainer mContainer;    /// &lt;summary&gt;    /// 打开窗口    /// &lt;/summary&gt;    [MenuItem(&quot;LBFramework/LBUtils/LBEditor&quot;)]    public static void Open()    &#123;        var editorPlatform = GetWindow&lt;EditorModulizationPlatformEditor&gt;();        editorPlatform.position = new Rect(            Screen.width / 2,            Screen.height * 2 / 3,            600,            500        );        // 初始化 Container        editorPlatform.mContainer = new EditorModulizationContainer();        editorPlatform.mContainer.Init();        editorPlatform.Show();    &#125;    private void OnGUI()    &#123;        // 渲染        mContainer.ResolveAll&lt;IEditorPlatformModule&gt;()            .ForEach(editorPlatformModule=&gt;editorPlatformModule.OnGUI());    &#125;&#125;</code></pre></details>调用的测试如下所示  <details><summary><font color=darkred>点击查看测试脚本详细内容</font></summary><pre><code>public class LBEditorTest:IEditorPlatformModule&#123;    public void OnGUI()    &#123;        GUILayout.Label(&quot;这个是一个新的模块&quot;, new GUIStyle()        &#123;            fontSize = 30        &#125;);        GUILayout.Button(&quot;LianBai&quot;);    &#125;&#125;</code></pre></details><h3 id="EditorCreatCShapTemp-编辑器扩展创建模板脚本"><a href="#EditorCreatCShapTemp-编辑器扩展创建模板脚本" class="headerlink" title="EditorCreatCShapTemp  编辑器扩展创建模板脚本"></a>EditorCreatCShapTemp  编辑器扩展创建模板脚本</h3><p>这是一个创建各种类型脚本的工具，笔者在写脚本的时候，因为Unity自带的创建脚本都是提供的模板，需要删除很多东西，所以笔者就自己写了一个工具用来创建脚本。  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><pre><code>public class EditorCreatScript&#123;    //获取选中的文件夹路径    public static string GetSelectedPathOrFallBack()    &#123;        string path = &quot;Assets&quot;;        foreach (UnityEngine.Object obj  in Selection.GetFiltered(typeof(UnityEngine.Object),SelectionMode.Assets))        &#123;            path = AssetDatabase.GetAssetPath(obj);            if (!string.IsNullOrEmpty(path) &amp;&amp; File.Exists(path))            &#123;                path = Path.GetDirectoryName(path);                break;            &#125;        &#125;        return path;    &#125;&#125;public //定义一个创建资源的Action类并实现其Action方法    class CraetEventCSScriptAsset : EndNameEditAction&#123;    public override void Action(int instanceId, string pathName, string resourceFile)    &#123;        //创建资源        UnityEngine.Object o = CreatScriptAssetFormTemplate(pathName, resourceFile);        //高亮显示该资源        ProjectWindowUtil.ShowCreatedAsset(o);    &#125;    internal static UnityEngine.Object CreatScriptAssetFormTemplate(string pathName, string resourcesFile)    &#123;        //获取创建资源的绝对路径        string fullName = Path.GetFullPath(pathName);        //读取本地模板        StreamReader streamReader = new StreamReader(resourcesFile);        string text = streamReader.ReadToEnd();        streamReader.Close();                    //获取文件名字        string fileName = Path.GetFileNameWithoutExtension(pathName);        //替换文件中的内容        text = text.Replace(&quot;#NAME&quot;,fileName);        bool encoderShouldEmitUTF8Identifier = true;        bool throwOnInvalidBytes = false;        UTF8Encoding uTF8Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier, throwOnInvalidBytes);        bool append = false;        //写入新文件        StreamWriter streamWriter = new StreamWriter(fullName, append, uTF8Encoding);        streamWriter.Write(text);        streamWriter.Close();                    //刷新本地资源        AssetDatabase.ImportAsset(pathName);        AssetDatabase.Refresh();        return AssetDatabase.LoadAssetAtPath(pathName, typeof(UnityEngine.Object));    &#125;&#125;</code></pre></details>调用的方法如下列代码所示  <details><summary><font color=darkred>点击查看测试脚本详细内容</font></summary><pre><code>public class EditorCreanScriptTest : EditorCreatScript&#123;    [MenuItem(&quot;Assets/Create/LBFCShap&quot;, false, 80)]    public static void CreatLBFCShap()    &#123;        ProjectWindowUtil.StartNameEditingIfProjectWindowExists(0,            ScriptableObject.CreateInstance&lt;CraetEventCSScriptAsset&gt;(),            GetSelectedPathOrFallBack()+&quot;/New Script.cs&quot;,            null,            &quot;Assets/LBFramework/LBUnitTest/&quot; +            &quot;Editor/CShapTemp/LBFCSTemp.txt&quot;         // 只需要在此文件夹下创建你需要的模板，命名与EventCSClass.cs一致就行        );    &#125;&#125;</code></pre></details><h2 id="AssemblyUtil的获取"><a href="#AssemblyUtil的获取" class="headerlink" title="AssemblyUtil的获取"></a>AssemblyUtil的获取</h2><p>这是一个收集AssemblyUtil获取部分的代码  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><pre><code>public class AssemblyUtil&#123;    public static Assembly EditorAssembly    &#123;        get        &#123;            // 1.获取当前项目中所有的 assembly (可以理解为 代码编译好的 dll)            var assemblies = AppDomain.CurrentDomain.GetAssemblies();            // 2.获取编辑器环境(dll)            var editorAssembly =                assemblies.First(assembly =&gt; assembly.FullName.StartsWith(&quot;Assembly-CSharp-Editor&quot;));            return editorAssembly;        &#125;    &#125;&#125;public static Assembly CShapAssembly&#123;    get    &#123;        // 1.获取当前项目中所有的 CShap assembly (可以理解为 代码编译好的 dll)        var assemblies = AppDomain.CurrentDomain.GetAssemblies();        // 2.获取编辑器环境(dll)        var cShapAssembly =            assemblies.First(assembly =&gt; assembly.FullName.StartsWith(&quot;Assembly-CSharp&quot;));        return cShapAssembly;    &#125;&#125;public static List&lt;Type&gt; GetEditoeAssemblyInstance&lt;Type&gt;()&#123;    return EditorAssembly        // 获取所有的编辑器环境中的类型         .GetTypes()        // 过滤掉抽象类型（接口/抽象类)、和未实现 Type 的类型        .Where(type =&gt; typeof(Type).IsAssignableFrom(type) &amp;&amp; !type.IsAbstract)        // 获取类型的构造创建实例        .Select(type =&gt; type.GetConstructors().First().Invoke(null))        // 转换成 List&lt;Type&gt;        .ToList()        .OfType&lt;Type&gt;()        .ToList();&#125;public static List&lt;Type&gt; GetCShapAssemblyInstance&lt;Type&gt;()&#123;    return CShapAssembly        // 获取所有的编辑器环境中的类型         .GetTypes()        // 过滤掉抽象类型（接口/抽象类)、和未实现 Type 的类型        .Where(type =&gt; typeof(Type).IsAssignableFrom(type) &amp;&amp; !type.IsAbstract)        // 获取类型的构造创建实例        .Select(type =&gt; type.GetConstructors().First().Invoke(null))        // 转换成 List&lt;Type&gt;        .ToList()        .OfType&lt;Type&gt;()        .ToList();&#125;</code></pre></details><h2 id="ResolutionCheck-屏幕检测"><a href="#ResolutionCheck-屏幕检测" class="headerlink" title="ResolutionCheck 屏幕检测"></a>ResolutionCheck 屏幕检测</h2><p>这个模块是一个屏幕检测的脚本，主要是用于检测是横屏竖屏的。  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><pre><code>public class ResolutionCheck&#123;    //判断是否横屏    public static bool IsLandScape    &#123;        get &#123; return Screen.width &gt; Screen.height; &#125;    &#125;        //Pad、Android 大部分平板的宽高比是 4:3    public static bool IsPad    &#123;        get &#123; return IsRatito(4,3);; &#125;    &#125;    //1280 / 720（一般安卓设备，结果为 1.777778） 还是 1136 / 640（iPhone 5s，结果为 1.775）    //或者是 1920 / 1080（iPhone 6p ，结果为 1.777778），它们都属于 16 ： 9 这个宽高比的范畴    public static bool IsPhone16_9    &#123;        get &#123; return IsRatito(16,9); &#125;    &#125;    public static bool IsRatito(float width, float height)    &#123;        var aspectRatio = IsLandScape            ? (float) Screen.width / Screen.height            : (float) Screen.height / Screen.width;        var destinationRatio = width / height;        return aspectRatio &gt; destinationRatio - 0.05f &amp;&amp; aspectRatio &lt; destinationRatio + 0.05f;    &#125;&#125;</code></pre></details><p>这个模块的单元测试如下列代码：  </p><details><summary><font color=darkred>点击查看测试脚本详细内容</font></summary><pre><code>public class ResolutionCheckTests&#123;    [Test]    public void ResolutionCheck_LandscapeTests()    &#123;        Debug.LogFormat(&quot;是否是横屏:&#123;0&#125;&quot;, ResolutionCheck.IsLandScape);        Assert.AreEqual(ResolutionCheck.IsLandScape, Screen.width &gt; Screen.height);    &#125;        [Test]    public void ResolutionCheck_4_3_Tests()    &#123;        Debug.LogFormat(&quot;是否是4:3分辨率？&#123;0&#125;&quot;, ResolutionCheck.IsPad);    &#125;        [Test]    public void ResolutionCheck_16_9_Tests()    &#123;        Debug.LogFormat(&quot;是否是16:9分辨率？&#123;0&#125;&quot;, ResolutionCheck.IsPhone16_9);    &#125;    [Test]    public void ResolutionCheck_Other_Tests()    &#123;        Debug.LogFormat(&quot;是否是750:1334分辨率？&#123;0&#125;&quot;, ResolutionCheck.IsRatito(750,1334));        Debug.LogFormat(&quot;是否是1024:768分辨率？&#123;0&#125;&quot;, ResolutionCheck.IsRatito(1024,768));    &#125;&#125;</code></pre></details><h2 id="CompExtend-组件扩展"><a href="#CompExtend-组件扩展" class="headerlink" title="CompExtend 组件扩展"></a>CompExtend 组件扩展</h2><p>这个模块主要用于扩展Unity中的Component,我们再为坐标赋值的时候，因为用的是struct，所以每次都要重新构造一个Vector3，因此可以扩展一下从而可以很简单的赋值。<br>这个模块是一个屏幕检测的脚本，主要是用于检测是横屏竖屏的。  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><pre><code>public static class CompExtend&#123;    //设置世界坐标X的值    public static T PositionX&lt;T&gt;(this T self, float x) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var position = transform.position;           //临时变量存储坐标信息        position.x = x;                                    //更改临时变量的坐标信息        transform.position = position;                    //重新给位置信息赋值        return self;    &#125;    //设置世界坐标Y的值    public static T PositionY&lt;T&gt;(this T self, float y) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var position = transform.position;           //临时变量存储坐标信息        position.y = y;                                    //更改临时变量的坐标信息        transform.position = position;                    //重新给位置信息赋值        return self;    &#125;    //设置世界坐标Z的值    public static T PositionZ&lt;T&gt;(this T self, float z) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var position = transform.position;           //临时变量存储坐标信息        position.z = z;                                    //更改临时变量的坐标信息        transform.position = position;                    //重新给位置信息赋值        return self;    &#125;    //设置世界坐标XY的值    public static T PositionXY&lt;T&gt;(this T self, float x,float y) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var position = transform.position;           //临时变量存储坐标信息        position.x = x;                                    //更改临时变量的坐标信息        position.y = y;                                            transform.position = position;                    //重新给位置信息赋值        return self;    &#125;    //设置世界坐标XZ的值    public static T PositionXZ&lt;T&gt;(this T self, float x,float z) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var position = transform.position;           //临时变量存储坐标信息        position.x = x;                                    //更改临时变量的坐标信息        position.z = z;                                            transform.position = position;                    //重新给位置信息赋值        return self;    &#125;    //设置世界坐标YZ的值    public static T PositionYZ&lt;T&gt;(this T self, float y,float z) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var position = transform.position;           //临时变量存储坐标信息        position.y = y;                                    //更改临时变量的坐标信息        position.z = z;                                            transform.position = position;                    //重新给位置信息赋值        return self;    &#125;    //设置本地坐标X的值    public static T LocalPositionX&lt;T&gt;(this T self, float x) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var localPosition = transform.localPosition;           //临时变量存储坐标信息        localPosition.x = x;                                    //更改临时变量的坐标信息        transform.localPosition = localPosition;                    //重新给位置信息赋值        return self;    &#125;    //设置本地坐标Y的值    public static T LocalPositionY&lt;T&gt;(this T self, float y) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var localPosition = transform.localPosition;           //临时变量存储坐标信息        localPosition.y = y;                                    //更改临时变量的坐标信息        transform.localPosition = localPosition;                    //重新给位置信息赋值        return self;    &#125;    //设置本地坐标Z的值    public static T LocalPositionZ&lt;T&gt;(this T self, float z) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var localPosition = transform.localPosition;           //临时变量存储坐标信息        localPosition.z = z;                                    //更改临时变量的坐标信息        transform.localPosition = localPosition;                    //重新给位置信息赋值        return self;    &#125;    //设置本地坐标XY的值    public static T LocalPositionXY&lt;T&gt;(this T self, float x,float y) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var localPosition = transform.localPosition;           //临时变量存储坐标信息        localPosition.x = x;                                    //更改临时变量的坐标信息        localPosition.y = y;                                            transform.localPosition = localPosition;                    //重新给位置信息赋值        return self;    &#125;    //设置本地坐标XZ的值    public static T LocalPositionXZ&lt;T&gt;(this T self, float x,float z) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var localPosition = transform.localPosition;           //临时变量存储坐标信息        localPosition.x = x;                                    //更改临时变量的坐标信息        localPosition.z = z;                                            transform.localPosition = localPosition;                    //重新给位置信息赋值        return self;    &#125;    //设置本地坐标YZ的值    public static T LocalPositionYZ&lt;T&gt;(this T self, float y,float z) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var localPosition = transform.localPosition;           //临时变量存储坐标信息        localPosition.y = y;                                    //更改临时变量的坐标信息        localPosition.z = z;                                            transform.localPosition = localPosition;                    //重新给位置信息赋值        return self;    &#125;    //Transfroam本地数据重置    public static T LocalIdentity&lt;T&gt;(this T self) where T : Component    &#123;        var transform = self.transform;        transform.localPosition = Vector3.zero;        transform.localRotation = Quaternion.identity;        transform.localScale = Vector3.one;        return self;    &#125;        //Transfroam世界数据重置    public static T Identity&lt;T&gt;(this T self) where T : Component    &#123;        var transform = self.transform;        transform.position = Vector3.zero;        transform.rotation = Quaternion.identity;        transform.localScale = Vector3.one;                return self;    &#125;        public static T Show&lt;T&gt;(this T self) where T : Component    &#123;        self.gameObject.SetActive(true);        return self;    &#125;    public static T Hide&lt;T&gt;(this T self) where T : Component    &#123;        self.gameObject.SetActive(false);        return self;    &#125;    public static GameObject Show(this GameObject self)    &#123;        self.SetActive(true);        return self;    &#125;    public static GameObject Hide(this GameObject self)    &#123;        self.SetActive(false);        return self;    &#125;&#125;</code></pre></details><p>调用的单元测试如下列脚本：  </p><details><summary><font color=darkred>点击查看测试脚本详细内容</font></summary><pre><code>public class CompExendTest&#123;    [Test]    public static void Extensions_AllTest()    &#123;        var gameObject = new GameObject();        gameObject.transform.PositionX(10);        Assert.AreEqual(gameObject.transform.position.x, 10);        gameObject.transform.PositionY(20);        Assert.AreEqual(gameObject.transform.position.y, 20);                gameObject.transform.PositionZ(30);        Assert.AreEqual(gameObject.transform.position.z, 30);        gameObject.transform.PositionXY(40,50);        Assert.AreEqual(gameObject.transform.position.x, 40);        Assert.AreEqual(gameObject.transform.position.y, 50);                gameObject.transform.PositionXZ(60,70);        Assert.AreEqual(gameObject.transform.position.x, 60);        Assert.AreEqual(gameObject.transform.position.z, 70);        gameObject.transform.PositionYZ(80,90);        Assert.AreEqual(gameObject.transform.position.y, 80);        Assert.AreEqual(gameObject.transform.position.z, 90);        gameObject.transform.LocalPositionX(100);        Assert.AreEqual(gameObject.transform.localPosition.x, 100);        gameObject.transform.LocalPositionY(110);        Assert.AreEqual(gameObject.transform.localPosition.y, 110);        gameObject.transform.LocalPositionZ(120);        Assert.AreEqual(gameObject.transform.localPosition.z, 120);        gameObject.transform.LocalPositionXY(130,140);        Assert.AreEqual(gameObject.transform.localPosition.x, 130);        Assert.AreEqual(gameObject.transform.localPosition.y, 140);                gameObject.transform.LocalPositionXZ(150,160);        Assert.AreEqual(gameObject.transform.localPosition.x, 150);        Assert.AreEqual(gameObject.transform.localPosition.z, 160);                gameObject.transform.LocalPositionYZ(170,180);        Assert.AreEqual(gameObject.transform.localPosition.y, 170);        Assert.AreEqual(gameObject.transform.localPosition.z, 180);        gameObject.transform.LocalIdentity();        Assert.AreEqual(gameObject.transform.localPosition, Vector3.zero);        Assert.AreEqual(gameObject.transform.localRotation,Quaternion.identity);        Assert.AreEqual(gameObject.transform.localScale,Vector3.one);                gameObject.transform.Identity();        Assert.AreEqual(gameObject.transform.position, Vector3.zero);        Assert.AreEqual(gameObject.transform.rotation,Quaternion.identity);        Assert.AreEqual(gameObject.transform.lossyScale,Vector3.one);        gameObject.Show();        Assert.AreEqual(gameObject.activeSelf, true);        gameObject.Hide();        Assert.AreEqual(gameObject.activeSelf, false);        // Transform 测试        gameObject.transform.Show();        Assert.AreEqual(gameObject.activeSelf, true);        gameObject.transform.Hide();        Assert.AreEqual(gameObject.activeSelf, false);        // Component 测试        var camera = gameObject.AddComponent&lt;Camera&gt;();        camera.Show();        Assert.AreEqual(gameObject.activeSelf, true);                camera.Hide();        Assert.AreEqual(gameObject.activeSelf, false);    &#125;&#125;</code></pre></details><h2 id="LBSingleton"><a href="#LBSingleton" class="headerlink" title="LBSingleton"></a>LBSingleton</h2><p>游戏中的单例是常用，但是每次单例都需要自己部分代码，这套结构可以快速制作单例脚本，只需要继承对应的虚类就行了。</p><p>单例的脚本如下  </p><details><summary><font color=darkred>点击查看测试脚本详细内容</font></summary><pre><code>using System;using System.Reflection;#if UNITY_5_6_OR_NEWERusing UnityEngine;using Object = UnityEngine.Object;#endifnamespace LBFramework.LBUtils&#123;    public interface ISingleton    &#123;        void OnInitSingleton();    &#125;    public abstract class Singleton&lt;T&gt; : ISingleton where T : Singleton&lt;T&gt;    &#123;        protected static T mInstance;        private static object mLock = new object();        //用来锁定，防止多线程问题        public static T Instabce        &#123;            get            &#123;                lock (mLock)                &#123;                    if (mInstance == null)                    &#123;                        mInstance = SingletonCreator.CreateSingleton&lt;T&gt;();                    &#125;                &#125;                return mInstance;            &#125;        &#125;        public void OnInitSingleton() &#123; &#125;    &#125;    public static class SingletonCreator    &#123;        public static T CreateSingleton&lt;T&gt;() where T : class, ISingleton        &#123;            // 获取私有构造函数            var ctors = typeof(T).GetConstructors(BindingFlags.Instance | BindingFlags.NonPublic);            // 获取无参构造函数            var ctor = Array.Find(ctors, c =&gt; c.GetParameters().Length == 0);            if (ctor == null)            &#123;                throw new Exception(&quot;Non-Public Constructor() not found! in &quot; + typeof(T));            &#125;            // 通过构造函数，常见实例            var retInstance = ctor.Invoke(null) as T;            retInstance.OnInitSingleton();            return retInstance;        &#125;    &#125;#if UNITY_5_6_OR_NEWER    [Obsolete]    public class QMonoSingletonPath : MonoSingletonPath    &#123;        public QMonoSingletonPath(string pathInHierarchy) : base(pathInHierarchy)        &#123;        &#125;    &#125;    //定义一个特性并控制定义特性的使用    [AttributeUsage(AttributeTargets.Class)]    public class MonoSingletonPath : Attribute    &#123;        private string mPathInHierarchy;        public MonoSingletonPath(string pathInHierarchy)        &#123;            mPathInHierarchy = pathInHierarchy;        &#125;        public string PathInHierarchy        &#123;            get &#123; return mPathInHierarchy; &#125;        &#125;    &#125;    public abstract class MonoSingleton&lt;T&gt; : MonoBehaviour, ISingleton where T : MonoSingleton&lt;T&gt;    &#123;        protected static T mInstance;        protected static bool mOnApplicationQuit = false;        public static T Instance        &#123;            get            &#123;                if (mInstance == null &amp;&amp; !mOnApplicationQuit)                &#123;                    mInstance = MonoSingletonCreator.CreateMonoSingleton&lt;T&gt;();                &#125;                return mInstance;            &#125;        &#125;        public virtual void OnInitSingleton() &#123; &#125;        public virtual void Dispose()        &#123;            if (MonoSingletonCreator.IsUnitTestMode)            &#123;                var curTrans = transform;                do                &#123;                    var parent = curTrans.parent;                    DestroyImmediate(curTrans.gameObject);                    curTrans = parent;                &#125; while (curTrans != null);                mInstance = null;            &#125;            else &#123; Destroy(gameObject); &#125;        &#125;        //应用退出前进行处理        protected virtual void OnApplicationQuit()        &#123;            mOnApplicationQuit = true;            if (mInstance == null) return;            Destroy(mInstance.gameObject);            mInstance = null;        &#125;        protected virtual void OnDestroy() &#123; mInstance = null; &#125;        //判断对象是否已经退出        public static bool IsApplicationQuit        &#123;            get &#123; return mOnApplicationQuit; &#125;        &#125;    &#125;    //创建单例    public static class MonoSingletonCreator    &#123;        public static bool IsUnitTestMode &#123; get; set; &#125;        public static T CreateMonoSingleton&lt;T&gt;() where T : MonoBehaviour, ISingleton        &#123;            T instance = null;            //判断是否需要创建            if (!IsUnitTestMode &amp;&amp; !Application.isPlaying) return instance;            instance = Object.FindObjectOfType&lt;T&gt;();            //如果已经存在了就初始化并且返回            if (instance != null)            &#123;                instance.OnInitSingleton();                return instance;            &#125;            //获取成员信息            MemberInfo info = typeof(T);            var attributes = info.GetCustomAttributes(true);            foreach (var atribute in attributes)            &#123;                var defineAttri = atribute as MonoSingletonPath;                if (defineAttri == null)                &#123;                    continue;                &#125;                instance = CreateComponentOnGameObject&lt;T&gt;(defineAttri.PathInHierarchy, true);                break;            &#125;            if (instance == null)            &#123;                var obj = new GameObject(typeof(T).Name);                if (!IsUnitTestMode)                    Object.DontDestroyOnLoad(obj);                instance = obj.AddComponent&lt;T&gt;();            &#125;            instance.OnInitSingleton();            return instance;        &#125;        private static T CreateComponentOnGameObject&lt;T&gt;(string path, bool dontDestroy) where T : MonoBehaviour        &#123;            var obj = FindGameObject(path, true, dontDestroy);            if (obj == null)            &#123;                obj = new GameObject(&quot;Singleton of &quot; + typeof(T).Name);                if (dontDestroy &amp;&amp; !IsUnitTestMode)                &#123;                    Object.DontDestroyOnLoad(obj);                &#125;            &#125;            return obj.AddComponent&lt;T&gt;();        &#125;        private static GameObject FindGameObject(string path, bool build, bool dontDestroy)        &#123;            if (string.IsNullOrEmpty(path))            &#123;                return null;            &#125;            var subPath = path.Split(&#39;/&#39;);            if (subPath == null || subPath.Length == 0)            &#123;                return null;            &#125;            return FindGameObject(null, subPath, 0, build, dontDestroy);        &#125;        private static GameObject FindGameObject(GameObject root, string[] subPath, int index, bool build,            bool dontDestroy)        &#123;            GameObject client = null;            if (root == null)            &#123;                client = GameObject.Find(subPath[index]);            &#125;            else            &#123;                var child = root.transform.Find(subPath[index]);                if (child != null)                &#123;                    client = child.gameObject;                &#125;            &#125;            if (client == null)            &#123;                if (build)                &#123;                    client = new GameObject(subPath[index]);                    if (root != null)                    &#123;                        client.transform.SetParent(root.transform);                    &#125;                    if (dontDestroy &amp;&amp; index == 0 &amp;&amp; !IsUnitTestMode)                    &#123;                        GameObject.DontDestroyOnLoad(client);                    &#125;                &#125;            &#125;            if (client == null)            &#123;                return null;            &#125;            return ++index == subPath.Length ? client : FindGameObject(client, subPath, index, build, dontDestroy);        &#125;    &#125;#endif&#125;</code></pre></details><p>普通单例的测试脚本如下：  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><pre><code>public class TestSingletonClass : Singleton&lt;TestSingletonClass&gt;&#123;    private TestSingletonClass()    &#123;            &#125;&#125;public class LBSingletonTest&#123;        [Test]    public void Test()    &#123;        TestSingletonClass objA = TestSingletonClass.Instabce;        TestSingletonClass objB = TestSingletonClass.Instabce;                Assert.AreSame(objA, objB);    &#125;&#125;</code></pre></details><h2 id="LBEventSystem-事件系统"><a href="#LBEventSystem-事件系统" class="headerlink" title="LBEventSystem 事件系统"></a>LBEventSystem 事件系统</h2><p>事件系统采用的是接口的形式，需要接收事件的类只需要继承对应的接口就可以了，然后实现对应的接口，然后通过接口来接收对应的事件ID，通过判断ID来实现对应的事件。  </p><p>事件系统对应的脚本如下：  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><p>脚本一(接口)：  </p><pre><code>//事件系统对应的接口public interface ILBEventHandler&#123;    void HandleEvent(int eventId, LBEventComArg arg = null);&#125;</code></pre><p>脚本二(数据)：</p><pre><code>//事件系统传输的数据public class LBEventComArg&#123;    #region 获取多参数类型    public bool TryGet&lt;T&gt;(out T t)    &#123;        LBEventOneArg&lt;T&gt; arg = this as LBEventOneArg&lt;T&gt;;        arg.Get(out t);        return true;    &#125;    public bool TryGet&lt;T,U&gt;(out T t,out U u)    &#123;        LBEventTwoArg&lt;T,U&gt; arg = this as LBEventTwoArg&lt;T,U&gt;;        arg.Get(out t,out u);        return true;    &#125;    public bool TryGet&lt;T,U,K&gt;(out T t,out U u,out K k)    &#123;        LBEventThreeArg&lt;T,U,K&gt; arg = this as LBEventThreeArg&lt;T,U,K&gt;;        arg.Get(out t,out u,out k);        return true;    &#125;    public bool TryGet&lt;T,U,K,I&gt;(out T t,out U u,out K k,out I i)    &#123;        LBEventFourArg&lt;T,U,K,I&gt; arg = this as LBEventFourArg&lt;T,U,K,I&gt;;        arg.Get(out t,out u,out k,out i);        return true;    &#125;    public bool TryGet&lt;T,U,K,I,W&gt;(out T t,out U u,out K k,out I i,out W w)    &#123;        LBEventFiveArg&lt;T,U,K,I,W&gt; arg = this as LBEventFiveArg&lt;T,U,K,I,W&gt;;        arg.Get(out t,out u,out k,out i,out w);        return true;    &#125;    #endregion&#125;#region  多参数数据类public class LBEventOneArg&lt;T&gt; : LBEventComArg&#123;    private T m_t;    public void Set(T t) &#123; m_t = t; &#125;    public void Get(out T t) &#123; t = m_t; &#125;&#125;public class LBEventTwoArg&lt;T,U&gt; : LBEventComArg&#123;    private T m_t; private U m_u;    public void Set(T t,U u) &#123; m_t = t; m_u = u; &#125;    public void Get(out T t,out U u) &#123; t = m_t; u = m_u; &#125;&#125;public class LBEventThreeArg&lt;T,U,K&gt; : LBEventComArg&#123;    private T m_t; private U m_u; private K m_k;    public void Set(T t,U u,K k) &#123; m_t = t; m_u = u; m_k = k; &#125;    public void Get(out T t,out U u,out K k) &#123; t = m_t; u = m_u; k = m_k; &#125;&#125;public class LBEventFourArg&lt;T,U,K,I&gt; : LBEventComArg&#123;    private T m_t; private U m_u; private K m_k; private I m_i;    public void Set(T t,U u,K k,I i) &#123; m_t = t; m_u = u; m_k = k; m_i = i; &#125;    public void Get(out T t,out U u,out K k,out I i) &#123; t = m_t; u = m_u; k = m_k; i = m_i; &#125;&#125;public class LBEventFiveArg&lt;T,U,K,I,W&gt; : LBEventComArg&#123;    private T m_t; private U m_u; private K m_k; private I m_i; private W m_w;    public void Set(T t,U u,K k,I i,W w) &#123; m_t = t; m_u = u; m_k = k; m_i = i; m_w = w; &#125;    public void Get(out T t,out U u,out K k,out I i,out W w) &#123; t = m_t; u = m_u; k = m_k; i = m_i; w = m_w; &#125;&#125;#endregion</code></pre><p>脚本三(通信)：</p><pre><code>//自定义事件委托类型public delegate void CustomEventHandler(LBEventComArg arg = null);public class LBEventDispatcher:Singleton&lt;LBEventDispatcher&gt;&#123;    private readonly Dictionary&lt;int, HashSet&lt;ILBEventHandler&gt;&gt; id2HandlerDict = new Dictionary&lt;int, HashSet&lt;ILBEventHandler&gt;&gt;();    private readonly Dictionary&lt;int, CustomEventHandler&gt; id2DeleDict = new Dictionary&lt;int, CustomEventHandler&gt;();    private LBEventDispatcher()    &#123;            &#125;    public void AddListener(int eventId, ILBEventHandler handler)    &#123;        if (!id2HandlerDict.TryGetValue(eventId, out HashSet&lt;ILBEventHandler&gt; handlerSet))            handlerSet = id2HandlerDict[eventId] = new HashSet&lt;ILBEventHandler&gt;();        handlerSet.Add(handler);    &#125;        public void AddListener(int eventId, CustomEventHandler eventHandleDele)    &#123;        if (id2DeleDict.TryGetValue(eventId, out CustomEventHandler eventDele))        &#123;            Delegate[] delegates = eventHandleDele.GetInvocationList();            if (Array.IndexOf(delegates, eventHandleDele) == -1)                eventDele += eventHandleDele;        &#125;        else            id2DeleDict.Add(eventId, eventHandleDele);    &#125;    public void SendEvent(int eventId)    &#123;        TiggerEvent(eventId,null);        //当函数参数不需要赋值的时候就赋值一个NULL,减少GC    &#125;    public void SendEvent&lt;T&gt;(int eventId, T arg1)    &#123;        //临时闯将将来可以换成对象池        LBEventOneArg&lt;T&gt; eventArg = new LBEventOneArg&lt;T&gt;();        eventArg.Set(arg1);        TiggerEvent(eventId,eventArg);        //如果用对象池，在这里就可以回收    &#125;    public void SendEvent&lt;T,U&gt;(int eventId, T arg1,U arg2)    &#123;        //临时闯将将来可以换成对象池        LBEventTwoArg&lt;T,U&gt; eventArg = new LBEventTwoArg&lt;T,U&gt;();        eventArg.Set(arg1,arg2);        TiggerEvent(eventId,eventArg);        //如果用对象池，在这里就可以回收    &#125;    public void SendEvent&lt;T,U,K&gt;(int eventId, T arg1,U arg2,K arg3)    &#123;        //临时闯将将来可以换成对象池        LBEventThreeArg&lt;T,U,K&gt; eventArg = new LBEventThreeArg&lt;T,U,K&gt;();        eventArg.Set(arg1,arg2,arg3);        TiggerEvent(eventId,eventArg);        //如果用对象池，在这里就可以回收    &#125;    public void SendEvent&lt;T,U,K,I&gt;(int eventId, T arg1,U arg2,K arg3,I arg4)    &#123;        //临时闯将将来可以换成对象池        LBEventFourArg&lt;T,U,K,I&gt; eventArg = new LBEventFourArg&lt;T,U,K,I&gt;();        eventArg.Set(arg1,arg2,arg3,arg4);        TiggerEvent(eventId,eventArg);        //如果用对象池，在这里就可以回收    &#125;        private void TiggerEvent(int eventId, LBEventComArg arg)    &#123;        if (id2HandlerDict.TryGetValue(eventId, out HashSet&lt;ILBEventHandler&gt; handlerSet))        &#123;            foreach (var handler in handlerSet)            &#123;                handler.HandleEvent(eventId, arg);            &#125;        &#125;        if (id2DeleDict.TryGetValue(eventId, out CustomEventHandler oldDele))        &#123;            oldDele.Invoke(arg);        &#125;    &#125;        public void RemoveListener(int eventId, ILBEventHandler handler)    &#123;        if (id2HandlerDict.TryGetValue(eventId, out HashSet&lt;ILBEventHandler&gt; handlerSet))        &#123;            id2HandlerDict[eventId].Remove(handler);        &#125;    &#125;    public void RemoveListener(int eventId, CustomEventHandler eventHandlerDele)    &#123;        if (id2DeleDict.TryGetValue(eventId, out CustomEventHandler oldDele))        &#123;            oldDele -= eventHandlerDele;            if (oldDele == null)                id2DeleDict.Remove(eventId);        &#125;    &#125;    public void Destruct()    &#123;        id2HandlerDict.Clear();        id2DeleDict.Clear();    &#125;&#125;</code></pre></details><p>事件系统的单元测试如下所示：  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><pre><code>public enum LBEventTestType&#123;    EventTestType = 100,&#125;public class LBEventSystemClass:ILBEventHandler&#123;    public int testValue = 5;        public void HandleEvent(int eventId, LBEventComArg arg = null)    &#123;        switch ((LBEventTestType)eventId)        &#123;            case LBEventTestType.EventTestType:                arg.TryGet(out testValue);                break;        &#125;    &#125;&#125;public class LBEventSystemTest&#123;    [Test]    public void EventTest()    &#123;        LBEventSystemClass testClass = new LBEventSystemClass();        LBEventDispatcher.Instabce.AddListener((int)LBEventTestType.EventTestType, testClass);        LBEventDispatcher.Instabce.SendEvent((int)LBEventTestType.EventTestType,10);                Assert.AreEqual(testClass.testValue,10);    &#125;&#125;</code></pre></details>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LBFramework简介&quot;&gt;&lt;a href=&quot;#LBFramework简介&quot; class=&quot;headerlink&quot; title=&quot;LBFramework简介&quot;&gt;&lt;/a&gt;LBFramework简介&lt;/h1&gt;&lt;p&gt;&lt;font size=4&gt;&lt;strong&gt;单元测试环</summary>
      
    
    
    
    <category term="Unity框架" scheme="http://yoursite.com/categories/Unity%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="LBFramework" scheme="http://yoursite.com/tags/LBFramework/"/>
    
  </entry>
  
  <entry>
    <title>UniRx精讲(112)——LINQ 是拉取数据</title>
    <link href="http://yoursite.com/2019/12/07/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-112-%E2%80%94%E2%80%94LINQ-%E6%98%AF%E6%8B%89%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2019/12/07/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-112-%E2%80%94%E2%80%94LINQ-%E6%98%AF%E6%8B%89%E5%8F%96%E6%95%B0%E6%8D%AE/</id>
    <published>2019-12-07T06:53:39.000Z</published>
    <updated>2021-12-27T03:39:09.479Z</updated>
    
    <content type="html"><![CDATA[<p>在之前我们实现了如下代码:  </p><pre><code>    private void Start()    &#123;        var testNumbers = new List&lt;int&gt; &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;        testNumbers.ListWhere(testNumber =&gt; testNumber % 2 == 0)            .ListSelect(number =&gt; number / 2)            //.ToList()  省略了，本身就是 List 类型。            .ListForEach(resultNumber =&gt; &#123; Debug.Log(resultNumber); &#125;);    &#125;</code></pre><p>.<br>ListWhere 和 ListSelect 还有 ListForEach 加起来，我们进行了三次的遍历。<br>而如果换成 LINQ 则不会这样。  </p><pre><code>using System.Collections.Generic;using System.Linq;using UnityEngine;namespace UniRxLesson&#123;    public class LINQExample : MonoBehaviour    &#123;        private void Start()        &#123;            var testNumbers = new List&lt;int&gt; &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;            testNumbers.Where(testNumber =&gt; testNumber % 2 == 0)                       .Select(number =&gt; number / 2)                       .ToList()                       .ForEach(resultNumber =&gt;                       &#123;                           Debug.Log(resultNumber);                       &#125;);        &#125;    &#125;&#125;</code></pre><p>其中只有 Where 和 ForEach 进行了遍历，也就是两次遍历。中间的 Select 会和 Where 合并成一个 SelectWhere 操作符。 而且，与老师实现的不同。LINQ 是一个拉取数据的操作。Where 和 Select 有对应的 WhereIterator 和 SelectIterator。这些 Iterator 是可以组装的。到最后的 ForEach 阶段，可能只有一个 Root Iterator，其余的都会作为 Root Iterator 的 子 Iterator。当进行遍历的时候，会对 Root Iterator 进行一个 MoveNext 操作，而 RootIterator 的 MoveNext 又有可能会调用子 Iterator 的 MoveNext 操作。就这样不断地 拉取数据。而不是想老师的实现方式一样，每一个操作符都进行一个遍历操作。<br>相比老师的实现，LINQ 的性能会更好，所浪费的计算量会更少。<br>所以 LINQ 实际上是 Pull 数据。<br>到此，我们只要记住这个结论就足够了。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在之前我们实现了如下代码:  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    private void Start()
    &amp;#123;
        var testNumbers = new List&amp;lt;int&amp;gt; &amp;#123;1, 2, 3, 4, 5, 6, </summary>
      
    
    
    
    <category term="UniRx专栏" scheme="http://yoursite.com/categories/UniRx%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="UniRx" scheme="http://yoursite.com/tags/UniRx/"/>
    
  </entry>
  
  <entry>
    <title>UniRx精讲(111)——ForEach 操作符实现</title>
    <link href="http://yoursite.com/2019/12/07/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-111-%E2%80%94%E2%80%94ForEach-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/12/07/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-111-%E2%80%94%E2%80%94ForEach-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E7%8E%B0/</id>
    <published>2019-12-07T06:44:04.000Z</published>
    <updated>2021-12-27T03:39:09.479Z</updated>
    
    <content type="html"><![CDATA[<p>ForEach 其实不算操作符，只是一个遍历的静态方法。 其定义如下:  </p><pre><code>public void ForEach(Action&lt;T&gt; action)&#123;      if (action == null)        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.match);      int version = this._version;      // 重点      for (int index = 0; index &lt; this._size &amp;&amp; (version == this._version || !BinaryCompatibility.TargetsAtLeast_Desktop_V4_5); ++index)    action(this._items[index]);      if (version == this._version || !BinaryCompatibility.TargetsAtLeast_Desktop_V4_5)        return;      ThrowHelper.ThrowInvalidOperationException(ExceptionResource.InvalidOperation_EnumFailedVersion);&#125;</code></pre><p>非常简单，实现代码如下  </p><pre><code>using System;using System.Collections.Generic;using UnityEngine;namespace UniRxLesson&#123;    public class ForEachImplementExample : MonoBehaviour    &#123;        private void Start()        &#123;            var testNumbers = new List&lt;int&gt; &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;            testNumbers.ListWhere(testNumber =&gt; testNumber % 2 == 0)                .ListSelect(number =&gt; number / 2)//                .ToList()  省略了，本身就是 List 类型。                .ListForEach(resultNumber =&gt; &#123; Debug.Log(resultNumber); &#125;);        &#125;    &#125;    public static class ForEachImplement    &#123;        public static void ListForEach&lt;T&gt;(this List&lt;T&gt; sourceList, Action&lt;T&gt; eachAction)        &#123;            foreach (var sourceItem in sourceList)            &#123;                eachAction(sourceItem);            &#125;        &#125;    &#125;&#125;</code></pre><p>输出结果依旧是1~5。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ForEach 其实不算操作符，只是一个遍历的静态方法。 其定义如下:  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void ForEach(Action&amp;lt;T&amp;gt; action)
&amp;#123;
      if (action == null)
       </summary>
      
    
    
    
    <category term="UniRx专栏" scheme="http://yoursite.com/categories/UniRx%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="UniRx" scheme="http://yoursite.com/tags/UniRx/"/>
    
  </entry>
  
  <entry>
    <title>UniRx精讲(110)——LINQ Select 操作符实现</title>
    <link href="http://yoursite.com/2019/12/07/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-110-%E2%80%94%E2%80%94LINQ-Select-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/12/07/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-110-%E2%80%94%E2%80%94LINQ-Select-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E7%8E%B0/</id>
    <published>2019-12-07T06:17:25.000Z</published>
    <updated>2021-12-27T03:39:09.479Z</updated>
    
    <content type="html"><![CDATA[<p>我们反编译，示例中的 Select 操作符，其定义方法如下:  </p><pre><code>public static IEnumerable&lt;TResult&gt; Select&lt;TSource, TResult&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TResult&gt; selector)&#123;    if (source == null)        throw Error.ArgumentNull(nameof (source));    if (selector == null)        throw Error.ArgumentNull(nameof (selector));      Enumerable.Iterator&lt;TSource&gt; iterator;      if ((iterator = source as Enumerable.Iterator&lt;TSource&gt;) != null)        return iterator.Select&lt;TResult&gt;(selector);      IList&lt;TSource&gt; source1;      if ((source1 = source as IList&lt;TSource&gt;) != null)      &#123;        TSource[] source2;        if ((source2 = source as TSource[]) != null)        &#123;              if (source2.Length != 0)                return (IEnumerable&lt;TResult&gt;) new Enumerable.SelectArrayIterator&lt;TSource, TResult&gt;(source2, selector);              return (IEnumerable&lt;TResult&gt;) EmptyPartition&lt;TResult&gt;.Instance;        &#125;        List&lt;TSource&gt; source3;        if ((source3 = source as List&lt;TSource&gt;) != null)              return (IEnumerable&lt;TResult&gt;) new Enumerable.SelectListIterator&lt;TSource, TResult&gt;(source3, selector); // 重点        return (IEnumerable&lt;TResult&gt;) new Enumerable.SelectIListIterator&lt;TSource, TResult&gt;(source1, selector);      &#125;      IPartition&lt;TSource&gt; source4;      if ((source4 = source as IPartition&lt;TSource&gt;) == null)        return (IEnumerable&lt;TResult&gt;) new Enumerable.SelectEnumerableIterator&lt;TSource, TResult&gt;(source, selector);      if (!(source4 is EmptyPartition&lt;TSource&gt;))        return (IEnumerable&lt;TResult&gt;) new Enumerable.SelectIPartitionIterator&lt;TSource, TResult&gt;(source4, selector);      return (IEnumerable&lt;TResult&gt;) EmptyPartition&lt;TResult&gt;.Instance;&#125;</code></pre><p>代码与 Where 的定义非常类似，我们直接看SelectListIterator 的定义。  </p><pre><code>private sealed class SelectListIterator&lt;TSource, TResult&gt; : Enumerable.Iterator&lt;TResult&gt;, IPartition&lt;TResult&gt;, IIListProvider&lt;TResult&gt;, IEnumerable&lt;TResult&gt;, IEnumerable&#123;      private readonly List&lt;TSource&gt; _source;      private readonly Func&lt;TSource, TResult&gt; _selector;      private List&lt;TSource&gt;.Enumerator _enumerator;      public SelectListIterator(List&lt;TSource&gt; source, Func&lt;TSource, TResult&gt; selector)      &#123;        this._source = source;        this._selector = selector;      &#125;      public override Enumerable.Iterator&lt;TResult&gt; Clone()&#123;...&#125;      public override bool MoveNext()      &#123;        switch (this._state)        &#123;              case 1:                this._enumerator = this._source.GetEnumerator();                this._state = 2;                goto case 2;              case 2:                // 重点                if (this._enumerator.MoveNext())                &#123;                      this._current = this._selector(this._enumerator.Current);                      return true;                &#125;                this.Dispose();                break;        &#125;        return false;  &#125;  public override IEnumerable&lt;TResult2&gt; Select&lt;TResult2&gt;(Func&lt;TResult, TResult2&gt; selector)&#123;...&#125;  public TResult[] ToArray()&#123;...&#125;  public List&lt;TResult&gt; ToList()&#123;...&#125;  public int GetCount(bool onlyIfCheap)&#123;...&#125;  public IPartition&lt;TResult&gt; Skip(int count)&#123;...&#125;  public IPartition&lt;TResult&gt; Take(int count)&#123;...&#125;  public TResult TryGetElementAt(int index, out bool found)&#123;...&#125;  public TResult TryGetFirst(out bool found)&#123;...&#125;  public TResult TryGetLast(out bool found) &#123;...&#125;&#125;</code></pre><p>重点还是在 MoveNext 方法里。  </p><pre><code>if (this._enumerator.MoveNext())&#123;    this._current = this._selector(this._enumerator.Current);    return true;&#125;</code></pre><p>MoveNext 不用说了，就是遍历，为什么不是 while 而只是 if 判断一次? 答案很简单，Select 操作符会有多种实现，如果是先使用 Where 操作符再使用 Select 操作符，Select 操作符会自动合并成 WhereSelectListIterator ，在这个类里的 MoveNext 的核心代码如下。  </p><pre><code>while (this._enumerator.MoveNext())&#123;    TSource current = this._enumerator.Current;    if (this._predicate(current))    &#123;        this._current = this._selector(current);        return true;    &#125;&#125;</code></pre><p>是将 Select 和 Where 的逻辑合并在一起了。<br>而我们目前关注的是 SelectListIterator。 一般是作为 List 的第一个操作符的 Select 才会最终使用 SelectListIterator。 比如:  </p><pre><code>mList.Select(XXX);</code></pre><p>因为 List 本身是到最后才进行遍历操作的。 操作符的迭代器，是可以进行组合的。组合之后再最后进行遍历操作之后，这些组合的迭代器在会具体执行其 MoveNext 方法。<br>总之原理很简单。我们用 List 简单实现一下。  </p><pre><code>using System;using System.Collections.Generic;using System.Linq;using UnityEngine;namespace UniRxLesson&#123;    public class SelectImplementExample : MonoBehaviour    &#123;        private void Start()        &#123;            var testNumbers = new List&lt;int&gt; &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;            testNumbers.ListWhere(testNumber =&gt; testNumber % 2 == 0)                .ListSelect(number =&gt; number / 2)                .ToList()                .ForEach(resultNumber =&gt; &#123; Debug.Log(resultNumber); &#125;);        &#125;    &#125;    public static class SelectImplement    &#123;        public static List&lt;K&gt; ListSelect&lt;T, K&gt;(this List&lt;T&gt; sourceList, Func&lt;T, K&gt; convertion)        &#123;            var retList = new List&lt;K&gt;();            foreach (var sourceItem in sourceList)            &#123;                retList.Add(convertion(sourceItem));            &#125;            return retList;        &#125;    &#125;&#125;</code></pre><p>输出结果也就是1~5。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们反编译，示例中的 Select 操作符，其定义方法如下:  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static IEnumerable&amp;lt;TResult&amp;gt; Select&amp;lt;TSource, TResult&amp;gt;(this IEnumerable&amp;</summary>
      
    
    
    
    <category term="UniRx专栏" scheme="http://yoursite.com/categories/UniRx%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="UniRx" scheme="http://yoursite.com/tags/UniRx/"/>
    
  </entry>
  
  <entry>
    <title>UniRx精讲(109)——LINQ Where 操作符实现</title>
    <link href="http://yoursite.com/2019/12/06/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-109-%E2%80%94%E2%80%94LINQ-Where-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/12/06/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-109-%E2%80%94%E2%80%94LINQ-Where-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E7%8E%B0/</id>
    <published>2019-12-06T09:49:31.000Z</published>
    <updated>2021-12-27T03:39:09.479Z</updated>
    
    <content type="html"><![CDATA[<p>反编译 Where 操作符，可以看到如下代码:  </p><pre><code>public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate)&#123;  if (source == null)    throw Error.ArgumentNull(nameof (source));  if (predicate == null)    throw Error.ArgumentNull(nameof (predicate));  Enumerable.Iterator&lt;TSource&gt; iterator;  if ((iterator = source as Enumerable.Iterator&lt;TSource&gt;) != null)    return iterator.Where(predicate);  TSource[] source1;  if ((source1 = source as TSource[]) != null)  &#123;    if (source1.Length != 0)      return (IEnumerable&lt;TSource&gt;) new Enumerable.WhereArrayIterator&lt;TSource&gt;(source1, predicate);    return (IEnumerable&lt;TSource&gt;) EmptyPartition&lt;TSource&gt;.Instance;  &#125;  List&lt;TSource&gt; source2;  if ((source2 = source as List&lt;TSource&gt;) != null)    return (IEnumerable&lt;TSource&gt;) new Enumerable.WhereListIterator&lt;TSource&gt;(source2, predicate); // 重点  return (IEnumerable&lt;TSource&gt;) new Enumerable.WhereEnumerableIterator&lt;TSource&gt;(source, predicate); &#125;</code></pre><p>代码看着很复杂，我们再进行反编译一下，我们的重点类。 Where  </p><pre><code>private sealed class WhereListIterator&lt;TSource&gt; : Enumerable.Iterator&lt;TSource&gt;, IIListProvider&lt;TSource&gt;, IEnumerable&lt;TSource&gt;, IEnumerable&#123;  private readonly List&lt;TSource&gt; _source;  private readonly Func&lt;TSource, bool&gt; _predicate;  private List&lt;TSource&gt;.Enumerator _enumerator;  public WhereListIterator(List&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate)  &#123;    this._source = source;    this._predicate = predicate;  &#125;  public override Enumerable.Iterator&lt;TSource&gt; Clone() &#123;...&#125;  public int GetCount(bool onlyIfCheap) &#123;...&#125;  public override bool MoveNext()  &#123;    switch (this._state)    &#123;      case 1:        this._enumerator = this._source.GetEnumerator();        this._state = 2;        goto case 2;      case 2:        // 重点        while (this._enumerator.MoveNext())        &#123;          TSource current = this._enumerator.Current;          if (this._predicate(current))          &#123;            this._current = current;            return true;          &#125;        &#125;        this.Dispose();        break;    &#125;    return false;  &#125;  public override IEnumerable&lt;TResult&gt; Select&lt;TResult&gt;(Func&lt;TSource, TResult&gt; selector) &#123;...&#125;  public TSource[] ToArray() &#123;...&#125;  public List&lt;TSource&gt; ToList() &#123;...&#125;  public override IEnumerable&lt;TSource&gt; Where(Func&lt;TSource, bool&gt; predicate)&#123;...&#125;&#125;</code></pre><p>重点是 MoveNext 方法。在 MoveNext 方法里，对所有数据进行了一层过滤， 代码如下:  </p><pre><code>while (this._enumerator.MoveNext())&#123;    TSource current = this._enumerator.Current;    if (this._predicate(current))    &#123;        this._current = current;        return true;    &#125;&#125;</code></pre><p>从代码中<strong>while (this._enumerator.MoveNext())</strong> 这行代码就是之前做的循环遍历。<br>然后接下来就是where的过滤了，看下列代码：  </p><pre><code>TSource current = this._enumerator.Current;if (this._predicate(current))&#123;     this._current = current;     return true;&#125;</code></pre><h2 id="如何自己实现一个-Where-操作符"><a href="#如何自己实现一个-Where-操作符" class="headerlink" title="如何自己实现一个 Where 操作符?"></a>如何自己实现一个 Where 操作符?</h2><p>自己实现 IEnumerable 是比较复杂的，因为里边涉及了状态的切换。最简单的还是对 List 进行操作。本质是一样的，只不过本文是仅供同学理解，在真实项目中还是建议用 Where 操作符。<br>实现的代码很简单，Where 用了一个静态扩展关键字 this。 也就是   </p><pre><code>public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate)</code></pre><p>中的 this 这个关键字。<br>示例代码：  </p><pre><code>using System;using System.Collections.Generic;using System.Linq;using UnityEngine;namespace UniRxLesson&#123;    public class WhereImplementExample : MonoBehaviour    &#123;        private void Start()        &#123;            var testNumbers = new List&lt;int&gt; &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;            testNumbers.ListWhere(testNumber =&gt; testNumber % 2 == 0)                .Select(number =&gt; number / 2)                .ToList()                .ForEach(resultNumber =&gt; &#123; Debug.Log(resultNumber); &#125;);        &#125;    &#125;    public static class WhereImplement    &#123;        public static List&lt;T&gt; ListWhere&lt;T&gt;(this List&lt;T&gt; sourceList,Func&lt;T,bool&gt; condition)        &#123;            var retList = new List&lt;T&gt;();            foreach (var sourceItem in sourceList)            &#123;                if (condition(sourceItem))                &#123;                    retList.Add(sourceItem);                &#125;            &#125;            return retList;        &#125;    &#125;&#125;</code></pre><p>输出结果与之前相同。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;反编译 Where 操作符，可以看到如下代码:  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static IEnumerable&amp;lt;TSource&amp;gt; Where&amp;lt;TSource&amp;gt;(this IEnumerable&amp;lt;TSource&amp;gt; so</summary>
      
    
    
    
    <category term="UniRx专栏" scheme="http://yoursite.com/categories/UniRx%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="UniRx" scheme="http://yoursite.com/tags/UniRx/"/>
    
  </entry>
  
  <entry>
    <title>UniRx精讲(108)——LINQ 示例</title>
    <link href="http://yoursite.com/2019/12/05/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-108-%E2%80%94%E2%80%94LINQ-%E7%A4%BA%E4%BE%8B/"/>
    <id>http://yoursite.com/2019/12/05/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-108-%E2%80%94%E2%80%94LINQ-%E7%A4%BA%E4%BE%8B/</id>
    <published>2019-12-05T10:48:00.000Z</published>
    <updated>2021-12-27T03:39:09.479Z</updated>
    
    <content type="html"><![CDATA[<pre><code>using System.Collections.Generic;using System.Linq;using UniRx;using UnityEngine;namespace UniRxLesson&#123;    public class LINQExample : MonoBehaviour    &#123;        private void Start()        &#123;            // Observable.Range            Enumerable.Range(1,10)                       .Where(testNumber =&gt; testNumber % 2 == 0)                       .Select(number =&gt; number / 2)                       .ToList()                       .ForEach(resultNumber =&gt;                       &#123;                           Debug.Log(resultNumber);                       &#125;);        &#125;    &#125;&#125;</code></pre><p>输出结果:  </p><pre><code>12345</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code&gt;using System.Collections.Generic;
using System.Linq;
using UniRx;
using UnityEngine;

namespace UniRxLesson
&amp;#123;
    public cla</summary>
      
    
    
    
    <category term="UniRx专栏" scheme="http://yoursite.com/categories/UniRx%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="UniRx" scheme="http://yoursite.com/tags/UniRx/"/>
    
  </entry>
  
  <entry>
    <title>UniRx精讲(107)——IObservable 和 IObserver 的简单使用</title>
    <link href="http://yoursite.com/2019/12/04/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-107-%E2%80%94%E2%80%94IObservable-%E5%92%8C-IObserver-%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/12/04/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-107-%E2%80%94%E2%80%94IObservable-%E5%92%8C-IObserver-%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2019-12-04T10:53:35.000Z</published>
    <updated>2021-12-27T03:39:09.479Z</updated>
    
    <content type="html"><![CDATA[<p>IObservable 用来定义可观察的类，而 IObserver 用来定义观察者类。<br>观察者模式，我们最容易接触的应用场景就是 MVC。<br>在 MVC 中，Model 通常是在多个 Controller/View 之间是共享的。<br>也就是一个 Model 经常要对应多个 View。<br>当 Model 中的数据有更改时，View 中的数据显示就会跟着更新。<br>IObservable 和 IObserver，一个是形容可观察的类，一个是观察者。<br>理解起来很容易，可观察的类就是应对发布者，而观察者应对订阅者。<br>那么 Model 和 View 与 IObservable 和 IObserver 对应关系是如何呢？<br>Model 是发布者对应的是 IObservable View 是订阅者对应的是 IObserver<br>我们先来定义一个 Model 类。数据比较简单，只管理一个数据 Level(等级) 先看下 IObservable 接口的定义:  </p><pre><code>public interface IObservable&lt;T&gt;&#123;    IDisposable Subscribe(IObserver&lt;T&gt; observer);&#125;</code></pre><p>只要实现 Subseribe 方法就好了。<br>而 T 则是感兴趣的数据类型，可以是一个类、结构体或者一个值。Level 是 int 类型，所以 T 是 int 类型。<br>代码如下:  </p><pre><code>public class Model : IObservable&lt;int&gt;&#123;    public Model()    &#123;        mObservers = new List&lt;IObserver&lt;int&gt;&gt;();    &#125;    private readonly List&lt;IObserver&lt;int&gt;&gt; mObservers;    public IDisposable Subscribe(IObserver&lt;int&gt; observer)    &#123;        if (!mObservers.Contains(observer))            mObservers.Add(observer);        return new Unsubscriber(mObservers, observer);    &#125;    public void UpdateLevel(int loc)    &#123;        foreach (var observer in mObservers)        &#123;            if (loc &lt; 0)                observer.OnError(new LevelUnknownException());            else                observer.OnNext(loc);        &#125;    &#125;    public void QuitGame()    &#123;        foreach (var observer in mObservers.ToArray())            if (mObservers.Contains(observer))                observer.OnCompleted();        mObservers.Clear();    &#125;    private class Unsubscriber : IDisposable    &#123;        private List&lt;IObserver&lt;int&gt;&gt; mObservers;        private IObserver&lt;int&gt;       mObserver;        public Unsubscriber(List&lt;IObserver&lt;int&gt;&gt; observers, IObserver&lt;int&gt; observer)        &#123;            this.mObservers = observers;            this.mObserver = observer;        &#125;        public void Dispose()        &#123;            if (mObserver != null &amp;&amp; mObservers.Contains(mObserver))                mObservers.Remove(mObserver);        &#125;    &#125;&#125;</code></pre><p>我们在看下，IObserver 的定义：  </p><pre><code>public interface IObserver&lt;T&gt;&#123;    void OnCompleted();    void OnError(Exception error);    void OnNext(T value);&#125;</code></pre><p>这三个方法，全部都是被 IObservable 调用。当有数据更新时则调用 OnNext，这样实现 IObserver 并对 IObservable 订阅的类，则会接收到更新的数据。<br>当结束数据发送则 OnCompleted 被调用，当出现异常则 OnErrer 被调用。<br>接下来定义 View.cs  </p><pre><code>public class View : IObserver&lt;int&gt;&#123;    private IDisposable unsubscriber;    private string      instName;    public View(string name)    &#123;        this.instName = name;    &#125;    public string Name    &#123;        get &#123; return this.instName; &#125;    &#125;    public void OnCompleted()    &#123;        Debug.LogFormat(&quot;The Model has completed update data to &#123;0&#125;.&quot;, this.Name);    &#125;    public void OnError(Exception e)    &#123;        Debug.LogFormat(&quot;&#123;0&#125;: The level cannot be determined.&quot;, this.Name);    &#125;    public void OnNext(int value)    &#123;        Debug.LogFormat(&quot;&#123;1&#125;: The current level is &#123;0&#125;&quot;, value, this.Name);    &#125;&#125;</code></pre><p>测试代码如下:  </p><pre><code>using System;using System.Collections.Generic;using UnityEngine;namespace UniRxLesson&#123;    public class SimpleObservableExample : MonoBehaviour    &#123;        private void Start()        &#123;            var model = new Model();            var loginView = new View(&quot;Login&quot;);            var unsubsriber = model.Subscribe(loginView);            var userInfoView = new View(&quot;UserInfo&quot;);            model.Subscribe(userInfoView);            model.UpdateLevel(1);            unsubsriber.Dispose();            model.UpdateLevel(2);            model.UpdateLevel(-1);            model.QuitGame();        &#125;    &#125;&#125;</code></pre><p>输出结果为:  </p><pre><code>Login: The current level is 1UserInfo: The current level is 1UserInfo: The current level is 2UserInfo: The level cannot be determined.The Model has completed update data to UserInfo.</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;IObservable 用来定义可观察的类，而 IObserver 用来定义观察者类。&lt;br&gt;观察者模式，我们最容易接触的应用场景就是 MVC。&lt;br&gt;在 MVC 中，Model 通常是在多个 Controller/View 之间是共享的。&lt;br&gt;也就是一个 Model 经</summary>
      
    
    
    
    <category term="UniRx专栏" scheme="http://yoursite.com/categories/UniRx%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="UniRx" scheme="http://yoursite.com/tags/UniRx/"/>
    
  </entry>
  
  <entry>
    <title>UniRx精讲(106)——IObservable 与 IEnumerable</title>
    <link href="http://yoursite.com/2019/12/04/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-106-%E2%80%94%E2%80%94IObservable-%E4%B8%8E-IEnumerable/"/>
    <id>http://yoursite.com/2019/12/04/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-106-%E2%80%94%E2%80%94IObservable-%E4%B8%8E-IEnumerable/</id>
    <published>2019-12-04T08:28:34.000Z</published>
    <updated>2021-12-27T03:39:09.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IObservable-与-IEnumerble-的定义"><a href="#IObservable-与-IEnumerble-的定义" class="headerlink" title="IObservable 与 IEnumerble 的定义"></a>IObservable 与 IEnumerble 的定义</h2><p>IObservable.cs  </p><pre><code>public interface IObservable&lt;T&gt;&#123;    IDisposable Subscribe(IObserver&lt;T&gt; observer);&#125;</code></pre><p>IEnumerable.cs  </p><pre><code>public interface IEnumerable&#123;    IEnumerator GetEnumerator();&#125;</code></pre><p>IEnumerable 我们理解成了 IForEachable。就是可遍历的意思，可以用 foreach 关键字拉取数据。<br>IObservable 作用也是类似的。也是可以获取数据(事件)的。可以用 Subscribe 捕获数据(事件)。<br>实现 IEnumerable 的类，我们可以叫他数据源，我们通过一系列的 LINQ 操作符，从中拉取数据并进行组合、变换等操作，直到最后会进行一次 foreach 遍历。  </p><pre><code>new List&lt;int&gt;()&#123;1,2,3&#125;    .Select(number=&gt;number * 2)    .Where(number=&gt;number &gt; 3)    .ToList()    .ForEach(number=&gt;Debug.Log(number));</code></pre><p>实现 IObservable 的类，我们可以叫他事件源，我们通过一些列的 UniRx 操作符，从中捕获数据并进行组合、变换等操作，直到最后会进行 Subscribe 的事件处理。  </p><pre><code>Observable.Range(1,3)    .Select(number=&gt;number * 2)    .Where(number=&gt;number &gt; 3)    .Subscribe(number=&gt;Debug.Log(number));</code></pre><p>IEnumerable 中的 GetEnumerator() 方法是为了获取迭代器。获取了迭代器，就可以进行拉取数据了。<br>IObservable 中的 Subscribe 方法是为了对 Observable 的事件进行监听，监听了了事件，就可以在 Subscribe 中捕获事件并进行处理了。  </p><h2 id="IEnumerator-Current-与-IObservaber-OnNext"><a href="#IEnumerator-Current-与-IObservaber-OnNext" class="headerlink" title="IEnumerator.Current 与 IObservaber.OnNext"></a>IEnumerator.Current 与 IObservaber.OnNext</h2><p>IEnumerator.Current 是用于获取当前数据的，直接从远端拉，然后返回一个数据。 而 IObservaber.OnNext 则是远端推一个数据(事件)过来的时候进行的相应的处理(捕获)。  </p><h2 id="IEnumerator-MoveNext-与-IObserver-OnCompleted-、-OnError"><a href="#IEnumerator-MoveNext-与-IObserver-OnCompleted-、-OnError" class="headerlink" title="IEnumerator.MoveNext 与 IObserver. OnCompleted 、 OnError"></a>IEnumerator.MoveNext 与 IObserver. OnCompleted 、 OnError</h2><p>当 MoveNext 为 False 的时候，则 foreach 完成迭代。 而当 OnCompleted 或 OnError 被调用时，也是类似，是完成了事件的捕获。<br>非常相像，那么 LINQ 与 Rx 的区别是什么呢? 唯一的区别就是，Rx 是非阻塞的，迭代是阻塞的。<br>Rx 是用了一种观察者模式的方法，本身就是在时间上异步的，而且常常处于一种”监听”数据的状态，所以是非阻塞的。<br>而 LINQ 本质上就是迭代器与静态扩展关键字，它是在时间上同步的，遍历时，当有一些数据出现了一些问题，则非常有可能拉取不到数据，从而导致程序卡死、崩溃等异常。  </p><h2 id="总结如下"><a href="#总结如下" class="headerlink" title="总结如下"></a>总结如下</h2><p>UniRx 的数据(事件)是从 IObservable 推送过来，然后在 IObserver 进行捕获。<br>而 LINQ 则是，在 IEnumerable 扔过来一个吸管，然后在遍历时(IEnumerator)进行拉取数据。<br>今天的内容就这些。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;IObservable-与-IEnumerble-的定义&quot;&gt;&lt;a href=&quot;#IObservable-与-IEnumerble-的定义&quot; class=&quot;headerlink&quot; title=&quot;IObservable 与 IEnumerble 的定义&quot;&gt;&lt;/a&gt;IO</summary>
      
    
    
    
    <category term="UniRx专栏" scheme="http://yoursite.com/categories/UniRx%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="UniRx" scheme="http://yoursite.com/tags/UniRx/"/>
    
  </entry>
  
  <entry>
    <title>UniRx精讲(105)——Courtine 实现原理</title>
    <link href="http://yoursite.com/2019/12/04/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-105-%E2%80%94%E2%80%94Courtine-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/12/04/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-105-%E2%80%94%E2%80%94Courtine-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2019-12-04T02:38:23.000Z</published>
    <updated>2021-12-27T03:39:09.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="枚举器的封装到协程"><a href="#枚举器的封装到协程" class="headerlink" title="枚举器的封装到协程"></a>枚举器的封装到协程</h2><p>在之前我们对枚举器 IEnumerator 枚举器接口和 yield 关键字做出了解释说明，开始对协程（coroutine）解释说明。<br>其实协程的原理非常简单，我们来试着简单实现一下。  </p><h2 id="通过-Unity-的-Update-模拟协程。"><a href="#通过-Unity-的-Update-模拟协程。" class="headerlink" title="通过 Unity 的 Update() 模拟协程。"></a>通过 Unity 的 Update() 模拟协程。</h2><p>修改上面代码，不使用 while 循环或者 foreach 关键字枚举元素。我们将在 Update() 实时刷新来枚举所有元素。 原理就是上面所说的每次 MoveNext() 方法后，改变当前的位置为下一个元素位置。<br>代码如下：  </p><pre><code>using System.Collections;using UnityEngine;namespace UniRxLesson&#123;    public class CoroutineExample : MonoBehaviour    &#123;        private Update2CoroutineTest mUpdate2CoroutineTest = new Update2CoroutineTest();        IEnumerator mE;        public CoroutineExample()        &#123;            mE = mUpdate2CoroutineTest.GetEnumerator();        &#125;        private void Update()        &#123;            if (mE.MoveNext())            &#123;            &#125;        &#125;        class Update2CoroutineTest        &#123;            public IEnumerator GetEnumerator()            &#123;                Debug.Log(&quot;协程:&quot; + 1);                yield return 0;                Debug.Log(&quot;协程:&quot; + 2);                yield return 0;                Debug.Log(&quot;协程:&quot; + &quot;枚举器&quot;);                yield return 0;            &#125;        &#125;    &#125;&#125;</code></pre><p>输出结果为:  </p><pre><code>协程:1协程:2协程:枚举器</code></pre><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>现在我们用 StartCoroutine（）方法启动协程。 代码如下：  </p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;public class CoroutineTest : MonoBehaviour&#123;    void Start()    &#123;        CoroutineJsTest coroutineJsTest = new CoroutineJsTest();        StartCoroutine(coroutineJsTest.GetEnumerator());    &#125;&#125;public class CorotuineJsTest&#123;    public IEnumerator GetEnumerator()    &#123;        Debug.Log(&quot;协程:&quot; + 1);        yield return 0;        Debug.Log(&quot;协程:&quot; + 2);        yield return 0;        Debug.Log(&quot;协程:&quot; + &quot;枚举器&quot;);        yield return 0;    &#125;&#125;</code></pre><p>输出结果如下:  </p><pre><code>协程:1协程:2协程:枚举器</code></pre><p>从上面可以看出，在 update 方法模拟协程和使用 Unity 自带 StartCoroutine() 方法启动协程效果差不多。看来自 Unity 实现的 StartCoroutine() 启动协程和我们 Update() 模拟是一样的。但是也不确定到底是不是通过类似 Update() 方法实现的。反编译 UnityEngine.dll 程序集也没有找到具体实现方法。。。。。但是唯一确定的一点就是 Unity 也是通过枚举一步步运行程序块的。<br>类似 Update() 模拟协程，每次遇到 yield return，就执行 yield 类型的 MoveNext() 方法，改变当前迭代位置为下一个元素位置。等待下一次 MoveNext() 方法调用。<br>StartCoroutine() 方法会不停的调用 MoveNext() 方法（这样就类似于 foreach）。直到枚举结束。<br>但是注意的是，yield return 后面跟的值除了 Unity 自带的累（如：new WaitForSeconds（0.2f)。继承自 YieldInstruction） 和协程语句块（返回值为 IEnumerator 的方法），其他值没有意义（yield return 0 和 yield return null） 其实都是一样的，只是遇到 yield return 就做相同处理，不会去处理后面跟的值了）。<br>Coroutine 的实现原理大致如此。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Coroutine 其实是一个 迭代器模式 + 定时器的一种实现。 与我们的 UniRx 的 Observable + Scheduler + LINQ 非常类似。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7oljdb0iuj30sw06baao.jpg"><br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7olja2cpij30fa0kqjv6.jpg">  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;枚举器的封装到协程&quot;&gt;&lt;a href=&quot;#枚举器的封装到协程&quot; class=&quot;headerlink&quot; title=&quot;枚举器的封装到协程&quot;&gt;&lt;/a&gt;枚举器的封装到协程&lt;/h2&gt;&lt;p&gt;在之前我们对枚举器 IEnumerator 枚举器接口和 yield 关键字做出了解</summary>
      
    
    
    
    <category term="UniRx专栏" scheme="http://yoursite.com/categories/UniRx%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="UniRx" scheme="http://yoursite.com/tags/UniRx/"/>
    
  </entry>
  
  <entry>
    <title>UniRx精讲(104)——Yield 同等实现</title>
    <link href="http://yoursite.com/2019/12/04/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-104-%E2%80%94%E2%80%94Yield-%E5%90%8C%E7%AD%89%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/12/04/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-104-%E2%80%94%E2%80%94Yield-%E5%90%8C%E7%AD%89%E5%AE%9E%E7%8E%B0/</id>
    <published>2019-12-04T01:55:09.000Z</published>
    <updated>2021-12-27T03:39:09.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><pre><code>using System.Collections;using UnityEngine;namespace UniRxLesson&#123;    public class YieldDeepExample : MonoBehaviour    &#123;        private    void Start()        &#123;            var enumeratorTest = new IEnumeratorTest();            foreach(var item in enumeratorTest)            &#123;                Debug.Log(item);            &#125;        &#125;        class IEnumeratorTest        &#123;            public IEnumerator GetEnumerator()            &#123;                yield return 1;                yield return 2;                yield return &quot;枚举器&quot;;            &#125;        &#125;    &#125;&#125;</code></pre><p>输出结果为：  </p><pre><code>12&quot;枚举器&quot;</code></pre><p>注意 IEnumeratorTest 没有实现 IEnumerator 接口，但是还是可以用 foreach 来迭代。这是因为，编译器只关心是否实现了 GetEnumerator() 方法。  </p><h2 id="yield-解释说明"><a href="#yield-解释说明" class="headerlink" title="yield 解释说明"></a>yield 解释说明</h2><p>我们把包含 yield 语句的方法或属性称为迭代块。如上面代码代码中的：  </p><pre><code>public IEnumerator GetEnumerator()&#123;    yield return 1;    yield return 2;    yield return 枚举器;&#125;</code></pre><p>这个语句块在编译时将会编译成一个 yield 类型，其中包含一个状态机。yield 类型实现 IEnumerator 和 IDisposable 接口属性和方法。  </p><pre><code>class IEnumeratorTest&#123;    public IEnumerator GetEnumerator()    &#123;        yield return 1;        yield return 2;        yield return &quot;枚举器&quot;;    &#125;&#125;</code></pre><p>上面这段代码将会编译成下列类似的代码：  </p><pre><code>public class IEnuemratorTest&#123;    public IEnumerator GetEnumerator()    &#123;        return new Enumerator(0);    &#125;    public class Enumerator:IEnumerator&lt;object&gt;,IEnumerator,IDisposable    &#123;        private int state;        private object current;        public Enumerator(int state)        &#123;            this.state = state;        &#125;        public object Current        &#123;            get             &#123;                        return current;            &#125;            &#125;        public void Dispose()        &#123;        &#125;        public bool MoveNext()        &#123;            switch(state)            &#123;                case 0:                    state++; // 改变当前迭代诶值为下一个元素位置                    current = 1; // 当前迭代位置的对象                    return true;                case 1:                    state++; // 改变当前迭代位置为下一个元素位置                    current = 2; // 当前迭代位置的对象                    return true;                case 2:                    state++; // 改变当前迭代位置为下一个元素位置                    current = &quot;枚举器&quot;; // 当前迭代位置的对象                    return true;            &#125;            return false;        &#125;        public void Reset()        &#123;        &#125;    &#125;&#125;</code></pre><p>枚举器其实就是通过每次调用 MoveNext() 方法，来改变集合中当前元素位置，来一个个遍历元素。类似通过更改下标来获取元素。yield 关键字其实是实现 IEnumerator 等接口如 MoveNext() 方法的编译器自动编译的关键字。当然你也可以自己实现 MoveNext() 等方法，如果你不怕麻烦。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;示例代码&quot;&gt;&lt;a href=&quot;#示例代码&quot; class=&quot;headerlink&quot; title=&quot;示例代码&quot;&gt;&lt;/a&gt;示例代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;using System.Collections;
using UnityEngine;

namespac</summary>
      
    
    
    
    <category term="UniRx专栏" scheme="http://yoursite.com/categories/UniRx%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="UniRx" scheme="http://yoursite.com/tags/UniRx/"/>
    
  </entry>
  
  <entry>
    <title>UniRx精讲(103)——Yield 关键字</title>
    <link href="http://yoursite.com/2019/12/03/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-103-%E2%80%94%E2%80%94Yield-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/12/03/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-103-%E2%80%94%E2%80%94Yield-%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2019-12-03T08:07:06.000Z</published>
    <updated>2021-12-27T03:39:09.478Z</updated>
    
    <content type="html"><![CDATA[<p>我们在之前学习了 IEnumerable 和 IEnumerator ，算是掌握了 C# 的迭代器模式的实现。 今天我们学习 yield 关键字。<br>yield 实质是一个语法糖，它让程序员能够更方便的去使用迭代器，通过 yield 你可以直接使用迭代器操作而不需要去实现 IEnumerable 和 IEnumerator，也不需要一个临时的 Collection 来完成迭代。<br>yield 有两种格式声明  </p><pre><code>yield return &lt;expression&gt;;yield break;</code></pre><p>我们通过实现与上堂课功能一样的示例代码，来了解下 yield 工作流程  </p><pre><code>using System.Collections;using UnityEngine;namespace UniRxLesson&#123;    public class YieldExample : MonoBehaviour    &#123;        private void Start()        &#123;            foreach (var empty in FiveTimes())            &#123;                Debug.Log(&quot;A&quot;);            &#125;        &#125;        private  IEnumerable FiveTimes()        &#123;            for (var i = 0; i &lt; 5; i++)            &#123;                yield return string.Empty;            &#125;        &#125;    &#125;&#125;</code></pre><p>结果一样输出五个A。<br>每一次 foreach 的循环中都会调用迭代器方法，当 yield return 被执行到时，表达式的值会被返回，同时当前的函数的上下文信息被保存下来。下一次循环执行之时会重新从上一次停止的位置继续执行。你也可以使用 yield break 来终止迭代过程。  </p><p>yield 关键字除了支持返回 IEnumerable 之外，还支持返回 IEnumerator。  </p><pre><code>using System.Collections;using UnityEngine;namespace UniRxLesson&#123;    public class YieldExample : MonoBehaviour    &#123;        private void Start()        &#123;            foreach (var empty in FiveTimes())            &#123;                Debug.Log(&quot;A&quot;);            &#125;            var fourTimes = FourTimes();            while (fourTimes.MoveNext())            &#123;                Debug.Log(&quot;B&quot;);            &#125;        &#125;        private IEnumerable FiveTimes()        &#123;            for (var i = 0; i &lt; 5; i++)            &#123;                yield return string.Empty;            &#125;        &#125;        private IEnumerator FourTimes()        &#123;            for (var i = 0; i &lt; 4; i++)            &#123;                yield return string.Empty;            &#125;        &#125;    &#125;&#125;</code></pre><p>输出结果为：  </p><pre><code>AAAAABBBB</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们在之前学习了 IEnumerable 和 IEnumerator ，算是掌握了 C# 的迭代器模式的实现。 今天我们学习 yield 关键字。&lt;br&gt;yield 实质是一个语法糖，它让程序员能够更方便的去使用迭代器，通过 yield 你可以直接使用迭代器操作而不需要去实</summary>
      
    
    
    
    <category term="UniRx专栏" scheme="http://yoursite.com/categories/UniRx%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="UniRx" scheme="http://yoursite.com/tags/UniRx/"/>
    
  </entry>
  
  <entry>
    <title>UniRx精讲(102)——IEnumerator 实现</title>
    <link href="http://yoursite.com/2019/12/03/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-102-%E2%80%94%E2%80%94IEnumerator-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/12/03/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-102-%E2%80%94%E2%80%94IEnumerator-%E5%AE%9E%E7%8E%B0/</id>
    <published>2019-12-03T07:43:44.000Z</published>
    <updated>2021-12-27T03:39:09.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IEnumerator-定义"><a href="#IEnumerator-定义" class="headerlink" title="IEnumerator 定义"></a>IEnumerator 定义</h2><pre><code>public interface IEnumerator&#123;    bool MoveNext();             //将游标的内部位置向前移动    object Current&#123;get;&#125;       //获取当前的项（只读属性）    void Reset();                 //将游标重置到第一个成员前面&#125;</code></pre><h2 id="IEnuemrator-代码示例"><a href="#IEnuemrator-代码示例" class="headerlink" title="IEnuemrator 代码示例"></a>IEnuemrator 代码示例</h2><pre><code>using System.Collections;using UnityEngine;namespace UniRxLesson&#123;    public class IEnumeratorExample : MonoBehaviour    &#123;        private class ForEachable : IEnumerable        &#123;            public IEnumerator GetEnumerator()            &#123;                return new FiveTimes();            &#125;        &#125;        private class FiveTimes : IEnumerator        &#123;            private int mCount = 5;            public bool MoveNext()            &#123;                mCount--;                return mCount &gt;= 0;            &#125;            public void Reset()            &#123;                mCount = 5;            &#125;            public object Current            &#123;                get &#123; return string.Empty; &#125;            &#125;        &#125;        private void Start()        &#123;            var foreachAble = new ForEachable();            foreach (var empty in foreachAble)            &#123;                Debug.Log(&quot;A&quot;);            &#125;        &#125;    &#125;&#125;</code></pre><p>输出结果为：  </p><pre><code>AAAAA</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;IEnumerator-定义&quot;&gt;&lt;a href=&quot;#IEnumerator-定义&quot; class=&quot;headerlink&quot; title=&quot;IEnumerator 定义&quot;&gt;&lt;/a&gt;IEnumerator 定义&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;public interfa</summary>
      
    
    
    
    <category term="UniRx专栏" scheme="http://yoursite.com/categories/UniRx%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="UniRx" scheme="http://yoursite.com/tags/UniRx/"/>
    
  </entry>
  
  <entry>
    <title>UniRx精讲(101)——IEnumerator 使用</title>
    <link href="http://yoursite.com/2019/12/03/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-101-%E2%80%94%E2%80%94IEnumerator-%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/12/03/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-101-%E2%80%94%E2%80%94IEnumerator-%E4%BD%BF%E7%94%A8/</id>
    <published>2019-12-03T07:20:33.000Z</published>
    <updated>2021-12-27T03:39:09.478Z</updated>
    
    <content type="html"><![CDATA[<p>我们学习了 IEnumerable 如何实现，今天我们来学习 foreach 的原理。 其原理非常简单，foreach 是 C# 提供的关键词，foreach 关键字只不过是在编译的过程中生成了 IL 代码而已。<br>接下来用一段示例，来介绍 foreach 的同等代码，当然这段代码与 foreach 生成的 IL 代码非常相似。  </p><h2 id="foreach-同等实现"><a href="#foreach-同等实现" class="headerlink" title="foreach 同等实现"></a>foreach 同等实现</h2><pre><code>using System.Collections;using UnityEngine;namespace UniRxLesson&#123;    public class ForEachExample : MonoBehaviour    &#123;        class ForEachable : IEnumerable        &#123;            object[] mObjArray = new object[4]            &#123;                &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,            &#125;;            public IEnumerator GetEnumerator()            &#123;                return mObjArray.GetEnumerator();            &#125;        &#125;        private void Start()        &#123;            var foreachAble = new ForEachable();            // 手动与 IEnumerator 协作            var i = foreachAble.GetEnumerator();            while (i.MoveNext())            &#123;                 var number = i.Current;                Debug.Log(number);            &#125;        &#125;    &#125;&#125;</code></pre><p>输出结果为：  </p><pre><code>1234</code></pre><p>代码中出现的 MoveNext、Current 等 API 我们简单看下 IEnumerator 定义就清楚了。  </p><pre><code>public interface IEnumerator&#123;    bool MoveNext();             //将游标的内部位置向前移动    object Current&#123;get;&#125;       //获取当前的项（只读属性）    void Reset();                 //将游标重置到第一个成员前面&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们学习了 IEnumerable 如何实现，今天我们来学习 foreach 的原理。 其原理非常简单，foreach 是 C# 提供的关键词，foreach 关键字只不过是在编译的过程中生成了 IL 代码而已。&lt;br&gt;接下来用一段示例，来介绍 foreach 的同等代码，</summary>
      
    
    
    
    <category term="UniRx专栏" scheme="http://yoursite.com/categories/UniRx%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="UniRx" scheme="http://yoursite.com/tags/UniRx/"/>
    
  </entry>
  
  <entry>
    <title>UniRx精讲(100)——迭代器模式 与 IEnumerable</title>
    <link href="http://yoursite.com/2019/12/03/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-100-%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F-%E4%B8%8E-IEnumerable/"/>
    <id>http://yoursite.com/2019/12/03/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-100-%E2%80%94%E2%80%94%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F-%E4%B8%8E-IEnumerable/</id>
    <published>2019-12-03T03:57:26.000Z</published>
    <updated>2021-12-27T03:39:09.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是迭代器模式"><a href="#什么是迭代器模式" class="headerlink" title="什么是迭代器模式"></a>什么是迭代器模式</h2><p>在不知道集合内部细节的情况下，提供一个按序方法存取的一个对象集合体的每一个单元。—GoF 提供一种方法顺序访问一个集合对象中的各个元素，又不暴露该对象的内部表示<br>迭代器模式由于经常使用到，已经被 .Net 收录到 API 中。<br>在 C# 中，经常使用泛型存储对象，当想按序存取这些泛型容器时，都会使用 C# 的 foreach 语句。<br>foreach 语句就是一个能顺序访问一个集合的方法。 它就是 C# 语言内置的迭代器模式。<br>基本上，以上两个定义，足够我们理解了。具体的经典的 迭代器模式的 UML 图 实现太过抽象。而且本教程也不是专门讲解迭代器模式的教程，所以我们先定一个容易达到的目标:掌握 IEnumerable 和 IEnumerator 两个接口。  </p><h2 id="如何使用-IEnumerable"><a href="#如何使用-IEnumerable" class="headerlink" title="如何使用 IEnumerable"></a>如何使用 IEnumerable</h2><p>在使用之前，我们先理解一下 IEnumerable。这里笔者直接给一个比较容易记住的定义，IEnumerable 中文意思是 可枚举的，教练直接把他理解为 IForeachable（可遍历的），虽然定义不是很准确，但是在区分 IEnumerable 和 IEnumerator 时候很容易搞清楚。<br>我们直接看下 IEnumerable 的定义:  </p><pre><code>//这个接口告知调方对象的子项可以枚举public interface IEnumerable&#123;    IEnumerator GetEnumerator();&#125;</code></pre><p>示例代码如下:  </p><pre><code>using System.Collections;using UnityEngine;namespace UniRxLesson&#123;    public class IEnumerableExample : MonoBehaviour    &#123;        class ForEachable : IEnumerable        &#123;            object[] mObjArray = new object[4]            &#123;                &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,            &#125;;            public IEnumerator GetEnumerator()            &#123;                return mObjArray.GetEnumerator();            &#125;        &#125;        private void Start()        &#123;            var foreachAble = new ForEachable();            foreach (var number in foreachAble)            &#123;                Debug.Log(number);            &#125;        &#125;    &#125;&#125;</code></pre><p>运行结果：  </p><pre><code>1234</code></pre><p>只要实现一个 GetEnumerator 就可以使用 foreach 了。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是迭代器模式&quot;&gt;&lt;a href=&quot;#什么是迭代器模式&quot; class=&quot;headerlink&quot; title=&quot;什么是迭代器模式&quot;&gt;&lt;/a&gt;什么是迭代器模式&lt;/h2&gt;&lt;p&gt;在不知道集合内部细节的情况下，提供一个按序方法存取的一个对象集合体的每一个单元。—GoF 提</summary>
      
    
    
    
    <category term="UniRx专栏" scheme="http://yoursite.com/categories/UniRx%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="UniRx" scheme="http://yoursite.com/tags/UniRx/"/>
    
  </entry>
  
  <entry>
    <title>UniRx精讲(099)——RepeatUntilDisable 操作符</title>
    <link href="http://yoursite.com/2019/12/03/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-099-%E2%80%94%E2%80%94RepeatUntilDisable-%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://yoursite.com/2019/12/03/UniRx%E7%B2%BE%E8%AE%B2/UniRx%E7%B2%BE%E8%AE%B2-099-%E2%80%94%E2%80%94RepeatUntilDisable-%E6%93%8D%E4%BD%9C%E7%AC%A6/</id>
    <published>2019-12-03T03:43:05.000Z</published>
    <updated>2021-12-27T03:39:09.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><pre><code>using System;using UniRx;using UnityEngine;namespace UniRxLesson&#123;    public class UniRxRepeatUntilDisableExample : MonoBehaviour    &#123;        void Start()        &#123;            Observable.Timer(TimeSpan.FromSeconds(1.0f))                      .RepeatUntilDisable(this)                      .Subscribe(_ =&gt; Debug.Log(&quot;ticked&quot;));        &#125;    &#125;&#125;</code></pre><p>运行结果为，每隔一秒输出 ticked，当把该脚本所在的 GameObject 隐藏，则停止输出。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;示例代码&quot;&gt;&lt;a href=&quot;#示例代码&quot; class=&quot;headerlink&quot; title=&quot;示例代码&quot;&gt;&lt;/a&gt;示例代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;using System;
using UniRx;
using UnityEngine;

namespa</summary>
      
    
    
    
    <category term="UniRx专栏" scheme="http://yoursite.com/categories/UniRx%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="UniRx" scheme="http://yoursite.com/tags/UniRx/"/>
    
  </entry>
  
</feed>
