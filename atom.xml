<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LianBai</title>
  
  <subtitle>手握日月摘星辰，世间无我这般人。</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-03-21T06:51:04.222Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LianBai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity杂文——自动创建asset资源文件</title>
    <link href="http://yoursite.com/2022/03/21/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BAasset%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2022/03/21/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BAasset%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/</id>
    <published>2022-03-21T06:36:13.000Z</published>
    <updated>2022-03-21T06:51:04.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Unity保存数据的方式有很多，比如我们经常用的json，xml和Txt，笔者今天讲到的是另外一种保存方式，asset文件，这个是unity提供的一种新的保存数据的方式，笔者也是刚使用没多久，这里就不详细进行介绍了，笔者今天主要是介绍一键自动创建对应的asset文件。  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code> public class CreateAssetEditor&#123;    [MenuItem(&quot;Assets/Create/CreateAsset&quot;,false,81)]    public static void OnCreateAsset()    &#123;        foreach (var guid in Selection.assetGUIDs)        &#123;            var path = AssetDatabase.GUIDToAssetPath(guid);            var pathSplit = path.Split(&#39;/&#39;);            var className = pathSplit[pathSplit.Length - 1].Replace(&quot;.cs&quot;, &quot;&quot;);            var classType = GetClassByClassName(className);            var assetPath = path.Replace(&quot;.cs&quot;, &quot;.asset&quot;);            if (File.Exists(assetPath))            &#123;                LBLogWrapper.Error(&quot;创建失败，资源已经存在&quot;);            &#125;            else if (classType != null)             &#123;                var classInst = ScriptableObject.CreateInstance(classType);                AssetDatabase.CreateAsset(classInst,assetPath);            &#125;            else            &#123;                LBLogWrapper.Error(&quot;创建失败，脚本不可创建&quot;);            &#125;        &#125;    &#125;        [MenuItem(&quot;Assets/Create/CreateAsset&quot;,true)]    private static bool IsValidateFun()    &#123;        return (from guid in Selection.assetGUIDs            select AssetDatabase.GUIDToAssetPath(guid)            into path            select path.Split(&#39;/&#39;)            into pathSplit            select pathSplit[pathSplit.Length - 1]).Any(className =&gt; className.Contains(&quot;.cs&quot;));    &#125;    /// &lt;summary&gt;    /// 通过类名获取对应的类    /// &lt;/summary&gt;    /// &lt;param name=&quot;className&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    private static Type GetClassByClassName(string className)    &#123;        var allAssemblies = AppDomain.CurrentDomain.GetAssemblies();        return allAssemblies.SelectMany(assembly =&gt; assembly.GetTypes()).FirstOrDefault(type =&gt;            type.Name == className &amp;&amp; type.IsSubclassOf(typeof(ScriptableObject)));    &#125;&#125;</code></pre><p>脚本的原理很简单，就是获取当前选择的脚本，判断是否可以创建asset文件，如果可以就是通过类名获取对应的类对象和，这里需要注意的是，<font color=red>文件名字必须等于类名</font>，然后通过类名获取对应的类型，就可以生成对应的asset文件了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Unity保存数据的方式有很多，比如我们经常用的json，xml和Txt，笔者今天讲到的是另外一种保存方式，asset文件，这个是unity</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="asset" scheme="http://yoursite.com/tags/asset/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——通过类名获取对应的Type</title>
    <link href="http://yoursite.com/2022/03/11/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E7%B1%BB%E5%90%8D%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E7%9A%84Type/"/>
    <id>http://yoursite.com/2022/03/11/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E7%B1%BB%E5%90%8D%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E7%9A%84Type/</id>
    <published>2022-03-11T07:36:03.000Z</published>
    <updated>2022-03-11T08:06:58.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者在编辑器开发过程中遇到一个问题，笔者想通过一个类的名字获取对应的类的Type然后再做一系列的操作，但是笔者发现无法直接获取，于是笔者通过不断的尝试通过下面的方法获取到了，如果有更好的方法欢迎告诉笔者。  </p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>话不多说，先上代码：  </p><pre><code>[MenuItem(&quot;Assets/GetType&quot;,false,81)]public static void GetClassTypeByClassTypeName()&#123;    const string className = &quot;TestScripts&quot;;    //方法一（在同一程序集内并且非自身Class才能获取到）    var type = Type.GetType(className);    Debug.LogError(type);        var allAssemblies = AppDomain.CurrentDomain.GetAssemblies();        //方法二（有特殊情况会获取不到，笔者没找到获取不到的原因）    type = allAssemblies.Select(assembly =&gt; assembly.GetType(className)).FirstOrDefault(assembly =&gt; assembly != null);    Debug.LogError(type);        //方法三（如果存在类重名的情况有概率获取错误，可以通过路径做限制）    type = allAssemblies.SelectMany(assembly =&gt; assembly.GetTypes()).FirstOrDefault(type1 =&gt; type1.Name == className);    Debug.LogError(type);&#125;</code></pre><p>运行结果如下  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1646985481130-2022-3-1115:58:02.png">  </p><p>方法一和方法二的获取条件都有限制，因此笔者建议使用方法三进行获取。  </p><h1 id="获取方式讲解"><a href="#获取方式讲解" class="headerlink" title="获取方式讲解"></a>获取方式讲解</h1><p>方法一是直接在当前程序集进行获取的。<br>方法二是通过遍历当前程序的所有程序集，然后通过程序集直接GetType进行获取<br>方法三是类似于方法二，得到所有的程序集再遍历程序集中的Type，判断名字是否相同来得到对应的Type</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;笔者在编辑器开发过程中遇到一个问题，笔者想通过一个类的名字获取对应的类的Type然后再做一系列的操作，但是笔者发现无法直接获取，于是笔者通过</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="C#反射" scheme="http://yoursite.com/tags/C-%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——按行删除字符串</title>
    <link href="http://yoursite.com/2022/03/10/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2022/03/10/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-03-10T09:02:29.000Z</published>
    <updated>2022-03-10T09:07:58.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>笔者在项目开发过程中需要做一个聊天的假数据显示，是用于demo的，于是笔者就直接用string字符串来模拟显示的数据，但是当聊天内容过多的时候就需要删除历史的聊天内容，于是笔者就想按照行数删除字符串，发现string并不包含这种接口，于是写下了下面的代码。  </p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><pre><code>private static string DeleteStrLine(string text, int startLine, int lineCount)&#123;    var curIndex = 0;    int? remStartIndex = null;    var sum = 1;    while (sum &lt; startLine + lineCount)     &#123;        if (sum == startLine) remStartIndex = curIndex;                curIndex = text.IndexOf(&quot;\n&quot;, curIndex, StringComparison.Ordinal);        if (curIndex &lt; 0)        &#123;            curIndex = text.Length;            break;        &#125;        curIndex++;        sum++;    &#125;    if (remStartIndex == null)    &#123;        return text;    &#125;    text = text.Remove(remStartIndex.Value, curIndex - remStartIndex.Value);    return text;&#125;</code></pre><p>上述代码是笔者的解决方案，原理很简单，遍历查找字符串的换行字符**”\n”**,然后记录下索引，根据传入的需要删除的行数找到对应的索引，最后使用Remove函数按照开始和结束的索引进行删除。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;笔者在项目开发过程中需要做一个聊天的假数据显示，是用于demo的，于是笔者就直接用string字符串来模拟显示的数据，但是当聊天内容过多的时</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>StarUML使用笔记</title>
    <link href="http://yoursite.com/2022/03/04/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/StarUML%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/03/04/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/StarUML%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-04T07:46:19.000Z</published>
    <updated>2022-03-10T07:01:11.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图操作菜单"><a href="#图操作菜单" class="headerlink" title="图操作菜单"></a>图操作菜单</h1><h2 id="Add-Diagram"><a href="#Add-Diagram" class="headerlink" title="Add Diagram"></a>Add Diagram</h2><pre><code>Class Diagram                   类图Package Diagram                 包图Object Diagram                  对象图Composite Structure Diagram     复合结构图Component Diagram               组件图Deployment Diagram              展开图Use Case Diagram                用例图Sequence Diagram                时序图Communication Diagram           交流图Statechart Diagram              状态图Activity Diagram                活动图Profile Diagram                    ER Diagram                      E-R图Flowchart Diagram               流程图Data Flow Diagram               数据流程图</code></pre><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><pre><code>Tempalate Parameter     模板参数Attribute               属性Port                    端口Operation               操作Reception               接待Class                   类Interface               接口Signal                  信号DataType                数据类型PrimitiveType           原始类型Enumeration             枚举Artifact                工件Component               组件Node                    节点UseCase                    ActorInformationItemCollaborationInteraction             交互State Machine           状态机    Activity                活动Opaque Behavior         不透明树    Constraint              约束Requirement             要求Block                   块Value Type              数值类型Interface Block         接口块Constraint Block        约束快Tag                     标签</code></pre><h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1646381948452-2022-3-416:19:09.png">   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图操作菜单&quot;&gt;&lt;a href=&quot;#图操作菜单&quot; class=&quot;headerlink&quot; title=&quot;图操作菜单&quot;&gt;&lt;/a&gt;图操作菜单&lt;/h1&gt;&lt;h2 id=&quot;Add-Diagram&quot;&gt;&lt;a href=&quot;#Add-Diagram&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="个人笔记" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity杂文——String按行删除</title>
    <link href="http://yoursite.com/2022/03/03/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94string%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4/"/>
    <id>http://yoursite.com/2022/03/03/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94string%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4/</id>
    <published>2022-03-03T07:19:36.000Z</published>
    <updated>2022-03-04T02:16:15.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在unity开发过程中，如果一个string字符串有多行，如果我们想删除前面一行或者多行应该如何操作？  </p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><pre><code>private static string DeleteStrLine(string text, int startLine, int lineCount)&#123;    var curIndex = 0;    int? remStartIndex = null;    var sum = 1;    while (sum &lt; startLine + lineCount)     &#123;        if (sum == startLine) remStartIndex = curIndex;                curIndex = text.IndexOf(&quot;\n&quot;, curIndex, StringComparison.Ordinal);        if (curIndex &lt; 0)        &#123;            curIndex = text.Length;            break;        &#125;        curIndex++;        sum++;    &#125;    if (remStartIndex == null)    &#123;        return text;    &#125;    text = text.Remove(remStartIndex.Value, curIndex - remStartIndex.Value);    return text;&#125;</code></pre><p>思路就是通过<strong>IndexOf</strong>函数遍历找到需要删除的行对应的”\n”(换行)的索引，然后再通过<strong>Remove</strong>函数对开始和结束的索引进行删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;在unity开发过程中，如果一个string字符串有多行，如果我们想删除前面一行或者多行应该如何操作？  &lt;/p&gt;
&lt;h1 id=&quot;解决方案</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Unity笔记</title>
    <link href="http://yoursite.com/2022/03/03/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Unity%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/03/03/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Unity%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-03T07:14:26.000Z</published>
    <updated>2022-03-18T08:43:22.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p><strong>[Conditional(“XXX”)]</strong>: 指定XXX宏下进行编译<br><strong>[RuntimeInitializeOnLoadMethod]</strong>:游戏运行是就执行的方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;特性&quot;&gt;&lt;a href=&quot;#特性&quot; class=&quot;headerlink&quot; title=&quot;特性&quot;&gt;&lt;/a&gt;特性&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;[Conditional(“XXX”)]&lt;/strong&gt;: 指定XXX宏下进行编译&lt;br&gt;&lt;strong&gt;[Runtime</summary>
      
    
    
    
    <category term="个人笔记" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Unity" scheme="http://yoursite.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——扩展Inspector面板(二)</title>
    <link href="http://yoursite.com/2022/02/23/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95Inspector%E9%9D%A2%E6%9D%BF(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2022/02/23/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95Inspector%E9%9D%A2%E6%9D%BF(%E4%BA%8C)/</id>
    <published>2022-02-23T10:30:36.000Z</published>
    <updated>2022-02-25T02:08:27.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>上次笔者讲解了如何自定义Inspector面板的显示，但是这里还有一个问题，就是对于支持的字段我们可以绘制对应的属性，但是有些字段我们并不支持绘制，比如一些类定义的变量，我们又改如何绘制？下面笔者介绍一下如何绘制一些本身不支持的字段。  </p><h1 id="自定义绘制Inspector"><a href="#自定义绘制Inspector" class="headerlink" title="自定义绘制Inspector"></a>自定义绘制Inspector</h1><p>笔者依旧拿笔者写的动画编辑器作为案例来进行讲解。  </p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>存放文件的目录如下  </p><blockquote><p>—Asset<br>——Scripts<br>———Editor<br>————UIAnimManagerEditor.cs<br>————<font color=#00FF00>UIAnimTransformInfoEditor.cs</font><br>———Engine<br>————UIAnimManager.cs<br>————<font color=#00FF00>UIAnimInfoBase.cs</font><br>————<font color=#00FF00>UIAnimTransformInfo.cs</font>  </p></blockquote><h2 id="创建一个Transform的信息的类（UIAnimTransformInfo）"><a href="#创建一个Transform的信息的类（UIAnimTransformInfo）" class="headerlink" title="创建一个Transform的信息的类（UIAnimTransformInfo）"></a>创建一个Transform的信息的类（UIAnimTransformInfo）</h2><p>为了方便我们可以绘制动画信息在Inspector面板上，我们需要在信息类上加上**[Serializable]**标签方便我们序列化</p><pre><code>[Serializable]public class UIAnimTransformInfo&#123;        public Transform m_Transform;&#125;</code></pre><p>然后我们在UIAnimManager上添加我们的信息就可以了</p><pre><code>public class UIAnimManager : MonoBehaviour&#123;    public float m_SumTime;                                                     //总时间    public bool m_IsDefReversed;                                                //默认的是否倒放    public bool m_IsDefLoop;                                                    //默认的是否循环    public bool m_IsDefAutoPlay;                                                //默认的是否自动播放    public UIAnimTransformInfo m_UIAnimTransformInfo;                           //Transform动画信息        [NonSerialized]    public float m_CurTime;                                                     //当前时间    [NonSerialized]    public UIAnimPlayState m_UIAnimPlayState = UIAnimPlayState.Stop;            //当前状态    &#125;</code></pre><h2 id="默认绘制类中类对象的Inspector面板"><a href="#默认绘制类中类对象的Inspector面板" class="headerlink" title="默认绘制类中类对象的Inspector面板"></a>默认绘制类中类对象的Inspector面板</h2><p>我们可以通过绘制属性的方式直接绘制我们的变量，代码如下：  </p><pre><code>EditorGUILayout.PropertyField(m_UIAnimTransformInfo);</code></pre><p>效果如下：  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1645698365713-2022-2-2418:26:06.png">  </p><p>这个绘制是unity默认的绘制。  </p><h2 id="自定义绘制类中类对象的Inspector面板"><a href="#自定义绘制类中类对象的Inspector面板" class="headerlink" title="自定义绘制类中类对象的Inspector面板"></a>自定义绘制类中类对象的Inspector面板</h2><p>如果我们类中的对象不想使用自定义的绘制，我们可以采用CustomPropertyDrawer这个属性标签来绑定我们类的绘制编辑器类。<br>代码如下  </p><pre><code>[CustomPropertyDrawer(typeof(UIAnimTransformInfo))]public class UIAnimTransformInfoEditor : PropertyDrawer&#123;    /// &lt;summary&gt;    /// 获取属性绘制的高度    /// &lt;/summary&gt;    /// &lt;param name=&quot;property&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;label&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public override float GetPropertyHeight(SerializedProperty property, GUIContent label)    &#123;        return EditorGUI.GetPropertyHeight(property);    &#125;    /// &lt;summary&gt;    /// 绘制自定义的面板    /// &lt;/summary&gt;    /// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;property&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;label&quot;&gt;&lt;/param&gt;    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)    &#123;            &#125;&#125;</code></pre><p>上述代码中，GetPropertyHeight函数是用来设置绘制面板的高度的，然后OnGUI的函数是写自定义的绘制的。  </p><font size=5 color=FF0000>提示：   在GetPropertyHeight函数离，如果类比较复杂，通过EditorGUI.GetPropertyHeight(property)获取的高度会出错，最好把属性里的需要绘制的字段分别获取高度再加一起返回。  在OnGUI函数里绘制的时候不能采用GUILayout和EditorGuiLayout的绘制方式，因为这个是给Rect进行绘制的，每次绘制的时候只需要计算宽度，然后绘制后坐标再自己移动绘制下一个。举例代码如下：</font>  <pre><code>/// &lt;summary&gt;/// 绘制单个可滑动的列表/// &lt;/summary&gt;/// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;property&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;uiReorderableList&quot;&gt;&lt;/param&gt;public static void OnReorderableListPropertyItemGUI(ref Rect position, SerializedProperty property,ReorderableList uiReorderableList)&#123;    position.height = GetReorderableListHeight(property);    uiReorderableList.DoList(position);    position.y += position.height;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;上次笔者讲解了如何自定义Inspector面板的显示，但是这里还有一个问题，就是对于支持的字段我们可以绘制对应的属性，但是有些字段我们并不支</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Unity编辑器" scheme="http://yoursite.com/tags/Unity%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——扩展Inspector面板(一)</title>
    <link href="http://yoursite.com/2022/02/18/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95Inspector%E9%9D%A2%E6%9D%BF(%E4%B8%80)/"/>
    <id>http://yoursite.com/2022/02/18/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95Inspector%E9%9D%A2%E6%9D%BF(%E4%B8%80)/</id>
    <published>2022-02-18T05:45:59.000Z</published>
    <updated>2022-02-18T07:23:45.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在使用unity的时候我们会经常使用到inspector面板来查看我们选中对象的信息，也会经常修改一些信息，但是，untiy默认的指挥显示我们组件上序列化的信息，也并不是所有的序列化的信息都显示，我们只需要添加**[HideInInspector]**标签就可以隐藏信息。但是这些并不能满足我们修改信息的需求，unity也为我们提供了自动绘制面板，这样我们不仅仅有修改字段的功能，还可以添加更多的功能了。  </p><h1 id="自定义绘制Inspector"><a href="#自定义绘制Inspector" class="headerlink" title="自定义绘制Inspector"></a>自定义绘制Inspector</h1><p>笔者是以自己写的一个UI的动画控制器为例来讲解的。  </p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>存放文件的目录如下  </p><blockquote><p>—Asset<br>——Scripts<br>———Editor<br>————UIAnimManagerEditor.cs<br>———Engine<br>————UIAnimManager.cs  </p></blockquote><h2 id="组件脚本"><a href="#组件脚本" class="headerlink" title="组件脚本"></a>组件脚本</h2><p>首先我们先创建一个需要绘制的脚本：  </p><pre><code>/// &lt;summary&gt;/// 动画播放状态/// &lt;/summary&gt;public enum UIAnimPlayState&#123;    Stop,                   //停止    Playing,                //播放中    Pause,                  //暂停    Finish,                 //完成&#125;/// &lt;summary&gt;/// 动画播放控制器/// &lt;/summary&gt;public class UIAnimManager : MonoBehaviour&#123;    public float m_SumTime;                                                     //总时间    public bool m_IsDefReversed;                                                //默认的是否倒放    public bool m_IsDefLoop;                                                    //默认的是否循环    public bool m_IsDefAutoPlay;                                                //默认的是否自动播放        [NonSerialized]    public float m_CurTime;                                                     //当前时间    [NonSerialized]    public UIAnimPlayState m_UIAnimPlayState = UIAnimPlayState.Stop;            //当前状态&#125;</code></pre><p>下面我们来看看默认的inspector的面板显示：  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1645165132213-2022-2-1814:18:53.png"></p><p>不仅仅**[HideInInspector]<strong>标签会隐藏字段，</strong>[NonSerialized]**标记没有序列化的字段也不会显示出来。  </p><h2 id="绘制Inspector面板脚本-CustomEditor"><a href="#绘制Inspector面板脚本-CustomEditor" class="headerlink" title="绘制Inspector面板脚本(CustomEditor)"></a>绘制Inspector面板脚本(CustomEditor)</h2><pre><code>[CustomEditor(typeof(UIAnimManager))]public class UIAnimManagerEditor : UnityEditor.Editor&#123;    #region 字段    private UIAnimManager m_UIAnimManager;                                      //面板的脚本        private SerializedProperty m_IsDefReversed;                                 //是否倒放    private SerializedProperty m_IsDefLoop;                                     //是否循环    private SerializedProperty m_IsDefAutoPlay;                                 //是否自动播放    #endregion        #region 继承方法    private void OnEnable()    &#123;        m_UIAnimManager = (UIAnimManager) target;                               //获取绑定的脚本                m_IsDefReversed = serializedObject.FindProperty(&quot;m_IsDefReversed&quot;);     //获取m_IsDefReversed字段        m_IsDefLoop = serializedObject.FindProperty(&quot;m_IsDefLoop&quot;);             //获取m_IsDefLoop字段        m_IsDefAutoPlay = serializedObject.FindProperty(&quot;m_IsDefAutoPlay&quot;);     //获取m_IsDefAutoPlay字段    &#125;    /// &lt;summary&gt;    /// 自定义绘制Inspector面板    /// &lt;/summary&gt;    public override void OnInspectorGUI()    &#123;        OnPropertyFieldGUI();    &#125;    #endregion        #region 自定义方法    /// &lt;summary&gt;    /// 绘制属性字段    /// &lt;/summary&gt;    private void OnPropertyFieldGUI()    &#123;        EditorGUI.BeginChangeCheck();                                       //监听面板是否发生变化        &#123;            EditorGUILayout.PropertyField(m_IsDefReversed);                 //绘制m_IsDefReversed属性            EditorGUILayout.PropertyField(m_IsDefLoop);                     //绘制m_IsDefLoop属性            EditorGUILayout.PropertyField(m_IsDefAutoPlay);                    //绘制m_IsAutoPlay属性        &#125;        if (EditorGUI.EndChangeCheck())                                     //如果发生变化为true        &#123;            EditorUtility.SetDirty(target);                                 //标记用于触发保存            serializedObject.ApplyModifiedProperties();                     //更新序列化的数据        &#125;    &#125;    #endregion&#125;</code></pre><p>如上述代码，编写脚本只需要类上面打上**[CustomEditor(typeof(UIAnimManager))]<strong>即可，中间的UIAnimManager换成需要绑定的类即可，然后在代码中继承</strong>OnInspectorGUI**方法，在这个方法里绘制自己想绘制的面板。<br>绘制样子如下：  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1645168657839-2022-2-1815:17:38.png">  </p><h2 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h2><p>首先开<strong>OnEnable</strong>函数里：  </p><blockquote><p>m_UIAnimManager = (UIAnimManager) target;获取当前绑定的脚本对象<br>serializedObject.FindProperty是获取脚本上的属性，是拿这些属性绘制的  </p></blockquote><p><strong>OnInspectorGUI</strong>函数就是我们编写绘制Inspector面板的函数，在代码里我们可以编写untiy提供的编辑器代码，笔者这里只是通过EditorGUILayout.PropertyField来绘制属性，也可以使用其他unity的编辑器绘制代码，这里就不举例了。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在使用unity的时候我们会经常使用到inspector面板来查看我们选中对象的信息，也会经常修改一些信息，但是，untiy默认的指挥显示我</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Unity编辑器" scheme="http://yoursite.com/tags/Unity%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>解决Hexo博客提交Warning</title>
    <link href="http://yoursite.com/2022/01/29/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E8%A7%A3%E5%86%B3Hexo%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4Warning/"/>
    <id>http://yoursite.com/2022/01/29/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E8%A7%A3%E5%86%B3Hexo%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4Warning/</id>
    <published>2022-01-29T07:19:22.000Z</published>
    <updated>2022-01-29T07:26:23.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Warning-Accessing-non-existent-property-‘XXX’-of-module-exports-inside-circular-dependency"><a href="#Warning-Accessing-non-existent-property-‘XXX’-of-module-exports-inside-circular-dependency" class="headerlink" title="Warning: Accessing non-existent property ‘XXX’ of module exports inside circular dependency"></a>Warning: Accessing non-existent property ‘XXX’ of module exports inside circular dependency</h1><p>笔者在更新本地npm和node后，提交hexo博客的时候遇到了这个问题。原因在于本地node的版本太高导致的。  </p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>降低node的版本，选择一个低版本的node，node的12版本应该就可以。  </p><p><a href="https://nodejs.org/download/release/"><font color=steelblue size=5>node各版本下载</font></a>  </p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>笔者并不想更新node版本，于是笔者找到了第二种解决方案，在博客目录下：  </p><pre><code>myBlog\node_modules\nib\node_modules\stylus\lib\nodes\index.jsmyBlog\node_modules\stylus\lib\nodes\index.js.</code></pre><p>上面两个路径下的<strong>index.js</strong>文件的前面分别添加下面代码即可。(两个文件都需要添加)  </p><pre><code>exports.lineno = null;exports.column = null;exports.filename = null;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Warning-Accessing-non-existent-property-‘XXX’-of-module-exports-inside-circular-dependency&quot;&gt;&lt;a href=&quot;#Warning-Accessing-non-existent</summary>
      
    
    
    
    <category term="搭建博客" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客Warning" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2Warning/"/>
    
  </entry>
  
  <entry>
    <title>UnityECS入门(三)——写一个简单的ECS</title>
    <link href="http://yoursite.com/2022/01/29/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%B8%89)%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84ECS/"/>
    <id>http://yoursite.com/2022/01/29/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%B8%89)%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84ECS/</id>
    <published>2022-01-29T03:12:57.000Z</published>
    <updated>2022-02-17T06:34:47.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><pre><code>unity: 2020.3.18f1Entities: 0.17.0Jobs: 0.8.0</code></pre><h1 id="SimpleECS"><a href="#SimpleECS" class="headerlink" title="SimpleECS"></a>SimpleECS</h1><p>一个简单的ECS应该包括Entity、Component和System，接下来笔者就带着大家写一个简单的ECS。  </p><h2 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h2><p>unity的<strong>Entity是已经封装好的，不需要自己创建</strong>。笔者一开始也没有理解，每个实例不一样，为啥不是自己制作Entity，笔者目前的理解是Entity就像一个没有任何属性的GameObject，我们是通过给这个空的GameObject添加Component来组成我们理解的实体对象。<br>下面我们来分析一下Entity，源码如下：  </p><pre><code>using System;namespace Unity.Entities&#123;        public struct Entity : IEquatable&lt;Entity&gt;, IComparable&lt;Entity&gt;    &#123;                public int Index;        public int Version;        public static bool operator==(Entity lhs, Entity rhs)        &#123;            return lhs.Index == rhs.Index &amp;&amp; lhs.Version == rhs.Version;        &#125;        public static bool operator!=(Entity lhs, Entity rhs)        &#123;            return !(lhs == rhs);        &#125;        public int CompareTo(Entity other)        &#123;            return Index - other.Index;        &#125;        public override bool Equals(object compare)        &#123;            return this == (Entity)compare;        public override int GetHashCode()        &#123;            return Index;        &#125;        public static Entity Null =&gt; new Entity();        public bool Equals(Entity entity)        &#123;            return entity.Index == Index &amp;&amp; entity.Version == Version;        &#125;        public override string ToString()        &#123;            return Equals(Entity.Null) ? &quot;Entity.Null&quot; : $&quot;Entity(&#123;Index&#125;:&#123;Version&#125;)&quot;;        &#125;    &#125;&#125;</code></pre><p>上面的代码重要部分是两个字段，<strong>Index</strong>和<strong>Version</strong>。<br>Index其实不难理解，笔者在上一篇文章提起过，Entity绑定的component是统一放在一个Chunk上的，为了提高访问的速度，当我们想要操作一个Entity的Component的时候，我们是通过Index在EntityDataManager中查找所在的Chunk和IndexInChunk。<br>Version是一个类似于版本号的东西，就像版本号会递增一样，Entity每次被回收的时候这个值会+1。用途的话，笔者猜测可能是当我们回调一个实例的时候，可以判断实例是否已经被回收了或者改变了。  </p><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><pre><code>[GenerateAuthoringComponent]public struct SimpleEcsComp : IComponentData&#123;    public float m_MoveSpeed;&#125;</code></pre><p>Component可以理解为Entity具有的属性或者组件，一个Entity是可以绑定多个Component的，就像一个GameObject上挂很多组件一样。<br>Component一般定义成struct，并且继承IComponentData或者ISharedComponentData这两个接口。   </p><h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>在以前的UnityECS版本里存在ComponentSystem和JobSystem两种System，但是目前已经被Unity弃用，这里就不介绍了，在新的ECS版本里，System采用的是<strong>SystemBase</strong>。  </p><pre><code>public class SimpleEcsSystem : SystemBase&#123;    protected override void OnUpdate()    &#123;        var deltaTime = Time.DeltaTime;        Entities.ForEach((ref Translation translation, ref SimpleEcsComp simpleEcsComp) =&gt;        &#123;            translation.Value.y += simpleEcsComp.m_MoveSpeed * deltaTime;            if (translation.Value.y &gt; 5f)            &#123;                simpleEcsComp.m_MoveSpeed = -math.abs(simpleEcsComp.m_MoveSpeed);            &#125;            else if (translation.Value.y &lt; -5f)            &#123;                simpleEcsComp.m_MoveSpeed = math.abs(simpleEcsComp.m_MoveSpeed);            &#125;        &#125;).ScheduleParallel();    &#125;&#125;</code></pre><p>如上述代码，在System的中，在进行Entities.ForEach的时候，最后需要执行一下<strong>ScheduleParallel</strong>这个方法，这里是一种扩展方法，这里常用的不仅仅是ScheduleParallel，还有Run和Schedul两个方法。下面介绍一下方法的用途：  </p><blockquote><p>Run() : evaluates the entity query and invokes the lambda function for each selected entity immediately on the main thread. Calling Run() completes the system Dependency JobHandle before running, blocking the main thread, if necessary, while it waits for those jobs to finish.<br>Schedul(): schedules the work to be done in a single job (no matter how many entities are selected).<br>ScheduleParallel() – schedules the work to be done in parallel using the C# Job system. Each parallel job instance processes at least one chunk of entities at a time. In other words, if all the selected entities are in the same chunk, then only one job instance is spawned.   </p></blockquote><h2 id="运行结果如下"><a href="#运行结果如下" class="headerlink" title="运行结果如下"></a>运行结果如下</h2><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1645079644114-2022-2-1714:34:04.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;unity: 2020.3.18f1
Entities: 0.17.0
Jobs: 0.8.0
&lt;/code&gt;&lt;/pre&gt;
</summary>
      
    
    
    
    <category term="UnityECS" scheme="http://yoursite.com/categories/UnityECS/"/>
    
    
    <category term="ECS" scheme="http://yoursite.com/tags/ECS/"/>
    
  </entry>
  
  <entry>
    <title>给hexo博客添加访问密码</title>
    <link href="http://yoursite.com/2022/01/28/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E7%BB%99hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E5%AF%86%E7%A0%81/"/>
    <id>http://yoursite.com/2022/01/28/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E7%BB%99hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E5%AF%86%E7%A0%81/</id>
    <published>2022-01-28T07:31:45.000Z</published>
    <updated>2022-01-29T06:25:45.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔者记忆力比较差，于是笔者想有个空间能记录笔者一些私人的内容，于是笔者想起来比较经常会遇到一些加密的博客，笔者便想如果自己如果有一个博客能记录自己的私人内容，然后把博客进行加密即可，这样自己想要查看内容的额时候只需要访问隐私博客，然后输入密码就可以看到了。  </p><h1 id="安装Hexo-Blog-Encrypt"><a href="#安装Hexo-Blog-Encrypt" class="headerlink" title="安装Hexo-Blog-Encrypt"></a>安装Hexo-Blog-Encrypt</h1><p>hexo的博客添加密码其实只需要安装一个插件就可以了。<br>通过npm在hexo博客目录安装Hexo-Blog-Encrypt  </p><pre><code>npm install --save hexo-blog-encrypt</code></pre><h1 id="博客使用密码"><a href="#博客使用密码" class="headerlink" title="博客使用密码"></a>博客使用密码</h1><p>只需要在博客的开头使用  </p><pre><code>---title: Hello Worlddate: 2022-01-28 15:31:45password: 密码---</code></pre><p>还可以添加一些描述的标签  </p><pre><code>---title: Hello Worldtags:- 加密文章的tagdate: 2022-01-28 15:31:45password: 密码abstract: 这里有东西被加密了，需要输入密码查看哦。message: 您好，这里需要密码。wrong_pass_message: 抱歉，这个密码看着不太对，请再试试。wrong_hash_message: 抱歉，这个文章不能被纠正，不过您还是能看看解密后的内容。---</code></pre><h1 id="根目录添加配置文件"><a href="#根目录添加配置文件" class="headerlink" title="根目录添加配置文件"></a>根目录添加配置文件</h1><pre><code># 安全encrypt: # hexo-blog-encrypt  abstract: 这里有东西被加密了，需要输入密码查看哦。  message: 您好, 这里需要密码.  tags:  - &#123;name: tagName, password: 密码A&#125;  - &#123;name: tagName, password: 密码B&#125;  #密码主题 https://github.com/D0n9X1n/hexo-blog-encrypt#encrypt-theme  theme: wave      wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.  wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;笔者记忆力比较差，于是笔者想有个空间能记录笔者一些私人的内容，于是笔者想起来比较经常会遇到一些加密的博客，笔者便想如果自己如果有一个博客能记</summary>
      
    
    
    
    <category term="搭建博客" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客密码" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>私人密码记事本</title>
    <link href="http://yoursite.com/2022/01/28/%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E7%A7%81%E4%BA%BA%E5%AF%86%E7%A0%81%E8%AE%B0%E4%BA%8B%E6%9C%AC/"/>
    <id>http://yoursite.com/2022/01/28/%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E7%A7%81%E4%BA%BA%E5%AF%86%E7%A0%81%E8%AE%B0%E4%BA%8B%E6%9C%AC/</id>
    <published>2022-01-28T06:29:49.000Z</published>
    <updated>2022-03-21T06:48:28.810Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="8df2ae586bdf056c057f50c0f07df7999ed0fe9afbed75a9e03035945aa4f2ee">2521a7807bde158c25736a82631336cef69c8023285301a3fbc36dfb98f6e317a65e61edf2bc05b5baa81011208e99997530f84143591992a31d06652f4777d39959a148e1cfd3abdbdaf0d3f2e34d58f7cc4a7a4d87e2c556ca3bee9db959a81e9156e003fb37ca67f0de85901c11ac6d22be5894add73186b8200509861945e827fa50350b7d8e7c577510e0c7f04f999f2c26ccf897139fd3896f616588fd1afbe305ba2e0eac4c212d14101f3577f98d2c52bd2650565b00fda22f9f9d6e18218f7b1b4a22a0e965b89a31a8eea52e911983bfa6ae6004db1f1a5699761c2efa572cac178ada568024e657744802d586129440fce350e84fba64ccc11c973d7ebb4e04fcb64e5c5ab9c4b0509629a073ec697eb076f97dd6a9ae5c64bcb423c71f31a01b8aa8044055484a5201d0572d83b5a6391fd3a270d18fdb7d17d01ff2d23cac00ba56047285218a835ce4172b11027c94775635d7463afd0cab8b1b25505a63352dbfb365b57273bdab223ebf72a4bca76007d3c40b827ce80a11944e689953d7e40365179a7e9b2db8be89f4964fd29295a16c4f8026e7191aee9fe0639b67528076158033ef7edf80be5192940dea83c279ae298e0b01fd2adde565ca12689622ccc70176902c952c67f422a6ffc7fccec83ad91e6e209dae4768122c5ddb501fddcc3cdedf0cac41c896ac2773a30d382b340d22a11aa43707701c7af90c0d46f2dfeeeea41afcbc6effe67fb9a735d1f78ee28282e51657883e3690f434b9197814b29f982fc6184e12181a64ca685f9ae7302fc04edb89202a286e6bf9afab89c382f5cb4a4bad2718886584e91a49998f47ef08a085c1a2a97857d9b22f9b18a012717f7d3ec86b80fc9523dbdecf7863fc8ac78b013240e22a738cff7984ec94f7421bd303d91db166c8fc116c168976bc6ebaf06d6755</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这里有东西被加密了，需要输入密码查看哦。</summary>
    
    
    
    <category term="私人文件" scheme="http://yoursite.com/categories/%E7%A7%81%E4%BA%BA%E6%96%87%E4%BB%B6/"/>
    
    
    <category term="密码记事本" scheme="http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E8%AE%B0%E4%BA%8B%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>UnityECS入门(二)——简单讲解一下ECS</title>
    <link href="http://yoursite.com/2022/01/28/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%BA%8C)%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3%E4%B8%80%E4%B8%8BECS/"/>
    <id>http://yoursite.com/2022/01/28/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%BA%8C)%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3%E4%B8%80%E4%B8%8BECS/</id>
    <published>2022-01-28T05:17:37.000Z</published>
    <updated>2022-01-28T08:04:29.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇我们已经成功的配置好本地的环境了，接下来我们来简单的讲解一下ECS。(笔者也是初学者，如果有错误欢迎大家指出)  </p><h1 id="ECS简介"><a href="#ECS简介" class="headerlink" title="ECS简介"></a>ECS简介</h1><p>在写ECS之前我们先了解一下什么是ECS？  </p><h2 id="ECS是什么？"><a href="#ECS是什么？" class="headerlink" title="ECS是什么？"></a>ECS是什么？</h2><p>ECS的缩写就是Entity Component System。对应的就是实例、组件和系统。笔者认为这是和MVC框架类似，虽然作用不是一样的，但是都代表了一种思想。ECS的思想打破了我们面向对象的思想，让我们直接面向数据变成。以往的Unity提供给使用者的都是GameObject，让我们来面向对象思想，但是ECS则是把GameObject拆成了Entity和Component，然后由System再进行同意管理。  </p><h2 id="为什么使用ECS？"><a href="#为什么使用ECS？" class="headerlink" title="为什么使用ECS？"></a>为什么使用ECS？</h2><h3 id="在编写思想上"><a href="#在编写思想上" class="headerlink" title="在编写思想上"></a>在编写思想上</h3><p>笔者认为，现在的大部分游戏其实都是数据驱动的游戏，游戏的界面对象其实是给使用者提供的。一个好的程序猿应该做到真正的数据和显示分离，这样不管显示是什么样，数据都可以去应对，但其实这是理想化的，因为显示是很难统一的。  </p><h3 id="在编写代码上"><a href="#在编写代码上" class="headerlink" title="在编写代码上"></a>在编写代码上</h3><p>ECS为我们提供了面向数据编程的结构、强迫使我们数据和显示进行分离，这样虽然编写复杂了一些，但是我们的扩展性和适应性会有很大的提高。<br>Unity的MonoBehavior的class其实是非常笨重的，里面包含了大量的信息，我们在平时开发中其实用不到那么多信息，在ECS上我们只需要添加上我们需要用到的组件即可。  </p><h3 id="在内存管里方面"><a href="#在内存管里方面" class="headerlink" title="在内存管里方面"></a>在内存管里方面</h3><p>ECS引入了Archetype和Chuck两个概念，Archetype对应的是我们的Component，就是存放我们Entity需要的所有组件，然后多个Archetype会被封装成一个个的Archetype Chuck，然后在内存里按照顺序进行存放，如果一个Chuck存放满了，会在后面内存里创建新的Chuck，这样Component就是在一起的，每次查找Component的时候速度会大大提升。<br>下面我们来看一看内存结构图：  </p><p><img src="https://i0.hdslb.com/bfs/article/6cb305d158f9daf75ef880b035a26afdea2961af.png" alt="在这里插入图片描述"></p><p><img src="https://i0.hdslb.com/bfs/article/363335a8d53167863db8a0c040e29e37d2f9b269.png" alt="在这里插入图片描述">  </p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>Unity使用的是单线程，虽然里面会有携程一些，但其根本原理都是单线程，所以并不能完全发挥CPU，ECS引入了多线程的Job system，并且Job System会把Entities分发到CPU的线程上，这样就提高了CPU的利用率。  </p><h1 id="怎么使用ECS"><a href="#怎么使用ECS" class="headerlink" title="怎么使用ECS"></a>怎么使用ECS</h1><p>ECS主要提升的是CPU的性能，并不是所有的项目都适合使用ECS，因为ECS是新的思想，团队开发成本也是有一定提高的，笔者业主要是为了学习了解，拓展一下自己的思路。<br>接下来笔者会继续学习如何使用ECS。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在上一篇我们已经成功的配置好本地的环境了，接下来我们来简单的讲解一下ECS。(笔者也是初学者，如果有错误欢迎大家指出)  &lt;/p&gt;
&lt;h1 </summary>
      
    
    
    
    <category term="UnityECS" scheme="http://yoursite.com/categories/UnityECS/"/>
    
    
    <category term="ECS" scheme="http://yoursite.com/tags/ECS/"/>
    
  </entry>
  
  <entry>
    <title>UnityECS入门(一)——安装Unity官方的ECS</title>
    <link href="http://yoursite.com/2022/01/27/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%B8%80)%E2%80%94%E2%80%94%E5%AE%89%E8%A3%85Unity%E5%AE%98%E6%96%B9%E7%9A%84ECS/"/>
    <id>http://yoursite.com/2022/01/27/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%B8%80)%E2%80%94%E2%80%94%E5%AE%89%E8%A3%85Unity%E5%AE%98%E6%96%B9%E7%9A%84ECS/</id>
    <published>2022-01-27T05:49:25.000Z</published>
    <updated>2022-01-28T05:16:43.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>笔者最近准备学习Unity官方的ECS，笔者才刚开始学习，这里就先不卖弄了，笔者写这篇博客的主要目的是为了分享如何安装官方ECS。  </p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><pre><code>Unity 2020.3.18f1c1</code></pre><h1 id="安装Entitie-com-unity-entities"><a href="#安装Entitie-com-unity-entities" class="headerlink" title="安装Entitie(com.unity.entities)"></a>安装Entitie(com.unity.entities)</h1><p>unity的版本低于2020.1的可以直接在Package Manager里搜索Entitie就可以了。<br>在unity2020.1版本的时候，官方对unity的Package Manager做了一些整改，默认不再显示Preview Package了。<br>首先笔者先介绍如何打开显示Preview Package。<br><img src="https://img-blog.csdnimg.cn/a6e1dd43a96d4951834981e78c8054e2.png" alt="在这里插入图片描述">  </p><p><img src="https://img-blog.csdnimg.cn/74d2605b303549cbbcc895a4013b83e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IS455m9,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">  </p><p>虽然打开了Preview Package但是依旧会搜不到部分Preview Package的库，这是因为处于早期开发阶段和开发不活跃的包无法直接搜索到。<br>笔者这里便介绍另外一种方式，通过url的方式导入需要的库。笔者在文章后面也会放入一些无法搜到的库。<br><strong>通过URL安装需要本地安装git来进行下载</strong><br>Entitie的url是： <strong>com.unity.entities</strong><br>导入步骤如下：<br><img src="https://img-blog.csdnimg.cn/b093196413e44d178d9a5656aee4ed7e.png" alt="在这里插入图片描述">  </p><p><img src="https://img-blog.csdnimg.cn/126370bd43ae4f8ca103be329245adde.png" alt="在这里插入图片描述">  </p><h1 id="安装Jobs-com-unity-jobs"><a href="#安装Jobs-com-unity-jobs" class="headerlink" title="安装Jobs(com.unity.jobs)"></a>安装Jobs(com.unity.jobs)</h1><p>通过git url的方式输入com.unity.jobs即可安装，笔者安装entities的时候会自动安装jobs，如果没有安装可以使用这种方式安装。  </p><h1 id="安装HyBrid-Renderer-com-unity-rendering-hybrid"><a href="#安装HyBrid-Renderer-com-unity-rendering-hybrid" class="headerlink" title="安装HyBrid Renderer(com.unity.rendering.hybrid)"></a>安装HyBrid Renderer(com.unity.rendering.hybrid)</h1><p>学习ECS过程中还有可能用到HyBrid Renderer这个package，这里也提供一下对应的URL  </p><p><strong>com.unity.rendering.hybrid</strong>  </p><h1 id="安装Burst-com-unity-barracuda-burst"><a href="#安装Burst-com-unity-barracuda-burst" class="headerlink" title="安装Burst(com.unity.barracuda.burst)"></a>安装Burst(com.unity.barracuda.burst)</h1><p>直接在package manager里搜索Burst是可以搜到的</p><h1 id="安装Mathematics-com-unity-mathematics"><a href="#安装Mathematics-com-unity-mathematics" class="headerlink" title="安装Mathematics(com.unity.mathematics)"></a>安装Mathematics(com.unity.mathematics)</h1><p>直接在package manager里搜索Mathematics是可以搜到的，这里也放一下url </p><p><strong>com.unity.mathematics</strong></p><h1 id="无法搜到的Preview-Package的URL"><a href="#无法搜到的Preview-Package的URL" class="headerlink" title="无法搜到的Preview Package的URL"></a>无法搜到的Preview Package的URL</h1><p>com.ptc.vuforia.engine<br>com.unity.2d.entities<br>com.unity.ai.planner<br>com.unity.aovrecorder<br>com.unity.assetbundlebrowser<br>com.unity.assetgraph<br>com.unity.barracuda<br>com.unity.barracuda.burst<br>com.unity.build-report-inspector<br>com.unity.cloud.userreporting<br>com.unity.collections<br>com.unity.connect.share<br>com.unity.dots.editor<br>com.unity.entities<br>com.unity.film-tv.toolbox<br>com.unity.google.resonance.audio<br>com.unity.immediate-window<br>com.unity.mathematics<br>com.unity.meshsync<br>com.unity.multiplayer-hlapi<br>com.unity.package-manager-doctools<br>com.unity.package-manager-ui<br>com.unity.package-validation-suite<br>com.unity.physics<br>com.unity.platforms<br>com.unity.platforms.android<br>com.unity.platforms.linux<br>com.unity.platforms.macos<br>com.unity.platforms.web<br>com.unity.platforms.windows<br>com.unity.playablegraph-visualizer<br>com.unity.render-pipelines.lightweight<br>com.unity.rendering.hybrid<br>com.unity.renderstreaming<br>com.unity.scene-template<br>com.unity.simulation.client<br>com.unity.simulation.core<br>com.unity.simulation.capture<br>com.unity.simulation.games<br>com.unity.standardevents<br>com.unity.streaming-image-sequence<br>com.unity.test-framework.performance<br>com.unity.tiny.all<br>com.unity.transport<br>com.unity.upm.develop<br>com.unity.vectorgraphics<br>com.unity.webrtc<br>com.unity.xr.googlevr.android<br>com.unity.xr.googlevr.ios<br>com.unity.xr.legacyinputhelpers<br>com.unity.xr.oculus.android<br>com.unity.xr.oculus.standalone<br>com.unity.xr.openvr.standalone<br>com.unity.xr.arsubsystems<br>com.unity.xr.interactionsubsystems<br>com.unity.xr.windowsmr.metro  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;笔者最近准备学习Unity官方的ECS，笔者才刚开始学习，这里就先不卖弄了，笔者写这篇博客的主要目的是为了分享如何安装官方ECS。  &lt;/p</summary>
      
    
    
    
    <category term="UnityECS" scheme="http://yoursite.com/categories/UnityECS/"/>
    
    
    <category term="ECS" scheme="http://yoursite.com/tags/ECS/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——序列化AnimationCurve</title>
    <link href="http://yoursite.com/2022/01/25/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%BA%8F%E5%88%97%E5%8C%96AnimationCurve/"/>
    <id>http://yoursite.com/2022/01/25/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%BA%8F%E5%88%97%E5%8C%96AnimationCurve/</id>
    <published>2022-01-24T16:18:28.000Z</published>
    <updated>2022-01-27T06:26:58.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者在开发一个地图编辑器的过程中，需要配置一个摄像机的移动速度，这个时候策划提了一个需求，他希望能够通过设置曲线的方式来设置摄像机的移动，于是笔者便想到了unity编辑器自带的AnimationCurve就可以获得运动曲线，但是这里有个问题，我们编辑器配置后是需要保存下来的，笔者选择了利用json保存，但是json是没有办法序列化一个AnimationCurve对象的，json序列化是有规则的，这里就不介绍了。没有办法序列化我们需要的对象我们应该怎么办呢？  </p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>我们没有办法序列化我们需要的AnimationCurve，但是我们知道AnimationCurve是由很多个keyframe组成的，我们只需要保留下来keyframe，每次保存的时候只保存keeyfram数组，然后加载的时候通过添加保存的keyframe既可以生成我们需要的AnimationCurve了。<br>当笔者想去保存keyframe的时候，通过rider编辑器可以看到keyframe的类似源码，里面的字段都是私有的，依旧没有办法序列化，这个时候我们可以换一种方式，那就是自定义一个新的keyframe，然后通过自己的keyframe去生成需要的keyframe就可以了。<br>话不多说，直接上代码：<br>通过查看keyframe的源码，我们可以摘取我们需要的数据，然后自定义类即可。（这里定义struct，打包的时候序列化会出错，具体原因还未查明）  </p><pre><code>public class LBSerializeAnimCurveKeyFrame&#123;    #region 字段    public float m_Time;    public float m_Value;    public float m_InTangent;    public float m_OutTangent;    public int m_TangentMode;    public int m_WeightedMode;    public float m_InWeight;    public float m_OutWeight;    #endregion        #region 属性        #endregion        #region 方法        public LBSerializeAnimCurveKeyFrame(        float time,        float value,        float inTangent,        float outTangent,        float inWeight,        float outWeight)    &#123;        this.m_Time = time;        this.m_Value = value;        this.m_InTangent = inTangent;        this.m_OutTangent = outTangent;        this.m_WeightedMode = 3;        this.m_InWeight = inWeight;        this.m_OutWeight = outWeight;        this.m_TangentMode = 0;    &#125;    public static implicit operator LBSerializeAnimCurveKeyFrame(Keyframe keyframe)    &#123;        return new LBSerializeAnimCurveKeyFrame(keyframe);    &#125;        public static implicit operator Keyframe(LBSerializeAnimCurveKeyFrame keyframe)    &#123;        return new Keyframe(keyframe.m_Time, keyframe.m_Value, keyframe.m_InTangent, keyframe.m_OutTangent,            keyframe.m_InWeight, keyframe.m_OutWeight);    &#125;        #endregion&#125;</code></pre><p>上面就是笔者自己定义的keyframe，然后我们只需要在我们需要序列化的类添加上即可，示例如下：<br>首先查看我们需要序列化的数据应该怎么设计：  </p><pre><code>public class SerializeAnimationCurveData&#123;    #region 字段        public List&lt;LBSerializeAnimCurveKeyFrame&gt; m_AnimCurveKeyFrameList;        [IgnoreDataMember]    public AnimationCurve AnimCurve    &#123;        get        &#123;            Keyframe[] keyframeArray;            if (m_AnimCurveKeyFrameList != null)            &#123;                keyframeArray = new Keyframe[m_AnimCurveKeyFrameList.Count];                for (int i = 0; i &lt; m_AnimCurveKeyFrameList.Count; i++)                &#123;                    keyframeArray[i] = m_AnimCurveKeyFrameList[i];                &#125;            &#125;            else            &#123;                keyframeArray = AnimationCurve.Linear(0f, 0f, 1f, 1f).keys;            &#125;            return new AnimationCurve(keyframeArray);        &#125;        set        &#123;            m_AnimCurveKeyFrameList.Clear();            foreach (var keyframe in value.keys)            &#123;                m_AnimCurveKeyFrameList.Add(keyframe);            &#125;        &#125;    &#125;    #endregion    #region 方法    public SerializeAnimationCurveData()    &#123;        AnimCurve = AnimationCurve.Linear(0, 0, 1, 1);        m_AnimCurveKeyFrameList = new List&lt;LBSerializeAnimCurveKeyFrame&gt;();        foreach (var keyframe in AnimCurve.keys)        &#123;            m_AnimCurveKeyFrameList.Add(keyframe);        &#125;    &#125;    #endregion&#125;</code></pre><p>接着我们看一下如何编辑器上设置，笔者是在自定义的窗口上绘制的，其他面板也是类似：  </p><pre><code>private SerializeAnimationCurveData m_SerAnimCurveData;private void Awake()&#123;    m_SerAnimCurveData = new SerializeAnimationCurveData();&#125;private void OnGUI()&#123;    EditorGUILayout.BeginVertical(GUILayout.Width(400f));    &#123;        m_SerAnimCurveData.AnimCurve =            EditorGUILayout.CurveField(LBEditorLNG.SerAnimCurveTitle, m_SerAnimCurveData.AnimCurve);    &#125;    EditorGUILayout.EndVertical();&#125;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当我们想序列化一个字段的时候，如果字段不可以序列化，我们可以通过保留组成的数据，然后在反序列化的时候通过保留下来的数据重新组成我们需要的字段。如果字段也是封装好的私有字段，我们只需要自己重新设计一个类，用来保留这些字段。当我们需要一个成品的时候，如果我们没有办法保留成品，我们可以拆分这些，这样使用的时候重新组成就行了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;笔者在开发一个地图编辑器的过程中，需要配置一个摄像机的移动速度，这个时候策划提了一个需求，他希望能够通过设置曲线的方式来设置摄像机的移动，于</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="JSON" scheme="http://yoursite.com/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——基于UGUI的UI拖拽监听</title>
    <link href="http://yoursite.com/2022/01/13/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EUGUI%E7%9A%84UI%E6%8B%96%E6%8B%BD%E7%9B%91%E5%90%AC/"/>
    <id>http://yoursite.com/2022/01/13/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EUGUI%E7%9A%84UI%E6%8B%96%E6%8B%BD%E7%9B%91%E5%90%AC/</id>
    <published>2022-01-13T15:46:06.000Z</published>
    <updated>2022-01-14T01:57:54.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果一个UI的面板想监听拖拽事件通常会有两种方式：  </p><blockquote><ol><li>继承IBeginDragHandler，IDragHandler，IEndDragHandler接口，然后实现自己需要的逻辑。（此方法需要脚本继承MonoBehaviour）  </li><li>监听Input的输入，通过判断按下和按住来实现自己拖拽的逻辑。  </li></ol></blockquote><p>已经有写好的放发笔者为什么还要写这边文章呢，是因为笔者目前参与的项目中的UI框架，面板的脚本都不是继承MonoBeehaviour的，都是通过统一管理的，这样的方式的好处就是UI的初始化和Update的一些都可以自己控制。面板的View都是通过绑定的方式进行操作的，了解框架的应该都知道，这样的好处有很多，这里就不过多介绍了。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>如果一个UI面板是通过绑定的方式进行的，没有继承MonoBehaviour，有不想在Update里写大量的逻辑，我们想见监听一个UI的拖拽应该怎么操作呢。  </p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>我们只需要自己写一个继承MonoBehaviour的脚本，然后脚本继承这些接口，在脚本里添加拖拽需要的一些参数，然后脚本里添加我们需要注册的委托就可以了，我们的面板脚本可以绑定面板的UI，我们只需要通过UI物体获取我们需要的拖拽脚本组件，然后注册我们需要的一些委托就可以了。脚本如下：  </p><pre><code>using System;using UnityEngine;using UnityEngine.EventSystems;public class UDragEvent : MonoBehaviour,IBeginDragHandler,IDragHandler,IEndDragHandler&#123;    private bool m_IsDraging;    public bool IsDraging    &#123;        get =&gt; m_IsDraging;        private set =&gt; m_IsDraging = value;    &#125;    public Action&lt;PointerEventData&gt; OnBeginDragEvent;    public Action&lt;PointerEventData&gt; OnDragEvent;    public Action&lt;PointerEventData&gt; OnEndDragEvent;    public void OnBeginDrag(PointerEventData eventData)    &#123;        OnBeginDragEvent?.Invoke(eventData);        m_IsDraging = true;    &#125;    public void OnDrag(PointerEventData eventData)    &#123;        OnDragEvent?.Invoke(eventData);    &#125;    public void OnEndDrag(PointerEventData eventData)    &#123;        OnEndDragEvent?.Invoke(eventData);        m_IsDraging = false;    &#125;&#125;</code></pre><p>上述脚本非常简单，只是把一些接口转换成了委托，然后在需要监听拖拽的组件上放上挂上这个脚本，在面板的控制脚本里获取这个脚本，然后绑定上对应的委托就可以使用了。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当我们使用一个接口或者方法的时候，如果我们没有办法直接调用，我们不仅仅只考虑找和它相同功能的方法替换掉，我们还可以通过转换的方式，间接的使用我们需要的。笔者就是通过委托的方式简介的使用了拖拽的接口。不仅仅是拖拽，很多接口我们都可以这样间接使用。也不仅仅是接口，很多开发者遇到的阻挡，我们不应该考虑换路，我们也要考虑能不能跨过阻挡或者绕过阻挡。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;如果一个UI的面板想监听拖拽事件通常会有两种方式：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;继承IBeginDragHand</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="UGUI" scheme="http://yoursite.com/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——自定义创建模板脚本</title>
    <link href="http://yoursite.com/2022/01/13/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%9B%E5%BB%BA%E6%A8%A1%E6%9D%BF%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2022/01/13/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%9B%E5%BB%BA%E6%A8%A1%E6%9D%BF%E8%84%9A%E6%9C%AC/</id>
    <published>2022-01-13T06:33:29.000Z</published>
    <updated>2022-01-18T09:39:48.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>相信大多数Unity开发人员在创建脚本的时候，经常会修改自从生成的脚本内容，比如去掉继承的MonoBehavior,添加命名空间，或者继承固定的接口、类等。这样重复的工作看似花费不了多少时间，但是如果每次创建都需要修改，还是有点麻烦的，所以如果我们能按照我们自定一的模板脚本去创建脚本就可以了。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者在团队开发中发现，每次创建UI的脚本的时候都需要固定修改继承，和添加一些标签等，这些重复性的工作笔者想了想可不可按照自定义的模板创建脚本。笔者发现unity自带的在unity安装目录下创建模板脚本有很大的缺点，只能创建C#脚本，并且只可以自己使用，并不可以上传到项目的库进行团队使用，于是笔者参考网上的一些文章写了下面的解决方案。  </p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>首先我们在创建一个Editor Default Resources目录，这个目录是提供为编辑器模式使用的资源路径，加载此目录的资源文件代码如下：<br><strong>EditorGUIUtility.Load(filePath)</strong><br>加载后通过as转换成需要的类型就可以了<br>笔者模板文件存放的目录如下：<br>—Assets<br>——Editor Default Resources<br>———CustomScriptTemplate<br>————C# Script-NewNoMonoBehaviourScript.text  </p><p>模板文件的内容如下：  </p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;namespace #NAMESPACE#&#123;    public class #SCRIPTNAME#    &#123;        #region 字段                #endregion                #region 属性                #endregion                #region 方法                                #endregion    &#125;&#125;</code></pre><h2 id="在选中的目录里创建模板脚本"><a href="#在选中的目录里创建模板脚本" class="headerlink" title="在选中的目录里创建模板脚本"></a>在选中的目录里创建模板脚本</h2><p>制作的原理就是通过读取模板文件的内容，然后将内容写入新的脚本中，监听编辑结束后替换新模板中的固定字符串就可以了。<br>直接上代码：  </p><pre><code>using System.Text;using System.Text.RegularExpressions;using UnityEditor;using UnityEditor.Compilation;using UnityEditor.ProjectWindowCallback;using UnityEngine;public static class CreatNewCShapScript&#123;        /// &lt;summary&gt;        /// 创建不继承MonoBehaviour脚本        /// &lt;/summary&gt;        [MenuItem(&quot;Assets/Create/C# Scripts Menu/C# NoMonoBehaviourScript&quot;, false,81)]        public static void CreatNoMonoBehaviourScript()        &#123;            //参数为传递给CreateEventCSScriptAsset类action方法的参数            ProjectWindowUtil.StartNameEditingIfProjectWindowExists(0,                ScriptableObject.CreateInstance&lt;CreateNewCShapScriptAsset&gt;(),                GetSelectPathOrFallback() + &quot;/NewNoMonoBehaviourScript.cs&quot;, null,                &quot;CustomScriptTemplate/C# Script-NewNoMonoBehaviourScript.txt&quot;);        &#125;        /// &lt;summary&gt;        /// 取得要创建文件的路径        /// &lt;/summary&gt;        /// &lt;returns&gt;&lt;/returns&gt;        public static string GetSelectPathOrFallback()        &#123;            string path = &quot;Assets&quot;;            //遍历选中的资源以获得路径            //Selection.GetFiltered是过滤选择文件或文件夹下的物体，assets表示只返回选择对象本身            foreach (UnityEngine.Object obj in Selection.GetFiltered(typeof(UnityEngine.Object), SelectionMode.Assets))            &#123;                path = AssetDatabase.GetAssetPath(obj);                if (!string.IsNullOrEmpty(path) &amp;&amp; File.Exists(path))                &#123;                    path = Path.GetDirectoryName(path);                    break;                &#125;            &#125;            return path;        &#125;        /// &lt;summary&gt;        /// 创建脚本文件的委托类        /// &lt;/summary&gt;        class CreateNewCShapScriptAsset : EndNameEditAction        &#123;            public override void Action(int instanceId, string pathName, string resourceFile)            &#123;                UnityEngine.Object obj = CreateScriptAssetFromTemplate(pathName, resourceFile);                         //创建资源                ProjectWindowUtil.ShowCreatedAsset(obj);                                                                //高亮显示资源            &#125;                        internal static UnityEngine.Object CreateScriptAssetFromTemplate(string pathName, string resourceFile)            &#123;                string fullPath = Path.GetFullPath(pathName);                                                           //获取要创建资源的绝对路径                string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(pathName);                           //获取文件名，不含扩展名                var textAsset = EditorGUIUtility.Load(resourceFile) as TextAsset;                string resourceFileText = textAsset.text;                resourceFileText = Regex.Replace(resourceFileText, &quot;#NAMESPACE#&quot;,                    CompilationPipeline.GetAssemblyRootNamespaceFromScriptPath(pathName));                resourceFileText = Regex.Replace(resourceFileText, &quot;#SCRIPTNAME#&quot;, fileNameWithoutExtension);              //将模板类中的类名替换成你创建的文件名                bool encoderShouldEmitUTF8Identifier = true;                                                            //参数指定是否提供 Unicode 字节顺序标记                bool throwOnInvalidBytes = false;                                                                       //是否在检测到无效的编码时引发异常                UTF8Encoding encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier, throwOnInvalidBytes);                bool append = false;                StreamWriter streamWriter = new StreamWriter(fullPath, append, encoding);                               //写入文件                streamWriter.Write(resourceFileText);                streamWriter.Close();                AssetDatabase.ImportAsset(pathName);                                                                    //刷新资源管理器                AssetDatabase.Refresh();                return AssetDatabase.LoadAssetAtPath(pathName, typeof(UnityEngine.Object));            &#125;        &#125;&#125;</code></pre><p>此代码有一个比较重要的一点就是获取文件所在的程序集的命名空间名字，因为要自动添加命名空间，最后找到了对应的API，通过**CompilationPipeline.GetAssemblyRootNamespaceFromScriptPath(pathName)**获取地址路径下的命名空间名字，然后动态替换就可以了。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;相信大多数Unity开发人员在创建脚本的时候，经常会修改自从生成的脚本内容，比如去掉继承的MonoBehavior,添加命名空间，或者继承固</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Unity工具" scheme="http://yoursite.com/tags/Unity%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Unity游戏开发知识点整理</title>
    <link href="http://yoursite.com/2022/01/12/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2022/01/12/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</id>
    <published>2022-01-12T12:23:29.000Z</published>
    <updated>2022-03-10T09:21:00.185Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="b31de94b1b8ad2dfcf914293b4e9b1ff6a3c9b7c7c6a0a512e32663b79f2f41e">2521a7807bde158c25736a82631336cef69c8023285301a3fbc36dfb98f6e317c9ac81c4d12edc8947dcaf8a0861a8948c1801f937c078349c26b44a4a8fc585f88e9b911e5ffe98e4c7f9fdd9db222ae42632ebcf17f27ad48bcdbcc168d62b44e4aa373d5c24a839a3c0b319a63a5c182a88b811178548b0323f67228629e8c978bed10d73398b17c41064f9b6c6b9c4a8e92bbf93b54102424c20a36908de17235eddb55912cd10dbe5b4f4fc656c45f4c077f0f23f660968530007a6c6fbfbcdff10375bdffd4321b5b82773bcd088f7a1c51e06d244212df83f4e2fa546ff493f5e44d4c75888c14742d5570e8e4277ef8915d02f74abcd84e16acfc24822e91881090fce77477bea1fa43493eb058c5de05e45e54d89275c297d3633bbda9813e4cb1ec72e59ec04b79a4bd604967ff4f5d7c92efa492f4bf5cc5c15e20b15ea904d22c5f083f3cc59fa46268420092fb77ce4ee7bba66bcc83a746b6c804ee413d84d822db9a22facd3538179d30a4ffeec47b94ea4cfe3f7eba065c685e4f98b48ea411e84e289d0f8dd28511bfbcd46566226414f81c1ec5a225a1e3d95853103a6e958a587ba5a9326fa27a1e38bae31fc14deab24639cbce5d3f369b444aa55927f2969ec552de62824cf0caef81e11f8266bbd9d60846fe5e17aaeb3c4cbdcef4939661409abff0658a92cbaa0261f835790653d8d88fcff6e95cfff50df65694559fee34c94a5ac2d1f4167f77a829dbf7e26d227e00f6b5acaaa64ed8d27e281ed718f75b49ee1e3ade9fa64b2ed6dbfcb867a3e924e897438c221380e732232bc85e1600d771725f919c13b71132b96838f8cedcda8613760af5bcedf047bf052d2cfb212014f7ab112811f0dc04d2bdd718710aa8923e4b7d095d85ffa6b4ac60477ec26f99ad8eae42f6f684252f59b780d870f2c9e5e8132b4fe401c75d88a549d6a268727784eb4ecb729c03b057df4c68a73c89681edcd0ecbc1e5c483365dc361958efb0175a4b916b4434038c606c50d40e3798f53b72a0f90a1e58a4c88edf7832064ed063b6331de873ec5d591ef1dd933b2a3a08a44433ce5d8a5619d5b38d892b8a7dfd4ddb526bfc60a61d2c673e130ebcc49b37f8dc014bd6efd66b05aa1220201178c80ace74f0d2913ccf28455ff63b918c97ff2ec632d957490912e08ae29ca1b741cc34a75b52ad655ce1ef31d7400271feb69eb538ad782a1dbb7272737adf16bc3c706f05e2d8c680c1199f1a1d770d73967959ad696232cf1cd685b90f8f07b94ec3f0e2cc1fb0865806f1a5e05817fc480b6832ccbff394d5615f194d36e81610cdf417b6e3cfba49555e41fae7b1220df3bc191c6e6347f6131049a8acf811a6d94cfaa8f4b3e9dab1b8d1fabf2b85bd1c3ae8e37454da6bf6dea061f65aa330877dfacad126910b286833835ebd759e77b1dfbbb3f9354af910187c2672ad8e211dc9fa17d2bb3ebfe94114154eb2370488235637dd9892f3a924cf6370be836d34b11d5c28a30aa616fddca438a208980bdcdbcf225ca13b76c1405a175914c770efb31a0b31c5e2852fed7cc8778fc0e10ff0c26e66057fc41b82820f69f391488047b969f377689d2feb04c4d1e32a46eeb93a660a1ee4988ef1917864e7a150d90f6435129ea313801c9d25f842a3f75aa8e2a3c7b4a02bc25f9b280347c1badee42de2d3614b801395112e6b100cd4dc0e6805a831b946794c4c13a65ae41d4a3166a1c75edf9880cd9957987a21c2d63906bb2e68adf66916b82b2ad13065a4d536623bfcbf05de8027c344aca1e907ba6df1f8773098346e00971cc55f5c05ecab515c377adee4dd3c74d07746c983c115daa1c5114fedfe9f9d777b2b26e4f32e0f288f6ee2fabaee3862901c0bcc5fbdec349872b2a002c99bc49ffbce6bde484b50e95d5cf8b803f358021e2ee1649f87abcb7b059a99581871e6a77c913b70e6da146d2e15cd90bc8c7ae1c3d80dcb07338e116e5097600d63c9a9c64a0360ed5f0a3c6ed97c1589050eea8fd4d20d4b50aee246682e08d049764355b3e85dd4ddaae425664c76826bd726eb99537fe3f8e968895f69613faa68a837eeb4153792974a6be68993f8ef2b14b7a904d66bedfbb6aaf09e443e9d339cfa7bf289585b3e5b10d37056d1525233b7212024b1e94a58a9cef49bce875f4b6e70121106065047ad895eba32a0807fc52205fab52ec0e419f5416874255c99163620874aba27764c2f27b50fceed97bf7d5486cd88ed2e8dcadd9fc35bd00e7be5276e70be83479e1246911f386779ab8e7868b37c140fe86d9f74380dbe35b4e32b88016f3338603b5c45fdec8c82f634bf5f09c8b63631e37bb7fc54a9fbb162b9083d7b9decda441cf19ab76b27a87a17a913a513b19c3e7d664e145c12ab6fe80aad77054acd6d3f4507969017819b9e541cc67d3674bf33a2378b958b5df6efbfa8664d33bd35d082d0f982ac4026cf064d848a5d6b1c09a3890c9ecb2e4a069aaad60a82709305d84cebd882874920cc622333188f6717f30d5e853774b464a8367475507ed313eefd896e2f716dba67437c608928f29eedb79303aab811442920950ff496040cfa94c39bd44f9e491841b19fd48e6610fceed602840bcbed884ef88389b752be74dc41cf1ca44544dc1e0283fc143235b9dababb6e873dee6c991d59c032c6ac1b39b139bce2f75ab36dfe6894ee4e26092f8ba0ca3a1f9de21c9501aed5c37ce89c9d2bddd865af03c39694810de43be6476be3665af392bab514e6ec1ec346a8cad1dad8f80d3e0bda1b9c1fec09dcf5c15b49a993a1c4eea5af61d05fc192b805ba2a17495703470f3cbce5001ff72be3d3a8da9a4e06758ce15e544eb7b202631a769ea7a3479440d515acb2e559dd8b6829b4d4a13128db01d0ac20fc85b48083781f1fb2429693bc4830497462277832bb67176a5f204fb2831308ca19e33c6a9fcb66cb50aa177fcf5b1191b11b4a85b5e0a1051a313e623aa631bc4d84e4a61088ac22b1b97fc2d1e120767b06f7c378edf48184d6f3db86eb3aa308c1f2790463ef05f3b457b444c0513034aa50bc2417cd04d2c50494a35cdfd7ddee0d4c4ea4bb962738ac045064eb69398b599e6887bad6e0be05484946a08ddcce5b8c321b91b6740306390ba31e5320a6357fe4b11a0925cf3e25fd4858096dde022ed8e272ceeb8056ce4b11d43694ea662feda4eaf2a065af25b9ac8d6905cd424b0614b9467431dac304ecbd4a54defa680a0eb78e4f26d86ba87bc130141adf57ee576ad02a89327bed75f17cb8f2c9068d5cfc64713e3544e2ed0767d4c3e33249a005ac5b3df9fbe8372bf8a8366a8d22f2c58dd519df8fd7d9d3ec502bacea4eb509be81156bb3531a91c5d3a995c3f56874c5c787940b6d826c429380f608d65a47f0cc290ed44d2bf3e4a434f5b04f9848f4534150ecf7de64528f2c53ebe86dc282b4ec0f45c926338b3f8b66b8d14a8b7763aa1894c43dccdf90011fc868be864dbc72f8ddb04a8ba2200273fa161684845c140bece7e79697239f0c67200740622e039f2b89a34be3d657f391bd5ecbda4b48844fbfa3e715ba8a66ed5a1a11e8dafba36944741ace0db2247ed4970f5f359919273ff19160bbea6b5344bb717038334c54da9e26cd3b56ffd01a003a0d74e4ae2ffd6918c5a23ad27f0805cc219f534a3af7705d45d3479f2aa0fc62d470083f65444977cf6e411d0e76df19f962f54e7dee752ee99ea6ae1dbfa2de786251c4a1323ebec68618b9cd118ac7cf9ec626d9989fefc75a4b9faaed8a3817e2d4f81277a0293b9437df06364cdae9e84904ebe75cdee65abc96ccec9ee76c6e5ac0943e360afe84712c8ca46aaa64ffd9cac733037cc46ddef976e182748fdd1d10bdbf90bd835f8c43ba6887e4ecbaa09884e879abe42ff56c7b81993cbaddd87d34a8c9c3ffe9784db00a4b7c02624d8b1903f7950f672b33b2b14e741da7a72aee7a1ba481e684ec6607ed81590a84ff827309277b75ab077d12b72bd5eb7004c5d4e6bceb4660af156cc4cc0ed1befe48cf48e687483628a0150dc04c66c43991964fdda00ba9e2becef3dcc1f777685a1bd38de24d8b3a4c7317e5831e2de4a5fdeaf5d617937b883f4c308b6d4eeb9fb867d0c52941b17c1857ce9305cad0968283c057132b59348b241cafc64d70cb56bea7cd6a1d067cbd396afde82e36a8d16735fb98dc3a5a10980678b464dd9fbff6c6d554a3a0826cb272d349b920d27caad48c4e23f977b35e32fa6a6c8b5a840960ac9427b74f9f969461a7f1ceab64bc817d37087ae82259bfa69c1f416ff24b20307496e9135654c6f83fd5fd1ba96bb23aba10623bdb190de3d3d99c6efb4f85363d117c49f4a85a9c0d53d3992d41d0ecf1ed83426161a81483ba622761348c4525351ba6b786cb144b450368c1af54ac9ce3f3bd3ccace525b6c7fc1282c5df225060a930c7f3e1c17f4d44da52e21ce010f709578d33cfbf7a2c579f3e7cb6316ffa958005bcb6252ef4380851dc492b0e626af30ec2c1cf502b92ead8c411c9fb6f6604442a9f1e85f8181a334b81a73202b4d563f9c257689b1f4d2782fad1d56620111b68ed8c29f62122ee8ab7743bea3fb6f1c84a05e82ce623c7387fe6ad91196dde96a1320e9fc2c709d151fb8fc39e1b2445a368be3425dbf020b0c24646f1de34815083539a5d7f2c16342e0e32088db327781b28df04ccbc9dc25df6a1c22498d2e4079530bc71c9e7ca8a8945abdbbf30e440afac2f51a218f587fc6b55355d0988bd069f9053caea90ba31356655db67e8e8296754e4a1435c8a9919008c4a9fc2345dd4d55c15292e9e5098124f12f39f67d811dd4a4f5370c15114341c1171c9d34fa42a54b290f8a83c51d5c9d9d1b403710bf72f9788bc7a1c6b7de61a979b97a3398f804bdde97e01db339a220e7d0fe5cd006ec648c1bf65e35b53334a2b0b20d68c29e5f3b58dbef987f7d8e4da323bd00f1ed6caaa77bb13e9053ac6d60996a1f6fd4d61f6e35afe65073b8f789496cefabd14850171d1b17ec7cf3cce0a7d6817ac4637a51519768522b9cd928d5c28a5aca4501041bc20668b7f5f0d7b28cd57df9f487ca8ff9991a1ac9e435f08876f30214a1577710b96fdc14bb70d3494256f99f4cd471ba80d500da00cf5493b86002a599e273c55d8ea3c29abc422f983595f61b2a58fbe460e74562c40604fe79e070449ea1113d92a174c27365325dc4a5471ce403e9ce77da44ba3c292b638696c9d1318b3c0da184b8d6244ad92871a3b5eb05c82896d5466d1df756f78d7c21dd2250e8f67d8054be1ebd0a7971df814a1953afd0b98c81e15b2cf2ffdf432595c0a82e521091a5b4c05d50104c41bde5d47b05a4fc766d13471aa4390bc69fa3462c6af46ba3db6415d4009259772ede515497dc40bbf846ebdffc06ee5ed95767ddc280da1aaf2ba7582f90c5e1deeeec41705687bea1864780d075b154fe3af9afb092ff02d134009d4c19db279323b1ba72841b3627502e126757cca99398affbb0ec6ef9e388ee679e3dc60b5fcece355edc98b4c18ce73f2bc7b36487652ce6dc56274f3448681fbb2882fffff1caa9d434f79c537624109aa5c208ee990a26016e879c181644279ac8332b44ab453d7fec00f7bc34fd76e56b6342e7fad0fd7c2f1e605e618887291925f8ae7ecbe1c278c5f41058c5e84b3e2158f2d143c88c1fb687099211b420ba2310566398d0fc8ad11fe07d7806301f172d0d06510dbc44bfca6adad823d4b5a2e8b20a6dd2c0bfdae7ebbc44e58c9d0428bcfdc2d1c5dbcdb49302eb35f1f26f6cf2055e0c0b80f2007dc3251d1aab4c607ba53bfbfa25aca8fa7cbf224022c93aec292ef3fb701e0eb5a2cabbbd9bbeba9203e3e4145d8b596d07df3ddd9e610e05a920f0880f8c1bab0b2d4cd40f713bf6185e7bc7ab3a755225b2d77dfeacb4dbcc3cd80011659abedf4231b8b1c854044f468ee6164dc795409d4a55aff97fec7162d78f13a10c442feed9acd0e80371b742745ce7d6387627021ebd1d4a40237a0b6652252da0bbd6547b30bdb49f48671cd2b7398cde8853b19f86a303b58781599f25a2e8785b688e8b80e4f3a971cd6676a60ab177de3602de9df234bd36b425b57a88333ddcd2bd9e23d8925b428e1891445f2e78a44314c8aa1a4a4f111e461e0ff80c2ffb8449f3a0ef3ce3a0bb53d62c739f6567e663639f9f65aac8b67f578bcc71eb6ab7fca1936565f084af0aec4812c5ab4de4ee66044d162ae42ade6a9bb564b838f306d395de14b5ceafd3def1f88300569c07359f908d25f9191216e91868d1e3183a4bf1539657d1200af38f4cbf003671a5dd707cddc5d24d1d45012abfc2dcc947cca3bdbb92b3f6b18dbcf4d3c00a8fcac0d4472840de6ef91c99d020c65f5dbd31c9c1d427ed7e9f11b33814da925d4aaef3a6c6e2398000500cc8315e22429b7750ef2fc6ea74d3df0ea4830167ac1bf3f05b71eeeea86c5ac4b0246c338e8a76fb33ac30ab1ca0fb6f1f197793e73d5e7b5636d90b48faf6185e801b2c7372366652af569781adf4301b98c5bef7e3951bbe332ae86e7260f1e1383b744296ef67734fd07232403bd18c350ef3478d9cfed71c2de01824bf73c2c2578ec76029b741aec7caa4e4ac42a924c758365a736a9653e1788537cc30abcad849e2a1e197fc171727604d9dee8af0737c6a769a383902d2d2ca9d4fc01ebb021c0076b10bfd92443ec7f05898ff272f1370550d2823840200b35154974b3dcd0cdb7075cde19dcd6b96330c1069222b6f1780346e410e147b2a0f05c1fea3cc754c88763a8e267103a6fdd2cd23aceb82ff85e0bc41774763c1fa2cad15ce9750afbba76f7d3a774fd065052c009e2c17211ef3094bb4c7045ff9c1f4200861c7011110ed361a4f17806db1b01a4b15bc026fe9327b3cd251e25fd8cd51374734a04f8cdcd0521930f576d5e429098a8ed67ef2375604feab36e654702a9d82a84074588d4ccd3ae7f38c2ccc8985e7fe72f577d1bb00379fb9de593571373770451f640ed8e4ac57c62ee391ac1c4f1e2d7444051d5fab49dce51f910ec34802a93c0b1b60e1c39776a86bf26ee2ce4658876f8d7c8df1b889facca01978ad2f115bfcb977c1011e0640fe92441194c35f8ea2e46137cf9d070581e31e80f578af0a13c3ee50f141d6abc49f64567ae01fab5efdfeb68acd1ffdb40e0f8d23fe1fd41a359c1399caab48a33d1f94d40377a9037eabb672d9e3ea130e03c3cd57d5802398e79e9bc8cdaf026adb06ed5b2efb2834ee9c8ee4966a23a42557f62d23c5808255cfd74aed047285d85acffad6897bb0a0b1745a603f22c556a89caaa63b724595deeec99274d72364ec863b023a84f3fa547daa213f6da12c2730bbe031edcb4ba12f337b9d2484a8ae8bbe31148ff1413cdb3e6cb03a28b7fb05fc789ff05ff5cb8f115ae773cfb99036bb4fb6bba9589d3e553f97715ccf4924ad5cefba91b80aa34bb416d8da7de15a02b8a7964b378d8d61dd03fbecad00cc4c96956ac462bb21d7dce3b46bb06dfcd337116e9d322bb2f401260ff113a3fba74eafb41d951a9791610295f9f159f00bb924cd3097666927f5ebc03382565a0ace5ce62064a87fd2969269e3cd9ade9610061897c29d7de4b015ccfdc3ad95315c673588c73fd2a041966573f3fd0e1dd6ca2f4258d0e32cccfb63753cda52f6841565c60931d1e56539d7b18565e1c0a899e35d27928c47d188cea2f608138caab01b4a4f0e8c0855f5b79448b1b0fde110d93e116878e4015e0059b1a2494c2f412c24ca254828b29525b0cf397ae43b0a6121384dfc08f1e286f215b6746451dd69f65a0fcc2f4b943ba9d53a23bde9b347cabb88c735ced8792c5e484537900eda2e9def81fb506110fe3e94c7cbe6fffc55c80ddd55095576683dc88ebc93ba761219065d891451c985bd4b157a6cce1b38bb16512cdac23b48c4ca56968faa6184f544e646bc7ea0fc2120b2096820075201f22ade6ed3929484b81ca767c45daebe4679d323c1630a679180cbe7a3493c5267060e4d582b34954c60b5ed5528d31a159edfe45681806a48f8a79fd0e2ae43e4d070069654e7d8a2758856f46bf86af9687a0629b1de416da7b9fb0b5781c5496c74ce9de865f2d48e7150415c5277b4ce8ef26a002365acbae686c9698776518a8302b033dc413c8a90005509fbc44f6efdcdd3ea229d0ae75ae56908fc781bcaf39399ab6977475b2c1460d93a6d42994309c9500ea9e1b30b0805b4933094d26b8aa469b728f47a9bc374fcb169b7d153964e5fbe20d69fc0163a446aa6b8c9b5effba1d96937db7cc18292ff19d3badfadfbc38975ccc147a0d8fd3e4605a3780a3a54661820921ad056b82a5b3a3acbee2e38519b0a23de4868d83bd2cb37113e9542ef92002260ce5aa3535b07610c0738d3d1afa20fe67408f8f419d586a64b3bb0656cffe2a00938590b9ef1672bb8136813383de3413cce173876e827957b854d806aea5116d2931af16be0cd15e5d43c26a3c8dd2266abed9b12548eea529af5e03293b440da41174a67f97c04128c8ed753a60c7c67925d12b2d906d648fd3c4eefe9a6ccd60cc1cc6568ad78645e08e751d8a249230a88a6af57c61ea430e6a7a222b397a0563659eecca080246f6c14252b32db6da8dd718ea63b9a07d5b1d9502cc5f76261e28d8d86ca2b15943fc059edf90b7a996c03aa089a6b45daf0d2b068fb337afb4fa7a388354dad800939ed52cb42ecce01844782d45eb24d8732632f0122325e99899ce0ad449360d54e99e11dd0ac4ef53d45a560f18851d20f061d26d99853a825fcc2e98e82eaaac755e57118574f279ac94a4b22258610dcb61a2df0e4b058ea5bec211c0d8da2caf682da56a0f36f14596f330631e6141a9c18fb688a0f47487185682998f761a2d7818bdb9974cbb3d360369dab5905fed6ddd244fc73aaefa8b47e18a8eaf5d1a2f5507f51fa344a85000fc222718d14cb91a0c43ca5d1cef6b0ae8bd004e8b84492e9ee54c50cb3e0f624c148cebafebba25715171fd74d655af3929538ae5ad428737ee4be8de8fc709c919db97a463baf08780664260c5dfc23a98aa82de4a8955b58d697a7a10c0807858719870618b45a078dc47552c14cef0ae7db2691546a3cd99ec00cb7c7494898e7a867666eb018d2be6d384999318c35e6a22bf8005127d03cacf9b313a25b6af4f547fb8bb0d02a0eb9386a954b84e2c8912575aaf892f3f043879209a8053e72af9ec8ae95923d11bf2f495c6ec4eb4b194f51d83f4d0c9ca142c0d77f28ee5d05cd521a91079ea99c3e2d018a343f0741f939207073e29f348fd513096f70e1a8eef323a92d67ecfd4a9d7059c7414b3e5a9c7bcf3d68f30212ba11cc49cf97764a73870e4b4503ebdf3b9654c08f517f3f5563b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这里有东西被加密了，需要输入密码查看哦。</summary>
    
    
    
    <category term="个人笔记" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="unity知识点" scheme="http://yoursite.com/tags/unity%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——扩展变量增加OnValueChange功能</title>
    <link href="http://yoursite.com/2022/01/07/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95%E5%8F%98%E9%87%8F%E5%A2%9E%E5%8A%A0OnValueChange%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2022/01/07/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95%E5%8F%98%E9%87%8F%E5%A2%9E%E5%8A%A0OnValueChange%E5%8A%9F%E8%83%BD/</id>
    <published>2022-01-07T06:00:09.000Z</published>
    <updated>2022-01-07T06:31:58.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔者参与的项目的UI框架并没有采用MVC结构，而是把MVC中的C去掉了，只使用了MV，把C的逻辑拆分了一下，分别分为M里的C和V里的C，分别写在了对应的M或者V里面，V是根据M里的数据变化从而进行变化的。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>C#自带的属性并没有数据变化响应的事件或者委托，笔者的UI结构是需要根据数据变化进行更新的，所以笔者希望属性能有一个类似于OnValueChange的功能。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="方法一（使用委托）"><a href="#方法一（使用委托）" class="headerlink" title="方法一（使用委托）"></a>方法一（使用委托）</h2><p>这种方式是自己增加一个变量的委托事，然后在属性的set方法里进行响应对应的委托，每次需要监听数据变化的时候注册一下对应的委托就可以了。<br>缺点：变量需要定义成委托，并且每个需要监听变化的变量都需要增加一个委托的变量。<br>代码如下：  </p><pre><code>public class ExtendProperty&#123;    private int m_Value;    public Action&lt;int, int&gt; OnValueChange;    public int Value    &#123;        get =&gt; m_Value;        set        &#123;            OnValueChange?.Invoke(m_Value, value);            m_Value = value;        &#125;    &#125;&#125;</code></pre><p>根据代码可以看出，如果是属性使用只需要两个变量，但是如果是字段使用就需要三个变量了。<br>使用方法如下：  </p><pre><code> void Start()&#123;    ExtendProperty property = new ExtendProperty();    property.Value = 10;    property.OnValueChange += OnValueChange;    property.Value = 20;&#125;private void OnValueChange(int arg1, int arg2)&#123;    Debug.Log(string.Format(&quot;&#123;0&#125;-&#123;1&#125;&quot;, arg1, arg2));&#125;</code></pre><h2 id="方法二（推荐）"><a href="#方法二（推荐）" class="headerlink" title="方法二（推荐）"></a>方法二（推荐）</h2><p>方法一的缺点很明显，如果是少数变量使用还可以，但是如果大量的变量都需要监听会比较麻烦，于是笔者就找到了另外的解决办法，笔者自定义一个类，然后变量都使用这个类定义，在类里面进行变量监听就可以了。<br>代码如下：  </p><pre><code>public class ExtendProperty&lt;T&gt;&#123;    private T m_Value;    public Action&lt;T, T&gt; OnValueChange;    public T Value    &#123;        get =&gt; m_Value;        set        &#123;            OnValueChange?.Invoke(m_Value, value);            m_Value = value;        &#125;    &#125;    public ExtendProperty(T value)    &#123;        m_Value = value;    &#125;        public ExtendProperty()    &#123;        m_Value = default;    &#125;        public static implicit operator T(ExtendProperty&lt;T&gt; vl)    &#123;        return vl.Value;    &#125;&#125;</code></pre><p>缺点：定义普通变量的时候都需要初始化，不会默认赋值，并且每次使用变量的时候都不是直接赋值，而是采用property.Value = value的方式赋值。<br>使用案例如下：  </p><pre><code>ExtendProperty&lt;int&gt; property = new ExtendProperty&lt;int&gt;(10);property.OnValueChange += OnValueChange;property.Value = 20;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>采用OnValue的方式是一种简单的响应式框架，类似于UniRx，笔者在使用方法二的时候一直在想办法解决如何让使用者使用的时候像普通变量一样赋值而不是采用.Value的方式赋值，奈何一直找不到能拿到赋值的左值的方法。第二种方式更像是把第一种方式整合成一个对象，从而减少代码量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;笔者参与的项目的UI框架并没有采用MVC结构，而是把MVC中的C去掉了，只使用了MV，把C的逻辑拆分了一下，分别分为M里的C和V里的C，分别</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="C#-Property" scheme="http://yoursite.com/tags/C-Property/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——解决Unity修改Prefab的参数不生效，无法保存</title>
    <link href="http://yoursite.com/2021/12/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3Unity%E4%BF%AE%E6%94%B9Prefab%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%8D%E7%94%9F%E6%95%88%EF%BC%8C%E6%97%A0%E6%B3%95%E4%BF%9D%E5%AD%98/"/>
    <id>http://yoursite.com/2021/12/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3Unity%E4%BF%AE%E6%94%B9Prefab%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%8D%E7%94%9F%E6%95%88%EF%BC%8C%E6%97%A0%E6%B3%95%E4%BF%9D%E5%AD%98/</id>
    <published>2021-12-30T02:06:39.000Z</published>
    <updated>2022-01-07T06:30:40.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔者刚入职一家公司，团队的项目在UI方面处理和外面大部分框架都差不多，都是采用绑定的方式处理UI面板，笔者在开发UI面板的时候发现，笔者修改绑定的脚本的数据的时候，发现无法触发prefab的保存，所以不管从场景还是资源中修改参数，在重新打开的时候都没有生效。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者经过一系列的搜索，最后发现是因为笔者所在团队的框架，修改prefab上绑定面板的脚本是通过这个脚本的编辑器扩展脚本中的OnInspectorGUI方法中进行赋值的，但是在这个方法中通过代码赋值的数据都无法触发Prefab的修改，所以无法进行保存，因此下次再打开prefab的时候依旧不生效。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="方法一（不建议使用）"><a href="#方法一（不建议使用）" class="headerlink" title="方法一（不建议使用）"></a>方法一（不建议使用）</h2><p>这个方法是笔者同事用的方法，采用的方式是通过其他方式触发Prefab的修改，从而进行Apply或者Save，这个时候进行保存就会把修改进行保存。笔者同事是Prefab拖到场景中，通过设置Prefab的显示隐藏，触发修改，然后保存。笔者在测试过程中是通过增加节点再删除触发的。这个方法并不推荐使用，因为每次修改都需要想办法触发保存。  </p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>这个方法是在OnInspectorGUI函数中，在调用参数修改的地方，通过**Undo.RecordObject(object,”value change”)**的方法,然后在修改的时候发现就可以触发了，这个方法笔者是从度娘那里学到的方法，笔者并没有采用成功是因为笔者框架的Object是System.Object,但是接口要求的是UnityEngine.Object，因此笔者如果修改会修改大量代码。并且据说这个方法不是百分百生效。  </p><h2 id="方法三（推荐）"><a href="#方法三（推荐）" class="headerlink" title="方法三（推荐）"></a>方法三（推荐）</h2><p>这个方法是在OnInspectorGUI函数中，在调用参数修改的地方，通过**EditorUtility.SetDirty(obj);**的方法监听赋的值就可以了，这是笔者采用的发放，这样修改就可以直接保存了。不过此方法有个确定，就是修改后无法使用ctrl+z进行回退，本身修改也是无法回退，据说方法二是可以支持回退的。  </p><pre><code>[CustomEditor(typeof(XXX))]public class XXXEditor : Editor&#123;    public override void OnInspectorGUI()    &#123;        ...        XXX xxx = value as XXX;        if (#change#)        //数据发生变化        &#123;            xxx.Value = object;            EditorUtility.SetDirty(object);        &#125;        ...    &#125;&#125;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>笔者的方法依旧存在无法回退的方法，如果那位大佬有好的方法可以联系笔者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;笔者刚入职一家公司，团队的项目在UI方面处理和外面大部分框架都差不多，都是采用绑定的方式处理UI面板，笔者在开发UI面板的时候发现，笔者修改</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Prefab" scheme="http://yoursite.com/tags/Prefab/"/>
    
  </entry>
  
</feed>
