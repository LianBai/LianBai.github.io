<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LianBai</title>
  
  <subtitle>手握日月摘星辰，世间无我这般人。</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-12-30T02:50:53.261Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LianBai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity杂文——解决Unity修改Prefab的参数不生效，无法保存</title>
    <link href="http://yoursite.com/2021/12/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3Unity%E4%BF%AE%E6%94%B9Prefab%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%8D%E7%94%9F%E6%95%88%EF%BC%8C%E6%97%A0%E6%B3%95%E4%BF%9D%E5%AD%98/"/>
    <id>http://yoursite.com/2021/12/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3Unity%E4%BF%AE%E6%94%B9Prefab%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%8D%E7%94%9F%E6%95%88%EF%BC%8C%E6%97%A0%E6%B3%95%E4%BF%9D%E5%AD%98/</id>
    <published>2021-12-30T02:06:39.000Z</published>
    <updated>2021-12-30T02:50:53.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔者刚入职一家公司，团队的项目在UI方面处理和外面大部分框架都差不多，都是采用绑定的方式处理UI面板，笔者在开发UI面板的时候发现，笔者修改绑定的脚本的数据的时候，发现无法触发prefab的保存，所以不管从场景还是资源中修改参数，在重新打开的时候都没有生效。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者经过一系列的搜索，最后发现是因为笔者所在团队的框架，修改prefab上绑定面板的脚本是通过这个脚本的编辑器扩展脚本中的OnInspectorGUI方法中进行赋值的，但是在这个方法中通过代码赋值的数据都无法触发Prefab的修改，所以无法进行保存，因此下次再打开prefab的时候依旧不生效。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="方法一（不建议使用）"><a href="#方法一（不建议使用）" class="headerlink" title="方法一（不建议使用）"></a>方法一（不建议使用）</h2><p>这个方法是笔者同事用的方法，采用的方式是通过其他方式触发Prefab的修改，从而进行Apply或者Save，这个时候进行保存就会把修改进行保存。笔者同事是Prefab拖到场景中，通过设置Prefab的显示隐藏，触发修改，然后保存。笔者在测试过程中是通过增加节点再删除触发的。这个方法并不推荐使用，因为每次修改都需要想办法触发保存。  </p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>这个方法是在OnInspectorGUI函数中，在调用参数修改的地方，通过**Undo.RecordObject(object,”value change”)**的方法,然后在修改的时候发现就可以触发了，这个方法笔者是从度娘那里学到的方法，笔者并没有采用成功是因为笔者框架的Object是System.Object,但是接口要求的是UnityEngine.Object，因此笔者如果修改会修改大量代码。并且据说这个方法不是百分百生效。  </p><h2 id="方法三（推荐）"><a href="#方法三（推荐）" class="headerlink" title="方法三（推荐）"></a>方法三（推荐）</h2><p>这个方法是在OnInspectorGUI函数中，在调用参数修改的地方，通过**EditorUtility.SetDirty(obj);**的方法监听赋的值就可以了，这是笔者采用的发放，这样修改就可以直接保存了。不过此方法有个确定，就是修改后无法使用ctrl+z进行回退，本身修改也是无法回退，据说方法二是可以支持回退的。  </p><pre><code>[CustomEditor(typeof(XXX))]public class XXXEditor : Editor&#123;    public override void OnInspectorGUI()    &#123;        ...        XXX xxx = value as XXX;        if (#change#)        //数据发生变化        &#123;            xxx.Value = object;            EditorUtility.SetDirty(object);        &#125;        ...    &#125;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>笔者的方法依旧存在无法回退的方法，如果那位大佬有好的方法可以联系笔者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;笔者刚入职一家公司，团队的项目在UI方面处理和外面大部分框架都差不多，都是采用绑定的方式处理UI面板，笔者在开发UI面板的时候发现，笔者修改</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Prefab" scheme="http://yoursite.com/tags/Prefab/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2021/12/27/hello-world/"/>
    <id>http://yoursite.com/2021/12/27/hello-world/</id>
    <published>2021-12-27T03:39:09.484Z</published>
    <updated>2021-12-27T03:39:09.484Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Unity杂文——海外开发踩坑笔记</title>
    <link href="http://yoursite.com/2021/07/09/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%B5%B7%E5%A4%96%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/07/09/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%B5%B7%E5%A4%96%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</id>
    <published>2021-07-09T10:25:32.000Z</published>
    <updated>2021-12-27T03:39:09.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><h2 id="Gradle版本问题"><a href="#Gradle版本问题" class="headerlink" title="Gradle版本问题"></a>Gradle版本问题</h2><p>本地打包的大部分错误都是因为这个问题，这是因为笔者接入的SDK自定义了gradle的插件版本，这个再unity本身其实已经定义过了，但是自己是可以通过修改build.gradle进行修改的。查看unity本身gradel的插件版本的路径是：Editor\Data\PlaybackEngines\AndroidPlayer\Tools\GradleTemplates\baseProjectTemplate.gradle,以2019.4.28版本为例，里面代码为：  </p><pre><code>// GENERATED BY UNITY. REMOVE THIS COMMENT TO PREVENT OVERWRITING WHEN EXPORTING AGAINallprojects &#123;    buildscript &#123;        ***        dependencies &#123;            ***            classpath &#39;com.android.tools.build:gradle:3.4.0&#39;            **BUILD_SCRIPT_DEPS**        &#125;    &#125;    ***&#125;***</code></pre><p>如上图，可以看到插件版本为3.4.0，如果unity里本身修改了baseProjectTemplate.gradle就按照修改后的来，这个文件夹内所有的gradle和properties都是默认的，如果程序里修改就按照程序里的来。修改的方法在Editor–&gt;ProjectSettings–&gt;Player–&gt;Publishing Settings，如下图所示：  </p><p>  <img src="https://file.liangxiegame.com/f69ca480-57fe-4313-8391-4318b1cead9a.png" alt="image.png">   </p><p>如上图，其实就是对应编辑器文件夹下的gradle文件，如果打勾就会在pluging/Android文件夹下生成对应的文件，就可以直接修改，不再按照unity默认的来，就可以修改配置了。</p><p>经过上面的介绍已经知道如何查看并修改unity的gradle插件版本，下面就是修改对应的gradle版本。首先打开Editor–&gt;Preference–&gt;External Tools就可以看到Android的打包环境配置。  </p><p><img src="https://file.liangxiegame.com/13b80d7b-6dd0-4fdd-8199-82222a81d8e2.png" alt="image.png">   </p><p>2020版本以后的Unity是默认路径下就自己配置好环境，选择默认就可以，但是依旧可能会存在环境不存在或者版本不对，所以可以自己配置，这样修改也方便。这里有需要特别关注的一点也是大部分打包失败的原因，就是gradle的版本和对应的插件版本是有对照关系的，必须对照上才能正常打包。对应关系如下图：  </p><p><img src="https://file.liangxiegame.com/10319033-5e95-4d83-a544-060a7ff6cac3.png" alt="image.png">   </p><p>只要配置好对应的关系就行了。  </p><h2 id="NDK版本问题"><a href="#NDK版本问题" class="headerlink" title="NDK版本问题"></a>NDK版本问题</h2><p>在打包的时候也遇到了NDK版本不对无法打包的问题，打包失败会提示打包需要的版本，下载对应的版本即可，笔者打包的时候需要的是版本19，但是下载19版本依旧无法打包，这是因为版本的小版本依旧对不上，这里可以不用找对应的小版本，只要对应的大版本一样，在自己ndk安装目录下，找到source.properties文件，编辑文件，如下，修改对应的<strong>Pkg.Revision</strong>即可。  </p><pre><code>Pkg.Desc = Android NDKPkg.Revision = 19.0.5232133</code></pre><h2 id="maven仓库下载问题"><a href="#maven仓库下载问题" class="headerlink" title="maven仓库下载问题"></a>maven仓库下载问题</h2><p>这个问题是打包的时候并没有找到对应的maven仓库，笔者接入的SDK需要的maven都写在了launcherTemplate文件里，但是打包的时候并没有找到仓库，这是因为maven的仓库应该写在mainTemplate文件里，在launcherTemplate文件里可能会存在没有下载到的情况。  </p><h2 id="API版本问题API"><a href="#API版本问题API" class="headerlink" title="API版本问题API"></a>API版本问题API</h2><p>这里牵扯到两个API的版本，分别是minSdkVersion和targetSdkVersion，打包的时候会报错版本问题，这里只需要在Editor–&gt;ProjectSettings–&gt;Player–&gt;Other Settings里修改对应的Minimum API Level和Target API Level，修改到要求的版本或者更高的版本即可。  </p><p><img src="https://file.liangxiegame.com/8f76046e-d068-4e4a-a7f0-09db7505453d.png" alt="image.png">   </p><h2 id="APK-obb分包无法运行问题"><a href="#APK-obb分包无法运行问题" class="headerlink" title="APK+obb分包无法运行问题"></a>APK+obb分包无法运行问题</h2><p>因为Google商店对上传的apk有内存限制，要求是100M以内，这里推荐使用的是APk+OBB进行分包，根据最新的要求是要求使用AAB包，这里先介绍APK+OBB的分包遇到的问题。  </p><p>分开打包的方法是Editor–&gt;ProjectSettings–&gt;Player–&gt;Publishing Settings里，勾选上最下面的Split Application Binary。 </p><p><img src="https://file.liangxiegame.com/1ce243b5-e799-4710-a446-0e141fc2a4c1.png" alt="image.png">    </p><p>这个是可以代码控制的：  </p><pre><code>PlayerSettings.Android.useAPKExpansionFiles = true;</code></pre><p>分包后如何在手机上运行呢，这里只需要安装分包后的APK，然后在手机上运行，发现第一次运行不成功，这是因为资源都在OBB中，所以无法正常运行，这里只需要吧自己的OBB改好名字放在对应的文件夹就行了。然后再运行就可以了。   </p><p>文件夹地址：手机目录\Android\obb&quot;APP的包名”<br>OBB文件的名字: main.安卓内部版本号.APP包名.obb (举例：main.102.com.XXX.XXX.XXX.obb)</p><h2 id="打包AAB报错-FileNotFoundException-Temp-launcher-aab-does-not-exist"><a href="#打包AAB报错-FileNotFoundException-Temp-launcher-aab-does-not-exist" class="headerlink" title="打包AAB报错:FileNotFoundException: Temp...\launcher.aab does not exist"></a>打包AAB报错:FileNotFoundException: Temp...\launcher.aab does not exist</h2><p>打包aab的方法就是打开File–&gt;Build Settings的面板，然后勾选上Build AppBundle(Google Play)再进行打包就可以了。  </p><p><img src="https://file.liangxiegame.com/09a6726f-1fd1-4805-be17-d0bbb3ad5481.png" alt="image.png">   </p><p>这个报错网上查了一下原因，说的是因为gradle版本过高，导致unity内部逻辑出错的问题。笔者的gradle的版本确实比unity自带的版本过高，于是利用网上给的解决方案解决了。解决方法是在launcher的gradle的defaultConfig里添加下面代码，笔者不导出安卓工程于是就在launcherTemplate的defaultConfig里添加了下列的代码。  </p><pre><code>defaultConfig &#123;    ***    //打包abb的话需要这个    tasks.whenTaskAdded &#123;        task -&gt;        if (task.name.startsWith(&quot;bundle&quot;)) &#123;                   def renameTaskName = &quot;rename$&#123;task.name.capitalize()&#125;Aab&quot;            def flavor = task.name.substring(&quot;bundle&quot;.length()).uncapitalize()            tasks.create(renameTaskName, Copy) &#123;                       def path = &quot;$&#123;buildDir&#125;/outputs/bundle/$&#123;flavor&#125;/&quot;                from(path)                include &quot;launcher-release.aab&quot;                destinationDir file(&quot;$&#123;buildDir&#125;/outputs/bundle/$&#123;flavor&#125;/&quot;)                rename &quot;launcher-release.aab&quot;, &quot;launcher.aab&quot;            &#125;                 task.finalizedBy(renameTaskName)        &#125;    &#125;&#125;</code></pre><h2 id="AAB格式手机安装方法"><a href="#AAB格式手机安装方法" class="headerlink" title="AAB格式手机安装方法"></a>AAB格式手机安装方法</h2><p>首先需要把aab格式的安装包解析成apks格式的安装包，在解析的时候需要一个jar的包，这个jar包是bundletool-all-1.6.1，版本不要求一定是1.6.1，解析的方法是下面CMD的命令：  </p><pre><code>java -jar &lt;bundletool.jar的路径&gt; build-apks --bundle=&lt;.aab文件的路径&gt; --output=&lt;输出.apks的路径&gt; --ks=&lt;打包.aab文件时的秘钥文件路径，如果.aab文件时没有使用秘钥则可以省去秘钥环节的配置&gt; --ks-pass=pass:&lt;秘钥密码&gt; --ks-key-alias=&lt;秘钥别名&gt; --key-pass=pass:&lt;秘钥别名密码&gt; --device-spec=&lt;要输出的目标sdkVersion的APK的json配置文件路径&gt;</code></pre><p>举例：  </p><pre><code>java -jar C:\Users\XX\Desktop\bundletool-all-1.0.0.jar build-apks --bundle=C:\Users\XX\Desktop\test23.aab --output=C:\Users\XX\Desktop\test23.apks --ks=G:\Client\Trunk\key\user.keystore --ks-pass=pass:abcdef --ks-key-alias=yunzhong --key-pass=pass:abcdef --device-spec=C:\Users\XX\Desktop\config.json</code></pre><p>然后手机链接电脑，打开调试模式，接着调用CMD的安装命令：  </p><pre><code>java -jar C:\Users\XX\Desktop\bundletool-all-1.6.1.jar install-apks --apks=C:\Users\XX\Desktop\test23.apks  </code></pre><p>安装结束后手机上就存在自己需要的安装包了。  </p><h2 id="报错Illegal-usage-of-unity-detected-shutdown-unity"><a href="#报错Illegal-usage-of-unity-detected-shutdown-unity" class="headerlink" title="报错Illegal usage of unity detected, shutdown unity"></a>报错Illegal usage of unity detected, shutdown unity</h2><p>分包之后笔者运行发现APP直接闪退，看了半天日志最后发现了一句报错是Illegal usage of unity detected, shutdown unity。笔者使用的是unity2019.4.26f1c1(中国版，以后的中国版本后面都会有个c)。通过百度发现Unity中国版2019.4版本再分割obb编译的时候会导致这个错误，其他版本还没试过，不知道会不会有这个问题。发现只需要使用国际版本即可。  </p><h2 id="报错DSL-element-‘useProguard’-is-obsolete-and-will-be-removed-soon-Use-‘android-enableR8’-in-gradle-pro"><a href="#报错DSL-element-‘useProguard’-is-obsolete-and-will-be-removed-soon-Use-‘android-enableR8’-in-gradle-pro" class="headerlink" title="报错DSL element ‘useProguard’ is obsolete and will be removed soon. Use ‘android.enableR8’ in gradle.pro"></a>报错DSL element ‘useProguard’ is obsolete and will be removed soon. Use ‘android.enableR8’ in gradle.pro</h2><p>出现这个警告是因为build.gradle里配置了 ‘useProguard’属性，而这个属性将很快被移除，使用‘android.enableR8’来代替。这里只需要在gradleTemplate.properties文件后面添加下面一句话就可以了： </p><pre><code>android.enableR8 = true</code></pre><h2 id="报错自己定义的Application丢失"><a href="#报错自己定义的Application丢失" class="headerlink" title="报错自己定义的Application丢失"></a>报错自己定义的Application丢失</h2><p>打包后出现自己写的Application脚本丢失，这个大部分是因为AndroidManifest没有配置自己的Application，配置方法这里就不多做介绍，网上很多介绍。笔者这里遇到的并不是因为没有配置，是因为笔者接入的SDK是继承的MultiDexApplication，这里需要注意的是如果您的 minSdkVersion 设为 21 或更高版本，系统会默认启用 MultiDex，并且您不需要 MultiDex 库。<br>不过，如果您的 minSdkVersion 设为 20 或更低版本，您必须使用 MultiDex 库并对应用项目进行以下修改：</p><pre><code>android &#123;    defaultConfig &#123;        ...        multiDexEnabled true    &#125;    ...&#125;dependencies &#123;    implementation &quot;androidx.multidex:multidex:2.0.1&quot;&#125;</code></pre><p>此时重新编译打包后发现果然打包出多个dex文件，在安卓6.0上测试完美运行，并且用360加固以后5.0以上都能正常运行。<br>但是坑来了 ：在5.0，5.1系统上一运行就奔溃！<br>后来知道在高版本系统上使用art支持多dex，而低版本dalvik默认先加载主dex，如果启动时需要的类不在主dex内就会报错ClassNotFoundException。 解压apk发现里面有上百个dex文件，一般不会拆分如此多，百度查阅后得知：<br>对于dex 的–multi-dex 选项设置与预编译的library工程有冲突,如果你的应用中包含引用的lirary工程,需要将预编译设置为false:<br>在 build.gradle中添加  </p><pre><code>dexOptions&#123;    preDexLibraries = false&#125;</code></pre><h1 id="SDK遇到问题"><a href="#SDK遇到问题" class="headerlink" title="SDK遇到问题"></a>SDK遇到问题</h1><h2 id="华为手机出现水滴屏无法适配的问题"><a href="#华为手机出现水滴屏无法适配的问题" class="headerlink" title="华为手机出现水滴屏无法适配的问题"></a>华为手机出现水滴屏无法适配的问题</h2><p>笔者的项目要求手机在遇到水滴屏或者刘海屏的时候，上面显示黑条不进行渲染就可以，笔者查了一下unity的设置方法，发现只需要不勾选Editor–&gt;ProjectSettings–&gt;Resolution and Presentation里的Render outside safe area即可。  </p><p><img src="https://file.liangxiegame.com/45f3375d-4006-40a8-a599-3efb2978e578.png" alt="image.png">   </p><p>但是笔者发现APP在某个测试的华为手机上依旧渲染了，最后发现是接入的SDK里设置了华为手机的屏幕渲染。在华为手机Android8.0的适配方案是在AndroidManfiest里面添加下面的话即可，笔者发现接入的SDK设置了这个，于是去掉就没有问题了。  </p><pre><code>&lt;meta-data android:name=&quot;android.notch_support&quot; android:value=&quot;true&quot;/&gt; </code></pre><p>这里列举一下小米手机的适配方案是：  </p><pre><code>&lt;meta-data android:name=&quot;notch.config&quot; android:value=&quot;portrait|landscape&quot;/&gt;</code></pre><h2 id="如何修改build-gradle"><a href="#如何修改build-gradle" class="headerlink" title="如何修改build.gradle"></a>如何修改build.gradle</h2><p>关于对Android的gradle的脚本进行修改，其实上面已经介绍了。Pluging/Android文件夹下的XXXTemplate对应的其实就是导出android工程下的build.gradle，修改对应的Template就是修改对应的build.gradle。  </p><h2 id="如何添加Android需要的java脚本"><a href="#如何添加Android需要的java脚本" class="headerlink" title="如何添加Android需要的java脚本"></a>如何添加Android需要的java脚本</h2><p>首先导出一个安卓工程，然后用AndroidStudio打开导出的Android工程，然后直接在安卓工程里写对应的脚本，脚本完成后直接复制到unity工程中pluging下Android文件夹下面。这里因为每次都要复制文件，所以笔者写了一个脚本直接一键复制所有的bat脚本。脚本内容如下：  </p><pre><code>@echo offset filePath=unityLibrary\src\main\java\com\ksset targetFilePath=..\..\project\Assets\Plugins\Androidfor /R %filePath% %%i in (*.java) do (    xcopy /y /c /h /r %%i %targetFilePath%    echo %%i)pause</code></pre><p>后来发现每次改好脚本后，还需要找到这个bat文件执行，于是笔者简化了这个步骤，笔者添加了一个unity的编辑器脚本，用于执行这个bat文件。脚本内容如下：  </p><pre><code>public static void SyncAndroidJava2()&#123;    var filepath = FileEditorTools.FormatPath(Application.dataPath + &quot;/../../android/AndroidBDSDK_R/&quot;);    RunBat(&quot;CopyJavaScripts.bat&quot;, &quot;&quot;, filepath);&#125;//cmd是执行的脚本的名字    args是参数，可以直接设置为“”        workingDir是执行bat文件所在文件夹路径public static System.Diagnostics.Process CreateShellExProcess(string cmd, string args, string workingDir = &quot;&quot;)&#123;    var pStartInfo = new System.Diagnostics.ProcessStartInfo(cmd);    pStartInfo.Arguments = args;    pStartInfo.CreateNoWindow = false;    pStartInfo.UseShellExecute = true;    pStartInfo.RedirectStandardError = false;    pStartInfo.RedirectStandardInput = false;    pStartInfo.RedirectStandardOutput = false;    if (!string.IsNullOrEmpty(workingDir))        pStartInfo.WorkingDirectory = workingDir;    return System.Diagnostics.Process.Start(pStartInfo);&#125;public static void RunBat(string batfile, string args, string workingDir = &quot;&quot;)&#123;    var p = CreateShellExProcess(batfile, args, workingDir);    p.Close();&#125;</code></pre><p>在执行bat脚本的时候笔者发现，自己完全可以写一个复制用的脚本，就不需要再依靠bat脚本进行执行。脚本如下：<br>    public static void SyncAndroidJava()<br>    {<br>        var filepath = FileEditorTools.FormatPath(Application.dataPath + “/../../android/AndroidBDSDK_R/unityLibrary/src/main/java/com/ks/“);            //需要复制的java文件所在的文件夹<br>        var folderpath = Application.dataPath + “/Plugins/Android/“;            //复制到的文件位置<br>        var filelist = FileEditorTools.GetallFile(filepath, “.java”);</p><pre><code>    var curcount = 0;    var sumcount = filelist.Count;        EditorUtility.DisplayProgressBar(&quot;同步Android的Java脚本&quot;, &quot;开始复制文字...&quot;, 0);    foreach (var javafile in filelist)    &#123;        EditorUtility.DisplayProgressBar(&quot;复制文件&quot;, javafile.FullName, (float)curcount / sumcount);        // 判断目标目录是否存在如果不存在则新建        try        &#123;            FileEditorTools.CopyFileToFolder(javafile,folderpath);        &#125;        catch (Exception e)        &#123;            Debug.LogError(e);            EditorUtility.ClearProgressBar();            return;        &#125;        Debug.Log(javafile.FullName);        curcount++;    &#125;    EditorUtility.ClearProgressBar();&#125;public class FileEditorTools&#123;    // 文件列表    private static List&lt;FileInfo&gt; _FileList = new List&lt;FileInfo&gt;();        #region   公有方法    /// &lt;summary&gt;    /// 获得目录下所有文件或指定文件类型文件(包含所有子文件夹)    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件夹路径&lt;/param&gt;    /// &lt;param name=&quot;extName&quot;&gt;扩展名可以多个 例如[.mp4] [.mp3] [.wma] 等&lt;/param&gt;    /// &lt;returns&gt;List&lt;FileInfo&gt;&lt;/returns&gt;    public static List&lt;FileInfo&gt; GetallFile(string path, string extName)    &#123;        //检查目录是否存在        if (!string.IsNullOrWhiteSpace(path))        &#123;            if (Directory.Exists(path))            &#123;                GetallfilesOfDir(path, extName);            &#125;            else            &#123;                Directory.CreateDirectory(path);            &#125;        &#125;        else        &#123;            //注意这里的EverydayLog.Write()是我自定义的日志文件，可以根据需要保留或删除            Debug.LogError(&quot;GetAllFileOfFolder/GetallFile()/存储视频文件的路径为空，请检查！！！&quot; );        &#125;        return _FileList;    &#125;    public static void CopyFileToFolder(FileInfo fileinfo,string fildername)    &#123;        var destfilename = FormatPath(fildername+fileinfo.Name);        File.Copy(fileinfo.FullName, destfilename, true);    &#125;        public static string FormatPath(string path)    &#123;        path = path.Replace(&quot;/&quot;, &quot;\\&quot;);        if (Application.platform == RuntimePlatform.OSXEditor)            path = path.Replace(&quot;\\&quot;, &quot;/&quot;);        return path;    &#125;    #endregion        #region   私有方法    /// &lt;summary&gt;    /// 递归获取指定类型文件,包含子文件夹    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;指定文件夹的路径&lt;/param&gt;    /// &lt;param name=&quot;extName&quot;&gt;文件拓展名&lt;/param&gt;    private static void GetallfilesOfDir(string path, string extName)    &#123;        try        &#123;            string[] dir = Directory.GetDirectories(path); //文件夹列表               DirectoryInfo fdir = new DirectoryInfo(path);            FileInfo[] file = fdir.GetFiles();            if (file.Length != 0 || dir.Length != 0) //当前目录文件或文件夹不为空                               &#123;                foreach (FileInfo f in file) //显示当前目录所有文件                   &#123;                    if (extName.ToLower().IndexOf(f.Extension.ToLower()) &gt;= 0)                    &#123;                        _FileList.Add(f);                    &#125;                &#125;                foreach (string d in dir)                &#123;                    GetallfilesOfDir(d, extName);//递归                   &#125;            &#125;        &#125;        catch (Exception ex)        &#123;            //注意这里的EverydayLog.Write()是我自定义的日志文件，可以根据需要保留或删除            Debug.LogError(&quot;/GetAllFileOfFolder()/GetallfilesOfDir()/获取指定路径：&quot;+path+&quot;   下的文件失败！！！，错误信息=&quot;+ex.Message);        &#125;    &#125;    #endregion    &#125;</code></pre><h2 id="设备唯一标识"><a href="#设备唯一标识" class="headerlink" title="设备唯一标识"></a>设备唯一标识</h2><p>这里的设备唯一标识一开始笔者用的是设备的OAID，后来发现有些设备并不能获取到设别的OAID，并且换位的手机如果打开了”关闭广告追踪“，那么获取的OAID所以这个并不能作为设别的唯一标识，网上有很多进行多数据拼接的方法，于是笔者从自己公司的SDK摘取了或者设备唯一标识的方法，这是一个比较简单的方法，就是先获取设备的androidID，如果获取不到就会自己保存一个数据到文件里，然后每次从文件里读取就行了。  </p><pre><code>private static String deviceId;public String GetDeviceID() &#123;    Application yourApplicatoin = this;            //这里只是举个例子，这里需要大家获取一下自己的Application    if (yourApplicatoin.getApplicationContext() == null) //这里是获取Application的实例，如果没有就可以直接返回空        return &quot;&quot;;    else &#123;        String var1;        if ((var1 = deviceId) != null)            //先判断deviceID是否已经赋值过了，如果已经赋值就直接返回就行了            return var1;        else &#123;            deviceId = getSPValue(yourApplicatoin, &quot;DeviceId&quot;);    //如果没有就先从文件里获取一下            if (!TextUtils.isEmpty(deviceId)) &#123;                    //如果获取到了就直接返回                return deviceId;            &#125; else &#123;                deviceId = getAndroidIdAsDeviceId(yourApplicatoin);    //如果文件里没有就先尝试获取一下androidID作为设备唯一标识                if (!TextUtils.isEmpty(deviceId)) &#123;                    //获取到了就进行保存并返回这个标识                    saveSPValue(yourApplicatoin, &quot;DeviceId&quot;, deviceId);                        return deviceId;                &#125; else &#123;                    deviceId = generateSoftDeviceId();                //如果没有获取到就通过自己的混合加密方式进行缓存                    if (!TextUtils.isEmpty(deviceId)) &#123;                //如果不为空就保存然后返回标识                        saveSPValue(yourApplicatoin, &quot;DeviceId&quot;, deviceId);                        return deviceId;                    &#125; else &#123;                                        //如果都没获取到就是特殊情况，直接返回                        return deviceId;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="保存DeviceID到文件里"><a href="#保存DeviceID到文件里" class="headerlink" title="保存DeviceID到文件里"></a>保存DeviceID到文件里</h2><p>通过getSharedPreferences方法将deviceid保存到文件里。</p><pre><code>private static void saveSPValue(Context mycontext, String datakey, String datavalue) &#123;    mycontext.getSharedPreferences(&quot;myappsdkdeviceid&quot;, 0).edit().putString(&quot;datakey&quot;, datavalue).apply();&#125;</code></pre><p>myappsdkdeviceid是文件名字，datakey是保存的关键字名字，然后datavalue是储存的值，就是我们要储存的deviceid。  </p><h2 id="从文件里获取DeviceID"><a href="#从文件里获取DeviceID" class="headerlink" title="从文件里获取DeviceID"></a>从文件里获取DeviceID</h2><pre><code>private static String getSPValue(Context mycontext, String datakey) &#123;    return var0.getSharedPreferences(&quot;myappsdkdeviceid&quot;, 0).getString(datakey, (String)null);&#125;</code></pre><p>myappsdkdeviceid是文件名字，datakey是保存的关键字名字。 </p><h2 id="获取设备的AndroidID"><a href="#获取设备的AndroidID" class="headerlink" title="获取设备的AndroidID"></a>获取设备的AndroidID</h2><pre><code>private static String getAndroidIdAsDeviceId(Context mycontext) &#123;    String andid = Settings.Secure.getString(mycontext.getContentResolver(), &quot;android_id&quot;);    //获取设备的AndroidID    return isLegalAndroidId(andid) ? &quot;ANDROID_&quot; + andid : null;                //如果符合条件就添加前缀，不符合就返回空&#125;private static final Pattern ANDROID_ID_PATTERN = Pattern.compile(&quot;^[0-9a-fA-F]&#123;16&#125;$&quot;);private static boolean isLegalAndroidId(String andid) &#123;                                return !TextUtils.isEmpty(andid) &amp;&amp; ANDROID_ID_PATTERN.matcher(andid).find();&#125;</code></pre><p>第二个函数是判断获得到的android是否不为空并且符合正则表达式的规则  </p><h2 id="自定义的设备唯一标识"><a href="#自定义的设备唯一标识" class="headerlink" title="自定义的设备唯一标识"></a>自定义的设备唯一标识</h2><pre><code>private static long randomLong(long var0) &#123;    return Build.VERSION.SDK_INT &gt;= 21 ? ThreadLocalRandom.current().nextLong(var0) : (long)((new Random()).nextDouble() * (double)(var0 - 1L));&#125;private static String generateSoftDeviceId() &#123;    String arg0  = Build.SERIAL;            //首先获取序列号    if (TextUtils.isEmpty(arg0)) &#123;            //如果没有获取到序列化就赋值为&quot;NA&quot;        arg0 = &quot;NA&quot;;    &#125;    long arg1 = 2564562216496361285L;        //设置两个随机的long型的数据    long arg2 = 8545649582269949258L;    arg2 = randomLong(arg2);        //获取一个随机数，获取失败就调回去重新获取    arg1 += arg2;    String var8 = &quot;ANDROID_%1$s_%2$s&quot;;        //设置一下格式    Object[] arg3 = new Object[2];    arg3[0] = Long.toHexString(arg1);        //设置第一个参数    try &#123;        arg3[1] = arg0;                        //设置第二个参数        return String.format(var8, arg3);    &#125; catch (Throwable var3) &#123;    &#125;    Object[] arg4;                            //如果上述存在问题就根据时间设置一个随机数    Object[] arg5 = arg4 = new Object[2];    arg5[0] = &quot;NA&quot; + Long.toHexString(System.currentTimeMillis());    arg5[1] = arg0;    return String.format(&quot;ANDROID_%1$s_%2$s&quot;, arg4);&#125;</code></pre><h1 id="AWS-亚马逊-的CDN上传"><a href="#AWS-亚马逊-的CDN上传" class="headerlink" title="AWS(亚马逊)的CDN上传"></a>AWS(亚马逊)的CDN上传</h1><h2 id="网页上传"><a href="#网页上传" class="headerlink" title="网页上传"></a>网页上传</h2><p>这种上传方式就是访问网页，然后按照需求把自己需要上传的文件上传到对应网页的进行上传。  </p><h2 id="自动上传"><a href="#自动上传" class="headerlink" title="自动上传"></a>自动上传</h2><p>笔者采用的是利用python环境然后写的bat脚本进行上传。  </p><h2 id="Python环境配置"><a href="#Python环境配置" class="headerlink" title="Python环境配置"></a>Python环境配置</h2><p>首先需要在Python虚拟环境中安装 AWS CLI  </p><pre><code>$ pip install awscli</code></pre><p>这里介绍一个python比较好的版本管理工具，可以管理本地多版本的python。<a href="https://www.jianshu.com/p/d66fce9a7bdc"><font color=steelblue size=3>pyenv</font></a>   </p><h2 id="aws版本查看"><a href="#aws版本查看" class="headerlink" title="aws版本查看"></a>aws版本查看</h2><pre><code>$ aws --version</code></pre><p><img src="https://file.liangxiegame.com/12c0d1cf-5a76-4322-bbb6-55654310b33d.png" alt="image.png">   </p><h2 id="更新aws"><a href="#更新aws" class="headerlink" title="更新aws"></a>更新aws</h2><pre><code>$ aws install awscli --upgrade</code></pre><h2 id="卸载aws"><a href="#卸载aws" class="headerlink" title="卸载aws"></a>卸载aws</h2><pre><code>$ pip uninstall awscli  </code></pre><h2 id="配置AWS-CLI"><a href="#配置AWS-CLI" class="headerlink" title="配置AWS CLI"></a>配置AWS CLI</h2><pre><code>$ aws configureAWS Access Key ID [None]: *******AWS Secret Access Key [None]: *******Default region name [None]: us-east-2Default output format [None]: json</code></pre><p>这里分辨需要填上对应的参数，上面的ID和Key就是自己页面申请aws给提供的。下面的json也只输出的格式，这里最关键的其实是<strong>Default region name</strong>，这里并不是随便填的，而是填上aws终端节点对应的区域代码。  </p><p><img src="https://file.liangxiegame.com/63176da0-0361-49ed-8413-00163af95287.png" alt="image.png">   </p><p>这里其实会再打开终端的目录生成一个.aws文件夹，里面会有config和credentials两个文件就是我们的配置文件了。  </p><h2 id="aws与s3配合使用"><a href="#aws与s3配合使用" class="headerlink" title="aws与s3配合使用"></a>aws与s3配合使用</h2><p>想要使用aws cli上传文件需要与s3配合使用。  </p><h3 id="列举自己的库"><a href="#列举自己的库" class="headerlink" title="列举自己的库"></a>列举自己的库</h3><pre><code>$ aws s3 ls  </code></pre><h3 id="列举库中文件夹内容"><a href="#列举库中文件夹内容" class="headerlink" title="列举库中文件夹内容"></a>列举库中文件夹内容</h3><pre><code>$ aws s3 ls s3://my-bucket  </code></pre><h3 id="上传文件到s3的库"><a href="#上传文件到s3的库" class="headerlink" title="上传文件到s3的库"></a>上传文件到s3的库</h3><pre><code>$aws s3 cp my-file s3://my-bucket/my-folder</code></pre><p>如果每次都使用上面的命令传输文件还是比较麻烦的，所以笔者自己写了一个简单的bat脚本，可以更方便的上传文件  </p><pre><code>@echo offset filePath=..\resource\cdnfileroot\resource\packres\default-pack\android-defaultset cdnPath=s3://cyber-era-cdn/resource/packres/default-pack/android-defaultcall cd %filePath%for %%i in (*.zip) do (    call aws s3 cp %%i %cdnPath%/%%i    echo %%i)pause</code></pre><h1 id="海外文本替换"><a href="#海外文本替换" class="headerlink" title="海外文本替换"></a>海外文本替换</h1><h2 id="提取Prefab中文字到表里"><a href="#提取Prefab中文字到表里" class="headerlink" title="提取Prefab中文字到表里"></a>提取Prefab中文字到表里</h2><p>这里是把prefab上的文字全部提取到一个自定定义的Language表里。首先需要读取自定义的Language表里的数据，这是为了去重用的。然后加载本地所有的prefab，再遍历prefab所有的节点，然后判断是否包含Text的组件，如果包含文字就把文字记录在自己的字典中。在放进字典中是需要排重的。<br>加载Prefab的代码  </p><pre><code>private static void doLoadPrefab(bool clearText,bool onlyFindText = false)        //两个参数分别是是否清除Text组件和是否之查找文本，下面会有详细介绍&#123;    ...    if (string.IsNullOrEmpty(ExportExcel.excelFolder))        //接下来是查找自己的需要导入的表，不存在就创建一个新的表    &#123;        excelPath = EditorUtility.OpenFilePanel(&quot;选择SVN中的ProgramLanguage表&quot;,&quot;&quot;,&quot;&quot;);    &#125;    else    &#123;        excelPath = ExportExcel.excelFolder + &quot;/ProgramLanguage.xlsx&quot;;    &#125;    if (!string.IsNullOrEmpty(excelPath))    &#123;        ReadExcel();                                        //进行读取加载表格        LoadAllPrefabText(clearText,onlyFindText);            //进行加载所有prefab的文本内容        if (clearText)                                        //如果是清除文本组件的就只是需要清除字典        &#123;            textDesAddDic.Clear();        &#125;        else                                                //如果不是清除的就把读取内容写入到表格中        &#123;            WroadExcel();        &#125;    &#125;&#125;</code></pre><p>读取Language代码如下:  </p><pre><code>private static int exKey;private static string exValue;public static void ReadExcel()&#123;    var attrArr = File.GetAttributes(excelPath);            //这个是获取表格的属性，因为有些表格可能是只读属性，需要修改    File.SetAttributes(excelPath, FileAttributes.Normal);    //把表格的属性设置成普通属性，这样就一定能写入了，之所以不是去掉只读属性是因为只是单独修改可读属性不知道为何还是不能写入，就先设置为普通的属性了    textDesDic.Clear();                                        //清空自己的字典    excelFile = new FileInfo(excelPath);                    //接着就是获取表格文件    using (ExcelPackage excelPackage = new ExcelPackage(excelFile))        //下面就是循环读取表格内容然后写入到字典中    &#123;        var worksheet = excelPackage.Workbook.Worksheets[1];        for (int i = startRow; i &lt;= worksheet.Dimension.End.Row; i++)        &#123;            exKey = worksheet.Cells[i, keyColumn].GetValue&lt;int&gt;();            exValue = worksheet.Cells[i, valueVolumn].GetValue&lt;string&gt;();            startTextIndex = Mathf.Max(exKey, startTextIndex);            textDesDic.Add(exKey, exValue);        &#125;    &#125;    textDesAddDic.Clear();                                    //接着就是把第二个增加的字典清空，是为了记录新增的文字    File.SetAttributes(excelPath, attrArr);                    //然后就是把文件属性设置为原来的属性&#125;</code></pre><p>写入Language和读取类似，只是把原来的遍历读取变成遍历新增字典，然后一行一行写入。代码如下:  </p><pre><code>public static void WroadExcel()&#123;    var attrArr = File.GetAttributes(excelPath);    File.SetAttributes(excelPath, FileAttributes.Normal);    excelFile = new FileInfo(excelPath);    using (ExcelPackage excelPackage = new ExcelPackage(excelFile))    &#123;        var worksheet = excelPackage.Workbook.Worksheets[1];        var curRow = worksheet.Dimension.End.Row;        foreach (var textdespair in textDesAddDic)        &#123;            worksheet.Cells[++curRow, keyColumn].Value = textdespair.Key;            worksheet.Cells[curRow, valueVolumn].Value = textdespair.Value;        &#125;                excelPackage.Save();                                //保存表    &#125;        File.SetAttributes(excelPath, attrArr);        textDesAddDic.Clear();&#125;</code></pre><p>加载prefab中的Text文本，代码如下:  </p><pre><code>static StringBuilder newTexts = new StringBuilder();public static void LoadAllPrefabText(bool isClearText,bool onlyFindTxt = false)&#123;    newTexts.Clear();                            //清空字符串    textDesAddDic.Clear();                        //清空新增的字典    var sdirs =GetAllPrefabFiles();                //获取Prefab的存在文件夹    EditorUtility.DisplayProgressBar(&quot;Progress&quot;, &quot;LoadPrefabTxtDes...&quot;, 0);        //打开一个进度掉，为了方便查看加载进度使用    var asstIds = AssetDatabase.FindAssets(&quot;t:Prefab&quot;, sdirs);                    //得到所有Prefab的资源    int count = 0;                                //初始化加载的进度    for (int i = 0; i &lt; asstIds.Length; i++)    //循环遍历一下自己加载出来的prefab    &#123;        string path = AssetDatabase.GUIDToAssetPath(asstIds[i]);            //得到prefab资源的路径        //Debug.LogError(&quot;try deal with path &quot;+path);                                var pfb = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(path);            //根据路径加载对应的prefab        var texts = pfb.GetComponentsInChildren&lt;Text&gt;(true);                //得到prefab上所有节点的Text组件        if (texts == null || texts.Length &lt;= 0)                                //如果不存在就跳过，遍历到下一个prefab        &#123;            //Debug.LogError(&quot;asset no texts: &quot;+path);            continue;        &#125;        foreach (var item in texts)                                            //遍历prefab中的Text组件        &#123;            textDes = item.text;                                            //获取组件上的文字            if (textDes.IsNullOrWhitespace())                                //如果文字为空就跳过到下一个                continue;                        var langTextComp = item.gameObject.GetComponent&lt;MutiLangText&gt;();//获取Text文本上的脚本，自己写的替换文本的脚本            if (langTextComp &amp;&amp; onlyFindTxt)                                //如果存在脚本并且只是查找文本，说明已经添加过就可以直接跳过了            &#123;                continue;                //Debug.LogError(&quot;has Added MutiText: &quot;+item.name);            &#125;            bool addComP = false;                                            //标记是否增加组件为false            if (isClearText)                                                //判断是否需要清除自己的替换语言脚本            &#123;                if (!textDesDic.ContainsValue(textDes))                        //判断表里是否已经存在文本                &#123;                    item.text = &quot;&quot;;                                            //如果不存在就先清除文字                    if (langTextComp)                                        //如果不存在自己的脚本就一并删除                    &#123;                        //TODO  remove  comp                        DestroyImmediate(langTextComp);                    &#125;                &#125;                else                                                        //如果表里存在就从字典里获取到表里的ID                &#123;                    curDesId = textDesDic.Where(q =&gt; q.Value == textDes).Select(q =&gt; q.Key).ToArray()[0];                    addComP = true;                                            //标记需要增加组件                &#125;            &#125;            else                                                            //如果不是清除文本            &#123;                if (onlyFindTxt)                                            //如果只是查找文本                &#123;                    if (!textDesDic.ContainsValue(textDes))                    //如果字典中不存在就记录下来                    &#123;                        newTexts.AppendLine(textDes);                    &#125;                    continue;                &#125;                if (!textDesDic.ContainsValue(textDes))                        //如果字典中不存在，就往字典中添加，并且在新增字典中增加                &#123;                    textDesDic.Add(++startTextIndex, textDes);                    textDesAddDic.Add(startTextIndex,textDes);                    curDesId = startTextIndex;                &#125;                else                                                        //如果存在就记录下来文本对应的ID                &#123;                    curDesId = textDesDic.Where(q =&gt; q.Value == textDes).Select(q =&gt; q.Key).ToArray()[0];                &#125;                                if(!langTextComp)                                            //如果并没有增加切换语言脚本就标记需要增加脚本                &#123;                    addComP = true;                &#125;            &#125;            if (addComP &amp;&amp; !langTextComp)                                    //如果需要增加并且组件不存在，就增加一下自己的脚本                    &#123;                langTextComp = item.gameObject.AddComponent&lt;MutiLangText&gt;();                langTextComp.baseText = item;            &#125;                        if (langTextComp)                                                //如果存在组件就更新一下ID                langTextComp.languageID = curDesId;        &#125;        PrefabUtility.SavePrefabAsset(pfb, out bool success);                //修改完毕保存prefab就可以了        if (success)                                                        //记录加载进度，然后更新进度条        &#123;            count++;        &#125;        EditorUtility.DisplayProgressBar(&quot;LoadPrefabTxtDes Progress&quot;, pfb.name, count / (float)asstIds.Length);    &#125;    if (newTexts.Length &gt; 0)                                                //如果有新增的文字就记录下来    &#123;        Debug.LogError(&quot;write new text: &quot;+newTexts.Length);        File.WriteAllText(ExportExcel.excelFolder + &quot;/newText.txt&quot;,newTexts.ToString());    &#125;    EditorUtility.ClearProgressBar();                                        //结束之后清除加载进度条&#125;</code></pre><p>获取Prefab文件路径的代码：  </p><pre><code>private static string[] GetAllPrefabFiles()&#123;    string sdir = &quot;Assets/XXX/XXX&quot;;    List&lt;string&gt; sdirlist = new List&lt;string&gt;();    sdirlist.Add(sdir);    sdirlist.Add(&quot;Assets/Resources/RootPrefab&quot;);       return sdirlist.ToArray();    &#125;</code></pre><h2 id="查找代码中的中文"><a href="#查找代码中的中文" class="headerlink" title="查找代码中的中文"></a>查找代码中的中文</h2><p>因为一开始没有考虑到会做海外，并且写的代码不规范，所以存在一部分中文是在代码里。这部分中文代码是不好查找的，所以写了一个小脚本，可以快速标记到中文代码的位置，这个脚本可以解决大部分，但是仍旧是存在找不到的问题的。下面来看代码:  </p><p>首先会打开一个面板用来选择代码脚本所在的文件路径</p><pre><code>[MenuItem(&quot;Tools/ReplaceText/FindScriptsLanguage&quot;)]public static void Pack()&#123;    Rect wr = new Rect(300, 400, 400, 100);    FindChineseWindow window = (FindChineseWindow)EditorWindow.GetWindowWithRect(typeof(FindChineseWindow), wr, true, &quot;查找项目中的中文字符&quot;);    window.Show();&#125;public class FindChineseWindow : EditorWindow&#123;    private ArrayList csList = new ArrayList();    private int eachFrameFind = 4;    private int currentIndex = 0;    private bool isBeginUpdate = false;    private string outputText;    public string filePath = &quot;/Scripts&quot;;    private string strForShader = &quot;&quot;;    //这个是需要忽略检测的文件夹    private List&lt;string&gt; ingoreFileInfoDirNameList = new List&lt;string&gt; &#123;&quot;GMConsole&quot;, &quot;LogicWorld&quot;, &quot;NetWork&quot;, &quot;SDK&quot;&#125;;    //这个是需要忽略的代码文件名    private List&lt;string&gt; ingoreFileInfoNameList = new List&lt;string&gt; &#123;&quot;LocalLanguage&quot;&#125;;    //这个是需要忽略的代码包含的字符串    private List&lt;string&gt; ingoreScriptesDesList = new List&lt;string&gt; &#123;&quot;Debug&quot;, &quot;LogWrapper&quot;, &quot;Tooltip&quot;, &quot;throw new&quot;&#125;;    //获取需要检测的文件    private void GetAllFile(DirectoryInfo dir)    &#123;        FileInfo[] allFile = dir.GetFiles();        foreach (FileInfo fi in allFile)        &#123;            if (ingoreFileInfoDirNameList.Where(str =&gt; fi.DirectoryName.Contains(str)).Count() &gt; 0)                 continue;            if (ingoreFileInfoNameList.Where(str =&gt; fi.Name.Contains(str)).Count() &gt; 0)                 continue;            if (fi.FullName.IndexOf(&quot;.meta&quot;) == -1 &amp;&amp; fi.FullName.IndexOf(&quot;.cs&quot;) != -1)            &#123;                csList.Add(fi.DirectoryName + &quot;/&quot; + fi.Name);            &#125;        &#125;        DirectoryInfo[] allDir = dir.GetDirectories();        foreach (DirectoryInfo d in allDir)        //遍历子文件夹        &#123;            GetAllFile(d);        &#125;    &#125;    public void OnGUI()            //面板显示的代码    &#123;        filePath = EditorGUILayout.TextField(&quot;路径：&quot;, filePath);        //输入路径        EditorGUILayout.Space();        EditorGUILayout.Space();        if (GUILayout.Button(&quot;开始遍历目录&quot;))                                //显示的按钮        &#123;            csList.Clear();            DirectoryInfo d = new DirectoryInfo(Application.dataPath + filePath);    //从绝对路径读取文件            GetAllFile(d);                                                //获取所有的文件            //GetAllFile(d);            outputText = &quot;游戏内代码文件的数量：&quot; + csList.Count;            isBeginUpdate = true;            outputText = &quot;开始遍历项目&quot;;        &#125;        GUILayout.Label(outputText, EditorStyles.boldLabel);    &#125;    private bool HasChinese(string str)                //这是个判断是否是中文的方法    &#123;        return Regex.IsMatch(str, @&quot;[\u4e00-\u9fa5]&quot;);    &#125;    private Regex regex = new Regex(&quot;\&quot;[^\&quot;]*\&quot;&quot;);    private void printChinese(string path)            //开始输出中文文字所在位置    &#123;        if (File.Exists(path))        &#123;            string[] fileContents = File.ReadAllLines(path, Encoding.Default);            int count = fileContents.Length;            for (int i = 0; i &lt; count; i++)            &#123;                string printStr = fileContents[i].Trim();                if (printStr.IndexOf(&quot;//&quot;) == 0) //说明是注释                    continue;                if (ingoreScriptesDesList.Where(str =&gt; printStr.Contains(str)).Count() &gt; 0) //说明是需要排除的代码                    continue;                MatchCollection matches = regex.Matches(printStr);                foreach (Match match in matches)                &#123;                    if (HasChinese(match.Value))                    &#123;                        string[] fullPath = path.Split(&#39;/&#39;);                        path = fullPath[fullPath.Length - 1];                        Debug.Log(&quot;路径:&quot; + path + &quot; 行数:&quot; + i + &quot; 内容:&quot; + printStr);                        break;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;打包&quot;&gt;&lt;a href=&quot;#打包&quot; class=&quot;headerlink&quot; title=&quot;打包&quot;&gt;&lt;/a&gt;打包&lt;/h1&gt;&lt;h2 id=&quot;Gradle版本问题&quot;&gt;&lt;a href=&quot;#Gradle版本问题&quot; class=&quot;headerlink&quot; title=&quot;Gradl</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="海外Google" scheme="http://yoursite.com/tags/%E6%B5%B7%E5%A4%96Google/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——基于UGUI实现性能更好的圆形Image</title>
    <link href="http://yoursite.com/2021/04/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EUGUI%E5%AE%9E%E7%8E%B0%E6%80%A7%E8%83%BD%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%9C%86%E5%BD%A2Image/"/>
    <id>http://yoursite.com/2021/04/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EUGUI%E5%AE%9E%E7%8E%B0%E6%80%A7%E8%83%BD%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%9C%86%E5%BD%A2Image/</id>
    <published>2021-04-30T03:00:36.000Z</published>
    <updated>2021-12-27T03:39:09.483Z</updated>
    
    <content type="html"><![CDATA[<p>参考博客地址：<a href="https://www.cnblogs.com/leoin2012/p/6425089.html">https://www.cnblogs.com/leoin2012/p/6425089.html</a>  </p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在我们开发游戏过程中，会经常使用Mask来进行图片的裁剪，但是笔者在使用Mask进行裁剪的时候发现锯齿特别严重，因此笔者选择了利用shader进行图形遮罩，详情请看<a href="https://lianbai.github.io/2021/04/20/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UGUI%E5%9F%BA%E4%BA%8E%E5%9B%BE%E9%9B%86%E7%9A%84shader%E9%81%AE%E7%BD%A9/">Unity杂文——UGUI基于图集的shader遮罩</a>。<br>笔者虽然已经利用shader做好了遮罩并应用项目中的，但是在笔者在学习UGUI优化的时候发现Mask不仅有锯齿，也会增加两个DrawCall，因为Mask会把自己和子节点都和外面分开，不会进行合批，这样mask越多，DrawCall就会比较严重，笔者利用Shader进行遮罩虽然也会多一个DrawCall，但是相同的材质会进行合批，<br>裁剪随然已经改好了，但是笔者发现了不会增加DrawCall的方法。  </p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>我们在屏幕上看到的图形是GPU渲染出来的，而GPU渲染的最小单位是三角面片，我们从Unity的Scence场景中，切换视图方式为WireFrame或者Shader Wireframe都可以明显看到图片是三角形组成的，而我们要制作出圆形的Image可以利用多个等腰三角形，这样就可以拼接成看似圆形的Image，三角形数量越多就越像圆形。如下图：  </p><p><img src="https://file.liangxiegame.com/fc913a59-b938-4129-8c69-fc299a3ba79b.png" alt="image.png">   </p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>首先我们需要自己重写Image，我们要自己实现画图，我们首先查看Image的原码：  </p><pre><code>public class Image : MaskableGraphic, ISerializationCallbackReceiver, ILayoutElement, ICanvasRaycastFilter</code></pre><p>我们可以看到Image继承了MaskableGraphic，并且实现了ISerializationCallbackReceiver、ILayoutElement、ICanvasRaycastFilter的接口。最关键的其实是MaskableGraphic类，因为这个类主要是负责画图的，我们可以很简单的看到MaskableGraphic类其实继承了Graphic类，在这个类里面有个OnPopulateMesh函数，这个函数就是我们需要重写的函数。<br>当UI元素生成顶点数据时就会调用OnPopulateMesh函数，我们只需要继承这个函数并且将原来的顶带你数据清除，改写成我们自己设置的圆形的顶带你数据，这样我们就可以画我们需要的圆形了。<br>由于在Unity中，继承UnityEngine基类的派生类并不能在Inspector面板里显示参数，笔者在制作圆形的Image的时候肯定要设置一些可调节的参数，这样可以应用到更多的场景中，因为笔者就像参考博客一样新建一个BaseImage类去继承Image类，然后自己再写一个CircleImage类去继承BaseImage类，这样我们把可调节的变量放在CircleImage类中，这样就可以通过面板调节参数了。<font color=red>(原Image源码有近千行代码，BaseImage对其进行了部分精简，只支持Simple Image Type，并去掉了eventAlphaThreshold的相关代码。经过删减，得到一个百行代码的BaseImage类，精简版Image就完成了。)</font>  </p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>完整代码在最后面，因为内容过多，笔者就先写代码分析，您可以先复制最后的完整代码到工程里，然后自己对着代码一步一步进行。  </p><h3 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h3><p>笔者首先介绍一下笔者设置的允许调节的参数，参数描述都在代码中，代码如下：  </p><pre><code>[Tooltip(&quot;圆形的半径&quot;)][Range(0, 1)]public float fillRadius = 1f;[Tooltip(&quot;UV缩放比例&quot;)][Range(0, 1)]public float UVScale = 1f;[Tooltip(&quot;圆形的中心点&quot;)]public Vector2 fillCenter = new Vector2(0.5f, 0.5f);[Tooltip(&quot;圆形或扇形填充比例&quot;)][Range(0, 1)]public float fillPercent = 1f;[Tooltip(&quot;是否填充圆形&quot;)]public bool fill = true;[Tooltip(&quot;圆环宽度&quot;)]public float thickness = 5;[Tooltip(&quot;圆形&quot;)][Range(3, 100)]public int segements = 20;        //填充三角形数量</code></pre><p>在OnPopulateMesh函数中，函数的参数VertexHelper就是原来图片的顶带你信息，因为我们要重写这些顶点信息，所以我们要清空vh。在我们设置自己的顶点的信息之前，我们需要获得UV信息，获取方法就是DataUtility.GetOuterUV(overrideSprite)。  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    Vector4 uv = overrideSprite != null ? DataUtility.GetOuterUV(overrideSprite) : Vector4.zero;    float uvCenterX = (uv.x + uv.z) * (0.5f + (fillCenter.x - 0.5f) * (uv.z - uv.x));    float uvCenterY = (uv.y + uv.w) * (0.5f + (fillCenter.y - 0.5f) * (uv.w - uv.y));    float uvScaleX = (uv.z - uv.x) / tw  * fillRadius * UVScale;    float uvScaleY = (uv.w - uv.y) / th  * fillRadius * UVScale;    ...&#125;</code></pre><p>在设置的属性中我们有一个变量segements就是我们需要的三角形数量，正如原理将的，三角形数量越多，越像圆形，但是顶点数据就越多，影响性能，所以我们设置这个参数可以根据需求设置数量，然后我们知道数量后就可以算出顶点的夹角，然后面片数segements与填充比例fillPercent相乘，就知道要用多少个面片来显示圆形/扇形  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    //算出每个面片的顶点夹角，面片数segements与填充比例fillPercent相乘，就知道要用多少个面片来显示圆形/扇形    float degreeDelta = (float)(2 * Mathf.PI / segements);    int curSegements = (int)(segements * fillPercent);    ...&#125;</code></pre><p>我们可以通过RectTransform获取原图矩形的宽高，笔者这里也添加了一个可以调整的参数圆形半径个圆环宽度，圆环宽度是用来做圆环形状显示的，圆形半径其实就是原图的宽高乘以圆的半径就行了，这里圆的半径其实是一个比例，把原图的比作为1。  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    //通过RectTransform获取矩形宽高，计算出半径    float tw = rectTransform.rect.width * fillRadius;    float th = rectTransform.rect.height * fillRadius;    float outerRadius = rectTransform.pivot.x * tw;    float innerRadius = rectTransform.pivot.x * tw - thickness;    ...&#125;</code></pre><p>已经有了半径，夹角信息，根据圆形点坐标公式(radius * cosA,radius * sinA)可以算出顶点坐标，每次迭代新建UIVertex，将求出的坐标，color，uv等参数传入，再将UIVertex传给VertexHelper。重复迭代n次，VertexHelper就获得了多边形顶点及圆心点信息了。  这里笔者也设置了参数，UV的缩放和圆的中心点，也是为了适应更多的场景</p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    float uvCenterX = (uv.x + uv.z) * (0.5f + (fillCenter.x - 0.5f) * (uv.z - uv.x));    float uvCenterY = (uv.y + uv.w) * (0.5f + (fillCenter.y - 0.5f) * (uv.w - uv.y));    float uvScaleX = (uv.z - uv.x) / tw  * fillRadius * UVScale;    float uvScaleY = (uv.w - uv.y) / th  * fillRadius * UVScale;    float curDegree = 0;    UIVertex uiVertex;    int verticeCount;    int triangleCount;    Vector2 curVertice;    curVertice = Vector2.zero;    verticeCount = curSegements + 1;    uiVertex = new UIVertex();    uiVertex.color = color;    uiVertex.position = curVertice;    uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);    vh.AddVert(uiVertex);    for (int i = 1; i &lt; verticeCount; i++)    &#123;        float cosA = Mathf.Cos(curDegree);        float sinA = Mathf.Sin(curDegree);        curVertice = new Vector2(cosA * outerRadius, sinA * outerRadius);        curDegree += degreeDelta;        uiVertex = new UIVertex();        uiVertex.color = color;        uiVertex.position = curVertice;        uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);        vh.AddVert(uiVertex);        outterVertices.Add(curVertice);    &#125;    ...&#125;</code></pre><p>虽然已经传入了所有的顶带你信息，但是GPU还不知道顶点信息之间的关系，不知道顶带你分成了多少个三角形片面，所以还需要把三角形的信息告诉GPU,这里有一个VertexHelper的接口就是**AddTriangle(int idx0, int idx1, int idx2)**来接受三角形信息。<br>接口的传入参数并不是UIVertex类型，而是int类型的索引值。哪来的索引？还记得之前往VertexHelper传入了一堆顶点吗？按照传入顺序，第一个顶点，索引记为0，依次类推。每次传入三个顶点的索引，就记录下了一个三角形。  </p><blockquote><p>需要注意，GPU 默认是做backface culling(背面剔除)的，GPU只渲染正对屏幕的三角面片，当GPU认为某个三角面片是背对屏幕时，直接丢弃该三角面片，不做渲染。那么GPU怎么判断我们传入的某个三角形是正对屏幕，还是背对屏幕？答案是通过三个顶点的时针顺序，当三个顶点是呈顺时针时，判定为正对屏幕；呈逆时针时，判定为背对屏幕。</p></blockquote><p><img src="https://file.liangxiegame.com/f83adeb0-049d-413a-b538-e8a2cab10a6c.png" alt="image.png"></p><p>VertexHelper收到的第一个顶点是圆心，且算法是按逆时针方向，迭代计算出的多边形顶点，并依次传给VertexHelper。因此按(i, 0, i+1)(i&gt;=1)的规律取索引，就可以保证顶点顺序是顺时针的。  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    triangleCount = curSegements*3;    for (int i = 0, vIdx = 1; i &lt; triangleCount - 3; i += 3, vIdx++)    &#123;        vh.AddTriangle(vIdx, 0, vIdx+1);    &#125;    if (fillPercent == 1)    &#123;        //首尾顶点相连        vh.AddTriangle(verticeCount - 1, 0, 1);    &#125;    ...&#125;</code></pre><p>到此我们的圆形算是绘制完成了，但是观测我们的变量可以看出，笔者还支持了圆环的绘制  </p><h3 id="圆环"><a href="#圆环" class="headerlink" title="圆环"></a>圆环</h3><p>圆环的情况稍微复杂：顶点集没有圆心顶点了，只有内环、外环顶点；三角形集也不是简单的切饼式分割，采用一种比较直观的三角形划分，让内外环相邻的顶点类似一根鞋带那样互相连接，来划分三角形。  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    float uvCenterX = (uv.x + uv.z) * (0.5f + (fillCenter.x - 0.5f) * (uv.z - uv.x));    float uvCenterY = (uv.y + uv.w) * (0.5f + (fillCenter.y - 0.5f) * (uv.w - uv.y));    float uvScaleX = (uv.z - uv.x) / tw  * fillRadius * UVScale;    float uvScaleY = (uv.w - uv.y) / th  * fillRadius * UVScale;    float curDegree = 0;    UIVertex uiVertex;    int verticeCount;    int triangleCount;    Vector2 curVertice;    curVertice = Vector2.zero;    verticeCount = curSegements + 1;    uiVertex = new UIVertex();    uiVertex.color = color;    uiVertex.position = curVertice;    uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);    vh.AddVert(uiVertex);     verticeCount = curSegements*2;    for (int i = 0; i &lt; verticeCount; i += 2)    &#123;        float cosA = Mathf.Cos(curDegree);        float sinA = Mathf.Sin(curDegree);        curDegree += degreeDelta;        curVertice = new Vector3(cosA * innerRadius, sinA * innerRadius);        uiVertex = new UIVertex();        uiVertex.color = color;        uiVertex.position = curVertice;        uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);        vh.AddVert(uiVertex);        innerVertices.Add(curVertice);        curVertice = new Vector3(cosA * outerRadius, sinA * outerRadius);        uiVertex = new UIVertex();        uiVertex.color = color;        uiVertex.position = curVertice;        uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);        vh.AddVert(uiVertex);        outterVertices.Add(curVertice);    &#125;    ...&#125;</code></pre><h3 id="点击判断"><a href="#点击判断" class="headerlink" title="点击判断"></a>点击判断</h3><p>传统的UGUI的Image的点击判断是只要在矩形内点击，不管是不是透明，都认定为点击到了，笔者从网上学习了一套更好的判断点击的方法，利用的是<strong>Ray-Crossing算法</strong>。Ray-Crossing算法大概思路是从指定点p发出一条射线，与多边形相交，假若交点个数是奇数，说明点p落在多边形内，交点个数为偶数说明点p在多边形外。<br>射线选取哪个方向并没有限制，但为了实现起来方便，考虑屏幕点击点为点p，向水平方向右侧发出射线的情况，那么顶点v1,v2组成的线段与射线若有交点q，则点q必定满足两个条件：</p><blockquote><p>v2.y &lt; q.y = p.y &gt; v1.y<br>p.x &lt; q.x  </p></blockquote><p>我们根据这两个条件，逐一跟多边形线段求交点，并统计交点个数，最后判断奇偶即可得知点击点是否在圆形内。  </p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    public override bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)    &#123;        Sprite sprite = overrideSprite;        if (sprite == null)            return true;        Vector2 local;        RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, screenPoint, eventCamera, out local);        return Contains(local, outterVertices, innerVertices);    &#125;        private bool Contains(Vector2 p, List&lt;Vector3&gt; outterVertices, List&lt;Vector3&gt; innerVertices)    &#123;        var crossNumber = 0;        if(!fill)            RayCrossing(p, innerVertices, ref crossNumber);//检测内环        RayCrossing(p, outterVertices, ref crossNumber);//检测外环        return (crossNumber &amp; 1) == 1;    &#125;        /// &lt;summary&gt;    /// 使用RayCrossing算法判断点击点是否在封闭多边形里    /// &lt;/summary&gt;    /// &lt;param name=&quot;p&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;vertices&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;crossNumber&quot;&gt;&lt;/param&gt;    private void RayCrossing(Vector2 p, List&lt;Vector3&gt; vertices, ref int crossNumber)    &#123;        for (int i = 0, count = vertices.Count; i &lt; count; i++)        &#123;            var v1 = vertices[i];            var v2 = vertices[(i + 1) % count];            //点击点水平线必须与两顶点线段相交            if (((v1.y &lt;= p.y) &amp;&amp; (v2.y &gt; p.y))                || ((v1.y &gt; p.y) &amp;&amp; (v2.y &lt;= p.y)))            &#123;                //只考虑点击点右侧方向，点击点水平线与线段相交，且交点x &gt; 点击点x，则crossNumber+1                if (p.x &lt; v1.x + (p.y - v1.y) / (v2.y - v1.y) * (v2.x - v1.x))                &#123;                    crossNumber += 1;                &#125;            &#125;        &#125;    &#125;    ...&#125;</code></pre><p>###SetNativeSize<br>SetNativeSize的实现比较简单，只要把宽高设置图片的高度就行了。</p><pre><code>protected override void OnPopulateMesh(VertexHelper vh)&#123;    ...    public override void SetNativeSize()    &#123;        if (activeSprite != null)        &#123;            float w = activeSprite.rect.width / pixelsPerUnit;            float h = activeSprite.rect.height / pixelsPerUnit;            rectTransform.anchorMax = rectTransform.anchorMin;            rectTransform.sizeDelta = new Vector2(w, h);            SetAllDirty();        &#125;    &#125;    ...&#125;</code></pre><p>在这里笔者遇到了一个问题，就是我们怎么能像Image那样调用这个方法呢，笔者参考了Image的原码，Imnage是有一个专门的Editor脚本设置面板显示的，于是笔者就写了一个CircleImageEditor的脚本来控制。只需要脚本继承GraphicEditor，然后通过[CustomEditor(typeof(CircleImage))]标签就可以实现脚本的控制了。  </p><pre><code>[CustomEditor(typeof(CircleImage))]public class CircleImageEditor : GraphicEditor&#123;    public override void OnInspectorGUI() &#123;        DrawDefaultInspector();                CircleImage myScript = (CircleImage)target;        EditorGUILayout.BeginHorizontal();        &#123;            GUILayout.Space(EditorGUIUtility.labelWidth);            if (GUILayout.Button(&quot;Set Native Size&quot;, EditorStyles.miniButtonRight))            &#123;                myScript.SetNativeSize();            &#125;        &#125;        EditorGUILayout.EndHorizontal();    &#125;&#125;</code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>笔者在制作BaseImage的时候并没有继承MaskableGraphic而是自己复制了一份到BaseMaskableGraphic类中，这是因为笔者不喜欢脚本在Inspector面面板中显示m_OnCullStateChanged这个事件，因此笔者复制了一份，只是把这个变量变成了私有，就不在面板显示，如果不介意面板的了可以继续继承MaskableGraphic。</p><h3 id="BaseImage"><a href="#BaseImage" class="headerlink" title="BaseImage"></a>BaseImage</h3><pre><code>public class BaseImage : BaseMaskableGraphic,ISerializationCallbackReceiver, ILayoutElement, ICanvasRaycastFilter&#123;    [FormerlySerializedAs(&quot;m_Frame&quot;)]    [SerializeField]    private Sprite m_Sprite;        //私有的sorite，内部调用，防止外部修改    //对外公开的sprite属性    public Sprite sprite    &#123;        get &#123; return m_Sprite; &#125;        set&#123;if (SetPropertyUtilityExt.SetClass(ref m_Sprite, value)) SetAllDirty();&#125;    &#125;    [NonSerialized]    private Sprite m_OverrideSprite;        protected BaseImage()    &#123;        useLegacyMeshGeneration = false;    &#125;    public Sprite overrideSprite    &#123;        get &#123; return m_OverrideSprite == null ? sprite : m_OverrideSprite; &#125;        set        &#123;            if (SetPropertyUtilityExt.SetClass(ref m_OverrideSprite, value)) SetAllDirty();        &#125;    &#125;    /// &lt;summary&gt;    /// Image&#39;s texture comes from the UnityEngine.Image.    /// &lt;/summary&gt;    public override Texture mainTexture    &#123;        get        &#123;            return overrideSprite == null ? s_WhiteTexture : overrideSprite.texture;        &#125;    &#125;    public Sprite activeSprite &#123; get &#123; return overrideSprite != null ? overrideSprite : sprite; &#125; &#125;            public float pixelsPerUnit    &#123;        get        &#123;            float spritePixelsPerUnit = 100;            if (sprite)                spritePixelsPerUnit = sprite.pixelsPerUnit;            float referencePixelsPerUnit = 100;            if (canvas)                referencePixelsPerUnit = canvas.referencePixelsPerUnit;            return spritePixelsPerUnit / referencePixelsPerUnit;        &#125;    &#125;            /// &lt;summary&gt;    /// 子类需要重写该方法来自定义Image形状    /// &lt;/summary&gt;    /// &lt;param name=&quot;vh&quot;&gt;&lt;/param&gt;    protected override void OnPopulateMesh(VertexHelper vh)    &#123;        base.OnPopulateMesh(vh);    &#125;    #region ISerializationCallbackReceiver        public void OnBeforeSerialize()    &#123;    &#125;    public void OnAfterDeserialize()    &#123;    &#125;        #endregion    #region ILayoutElement    public virtual void CalculateLayoutInputHorizontal() &#123; &#125;    public virtual void CalculateLayoutInputVertical() &#123; &#125;    public virtual float minWidth &#123; get &#123; return 0; &#125; &#125;    public virtual float preferredWidth    &#123;        get        &#123;            if (overrideSprite == null)                return 0;            return overrideSprite.rect.size.x / pixelsPerUnit;        &#125;    &#125;    public virtual float flexibleWidth &#123; get &#123; return -1; &#125; &#125;    public virtual float minHeight &#123; get &#123; return 0; &#125; &#125;    public virtual float preferredHeight    &#123;        get        &#123;            if (overrideSprite == null)                return 0;            return overrideSprite.rect.size.y / pixelsPerUnit;        &#125;    &#125;    public virtual float flexibleHeight &#123; get &#123; return -1; &#125; &#125;    public virtual int layoutPriority &#123; get &#123; return 0; &#125; &#125;    #endregion        #region ICanvasRaycastFilter    public virtual bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)    &#123;        return true;    &#125;    #endregion&#125;</code></pre><h3 id="CircleImage"><a href="#CircleImage" class="headerlink" title="CircleImage"></a>CircleImage</h3><pre><code>[AddComponentMenu(&quot;UI/Circle Image&quot;)]public class CircleImage : BaseImage&#123;    [Tooltip(&quot;圆形的半径&quot;)]    [Range(0, 1)]    public float fillRadius = 1f;    [Tooltip(&quot;UV缩放比例&quot;)]    [Range(0, 1)]    public float UVScale = 1f;    [Tooltip(&quot;圆形的中心点&quot;)]    public Vector2 fillCenter = new Vector2(0.5f, 0.5f);    [Tooltip(&quot;圆形或扇形填充比例&quot;)]    [Range(0, 1)]    public float fillPercent = 1f;    [Tooltip(&quot;是否填充圆形&quot;)]    public bool fill = true;    [Tooltip(&quot;圆环宽度&quot;)]    public float thickness = 5;    [Tooltip(&quot;圆形&quot;)]    [Range(3, 100)]    public int segements = 20;    private List&lt;Vector3&gt; innerVertices;    private List&lt;Vector3&gt; outterVertices;    void Awake()    &#123;        innerVertices = new List&lt;Vector3&gt;();        outterVertices = new List&lt;Vector3&gt;();    &#125;        // Update is called once per frame    void Update () &#123;        if(!fill)            this.thickness = (float)Mathf.Clamp(this.thickness, 0, rectTransform.rect.width / 2);    &#125;    protected override void OnPopulateMesh(VertexHelper vh)    &#123;        vh.Clear();        innerVertices.Clear();        outterVertices.Clear();        //算出每个面片的顶点夹角，面片数segements与填充比例fillPercent相乘，就知道要用多少个面片来显示圆形/扇形        float degreeDelta = (float)(2 * Mathf.PI / segements);        int curSegements = (int)(segements * fillPercent);        //通过RectTransform获取矩形宽高，计算出半径        float tw = rectTransform.rect.width * fillRadius;        float th = rectTransform.rect.height * fillRadius;        float outerRadius = rectTransform.pivot.x * tw;        float innerRadius = rectTransform.pivot.x * tw - thickness;        Vector4 uv = overrideSprite != null ? DataUtility.GetOuterUV(overrideSprite) : Vector4.zero;        float uvCenterX = (uv.x + uv.z) * (0.5f + (fillCenter.x - 0.5f) * (uv.z - uv.x));        float uvCenterY = (uv.y + uv.w) * (0.5f + (fillCenter.y - 0.5f) * (uv.w - uv.y));        float uvScaleX = (uv.z - uv.x) / tw  * fillRadius * UVScale;        float uvScaleY = (uv.w - uv.y) / th  * fillRadius * UVScale;        float curDegree = 0;        UIVertex uiVertex;        int verticeCount;        int triangleCount;        Vector2 curVertice;        if (fill) //圆形        &#123;            curVertice = Vector2.zero;            verticeCount = curSegements + 1;            uiVertex = new UIVertex();            uiVertex.color = color;            uiVertex.position = curVertice;            uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);            vh.AddVert(uiVertex);            for (int i = 1; i &lt; verticeCount; i++)            &#123;                float cosA = Mathf.Cos(curDegree);                float sinA = Mathf.Sin(curDegree);                curVertice = new Vector2(cosA * outerRadius, sinA * outerRadius);                curDegree += degreeDelta;                uiVertex = new UIVertex();                uiVertex.color = color;                uiVertex.position = curVertice;                uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);                vh.AddVert(uiVertex);                outterVertices.Add(curVertice);            &#125;            triangleCount = curSegements*3;            for (int i = 0, vIdx = 1; i &lt; triangleCount - 3; i += 3, vIdx++)            &#123;                vh.AddTriangle(vIdx, 0, vIdx+1);            &#125;            if (fillPercent == 1)            &#123;                //首尾顶点相连                vh.AddTriangle(verticeCount - 1, 0, 1);            &#125;        &#125;        else//圆环        &#123;            verticeCount = curSegements*2;            for (int i = 0; i &lt; verticeCount; i += 2)            &#123;                float cosA = Mathf.Cos(curDegree);                float sinA = Mathf.Sin(curDegree);                curDegree += degreeDelta;                curVertice = new Vector3(cosA * innerRadius, sinA * innerRadius);                uiVertex = new UIVertex();                uiVertex.color = color;                uiVertex.position = curVertice;                uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);                vh.AddVert(uiVertex);                innerVertices.Add(curVertice);                curVertice = new Vector3(cosA * outerRadius, sinA * outerRadius);                uiVertex = new UIVertex();                uiVertex.color = color;                uiVertex.position = curVertice;                uiVertex.uv0 = new Vector2(curVertice.x * uvScaleX + uvCenterX, curVertice.y * uvScaleY + uvCenterY);                vh.AddVert(uiVertex);                outterVertices.Add(curVertice);            &#125;            triangleCount = curSegements*3*2;            for (int i = 0, vIdx = 0; i &lt; triangleCount - 6; i += 6, vIdx += 2)            &#123;                vh.AddTriangle(vIdx+1, vIdx, vIdx+3);                vh.AddTriangle(vIdx, vIdx + 2, vIdx + 3);            &#125;            if (fillPercent == 1)            &#123;                //首尾顶点相连                vh.AddTriangle(verticeCount - 1, verticeCount - 2, 1);                vh.AddTriangle(verticeCount - 2, 0, 1);            &#125;        &#125;    &#125;        public override bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)    &#123;        Sprite sprite = overrideSprite;        if (sprite == null)            return true;        Vector2 local;        RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, screenPoint, eventCamera, out local);        return Contains(local, outterVertices, innerVertices);    &#125;        private bool Contains(Vector2 p, List&lt;Vector3&gt; outterVertices, List&lt;Vector3&gt; innerVertices)    &#123;        var crossNumber = 0;        if(!fill)            RayCrossing(p, innerVertices, ref crossNumber);//检测内环        RayCrossing(p, outterVertices, ref crossNumber);//检测外环        return (crossNumber &amp; 1) == 1;    &#125;        /// &lt;summary&gt;    /// 使用RayCrossing算法判断点击点是否在封闭多边形里    /// &lt;/summary&gt;    /// &lt;param name=&quot;p&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;vertices&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;crossNumber&quot;&gt;&lt;/param&gt;    private void RayCrossing(Vector2 p, List&lt;Vector3&gt; vertices, ref int crossNumber)    &#123;        for (int i = 0, count = vertices.Count; i &lt; count; i++)        &#123;            var v1 = vertices[i];            var v2 = vertices[(i + 1) % count];            //点击点水平线必须与两顶点线段相交            if (((v1.y &lt;= p.y) &amp;&amp; (v2.y &gt; p.y))                || ((v1.y &gt; p.y) &amp;&amp; (v2.y &lt;= p.y)))            &#123;                //只考虑点击点右侧方向，点击点水平线与线段相交，且交点x &gt; 点击点x，则crossNumber+1                if (p.x &lt; v1.x + (p.y - v1.y) / (v2.y - v1.y) * (v2.x - v1.x))                &#123;                    crossNumber += 1;                &#125;            &#125;        &#125;    &#125;            /// &lt;summary&gt;    /// Adjusts the image size to make it pixel-perfect.    /// &lt;/summary&gt;    /// &lt;remarks&gt;    /// This means setting the Images RectTransform.sizeDelta to be equal to the Sprite dimensions.    /// &lt;/remarks&gt;    public override void SetNativeSize()    &#123;        if (activeSprite != null)        &#123;            float w = activeSprite.rect.width / pixelsPerUnit;            float h = activeSprite.rect.height / pixelsPerUnit;            rectTransform.anchorMax = rectTransform.anchorMin;            rectTransform.sizeDelta = new Vector2(w, h);            SetAllDirty();        &#125;    &#125;&#125;</code></pre><h3 id="CircleImageEditor"><a href="#CircleImageEditor" class="headerlink" title="CircleImageEditor"></a>CircleImageEditor</h3><pre><code>[CustomEditor(typeof(CircleImage))]public class CircleImageEditor : GraphicEditor&#123;    public override void OnInspectorGUI() &#123;        DrawDefaultInspector();                CircleImage myScript = (CircleImage)target;        EditorGUILayout.BeginHorizontal();        &#123;            GUILayout.Space(EditorGUIUtility.labelWidth);            if (GUILayout.Button(&quot;Set Native Size&quot;, EditorStyles.miniButtonRight))            &#123;                myScript.SetNativeSize();            &#125;        &#125;        EditorGUILayout.EndHorizontal();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考博客地址：&lt;a href=&quot;https://www.cnblogs.com/leoin2012/p/6425089.html&quot;&gt;https://www.cnblogs.com/leoin2012/p/6425089.html&lt;/a&gt;  &lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="UGUI" scheme="http://yoursite.com/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——UGUI基于图集的shader遮罩</title>
    <link href="http://yoursite.com/2021/04/20/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UGUI%E5%9F%BA%E4%BA%8E%E5%9B%BE%E9%9B%86%E7%9A%84shader%E9%81%AE%E7%BD%A9/"/>
    <id>http://yoursite.com/2021/04/20/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UGUI%E5%9F%BA%E4%BA%8E%E5%9B%BE%E9%9B%86%E7%9A%84shader%E9%81%AE%E7%BD%A9/</id>
    <published>2021-04-20T06:25:21.000Z</published>
    <updated>2021-12-27T03:39:09.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Unity开发过程中，为了节省图，经常会做一些图形的遮罩，笔者开发UI使用的是UGUI遮罩，用过UGUI的Mask做遮罩的应该都知道，UGUI的mask做遮罩有很明显的锯齿，于是笔者就从网上学习一套shader做的遮罩，但是仅仅是shader做的遮罩虽然效果很好，但是在正式开发中，为了优化性能，大部分图片都是会打成图集的，这时候shader中的UV就不是我们想要的UV了，这时候就需要做一些修改了。所以本文是基于图集的shader遮罩。</p><h1 id="普通的shader遮罩"><a href="#普通的shader遮罩" class="headerlink" title="普通的shader遮罩"></a>普通的shader遮罩</h1><p><img src="https://file.liangxiegame.com/e2f8acff-6e17-45c0-8bd1-ec8027772385.png" alt="image.png"> </p><p>上图左边是普通的UGUI的正常mask，右边是shader写的遮罩，边缘锯齿比较很明显。</p><h2 id="shader代码"><a href="#shader代码" class="headerlink" title="shader代码"></a>shader代码</h2><pre><code>Shader &quot;ImageMask01&quot;&#123;    Properties    &#123;        [PerRendererData] _MainTex (&quot;Sprite Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Mask (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;         _Color (&quot;Tint&quot;, Color) = (1,1,1,1)        _StencilComp(&quot;Stencil Comparison&quot;, Float) = 8        _Stencil(&quot;Stencil ID&quot;, Float) = 0        _StencilOp(&quot;Stencil Operation&quot;, Float) = 0        _StencilWriteMask(&quot;Stencil Write Mask&quot;, Float) = 255        _StencilReadMask(&quot;Stencil Read Mask&quot;, Float) = 255        _ColorMask(&quot;Color Mask&quot;, Float) = 15    &#125;    SubShader    &#123;        Tags        &#123;            &quot;Queue&quot;=&quot;Transparent&quot;            &quot;IgnoreProjector&quot;=&quot;True&quot;            &quot;RenderType&quot;=&quot;Transparent&quot;            &quot;PreviewType&quot;=&quot;Plane&quot;            &quot;CanUseSpriteAtlas&quot;=&quot;True&quot;        &#125;        Stencil        &#123;            Ref [_Stencil]            Comp [_StencilComp]            Pass [_StencilOp]            ReadMask [_StencilReadMask]            WriteMask [_StencilWriteMask]        &#125;        Cull Off        Lighting Off        ZWrite Off        ZTest [unity_GUIZTestMode]        Blend SrcAlpha OneMinusSrcAlpha        ColorMask [_ColorMask]        Pass        &#123;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #pragma target 2.0            #include &quot;UnityCG.cginc&quot;            #include &quot;UnityUI.cginc&quot;            #pragma multi_compile_local _ UNITY_UI_CLIP_RECT            #pragma multi_compile_local _ UNITY_UI_ALPHACLIP            struct appdata_t            &#123;                fixed2 uv : TEXCOORD0;                float4 vertex   : POSITION;                float4 color    : COLOR;            &#125;;            struct v2f            &#123;                fixed2 uv : TEXCOORD0;                float4 vertex   : SV_POSITION;                fixed4 color    : COLOR;            &#125;;            sampler2D _MainTex;            fixed4 _Color;            sampler2D _Mask;            v2f vert(appdata_t IN)            &#123;                v2f OUT;                OUT.vertex = UnityObjectToClipPos(IN.vertex);                OUT.uv = IN.uv;                OUT.color = IN.color * _Color;#ifdef PIXELSNAP_ON                OUT.vertex = UnityPixelSnap(OUT.vertex);#endif                return OUT;            &#125;            fixed4 frag(v2f IN) : SV_Target            &#123;                fixed4 color = tex2D(_MainTex, IN.uv) * IN.color;                fixed4 mask = tex2D(_Mask, IN.uv);                color.a *= mask.a;                return color;            &#125;        ENDCG        &#125;    &#125;&#125;</code></pre><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>上述代码虽然多，但是大部分都是通用的固定写法，包含一些shader支持UGUI的mask的写法，这里就不要进行讲解了，我们来看看我们shader做mask的关键代码。</p><pre><code>Properties&#123;    ...    _Mask (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;     ...&#125;</code></pre><p>在Properties主要是把我们需要遮罩的形状放进去，这里需要注意的是需要遮罩的部分图片必须不透明，因为在做遮罩的时候是读取这个图片的透明度来判断是否需要进行遮罩的。也就是下面的代码：</p><pre><code>fixed4 frag(v2f IN) : SV_Target&#123;    fixed4 color = tex2D(_MainTex, IN.uv) * IN.color;    fixed4 mask = tex2D(_Mask, IN.uv);    color.a *= mask.a;    return color;&#125;</code></pre><p>逐片源操作的时候来进行读取来遮罩显示。</p><h1 id="基于图集的遮罩"><a href="#基于图集的遮罩" class="headerlink" title="基于图集的遮罩"></a>基于图集的遮罩</h1><p>虽然上述已经实现了遮罩，但是在假如我们需要遮罩的图片是在图集上，会发现我们的遮罩会出现错误，不遮罩或者遮罩的不对，这是因为shader在读取图片的UV坐标的时候读取的并不是0<del>1而是图片在图集中的坐标，所以根据坐标进行遮罩是不行的。<br>解决方案就是需要把遮罩的坐标转成0</del>1的坐标，这样就可以判断是否需要遮罩了。<br>虽然我们有了解决方案，但是我们如何在shader中获取图片在图集的坐标呢，笔者的解决方案是利用一个C#的脚本，把图片坐标传递给shader。</p><h2 id="Shader新的代码"><a href="#Shader新的代码" class="headerlink" title="Shader新的代码"></a>Shader新的代码</h2><pre><code>Properties&#123;    ...    _Mask (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;     _UvRect (&quot;UvRect&quot;, Vector) = (0, 0, 1, 1)    ...&#125;</code></pre><p>上述是Properties中的代码，可以看出和普通的相比多了一个_UvRect参数，是用来保存图片在图集中的坐标的。  </p><pre><code>fixed4 frag(v2f IN) : SV_Target&#123;    fixed4 color = tex2D(_MainTex, IN.uv) * IN.color;        float2 temuv = float2((IN.uv.x - _UvRect.x)/(_UvRect.z - _UvRect.x),(IN.uv.y - _UvRect.y)/(_UvRect.w - _UvRect.y));    fixed4 mask = tex2D(_Mask, temuv);    color.a *= mask.a;    return color;&#125;</code></pre><p>在判断是否遮罩的时候，可以看到笔者关键性的代码，就是teamuv的赋值，算法很简单，知道图片四个角在图集的UV坐标，就是_UvRect参数，然后**(IN.uv.x - _UvRect.x)<strong>和</strong>(IN.uv.y - _UvRect.y)**就为了计算图片距离图片原点坐标的差值，也就是坐标系的坐标，他们在分别除以他们坐在的长度就转换成新的UV坐标了，其实就是图片本身的UV坐标了，然后就可以和普通的shader一样计算了。  </p><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C#代码"></a>C#代码</h2><pre><code>public class RefreshUVRect : MonoBehaviour&#123;    private Material material;    private Image img;    // Start is called before the first frame update    void Start()    &#123;        img = GetComponent&lt;Image&gt;();        material = img.material;        Refresh();    &#125;    public void Refresh()    &#123;        if (img)        &#123;            Vector4 uvRect = UnityEngine.Sprites.DataUtility.GetOuterUV(img.overrideSprite);            material.SetVector(&quot;_UvRect&quot;, uvRect);        &#125;    &#125;&#125;</code></pre><p>C#的代码比较简单，就是获取一下材质，然后把图片四个角的UV坐标传递给材质，<strong>UnityEngine.Sprites.DataUtility.GetOuterUV</strong>这个方法就是获取UV的边界坐标。<br><font color=red size=4>特别提醒一下，遮罩后编辑器模式下是错误的，因为获取的还是图片坐标，运行状态下观看就是正确的了</font></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在Unity开发过程中，为了节省图，经常会做一些图形的遮罩，笔者开发UI使用的是UGUI遮罩，用过UGUI的Mask做遮罩的应该都知道，UG</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="UGUI" scheme="http://yoursite.com/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——UGUI中粒子的遮罩与裁剪</title>
    <link href="http://yoursite.com/2021/04/19/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UGUI%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E9%81%AE%E7%BD%A9%E4%B8%8E%E8%A3%81%E5%89%AA/"/>
    <id>http://yoursite.com/2021/04/19/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UGUI%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E9%81%AE%E7%BD%A9%E4%B8%8E%E8%A3%81%E5%89%AA/</id>
    <published>2021-04-19T02:48:13.000Z</published>
    <updated>2021-12-27T03:39:09.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Unity开发中，在使用UGUI的mask的时候，如果子节点存在粒子特效，发现mask并不能裁剪粒子，比如笔者在开发中，有一个滑动列表，列表中的button上面存在按钮特效，在滑动的时候滑动的mask并不能裁剪粒子，因此笔者从网上找到了一些解决方案，并应用了一下，用着还可以。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>粒子的裁剪是用shader制作的，但是仅仅用shader是并不能满足需求的，因为特效有可能是会动的，这样剪裁区域就会发生变化，所以需要一个脚本把裁剪的区域传递给shader，然后shader在进行裁剪处理。  </p><h1 id="C-代码"><a href="#C-代码" class="headerlink" title="C#代码"></a>C#代码</h1><pre><code>public class TailorParticle : MonoBehaviour&#123;    private Material material;    private Mask mask;    private RectMask2D rectmask2d;    public void Start()    &#123;        material = GetComponentInChildren&lt;ParticleSystem&gt;().GetComponent&lt;Renderer&gt;().material;        mask = GetComponentInParent&lt;Mask&gt;();        rectmask2d = GetComponentInParent&lt;RectMask2D&gt;();        SetClip();        //如果运行时裁剪区域不会发生改变，可以注释掉下面这句代码        var scrollrecct = GetComponentInParent&lt;ScrollRect&gt;();        if (scrollrecct)        &#123;            scrollrecct.onValueChanged.AddListener(v =&gt; &#123; SetClip(); &#125;);        &#125;    &#125;    private bool isMask;    private Vector3[] corners = new Vector3[4];    private Vector3[] cornerstemp = new Vector3[4];    public void SetClip()    &#123;        //获取到需要裁剪的区域        isMask = false;        if (mask)         &#123;            mask.GetComponent&lt;RectTransform&gt;().GetWorldCorners(corners);            isMask = true;        &#125;        if(rectmask2d)        &#123;            rectmask2d.GetComponent&lt;RectTransform&gt;().GetWorldCorners(cornerstemp);            if (isMask)            &#123;                corners[0].x = Mathf.Min(corners[0].x, cornerstemp[0].x);                corners[0].y = Mathf.Min(corners[0].y, cornerstemp[0].y);                corners[2].x = Mathf.Max(corners[2].x, cornerstemp[2].x);                corners[2].y = Mathf.Max(corners[2].y, cornerstemp[2].y);            &#125;            else            &#123;                isMask = true;            &#125;        &#125;        if (material &amp;&amp; isMask)        &#123;            //将裁剪区域传入到Shader中            material.SetFloat(&quot;_MinX&quot;, corners[0].x);            material.SetFloat(&quot;_MinY&quot;, corners[0].y);            material.SetFloat(&quot;_MaxX&quot;, corners[2].x);            material.SetFloat(&quot;_MaxY&quot;, corners[2].y);        &#125;    &#125;&#125;</code></pre><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><pre><code>material = GetComponentInChildren&lt;ParticleSystem&gt;().GetComponent&lt;Renderer&gt;().material;mask = GetComponentInParent&lt;Mask&gt;();rectmask2d = GetComponentInParent&lt;RectMask2D&gt;();SetClip();//如果运行时裁剪区域不会发生改变，可以注释掉下面这句代码var scrollrecct = GetComponentInParent&lt;ScrollRect&gt;();if (scrollrecct)&#123;    scrollrecct.onValueChanged.AddListener(v =&gt; &#123; SetClip(); &#125;);&#125;</code></pre><p>首先我们先看Start函数中，material是获取子节点的粒子特效的材质(如果粒子多了可以自己扩展成组)，mask是获取父节点的Mask遮罩，rectmask2d和mask一样是获取父节点的RectMask2D组件，笔者之所以获取RectMask2D这个组件是因为笔者有些裁剪是用这个做的。接着就是进行裁剪函数，这里后面介绍。正常的裁剪到这里就结束了，但是我们如果想裁剪区域进行动态变化，那我们就要进行动态刷新shader，笔者这里只是简单的用ScrollRect进行举例，大家可以根据自己的项目进行监听。只要当变化的时候刷新一下裁剪就行了。  </p><pre><code>isMask = false;if (mask) &#123;    mask.GetComponent&lt;RectTransform&gt;().GetWorldCorners(corners);    isMask = true;&#125;if(rectmask2d)&#123;    rectmask2d.GetComponent&lt;RectTransform&gt;().GetWorldCorners(cornerstemp);    if (isMask)    &#123;        corners[0].x = Mathf.Min(corners[0].x, cornerstemp[0].x);        corners[0].y = Mathf.Min(corners[0].y, cornerstemp[0].y);        corners[2].x = Mathf.Max(corners[2].x, cornerstemp[2].x);        corners[2].y = Mathf.Max(corners[2].y, cornerstemp[2].y);    &#125;    else    &#123;        isMask = true;    &#125;&#125;</code></pre><p>接着我们来看一下裁剪的代码，首先是标记不需要裁剪，只有当父节点存在Mask的时候才进行裁剪，然后就是获取父节点的剪裁区域，笔者这里是把两个Mask进行融合，获取最小的范围，这里可以根据自己的需求进行变化，然后就是关键性的代码  </p><pre><code>if (material &amp;&amp; isMask)&#123;    //将裁剪区域传入到Shader中    material.SetFloat(&quot;_MinX&quot;, corners[0].x);    material.SetFloat(&quot;_MinY&quot;, corners[0].y);    material.SetFloat(&quot;_MaxX&quot;, corners[2].x);    material.SetFloat(&quot;_MaxY&quot;, corners[2].y);&#125;</code></pre><p>这里就是将剪裁区域传递给次材质的shader，然后shader进行裁剪。</p><h1 id="Shader关键代码"><a href="#Shader关键代码" class="headerlink" title="Shader关键代码"></a>Shader关键代码</h1><pre><code>Properties &#123;        ...    _MinX (&quot;Min X&quot;, Float) = -10    _MaxX (&quot;Max X&quot;, Float) = 10    _MinY (&quot;Min Y&quot;, Float) = -10    _MaxY (&quot;Max Y&quot;, Float) = 10&#125;SubShader &#123;    Pass &#123;        ...        float _MinX;        float _MaxX;        float _MinY;        float _MaxY;                ...        float4 frag(VertexOutput i) : COLOR &#123;                        ...                    c.a *= (i.vpos.x &gt;= _MinX );               c.a *= (i.vpos.x &lt;= _MaxX);            c.a *= (i.vpos.y &gt;= _MinY);            c.a *= (i.vpos.y &lt;= _MaxY);            c.rgb *= c.a;            return c;        &#125;        ...    &#125;&#125;</code></pre><p>shader的代码也比较简单，就是将传过来的区域进行判断，如果在区域内据显示，如果超出区域就将颜色的透明度设置为0，也就看不见了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在Unity开发中，在使用UGUI的mask的时候，如果子节点存在粒子特效，发现mask并不能裁剪粒子，比如笔者在开发中，有一个滑动列表，列</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="UGUI" scheme="http://yoursite.com/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>LBFramwork框架搭建</title>
    <link href="http://yoursite.com/2020/07/30/Unity%E6%A1%86%E6%9E%B6/LBFramwork%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/07/30/Unity%E6%A1%86%E6%9E%B6/LBFramwork%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</id>
    <published>2020-07-30T06:40:08.000Z</published>
    <updated>2021-12-27T03:39:09.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LBFramework简介"><a href="#LBFramework简介" class="headerlink" title="LBFramework简介"></a>LBFramework简介</h1><p><font size=4><strong>单元测试环境： NSubstitute</strong></font><br><font size=4><strong>编写脚本环境： rider 2020.1.4</strong></font><br><font size=4><strong>Unity环境: unity2019.4.3f1(LTS)</strong></font>    </p><p>此篇文章记录笔者一步一步创建LBFramework框架，一步一步学习游戏框架。    </p><h1 id="LBUtils"><a href="#LBUtils" class="headerlink" title="LBUtils"></a>LBUtils</h1><h2 id="LBEditor"><a href="#LBEditor" class="headerlink" title="LBEditor"></a>LBEditor</h2><p>记录框架中编辑器的扩展  </p><h3 id="EditorModulizationPlatform-模块化编辑器结构"><a href="#EditorModulizationPlatform-模块化编辑器结构" class="headerlink" title="EditorModulizationPlatform    模块化编辑器结构"></a>EditorModulizationPlatform    模块化编辑器结构</h3><p>这是一个模块化编辑器结构<br>首先创建一个接口  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><pre><code>public interface IEditorPlatformModule&#123;    /// &lt;summary&gt;    /// 渲染 IMGUI    /// &lt;/summary&gt;    void OnGUI();&#125;public class EditorModuleContainer&#123;    /// &lt;summary&gt;    /// 用来缓存的模s块    /// &lt;/summary&gt;    private List&lt;object&gt; mInstances = new List&lt;object&gt;();    /// &lt;summary&gt;    /// 溶解（获取全部)    /// &lt;/summary&gt;    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public List&lt;T&gt; ResolveAll&lt;T&gt;()    &#123;        return mInstances.OfType&lt;T&gt;()            .ToList();    &#125;    public void Init()    &#123;        // 清空掉之前的实例        mInstances.Clear();        // 1.获取当前项目中所有的 assembly (可以理解为 代码编译好的 dll)        var assemblies = AppDomain.CurrentDomain.GetAssemblies();        // 2.获取编辑器环境(dll)        var editorAssembly = assemblies.First(assembly =&gt; assembly.FullName.StartsWith(&quot;Assembly-CSharp-Editor&quot;));        // 3.获取 IEditorPlatformModule 类型        var moduleType = typeof(IEditorPlatformModule);        mInstances = editorAssembly            // 获取所有的编辑器环境中的类型             .GetTypes()            // 过滤掉抽象类型（接口/抽象类)、和未实现 IEditorPlatformModule 的类型            .Where(type =&gt; moduleType.IsAssignableFrom(type) &amp;&amp; !type.IsAbstract)            // 获取类型的构造创建实例            .Select(type =&gt; type.GetConstructors().First().Invoke(null))            // 转换成 List&lt;IEditorPlatformModule&gt;            .ToList();    &#125;&#125;public class EditorModulizationPlatformEditor : EditorWindow&#123;    private EditorModulizationContainer mContainer;    /// &lt;summary&gt;    /// 打开窗口    /// &lt;/summary&gt;    [MenuItem(&quot;LBFramework/LBUtils/LBEditor&quot;)]    public static void Open()    &#123;        var editorPlatform = GetWindow&lt;EditorModulizationPlatformEditor&gt;();        editorPlatform.position = new Rect(            Screen.width / 2,            Screen.height * 2 / 3,            600,            500        );        // 初始化 Container        editorPlatform.mContainer = new EditorModulizationContainer();        editorPlatform.mContainer.Init();        editorPlatform.Show();    &#125;    private void OnGUI()    &#123;        // 渲染        mContainer.ResolveAll&lt;IEditorPlatformModule&gt;()            .ForEach(editorPlatformModule=&gt;editorPlatformModule.OnGUI());    &#125;&#125;</code></pre></details>调用的测试如下所示  <details><summary><font color=darkred>点击查看测试脚本详细内容</font></summary><pre><code>public class LBEditorTest:IEditorPlatformModule&#123;    public void OnGUI()    &#123;        GUILayout.Label(&quot;这个是一个新的模块&quot;, new GUIStyle()        &#123;            fontSize = 30        &#125;);        GUILayout.Button(&quot;LianBai&quot;);    &#125;&#125;</code></pre></details><h3 id="EditorCreatCShapTemp-编辑器扩展创建模板脚本"><a href="#EditorCreatCShapTemp-编辑器扩展创建模板脚本" class="headerlink" title="EditorCreatCShapTemp  编辑器扩展创建模板脚本"></a>EditorCreatCShapTemp  编辑器扩展创建模板脚本</h3><p>这是一个创建各种类型脚本的工具，笔者在写脚本的时候，因为Unity自带的创建脚本都是提供的模板，需要删除很多东西，所以笔者就自己写了一个工具用来创建脚本。  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><pre><code>public class EditorCreatScript&#123;    //获取选中的文件夹路径    public static string GetSelectedPathOrFallBack()    &#123;        string path = &quot;Assets&quot;;        foreach (UnityEngine.Object obj  in Selection.GetFiltered(typeof(UnityEngine.Object),SelectionMode.Assets))        &#123;            path = AssetDatabase.GetAssetPath(obj);            if (!string.IsNullOrEmpty(path) &amp;&amp; File.Exists(path))            &#123;                path = Path.GetDirectoryName(path);                break;            &#125;        &#125;        return path;    &#125;&#125;public //定义一个创建资源的Action类并实现其Action方法    class CraetEventCSScriptAsset : EndNameEditAction&#123;    public override void Action(int instanceId, string pathName, string resourceFile)    &#123;        //创建资源        UnityEngine.Object o = CreatScriptAssetFormTemplate(pathName, resourceFile);        //高亮显示该资源        ProjectWindowUtil.ShowCreatedAsset(o);    &#125;    internal static UnityEngine.Object CreatScriptAssetFormTemplate(string pathName, string resourcesFile)    &#123;        //获取创建资源的绝对路径        string fullName = Path.GetFullPath(pathName);        //读取本地模板        StreamReader streamReader = new StreamReader(resourcesFile);        string text = streamReader.ReadToEnd();        streamReader.Close();                    //获取文件名字        string fileName = Path.GetFileNameWithoutExtension(pathName);        //替换文件中的内容        text = text.Replace(&quot;#NAME&quot;,fileName);        bool encoderShouldEmitUTF8Identifier = true;        bool throwOnInvalidBytes = false;        UTF8Encoding uTF8Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier, throwOnInvalidBytes);        bool append = false;        //写入新文件        StreamWriter streamWriter = new StreamWriter(fullName, append, uTF8Encoding);        streamWriter.Write(text);        streamWriter.Close();                    //刷新本地资源        AssetDatabase.ImportAsset(pathName);        AssetDatabase.Refresh();        return AssetDatabase.LoadAssetAtPath(pathName, typeof(UnityEngine.Object));    &#125;&#125;</code></pre></details>调用的方法如下列代码所示  <details><summary><font color=darkred>点击查看测试脚本详细内容</font></summary><pre><code>public class EditorCreanScriptTest : EditorCreatScript&#123;    [MenuItem(&quot;Assets/Create/LBFCShap&quot;, false, 80)]    public static void CreatLBFCShap()    &#123;        ProjectWindowUtil.StartNameEditingIfProjectWindowExists(0,            ScriptableObject.CreateInstance&lt;CraetEventCSScriptAsset&gt;(),            GetSelectedPathOrFallBack()+&quot;/New Script.cs&quot;,            null,            &quot;Assets/LBFramework/LBUnitTest/&quot; +            &quot;Editor/CShapTemp/LBFCSTemp.txt&quot;         // 只需要在此文件夹下创建你需要的模板，命名与EventCSClass.cs一致就行        );    &#125;&#125;</code></pre></details><h2 id="AssemblyUtil的获取"><a href="#AssemblyUtil的获取" class="headerlink" title="AssemblyUtil的获取"></a>AssemblyUtil的获取</h2><p>这是一个收集AssemblyUtil获取部分的代码  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><pre><code>public class AssemblyUtil&#123;    public static Assembly EditorAssembly    &#123;        get        &#123;            // 1.获取当前项目中所有的 assembly (可以理解为 代码编译好的 dll)            var assemblies = AppDomain.CurrentDomain.GetAssemblies();            // 2.获取编辑器环境(dll)            var editorAssembly =                assemblies.First(assembly =&gt; assembly.FullName.StartsWith(&quot;Assembly-CSharp-Editor&quot;));            return editorAssembly;        &#125;    &#125;&#125;public static Assembly CShapAssembly&#123;    get    &#123;        // 1.获取当前项目中所有的 CShap assembly (可以理解为 代码编译好的 dll)        var assemblies = AppDomain.CurrentDomain.GetAssemblies();        // 2.获取编辑器环境(dll)        var cShapAssembly =            assemblies.First(assembly =&gt; assembly.FullName.StartsWith(&quot;Assembly-CSharp&quot;));        return cShapAssembly;    &#125;&#125;public static List&lt;Type&gt; GetEditoeAssemblyInstance&lt;Type&gt;()&#123;    return EditorAssembly        // 获取所有的编辑器环境中的类型         .GetTypes()        // 过滤掉抽象类型（接口/抽象类)、和未实现 Type 的类型        .Where(type =&gt; typeof(Type).IsAssignableFrom(type) &amp;&amp; !type.IsAbstract)        // 获取类型的构造创建实例        .Select(type =&gt; type.GetConstructors().First().Invoke(null))        // 转换成 List&lt;Type&gt;        .ToList()        .OfType&lt;Type&gt;()        .ToList();&#125;public static List&lt;Type&gt; GetCShapAssemblyInstance&lt;Type&gt;()&#123;    return CShapAssembly        // 获取所有的编辑器环境中的类型         .GetTypes()        // 过滤掉抽象类型（接口/抽象类)、和未实现 Type 的类型        .Where(type =&gt; typeof(Type).IsAssignableFrom(type) &amp;&amp; !type.IsAbstract)        // 获取类型的构造创建实例        .Select(type =&gt; type.GetConstructors().First().Invoke(null))        // 转换成 List&lt;Type&gt;        .ToList()        .OfType&lt;Type&gt;()        .ToList();&#125;</code></pre></details><h2 id="ResolutionCheck-屏幕检测"><a href="#ResolutionCheck-屏幕检测" class="headerlink" title="ResolutionCheck 屏幕检测"></a>ResolutionCheck 屏幕检测</h2><p>这个模块是一个屏幕检测的脚本，主要是用于检测是横屏竖屏的。  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><pre><code>public class ResolutionCheck&#123;    //判断是否横屏    public static bool IsLandScape    &#123;        get &#123; return Screen.width &gt; Screen.height; &#125;    &#125;        //Pad、Android 大部分平板的宽高比是 4:3    public static bool IsPad    &#123;        get &#123; return IsRatito(4,3);; &#125;    &#125;    //1280 / 720（一般安卓设备，结果为 1.777778） 还是 1136 / 640（iPhone 5s，结果为 1.775）    //或者是 1920 / 1080（iPhone 6p ，结果为 1.777778），它们都属于 16 ： 9 这个宽高比的范畴    public static bool IsPhone16_9    &#123;        get &#123; return IsRatito(16,9); &#125;    &#125;    public static bool IsRatito(float width, float height)    &#123;        var aspectRatio = IsLandScape            ? (float) Screen.width / Screen.height            : (float) Screen.height / Screen.width;        var destinationRatio = width / height;        return aspectRatio &gt; destinationRatio - 0.05f &amp;&amp; aspectRatio &lt; destinationRatio + 0.05f;    &#125;&#125;</code></pre></details><p>这个模块的单元测试如下列代码：  </p><details><summary><font color=darkred>点击查看测试脚本详细内容</font></summary><pre><code>public class ResolutionCheckTests&#123;    [Test]    public void ResolutionCheck_LandscapeTests()    &#123;        Debug.LogFormat(&quot;是否是横屏:&#123;0&#125;&quot;, ResolutionCheck.IsLandScape);        Assert.AreEqual(ResolutionCheck.IsLandScape, Screen.width &gt; Screen.height);    &#125;        [Test]    public void ResolutionCheck_4_3_Tests()    &#123;        Debug.LogFormat(&quot;是否是4:3分辨率？&#123;0&#125;&quot;, ResolutionCheck.IsPad);    &#125;        [Test]    public void ResolutionCheck_16_9_Tests()    &#123;        Debug.LogFormat(&quot;是否是16:9分辨率？&#123;0&#125;&quot;, ResolutionCheck.IsPhone16_9);    &#125;    [Test]    public void ResolutionCheck_Other_Tests()    &#123;        Debug.LogFormat(&quot;是否是750:1334分辨率？&#123;0&#125;&quot;, ResolutionCheck.IsRatito(750,1334));        Debug.LogFormat(&quot;是否是1024:768分辨率？&#123;0&#125;&quot;, ResolutionCheck.IsRatito(1024,768));    &#125;&#125;</code></pre></details><h2 id="CompExtend-组件扩展"><a href="#CompExtend-组件扩展" class="headerlink" title="CompExtend 组件扩展"></a>CompExtend 组件扩展</h2><p>这个模块主要用于扩展Unity中的Component,我们再为坐标赋值的时候，因为用的是struct，所以每次都要重新构造一个Vector3，因此可以扩展一下从而可以很简单的赋值。<br>这个模块是一个屏幕检测的脚本，主要是用于检测是横屏竖屏的。  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><pre><code>public static class CompExtend&#123;    //设置世界坐标X的值    public static T PositionX&lt;T&gt;(this T self, float x) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var position = transform.position;           //临时变量存储坐标信息        position.x = x;                                    //更改临时变量的坐标信息        transform.position = position;                    //重新给位置信息赋值        return self;    &#125;    //设置世界坐标Y的值    public static T PositionY&lt;T&gt;(this T self, float y) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var position = transform.position;           //临时变量存储坐标信息        position.y = y;                                    //更改临时变量的坐标信息        transform.position = position;                    //重新给位置信息赋值        return self;    &#125;    //设置世界坐标Z的值    public static T PositionZ&lt;T&gt;(this T self, float z) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var position = transform.position;           //临时变量存储坐标信息        position.z = z;                                    //更改临时变量的坐标信息        transform.position = position;                    //重新给位置信息赋值        return self;    &#125;    //设置世界坐标XY的值    public static T PositionXY&lt;T&gt;(this T self, float x,float y) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var position = transform.position;           //临时变量存储坐标信息        position.x = x;                                    //更改临时变量的坐标信息        position.y = y;                                            transform.position = position;                    //重新给位置信息赋值        return self;    &#125;    //设置世界坐标XZ的值    public static T PositionXZ&lt;T&gt;(this T self, float x,float z) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var position = transform.position;           //临时变量存储坐标信息        position.x = x;                                    //更改临时变量的坐标信息        position.z = z;                                            transform.position = position;                    //重新给位置信息赋值        return self;    &#125;    //设置世界坐标YZ的值    public static T PositionYZ&lt;T&gt;(this T self, float y,float z) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var position = transform.position;           //临时变量存储坐标信息        position.y = y;                                    //更改临时变量的坐标信息        position.z = z;                                            transform.position = position;                    //重新给位置信息赋值        return self;    &#125;    //设置本地坐标X的值    public static T LocalPositionX&lt;T&gt;(this T self, float x) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var localPosition = transform.localPosition;           //临时变量存储坐标信息        localPosition.x = x;                                    //更改临时变量的坐标信息        transform.localPosition = localPosition;                    //重新给位置信息赋值        return self;    &#125;    //设置本地坐标Y的值    public static T LocalPositionY&lt;T&gt;(this T self, float y) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var localPosition = transform.localPosition;           //临时变量存储坐标信息        localPosition.y = y;                                    //更改临时变量的坐标信息        transform.localPosition = localPosition;                    //重新给位置信息赋值        return self;    &#125;    //设置本地坐标Z的值    public static T LocalPositionZ&lt;T&gt;(this T self, float z) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var localPosition = transform.localPosition;           //临时变量存储坐标信息        localPosition.z = z;                                    //更改临时变量的坐标信息        transform.localPosition = localPosition;                    //重新给位置信息赋值        return self;    &#125;    //设置本地坐标XY的值    public static T LocalPositionXY&lt;T&gt;(this T self, float x,float y) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var localPosition = transform.localPosition;           //临时变量存储坐标信息        localPosition.x = x;                                    //更改临时变量的坐标信息        localPosition.y = y;                                            transform.localPosition = localPosition;                    //重新给位置信息赋值        return self;    &#125;    //设置本地坐标XZ的值    public static T LocalPositionXZ&lt;T&gt;(this T self, float x,float z) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var localPosition = transform.localPosition;           //临时变量存储坐标信息        localPosition.x = x;                                    //更改临时变量的坐标信息        localPosition.z = z;                                            transform.localPosition = localPosition;                    //重新给位置信息赋值        return self;    &#125;    //设置本地坐标YZ的值    public static T LocalPositionYZ&lt;T&gt;(this T self, float y,float z) where T : Component    &#123;        var transform = self.transform;                    //获取Component的transfrom        var localPosition = transform.localPosition;           //临时变量存储坐标信息        localPosition.y = y;                                    //更改临时变量的坐标信息        localPosition.z = z;                                            transform.localPosition = localPosition;                    //重新给位置信息赋值        return self;    &#125;    //Transfroam本地数据重置    public static T LocalIdentity&lt;T&gt;(this T self) where T : Component    &#123;        var transform = self.transform;        transform.localPosition = Vector3.zero;        transform.localRotation = Quaternion.identity;        transform.localScale = Vector3.one;        return self;    &#125;        //Transfroam世界数据重置    public static T Identity&lt;T&gt;(this T self) where T : Component    &#123;        var transform = self.transform;        transform.position = Vector3.zero;        transform.rotation = Quaternion.identity;        transform.localScale = Vector3.one;                return self;    &#125;        public static T Show&lt;T&gt;(this T self) where T : Component    &#123;        self.gameObject.SetActive(true);        return self;    &#125;    public static T Hide&lt;T&gt;(this T self) where T : Component    &#123;        self.gameObject.SetActive(false);        return self;    &#125;    public static GameObject Show(this GameObject self)    &#123;        self.SetActive(true);        return self;    &#125;    public static GameObject Hide(this GameObject self)    &#123;        self.SetActive(false);        return self;    &#125;&#125;</code></pre></details><p>调用的单元测试如下列脚本：  </p><details><summary><font color=darkred>点击查看测试脚本详细内容</font></summary><pre><code>public class CompExendTest&#123;    [Test]    public static void Extensions_AllTest()    &#123;        var gameObject = new GameObject();        gameObject.transform.PositionX(10);        Assert.AreEqual(gameObject.transform.position.x, 10);        gameObject.transform.PositionY(20);        Assert.AreEqual(gameObject.transform.position.y, 20);                gameObject.transform.PositionZ(30);        Assert.AreEqual(gameObject.transform.position.z, 30);        gameObject.transform.PositionXY(40,50);        Assert.AreEqual(gameObject.transform.position.x, 40);        Assert.AreEqual(gameObject.transform.position.y, 50);                gameObject.transform.PositionXZ(60,70);        Assert.AreEqual(gameObject.transform.position.x, 60);        Assert.AreEqual(gameObject.transform.position.z, 70);        gameObject.transform.PositionYZ(80,90);        Assert.AreEqual(gameObject.transform.position.y, 80);        Assert.AreEqual(gameObject.transform.position.z, 90);        gameObject.transform.LocalPositionX(100);        Assert.AreEqual(gameObject.transform.localPosition.x, 100);        gameObject.transform.LocalPositionY(110);        Assert.AreEqual(gameObject.transform.localPosition.y, 110);        gameObject.transform.LocalPositionZ(120);        Assert.AreEqual(gameObject.transform.localPosition.z, 120);        gameObject.transform.LocalPositionXY(130,140);        Assert.AreEqual(gameObject.transform.localPosition.x, 130);        Assert.AreEqual(gameObject.transform.localPosition.y, 140);                gameObject.transform.LocalPositionXZ(150,160);        Assert.AreEqual(gameObject.transform.localPosition.x, 150);        Assert.AreEqual(gameObject.transform.localPosition.z, 160);                gameObject.transform.LocalPositionYZ(170,180);        Assert.AreEqual(gameObject.transform.localPosition.y, 170);        Assert.AreEqual(gameObject.transform.localPosition.z, 180);        gameObject.transform.LocalIdentity();        Assert.AreEqual(gameObject.transform.localPosition, Vector3.zero);        Assert.AreEqual(gameObject.transform.localRotation,Quaternion.identity);        Assert.AreEqual(gameObject.transform.localScale,Vector3.one);                gameObject.transform.Identity();        Assert.AreEqual(gameObject.transform.position, Vector3.zero);        Assert.AreEqual(gameObject.transform.rotation,Quaternion.identity);        Assert.AreEqual(gameObject.transform.lossyScale,Vector3.one);        gameObject.Show();        Assert.AreEqual(gameObject.activeSelf, true);        gameObject.Hide();        Assert.AreEqual(gameObject.activeSelf, false);        // Transform 测试        gameObject.transform.Show();        Assert.AreEqual(gameObject.activeSelf, true);        gameObject.transform.Hide();        Assert.AreEqual(gameObject.activeSelf, false);        // Component 测试        var camera = gameObject.AddComponent&lt;Camera&gt;();        camera.Show();        Assert.AreEqual(gameObject.activeSelf, true);                camera.Hide();        Assert.AreEqual(gameObject.activeSelf, false);    &#125;&#125;</code></pre></details><h2 id="LBSingleton"><a href="#LBSingleton" class="headerlink" title="LBSingleton"></a>LBSingleton</h2><p>游戏中的单例是常用，但是每次单例都需要自己部分代码，这套结构可以快速制作单例脚本，只需要继承对应的虚类就行了。</p><p>单例的脚本如下  </p><details><summary><font color=darkred>点击查看测试脚本详细内容</font></summary><pre><code>using System;using System.Reflection;#if UNITY_5_6_OR_NEWERusing UnityEngine;using Object = UnityEngine.Object;#endifnamespace LBFramework.LBUtils&#123;    public interface ISingleton    &#123;        void OnInitSingleton();    &#125;    public abstract class Singleton&lt;T&gt; : ISingleton where T : Singleton&lt;T&gt;    &#123;        protected static T mInstance;        private static object mLock = new object();        //用来锁定，防止多线程问题        public static T Instabce        &#123;            get            &#123;                lock (mLock)                &#123;                    if (mInstance == null)                    &#123;                        mInstance = SingletonCreator.CreateSingleton&lt;T&gt;();                    &#125;                &#125;                return mInstance;            &#125;        &#125;        public void OnInitSingleton() &#123; &#125;    &#125;    public static class SingletonCreator    &#123;        public static T CreateSingleton&lt;T&gt;() where T : class, ISingleton        &#123;            // 获取私有构造函数            var ctors = typeof(T).GetConstructors(BindingFlags.Instance | BindingFlags.NonPublic);            // 获取无参构造函数            var ctor = Array.Find(ctors, c =&gt; c.GetParameters().Length == 0);            if (ctor == null)            &#123;                throw new Exception(&quot;Non-Public Constructor() not found! in &quot; + typeof(T));            &#125;            // 通过构造函数，常见实例            var retInstance = ctor.Invoke(null) as T;            retInstance.OnInitSingleton();            return retInstance;        &#125;    &#125;#if UNITY_5_6_OR_NEWER    [Obsolete]    public class QMonoSingletonPath : MonoSingletonPath    &#123;        public QMonoSingletonPath(string pathInHierarchy) : base(pathInHierarchy)        &#123;        &#125;    &#125;    //定义一个特性并控制定义特性的使用    [AttributeUsage(AttributeTargets.Class)]    public class MonoSingletonPath : Attribute    &#123;        private string mPathInHierarchy;        public MonoSingletonPath(string pathInHierarchy)        &#123;            mPathInHierarchy = pathInHierarchy;        &#125;        public string PathInHierarchy        &#123;            get &#123; return mPathInHierarchy; &#125;        &#125;    &#125;    public abstract class MonoSingleton&lt;T&gt; : MonoBehaviour, ISingleton where T : MonoSingleton&lt;T&gt;    &#123;        protected static T mInstance;        protected static bool mOnApplicationQuit = false;        public static T Instance        &#123;            get            &#123;                if (mInstance == null &amp;&amp; !mOnApplicationQuit)                &#123;                    mInstance = MonoSingletonCreator.CreateMonoSingleton&lt;T&gt;();                &#125;                return mInstance;            &#125;        &#125;        public virtual void OnInitSingleton() &#123; &#125;        public virtual void Dispose()        &#123;            if (MonoSingletonCreator.IsUnitTestMode)            &#123;                var curTrans = transform;                do                &#123;                    var parent = curTrans.parent;                    DestroyImmediate(curTrans.gameObject);                    curTrans = parent;                &#125; while (curTrans != null);                mInstance = null;            &#125;            else &#123; Destroy(gameObject); &#125;        &#125;        //应用退出前进行处理        protected virtual void OnApplicationQuit()        &#123;            mOnApplicationQuit = true;            if (mInstance == null) return;            Destroy(mInstance.gameObject);            mInstance = null;        &#125;        protected virtual void OnDestroy() &#123; mInstance = null; &#125;        //判断对象是否已经退出        public static bool IsApplicationQuit        &#123;            get &#123; return mOnApplicationQuit; &#125;        &#125;    &#125;    //创建单例    public static class MonoSingletonCreator    &#123;        public static bool IsUnitTestMode &#123; get; set; &#125;        public static T CreateMonoSingleton&lt;T&gt;() where T : MonoBehaviour, ISingleton        &#123;            T instance = null;            //判断是否需要创建            if (!IsUnitTestMode &amp;&amp; !Application.isPlaying) return instance;            instance = Object.FindObjectOfType&lt;T&gt;();            //如果已经存在了就初始化并且返回            if (instance != null)            &#123;                instance.OnInitSingleton();                return instance;            &#125;            //获取成员信息            MemberInfo info = typeof(T);            var attributes = info.GetCustomAttributes(true);            foreach (var atribute in attributes)            &#123;                var defineAttri = atribute as MonoSingletonPath;                if (defineAttri == null)                &#123;                    continue;                &#125;                instance = CreateComponentOnGameObject&lt;T&gt;(defineAttri.PathInHierarchy, true);                break;            &#125;            if (instance == null)            &#123;                var obj = new GameObject(typeof(T).Name);                if (!IsUnitTestMode)                    Object.DontDestroyOnLoad(obj);                instance = obj.AddComponent&lt;T&gt;();            &#125;            instance.OnInitSingleton();            return instance;        &#125;        private static T CreateComponentOnGameObject&lt;T&gt;(string path, bool dontDestroy) where T : MonoBehaviour        &#123;            var obj = FindGameObject(path, true, dontDestroy);            if (obj == null)            &#123;                obj = new GameObject(&quot;Singleton of &quot; + typeof(T).Name);                if (dontDestroy &amp;&amp; !IsUnitTestMode)                &#123;                    Object.DontDestroyOnLoad(obj);                &#125;            &#125;            return obj.AddComponent&lt;T&gt;();        &#125;        private static GameObject FindGameObject(string path, bool build, bool dontDestroy)        &#123;            if (string.IsNullOrEmpty(path))            &#123;                return null;            &#125;            var subPath = path.Split(&#39;/&#39;);            if (subPath == null || subPath.Length == 0)            &#123;                return null;            &#125;            return FindGameObject(null, subPath, 0, build, dontDestroy);        &#125;        private static GameObject FindGameObject(GameObject root, string[] subPath, int index, bool build,            bool dontDestroy)        &#123;            GameObject client = null;            if (root == null)            &#123;                client = GameObject.Find(subPath[index]);            &#125;            else            &#123;                var child = root.transform.Find(subPath[index]);                if (child != null)                &#123;                    client = child.gameObject;                &#125;            &#125;            if (client == null)            &#123;                if (build)                &#123;                    client = new GameObject(subPath[index]);                    if (root != null)                    &#123;                        client.transform.SetParent(root.transform);                    &#125;                    if (dontDestroy &amp;&amp; index == 0 &amp;&amp; !IsUnitTestMode)                    &#123;                        GameObject.DontDestroyOnLoad(client);                    &#125;                &#125;            &#125;            if (client == null)            &#123;                return null;            &#125;            return ++index == subPath.Length ? client : FindGameObject(client, subPath, index, build, dontDestroy);        &#125;    &#125;#endif&#125;</code></pre></details><p>普通单例的测试脚本如下：  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><pre><code>public class TestSingletonClass : Singleton&lt;TestSingletonClass&gt;&#123;    private TestSingletonClass()    &#123;            &#125;&#125;public class LBSingletonTest&#123;        [Test]    public void Test()    &#123;        TestSingletonClass objA = TestSingletonClass.Instabce;        TestSingletonClass objB = TestSingletonClass.Instabce;                Assert.AreSame(objA, objB);    &#125;&#125;</code></pre></details><h2 id="LBEventSystem-事件系统"><a href="#LBEventSystem-事件系统" class="headerlink" title="LBEventSystem 事件系统"></a>LBEventSystem 事件系统</h2><p>事件系统采用的是接口的形式，需要接收事件的类只需要继承对应的接口就可以了，然后实现对应的接口，然后通过接口来接收对应的事件ID，通过判断ID来实现对应的事件。  </p><p>事件系统对应的脚本如下：  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><p>脚本一(接口)：  </p><pre><code>//事件系统对应的接口public interface ILBEventHandler&#123;    void HandleEvent(int eventId, LBEventComArg arg = null);&#125;</code></pre><p>脚本二(数据)：</p><pre><code>//事件系统传输的数据public class LBEventComArg&#123;    #region 获取多参数类型    public bool TryGet&lt;T&gt;(out T t)    &#123;        LBEventOneArg&lt;T&gt; arg = this as LBEventOneArg&lt;T&gt;;        arg.Get(out t);        return true;    &#125;    public bool TryGet&lt;T,U&gt;(out T t,out U u)    &#123;        LBEventTwoArg&lt;T,U&gt; arg = this as LBEventTwoArg&lt;T,U&gt;;        arg.Get(out t,out u);        return true;    &#125;    public bool TryGet&lt;T,U,K&gt;(out T t,out U u,out K k)    &#123;        LBEventThreeArg&lt;T,U,K&gt; arg = this as LBEventThreeArg&lt;T,U,K&gt;;        arg.Get(out t,out u,out k);        return true;    &#125;    public bool TryGet&lt;T,U,K,I&gt;(out T t,out U u,out K k,out I i)    &#123;        LBEventFourArg&lt;T,U,K,I&gt; arg = this as LBEventFourArg&lt;T,U,K,I&gt;;        arg.Get(out t,out u,out k,out i);        return true;    &#125;    public bool TryGet&lt;T,U,K,I,W&gt;(out T t,out U u,out K k,out I i,out W w)    &#123;        LBEventFiveArg&lt;T,U,K,I,W&gt; arg = this as LBEventFiveArg&lt;T,U,K,I,W&gt;;        arg.Get(out t,out u,out k,out i,out w);        return true;    &#125;    #endregion&#125;#region  多参数数据类public class LBEventOneArg&lt;T&gt; : LBEventComArg&#123;    private T m_t;    public void Set(T t) &#123; m_t = t; &#125;    public void Get(out T t) &#123; t = m_t; &#125;&#125;public class LBEventTwoArg&lt;T,U&gt; : LBEventComArg&#123;    private T m_t; private U m_u;    public void Set(T t,U u) &#123; m_t = t; m_u = u; &#125;    public void Get(out T t,out U u) &#123; t = m_t; u = m_u; &#125;&#125;public class LBEventThreeArg&lt;T,U,K&gt; : LBEventComArg&#123;    private T m_t; private U m_u; private K m_k;    public void Set(T t,U u,K k) &#123; m_t = t; m_u = u; m_k = k; &#125;    public void Get(out T t,out U u,out K k) &#123; t = m_t; u = m_u; k = m_k; &#125;&#125;public class LBEventFourArg&lt;T,U,K,I&gt; : LBEventComArg&#123;    private T m_t; private U m_u; private K m_k; private I m_i;    public void Set(T t,U u,K k,I i) &#123; m_t = t; m_u = u; m_k = k; m_i = i; &#125;    public void Get(out T t,out U u,out K k,out I i) &#123; t = m_t; u = m_u; k = m_k; i = m_i; &#125;&#125;public class LBEventFiveArg&lt;T,U,K,I,W&gt; : LBEventComArg&#123;    private T m_t; private U m_u; private K m_k; private I m_i; private W m_w;    public void Set(T t,U u,K k,I i,W w) &#123; m_t = t; m_u = u; m_k = k; m_i = i; m_w = w; &#125;    public void Get(out T t,out U u,out K k,out I i,out W w) &#123; t = m_t; u = m_u; k = m_k; i = m_i; w = m_w; &#125;&#125;#endregion</code></pre><p>脚本三(通信)：</p><pre><code>//自定义事件委托类型public delegate void CustomEventHandler(LBEventComArg arg = null);public class LBEventDispatcher:Singleton&lt;LBEventDispatcher&gt;&#123;    private readonly Dictionary&lt;int, HashSet&lt;ILBEventHandler&gt;&gt; id2HandlerDict = new Dictionary&lt;int, HashSet&lt;ILBEventHandler&gt;&gt;();    private readonly Dictionary&lt;int, CustomEventHandler&gt; id2DeleDict = new Dictionary&lt;int, CustomEventHandler&gt;();    private LBEventDispatcher()    &#123;            &#125;    public void AddListener(int eventId, ILBEventHandler handler)    &#123;        if (!id2HandlerDict.TryGetValue(eventId, out HashSet&lt;ILBEventHandler&gt; handlerSet))            handlerSet = id2HandlerDict[eventId] = new HashSet&lt;ILBEventHandler&gt;();        handlerSet.Add(handler);    &#125;        public void AddListener(int eventId, CustomEventHandler eventHandleDele)    &#123;        if (id2DeleDict.TryGetValue(eventId, out CustomEventHandler eventDele))        &#123;            Delegate[] delegates = eventHandleDele.GetInvocationList();            if (Array.IndexOf(delegates, eventHandleDele) == -1)                eventDele += eventHandleDele;        &#125;        else            id2DeleDict.Add(eventId, eventHandleDele);    &#125;    public void SendEvent(int eventId)    &#123;        TiggerEvent(eventId,null);        //当函数参数不需要赋值的时候就赋值一个NULL,减少GC    &#125;    public void SendEvent&lt;T&gt;(int eventId, T arg1)    &#123;        //临时闯将将来可以换成对象池        LBEventOneArg&lt;T&gt; eventArg = new LBEventOneArg&lt;T&gt;();        eventArg.Set(arg1);        TiggerEvent(eventId,eventArg);        //如果用对象池，在这里就可以回收    &#125;    public void SendEvent&lt;T,U&gt;(int eventId, T arg1,U arg2)    &#123;        //临时闯将将来可以换成对象池        LBEventTwoArg&lt;T,U&gt; eventArg = new LBEventTwoArg&lt;T,U&gt;();        eventArg.Set(arg1,arg2);        TiggerEvent(eventId,eventArg);        //如果用对象池，在这里就可以回收    &#125;    public void SendEvent&lt;T,U,K&gt;(int eventId, T arg1,U arg2,K arg3)    &#123;        //临时闯将将来可以换成对象池        LBEventThreeArg&lt;T,U,K&gt; eventArg = new LBEventThreeArg&lt;T,U,K&gt;();        eventArg.Set(arg1,arg2,arg3);        TiggerEvent(eventId,eventArg);        //如果用对象池，在这里就可以回收    &#125;    public void SendEvent&lt;T,U,K,I&gt;(int eventId, T arg1,U arg2,K arg3,I arg4)    &#123;        //临时闯将将来可以换成对象池        LBEventFourArg&lt;T,U,K,I&gt; eventArg = new LBEventFourArg&lt;T,U,K,I&gt;();        eventArg.Set(arg1,arg2,arg3,arg4);        TiggerEvent(eventId,eventArg);        //如果用对象池，在这里就可以回收    &#125;        private void TiggerEvent(int eventId, LBEventComArg arg)    &#123;        if (id2HandlerDict.TryGetValue(eventId, out HashSet&lt;ILBEventHandler&gt; handlerSet))        &#123;            foreach (var handler in handlerSet)            &#123;                handler.HandleEvent(eventId, arg);            &#125;        &#125;        if (id2DeleDict.TryGetValue(eventId, out CustomEventHandler oldDele))        &#123;            oldDele.Invoke(arg);        &#125;    &#125;        public void RemoveListener(int eventId, ILBEventHandler handler)    &#123;        if (id2HandlerDict.TryGetValue(eventId, out HashSet&lt;ILBEventHandler&gt; handlerSet))        &#123;            id2HandlerDict[eventId].Remove(handler);        &#125;    &#125;    public void RemoveListener(int eventId, CustomEventHandler eventHandlerDele)    &#123;        if (id2DeleDict.TryGetValue(eventId, out CustomEventHandler oldDele))        &#123;            oldDele -= eventHandlerDele;            if (oldDele == null)                id2DeleDict.Remove(eventId);        &#125;    &#125;    public void Destruct()    &#123;        id2HandlerDict.Clear();        id2DeleDict.Clear();    &#125;&#125;</code></pre></details><p>事件系统的单元测试如下所示：  </p><details><summary><font color=darkred>点击查看脚本详细内容</font></summary><pre><code>public enum LBEventTestType&#123;    EventTestType = 100,&#125;public class LBEventSystemClass:ILBEventHandler&#123;    public int testValue = 5;        public void HandleEvent(int eventId, LBEventComArg arg = null)    &#123;        switch ((LBEventTestType)eventId)        &#123;            case LBEventTestType.EventTestType:                arg.TryGet(out testValue);                break;        &#125;    &#125;&#125;public class LBEventSystemTest&#123;    [Test]    public void EventTest()    &#123;        LBEventSystemClass testClass = new LBEventSystemClass();        LBEventDispatcher.Instabce.AddListener((int)LBEventTestType.EventTestType, testClass);        LBEventDispatcher.Instabce.SendEvent((int)LBEventTestType.EventTestType,10);                Assert.AreEqual(testClass.testValue,10);    &#125;&#125;</code></pre></details>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LBFramework简介&quot;&gt;&lt;a href=&quot;#LBFramework简介&quot; class=&quot;headerlink&quot; title=&quot;LBFramework简介&quot;&gt;&lt;/a&gt;LBFramework简介&lt;/h1&gt;&lt;p&gt;&lt;font size=4&gt;&lt;strong&gt;单元测试环</summary>
      
    
    
    
    <category term="Unity框架" scheme="http://yoursite.com/categories/Unity%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="LBFramework" scheme="http://yoursite.com/tags/LBFramework/"/>
    
  </entry>
  
  <entry>
    <title>git学习笔记</title>
    <link href="http://yoursite.com/2019/11/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/11/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-11-24T03:09:11.000Z</published>
    <updated>2021-12-27T03:39:09.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><ol><li><p>初始化仓库，可以将本地目录变成git可以管理的本地仓库  </p><pre><code> git init</code></pre></li><li><p>关联远程仓库，可以将本地仓库与远程仓库关联，切记是<strong>本地仓库</strong>，不是本地目录，可以先利用<strong>git init</strong>将本地目录编程本地仓库后再进行关联。  </p><pre><code> git remote add origin 仓库地址</code></pre></li><li><p>取消关联地址</p><pre><code> git remote rm origin</code></pre></li><li><p>将远程仓库与本地仓库同步合并，下列命令是合并master分支</p><pre><code> git pull --rebase origin master</code></pre></li><li><p>查看远程分支命令和查看本地分支</p><pre><code> git branch -a    //查看远程分支 git branch        //查看本地分支</code></pre></li><li><p>切换分支命令</p><pre><code> git checkout 分支名字</code></pre></li><li><p>查看仓库状态</p><pre><code> git status</code></pre></li><li><p>将工作区内容添加到缓存区</p><pre><code> git add .        //所有内容添加 git add            //选择内容添加</code></pre></li><li><p>缓存区内容提交到本地仓库区</p><pre><code> git commit -m &quot;提交注释&quot;</code></pre></li><li><p>把本地仓库代码内容推送到远程仓库  </p><pre><code>git push -u origin master</code></pre></li><li><p>查看日志(历史版本)</p><pre><code>git loggit reflog</code></pre></li><li><p>撤销修改<br>— 撤销文件在工作区的修改:  </p><pre><code>git checkout -- 文件名git checkout</code></pre><p>— 撤销文件在缓存区的修改:  </p><pre><code>git reset 文件名          # 撤销指定文件的git add操作，即在缓存区的修改git reset                # 撤销之前所有的git add操作，即在缓存区的修改</code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;git常用命令&quot;&gt;&lt;a href=&quot;#git常用命令&quot; class=&quot;headerlink&quot; title=&quot;git常用命令&quot;&gt;&lt;/a&gt;git常用命令&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;初始化仓库，可以将本地目录变成git可以管理的本地仓库  &lt;/p&gt;
&lt;pre&gt;&lt;c</summary>
      
    
    
    
    <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>bat学习笔记</title>
    <link href="http://yoursite.com/2019/11/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/bat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/11/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/bat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-11-24T02:05:06.000Z</published>
    <updated>2021-12-27T03:39:09.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="bat文件执行多条命令"><a href="#bat文件执行多条命令" class="headerlink" title=".bat文件执行多条命令"></a>.bat文件执行多条命令</h2><p>笔者博客利用的是hexo+github搭建的，每次提交都会重复输入多条命令，于是笔者想到用一个bat脚本来代替这些重复的命令，但是，笔者发现bat在执行多条命令的情况下，不会等第一条命令执行完再去执行下一条命令，第一条命令执行的时候下一条命令还会继续执行，所以就会导致只执行第一条命令，笔者查了许多资料，最后了以下两种方法：  </p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><pre><code>命令1 &amp; 命令2 &amp; 命令3 ... (无论前面命令是否故障,照样执行后面)   命令1 &amp;&amp; 命令2 &amp;&amp; 命令3....(仅当前面命令成功时,才执行后面)   命令1 || 命令2 || 命令3.... (仅当前面命令失败时.才执行后面)</code></pre><p>下面来看看示例代码：</p><pre><code>call git add .&amp;&amp;git status&amp;&amp;git commit -m &quot;backups&quot;&amp;&amp;git pull --rebase origin master&amp;&amp;git push</code></pre><p>这条执行会一步一步执行命令，如果一条命令失败，就会停止。  </p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>此类方法并不是作者从网上查到了，是笔者一步一步试验出来的，如果存在问题，欢迎联系作者讨论。  </p><pre><code>call 命令1call 命令2call 命令3...</code></pre><p>笔者发现，每次在命令前加上call，就会等上一个命令结束后执行(不管错与对，只要上面结束就会停止)。<br>下面来看看笔者完成后的完整代码：  </p><pre><code>@echo off call cd D:/blogcall hexo cleancall hexo g -dcall pausecall git add .&amp;&amp;git status&amp;&amp;git commit -m &quot;backups&quot;&amp;&amp;git pull --rebase origin master&amp;&amp;git pushcall pause</code></pre><h2 id="bat变量的输入和赋值"><a href="#bat变量的输入和赋值" class="headerlink" title=".bat变量的输入和赋值"></a>.bat变量的输入和赋值</h2><p>在上文中，我们还可以改进一下，就是博客文件地址，其实可以用变量代替，因为代码有点短，而且很少更改，所以这一点就不用改进了，换地址直接换一行就行了，笔者在每次创建博客的时候，也会重复输入“hexo new post ‘’”,这种重复命令，虽然不多，但是，当你写一些专栏的时候，你会发现名字有很多重复的地方，这时候就会体现出变量的作用。<br>示例代码：</p><pre><code>@echo off call cd D:/blogset/p name=please input name:call hexo new post &quot;%name%&quot;call pause</code></pre><p>从代码中可以看书，输入变量的命令就是：**set/p 变量名 = 输入描述(可以为空)**，这里要切记，set/p中间不要加空格，笔者在这里也被坑了，加上空格后，有些变量赋值就会出现问题，至于原因，笔者还在研究，大家先记住就好了，下面来看看写专栏重复名字的时候，应该如何优化吧。<br>代码如下：  </p><pre><code>@echo off call cd D:/blogset/p number=please input UniRx number:set/p name=please input UniRx name:call hexo new post &quot;UniRx精讲(%number%)——%name%&quot;call pause</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;bat文件执行多条命令&quot;&gt;&lt;a href=&quot;#bat文件执行多条命令&quot; class=&quot;headerlink&quot; title=&quot;.bat文件执行多条命令&quot;&gt;&lt;/a&gt;.bat文件执行多条命令&lt;/h2&gt;&lt;p&gt;笔者博客利用的是hexo+github搭建的，每次提交都会重复输</summary>
      
    
    
    
    <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="BAT" scheme="http://yoursite.com/tags/BAT/"/>
    
  </entry>
  
  <entry>
    <title>Odin Inspector入门</title>
    <link href="http://yoursite.com/2019/10/29/Unity%E4%B8%93%E6%A0%8F/Odin-Inspector%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/10/29/Unity%E4%B8%93%E6%A0%8F/Odin-Inspector%E5%85%A5%E9%97%A8/</id>
    <published>2019-10-29T07:41:56.000Z</published>
    <updated>2021-12-27T03:39:09.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://odininspector.com/"><font color=steelblue size=5>官网</font></a><br><a href="https://assetstore.unity.com/packages/tools/utilities/odin-inspector-and-serializer-89041"><font color=steelblue size=5>AssetsStord地址</font></a><br><strong><font size=4>集成须知：如需获取对应Odin插件，请加QQ群：46885339，可在群文件中自行获取（如果放在github上就太放肆了。。。。）</font></strong>  </p><pre><code>unity:2019.2.0f1  Odin版本 2.1.5  </code></pre><p><a href="https://www.jianshu.com/p/f1b27e85bc35"><font color=steelblue size=3>参考博客：https://www.jianshu.com/p/f1b27e85bc35</font></a>  </p><h1 id="Essentials"><a href="#Essentials" class="headerlink" title="Essentials"></a>Essentials</h1><h2 id="Assets-Only-Attribute"><a href="#Assets-Only-Attribute" class="headerlink" title="Assets Only Attribute"></a>Assets Only Attribute</h2><p>Assets Only Attribute特性有两类：<br><strong>1.AssetsOnly</strong>： 点击需要序列化的资源字段时，在出现的弹窗中只有Project中的资源文件，不会出现Hierachy（场景）的资源<br><strong>2.SceneObjectsOnly</strong>： 点击需要序列化的资源字段时，在出现的弹窗中只有Hierachy中的资源文件，不会出现Project中的资源<br><strong>注意：例如：预制体等资源在Scene或者Project中都含有，出现的弹窗中也都会含有对应的资源</strong>   </p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><iframe height=1029 width=1375 src="https://upload-images.jianshu.io/upload_images/7643202-60190f219a6cbf63.gif">    <p>完整代码示例：  </p><pre><code>using Sirenix.OdinInspector;using System.Collections;using System.Collections.Generic;using UnityEngine;public class AssetsOnlyExample : MonoBehaviour&#123;    [Sirenix.OdinInspector.AssetsOnly]    public List&lt;GameObject&gt; OnlyPrefabs;    [Sirenix.OdinInspector.AssetsOnly]    public GameObject SomePrefab;    [Sirenix.OdinInspector.AssetsOnly]    public Material MaterialAsset;    [Sirenix.OdinInspector.AssetsOnly]    public MeshRenderer SomeMeshRendererOnPrefab;    [SceneObjectsOnly]    public List&lt;GameObject&gt; OnlySceneObjects;    [SceneObjectsOnly]    public GameObject SomeSceneObject;    [SceneObjectsOnly]    public MeshRenderer SomeMeshRenderer;&#125;</code></pre><p>创建上述脚本，添加到一个物体上即可，不同的标签选择资源的方式不一样。  </p><h2 id="Custom-Value-Drawer-Attribute"><a href="#Custom-Value-Drawer-Attribute" class="headerlink" title="Custom Value Drawer Attribute"></a>Custom Value Drawer Attribute</h2><p><strong>Custom Value Drawer Attribute 特性，允许用户自定义一个绘制方法，字段将以自定的绘制方式展示在Inspector中，非常灵活。</strong>  </p><h3 id="含有Label和不含有Label的字段"><a href="#含有Label和不含有Label的字段" class="headerlink" title="含有Label和不含有Label的字段"></a>含有Label和不含有Label的字段</h3><p><img src="https://upload-images.jianshu.io/upload_images/7643202-313444f24f0b9c5d.png"><br>代码如下：  </p><pre><code>[CustomValueDrawer(&quot;HaveLabelNameFunction&quot;)]public string HaveLabelName;[CustomValueDrawer(&quot;NoLabelNameFunction&quot;)]public string NoLabelName;public string HaveLabelNameFunction(string tempName, GUIContent label)&#123;    return EditorGUILayout.TextField(tempName);&#125;public string NoLabelNameFunction(string tempName, GUIContent label)&#123;    return EditorGUILayout.TextField(label,tempName);&#125;</code></pre><h3 id="绘制Slider滑动条"><a href="#绘制Slider滑动条" class="headerlink" title="绘制Slider滑动条"></a>绘制Slider滑动条</h3><iframe height=692 width=952 src="https://upload-images.jianshu.io/upload_images/7643202-0888c5e4ea14c3bb.gif">     代码如下：  <pre><code>public float Max = 100, Min = 0;[CustomValueDrawer(&quot;MyStaticCustomDrawerStatic&quot;)]public float CustomDrawerStatic;private static float MyStaticCustomDrawerStatic(float value, GUIContent label)&#123;    return EditorGUILayout.Slider(label, value, 0f, 10f);&#125;[CustomValueDrawer(&quot;MyStaticCustomDrawerInstance&quot;)]public float CustomDrawerInstance;private float MyStaticCustomDrawerInstance(float value, GUIContent label)&#123;    return EditorGUILayout.Slider(label, value, this.Min, this.Max);&#125;[CustomValueDrawer(&quot;MyStaticCustomDrawerArray&quot;)]public float[] CustomDrawerArray = new float[] &#123; 3f, 5f, 6f &#125;;private float MyStaticCustomDrawerArray(float value, GUIContent label)&#123;    return EditorGUILayout.Slider(value, this.Min, this.Max);&#125;</code></pre><h2 id="Delayed-Property-Attribute"><a href="#Delayed-Property-Attribute" class="headerlink" title="Delayed Property Attribute"></a>Delayed Property Attribute</h2><p>Delayed Property Attribute：此特性会延迟在editor中的序列化操作  </p><h3 id="即时性（非延迟）序列化"><a href="#即时性（非延迟）序列化" class="headerlink" title="即时性（非延迟）序列化"></a>即时性（非延迟）序列化</h3><iframe height=1060 width=1165 src="https://upload-images.jianshu.io/upload_images/7643202-24e1915e0255bb85.gif">   代码示例：  <pre><code>[OnValueChanged(&quot;ValueChangeCallBack&quot;)]public int field;//但是，正如名称所示，DelayedProperty应用于属性。[ShowInInspector][OnValueChanged(&quot;ValueChangeCallBack&quot;)]public string property &#123; get; set; &#125;public void ValueChangeCallBack()&#123;    Debug.Log(&quot;数值有变化&quot;);&#125;</code></pre><h3 id="延迟序列化"><a href="#延迟序列化" class="headerlink" title="延迟序列化"></a>延迟序列化</h3><iframe height=1060 width=1165 src="https://upload-images.jianshu.io/upload_images/7643202-aabb2c0456a4b3db.gif">   代码示例：  <pre><code>// 延迟和延迟属性实际上是相同的[Delayed][OnValueChanged (&quot;ValueChangeCallBack&quot;)]public int delayedField;//但是，正如名称所示，DelayedProperty应用于属性。[ShowInInspector, DelayedProperty][OnValueChanged(&quot;ValueChangeCallBack&quot;)]public string delayedProperty &#123; get; set; &#125;public void ValueChangeCallBack()&#123;    Debug.Log(&quot;数值有变化&quot;);&#125;</code></pre><h3 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h3><pre><code>using Sirenix.OdinInspector;using UnityEngine;public class DelayedPropertyExample : MonoBehaviour&#123;    [OnValueChanged(&quot;ValueChangeCallBack&quot;)]    public int field;    //但是，正如名称所示，DelayedProperty应用于属性。    [ShowInInspector]    [OnValueChanged(&quot;ValueChangeCallBack&quot;)]    public string property &#123; get; set; &#125;    // 延迟和延迟属性实际上是相同的    [Delayed]    [OnValueChanged (&quot;ValueChangeCallBack&quot;)]    public int delayedField;    //但是，正如名称所示，DelayedProperty应用于属性。    [ShowInInspector, DelayedProperty]    [OnValueChanged(&quot;ValueChangeCallBack&quot;)]    public string delayedProperty &#123; get; set; &#125;    public void ValueChangeCallBack()    &#123;        Debug.Log(&quot;数值有变化&quot;);    &#125;&#125;</code></pre><h2 id="Detailed-Info-Box-Attribute"><a href="#Detailed-Info-Box-Attribute" class="headerlink" title="Detailed Info Box Attribute"></a>Detailed Info Box Attribute</h2><pre><code>Detailed Info Box Attribute特性：  在Inspector面板中绘制一个信息面板，添加对应标题和详细信息描述，点击时可以显示出对应填写的详细信息</code></pre><iframe height=497 width=1178 src="https://upload-images.jianshu.io/upload_images/7643202-1f53cd969010afdc.gif">   ### 不同形式的消息框<iframe height=913 width=1320 src="https://upload-images.jianshu.io/upload_images/7643202-dc94efb220edcae3.gif">  示例代码：  <pre><code>[DetailedInfoBox(&quot;简介消息&quot;, &quot;默认情况下VisibleIf为True，所以此消息框可见&quot;, InfoMessageType = InfoMessageType.None)]public string NoneMessage = &quot;无&quot;;[DetailedInfoBox(&quot;简介消息&quot;, &quot;默认情况下VisibleIf为True，所以此消息框可见&quot;, InfoMessageType = InfoMessageType.Info)]public string InfoMessage = &quot;无&quot;;[DetailedInfoBox(&quot;简介消息&quot;, &quot;默认情况下VisibleIf为True，所以此消息框可见&quot;, InfoMessageType = InfoMessageType.Warning)]public string WarningMessage = &quot;无&quot;;[DetailedInfoBox(&quot;简介消息&quot;, &quot;默认情况下VisibleIf为True，所以此消息框可见&quot;, InfoMessageType = InfoMessageType.Error)]public string ErrorMessage = &quot;无&quot;;</code></pre><p>还可以通过一个方法的返回值（bool）来控制消息框是否显示，例如在这个函数中判断此字段是否为null，如果为null在出现弹窗提示等。<br><img src="https://upload-images.jianshu.io/upload_images/7643202-7dc744da0b791cdd.png"><br>示例代码：  </p><p>   [DetailedInfoBox(“简介消息”, “默认情况下VisibleIf为True。” +<br>        “所以此消息框可见.还可以通过一个方法的返回值（bool）来控制消息框是否显示，” +<br>        “例如在这个函数中判断此字段是否为null，如果为null在出现弹窗提示等。”,<br>        InfoMessageType = InfoMessageType.None, VisibleIf = “VisibleFunction”)]<br>    public string haveVisibleIfMessage = “”;</p><pre><code>[DetailedInfoBox(&quot;简介消息&quot;, &quot;还可以通过一个方法的返回值（bool）来控制消息框是否显示，例如在这个函数中判断此字段是否为null，如果为null在出现弹窗提示等。&quot;, InfoMessageType = InfoMessageType.None, VisibleIf = &quot;NoVisibleFunction&quot;)]public string noVisibleIfMessage = &quot;&quot;;public  bool VisibleFunction()&#123;    /*     * 根据情况下选择返回true或者false，让对应的消息框显示或者不显示     */    return true;&#125;public bool NoVisibleFunction()&#123;    return false;&#125;</code></pre><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code>using Sirenix.OdinInspector;using UnityEngine;public class DetailedInfoBoxExample : MonoBehaviour&#123;    [DetailedInfoBox(&quot;详情请点击...&quot;,        &quot;菜鸟海澜：下面是详细信息，这个欢迎大家留言指正，对应的工程已经上传Github，&quot; +        &quot;地址为：https://github.com/su9257/Odin-Inspector-Chinese-Tutorial&quot;)]    public string message = &quot;无&quot;;    [DetailedInfoBox(&quot;简介消息&quot;, &quot;默认情况下VisibleIf为True，所以此消息框可见&quot;, InfoMessageType = InfoMessageType.None)]    public string NoneMessage = &quot;无&quot;;    [DetailedInfoBox(&quot;简介消息&quot;, &quot;默认情况下VisibleIf为True，所以此消息框可见&quot;, InfoMessageType = InfoMessageType.Info)]    public string InfoMessage = &quot;无&quot;;    [DetailedInfoBox(&quot;简介消息&quot;, &quot;默认情况下VisibleIf为True，所以此消息框可见&quot;, InfoMessageType = InfoMessageType.Warning)]    public string WarningMessage = &quot;无&quot;;    [DetailedInfoBox(&quot;简介消息&quot;, &quot;默认情况下VisibleIf为True，所以此消息框可见&quot;, InfoMessageType = InfoMessageType.Error)]    public string ErrorMessage = &quot;无&quot;;    [DetailedInfoBox(&quot;简介消息&quot;, &quot;默认情况下VisibleIf为True。&quot; +        &quot;所以此消息框可见.还可以通过一个方法的返回值（bool）来控制消息框是否显示，&quot; +        &quot;例如在这个函数中判断此字段是否为null，如果为null在出现弹窗提示等。&quot;,         InfoMessageType = InfoMessageType.None, VisibleIf = &quot;VisibleFunction&quot;)]    public string haveVisibleIfMessage = &quot;&quot;;    [DetailedInfoBox(&quot;简介消息&quot;, &quot;还可以通过一个方法的返回值（bool）来控制消息框是否显示，例如在这个函数中判断此字段是否为null，如果为null在出现弹窗提示等。&quot;, InfoMessageType = InfoMessageType.None, VisibleIf = &quot;NoVisibleFunction&quot;)]    public string noVisibleIfMessage = &quot;&quot;;    public  bool VisibleFunction()    &#123;        /*         * 根据情况下选择返回true或者false，让对应的消息框显示或者不显示         */        return true;    &#125;    public bool NoVisibleFunction()    &#123;        return false;    &#125;&#125;</code></pre><h2 id="Enable-GUIAttribute"><a href="#Enable-GUIAttribute" class="headerlink" title="Enable GUIAttribute"></a>Enable GUIAttribute</h2><pre><code>Enable GUIAttribute特性：可以控制只有Get的属性，在Inspector中是否为可灰态的（但是依然不可编辑），不写则默认为灰态。</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/7643202-f2480f12bbd7a2aa.png"><br>完整代码：  </p><pre><code>using Sirenix.OdinInspector;using UnityEngine;public class EnableGUIExample : MonoBehaviour&#123;    [ShowInInspector]    public int GUIDisabledProperty &#123; get &#123; return 20; &#125; &#125;    [ShowInInspector, EnableGUI]    public int GUIEnabledProperty &#123; get &#123; return 10; &#125; &#125;&#125;</code></pre><h2 id="GUIColor-Attribute"><a href="#GUIColor-Attribute" class="headerlink" title="GUIColor Attribute"></a>GUIColor Attribute</h2><pre><code>GUIColor Attribute特性：用于任何属性，并更改用于绘制属性的GUI颜色。</code></pre><iframe height=617 width=1178 src="https://upload-images.jianshu.io/upload_images/7643202-e08001dd13334857.gif" >  **绘制颜色提供两种形式，一种为直接填写RGBA**  ![](https://upload-images.jianshu.io/upload_images/7643202-5257872b7b4864c0.png)  代码如下：    <pre><code>[GUIColor(0.3f, 0.8f, 0.8f, 1f)]public int ColoredInt1;[GUIColor(0.3f, 0.8f, 0.8f, 1f)]public int ColoredInt2;[ButtonGroup][GUIColor(0, 1, 0)]private void Apply()&#123;    Debug.Log(&quot;应用&quot;);&#125;[ButtonGroup][GUIColor(1, 0.6f, 0.4f)]private void Cancel()&#123;    Debug.Log(&quot;取消&quot;);&#125;</code></pre><p><strong>另一种是提供一个返回Color的方法，所以这种方式可有实现动态颜色效果，逼格满满</strong>   </p><iframe height=322 width=758 src="https://upload-images.jianshu.io/upload_images/7643202-568d1ad9fd14b5ed.gif"></iframe>  代码如下：  <pre><code>[GUIColor(&quot;GetButtonColor&quot;)][Button(ButtonSizes.Gigantic)]private static void IAmFabulous()&#123;&#125;private static Color GetButtonColor()&#123;    Sirenix.Utilities.Editor.GUIHelper.RequestRepaint();    return Color.HSVToRGB(Mathf.Cos((float)UnityEditor.EditorApplication.timeSinceStartup + 1f) * 0.225f + 0.325f, 1, 1);&#125;</code></pre><p><strong>当然还有另一种写法，使用@关键字将对应的方法体以字符串的形式传入进去，也能达到和方法一样的效果</strong>  </p><pre><code>// [GUIColor(&quot;@Color.Lerp(Color.red, Color.green, Mathf.Sin((float)EditorApplication.timeSinceStartup))&quot;)]// [GUIColor(&quot;CustomColor&quot;)]// 这两个写法相等[Button(ButtonSizes.Large)][GUIColor(&quot;@Color.Lerp(Color.red, Color.green, Mathf.Sin((float)EditorApplication.timeSinceStartup))&quot;)]private static void Expressive_One()&#123;&#125;[Button(ButtonSizes.Large)][GUIColor(&quot;CustomColor&quot;)]private static void Expressive_Two()&#123;&#125;# if UNITY_EDITORpublic Color CustomColor()&#123;    return Color.Lerp(Color.red, Color.green, Mathf.Sin((float)EditorApplication.timeSinceStartup));&#125;# endif</code></pre><p>完整的代码：  </p><pre><code>using Sirenix.OdinInspector;using UnityEditor;using UnityEngine;public class GUIColorExample : MonoBehaviour&#123;    [GUIColor(0.3f, 0.8f, 0.8f, 1f)]    public int ColoredInt1;    [GUIColor(0.3f, 0.8f, 0.8f, 1f)]    public int ColoredInt2;    [ButtonGroup]    [GUIColor(0, 1, 0)]    private void Apply()    &#123;        Debug.Log(&quot;应用&quot;);    &#125;    [ButtonGroup]    [GUIColor(1, 0.6f, 0.4f)]    private void Cancel()    &#123;        Debug.Log(&quot;取消&quot;);    &#125;    [GUIColor(&quot;GetButtonColor&quot;)]    [Button(ButtonSizes.Gigantic)]    private static void IAmFabulous()    &#123;    &#125;    private static Color GetButtonColor()    &#123;        Sirenix.Utilities.Editor.GUIHelper.RequestRepaint();        return Color.HSVToRGB(Mathf.Cos((float)UnityEditor.EditorApplication.timeSinceStartup + 1f) * 0.225f + 0.325f, 1, 1);    &#125;    // [GUIColor(&quot;@Color.Lerp(Color.red, Color.green, Mathf.Sin((float)EditorApplication.timeSinceStartup))&quot;)]    // [GUIColor(&quot;CustomColor&quot;)]    // 这两个写法相等    [Button(ButtonSizes.Large)]    [GUIColor(&quot;@Color.Lerp(Color.red, Color.green, Mathf.Sin((float)EditorApplication.timeSinceStartup))&quot;)]    private static void Expressive_One()    &#123;    &#125;    [Button(ButtonSizes.Large)]    [GUIColor(&quot;CustomColor&quot;)]    private static void Expressive_Two()    &#123;    &#125;# if UNITY_EDITOR    public Color CustomColor()    &#123;        return Color.Lerp(Color.red, Color.green, Mathf.Sin((float)EditorApplication.timeSinceStartup));    &#125;# endif&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://odininspector.com/&quot;&gt;&lt;font color=steelblue size=5&gt;官网&lt;/</summary>
      
    
    
    
    <category term="Unity专栏" scheme="http://yoursite.com/categories/Unity%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="Odin Inspector" scheme="http://yoursite.com/tags/Odin-Inspector/"/>
    
  </entry>
  
  <entry>
    <title>常用网站网址</title>
    <link href="http://yoursite.com/2019/10/14/%E5%85%B6%E4%BB%96/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99%E7%BD%91%E5%9D%80/"/>
    <id>http://yoursite.com/2019/10/14/%E5%85%B6%E4%BB%96/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99%E7%BD%91%E5%9D%80/</id>
    <published>2019-10-14T05:20:04.000Z</published>
    <updated>2021-12-27T03:39:09.485Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhutix.com/"><font color=steelblue size=5>致美化</font></a><br><a href="https://www.jianshu.com/p/f1b27e85bc35"><font color=steelblue size=5>Odin Inspector</font></a><br><a href="https://unity.cn/"><font color=steelblue size=5>Unity网址</font></a><br><a href="https://github.com/strangeioc/strangeioc"><font color=steelblue size=5>StrangeIOC开源网址</font></a><br><a href="https://kb.cnblogs.com/page/42470/"><font color=steelblue size=5>LINQ</font></a><br><a href="https://hexo.io/themes/"><font color=steelblue size=5>hexo主题</font></a><br><a href="https://www.cnblogs.com/wangshenhe/p/3256657.html"><font color=steelblue size=5>反射博客</font></a><br><a href="https://blog.csdn.net/qq_36848370/article/details/103125352"><font color=steelblue size=5>ShareSDK</font></a><br><a href="https://blog.uwa4d.com/"><font color=steelblue size=5>UWA</font></a><br><a href="https://www.syntevo.com/cn/smartgit/register-non-commercial/"><font color=steelblue size=5>SmartGit获取免费key</font></a><br><a href="https://www.jishuqq.com/QQjiqiao/2019/0108/62573.html"><font color=steelblue size=5>在线接收短信</font></a><br><a href="https://refactoringguru.cn/"><font color=steelblue size=5>重构与设计模式</font></a><br><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md"><font color=steelblue size=5>博客添加看板娘</font></a><br><a href="https://suulnnka.github.io/BullshitGenerator/index.html"><font color=steelblue size=5>文章生成器</font></a><br><a href="http://www.aisharing.com/archives"><font color=steelblue size=5>AI分享网站</font></a><br><a href="https://visualgo.net/zh"><font color=steelblue size=5>算法可视化</font></a><br><a href="https://bestcclm.com/"><font color=steelblue size=5>破解网址</font></a><br><a href="https://greasyfork.org/zh-CN"><font color=steelblue size=5>greasyfork</font></a><br><a href="http://tonytang1990.github.io/2017/04/29/Unity%E8%87%AA%E5%8A%A8%E5%8C%96&IOS%E8%87%AA%E5%8A%A8%E5%8C%96%E7%AD%BE%E5%8C%85/"><font color=steelblue size=5>Unity自动化&amp;IOS自动化签包</font></a><br><a href="https://www.jingfengji.tech/"><font color=steelblue size=5>JingFengJi博客</font></a><br><a href="https://www.jianshu.com/p/cd7be494435a"><font color=steelblue size=5>AWS CLI使用方法</font></a><br><a href="https://www.jianshu.com/p/4fee08fc531c?utm_campaign=haruki&utm_content=note&utm_medium=reader_share&utm_source=qq"><font color=steelblue size=5>【Unity项目实战】主程进阶之路文章整理</font></a><br><a href="https://github.com/mob-sakai"><font color=steelblue size=5>特殊UI的Git仓库</font></a><br><a href="https://aihailan.com/blog/"><font color=steelblue size=5>海澜大佬博客</font></a><br><a href="https://www.yomunchan.moe/"><font color=steelblue size=5>有木酱的小屋</font></a><br><a href="https://unityassetcollection.com/"><font color=steelblue size=5>Unity资源</font></a>  </p><pre><code>Markdown插入gif&amp;&amp;图片：&lt;iframe height=1375 width=1029                       src=&quot;https://upload-images.jianshu.io/upload_images/7643202-60190f219a6cbf63.gif&quot;                       frameborder=0 allowfullscreen&gt;&lt;/iframe&gt;    </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhutix.com/&quot;&gt;&lt;font color=steelblue size=5&gt;致美化&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/f1b27e85bc35&quot;&gt;&lt;font color</summary>
      
    
    
    
    <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="网址" scheme="http://yoursite.com/tags/%E7%BD%91%E5%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——AssetDatabase资源数据库</title>
    <link href="http://yoursite.com/2019/09/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94AssetDatabase%E8%B5%84%E6%BA%90%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2019/09/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94AssetDatabase%E8%B5%84%E6%BA%90%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2019-09-30T06:22:19.000Z</published>
    <updated>2021-12-27T03:39:09.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>unity中有个类，叫做AssetDatabase，这是一个在编辑器(Editor)下使用的一个类，是一个允许您访问工程中资源的API。这个类包含了查找、加载、创建、删除和修改资源等。这个类仅适用于编辑器状态下。</p><h1 id="导入资源"><a href="#导入资源" class="headerlink" title="导入资源"></a>导入资源</h1><p>unity不仅仅可以通过拖拽导入资源，还可以通过脚本导入资源，代码如下：  </p><pre><code>sing UnityEngine;using UnityEditor; public class ImportAsset &#123;    [MenuItem (&quot;AssetDatabase/ImportExample&quot;)]    static void ImportExample ()    &#123;        AssetDatabase.ImportAsset(&quot;资源路径+资源名字&quot;, ImportAssetOptions.Default);    &#125;&#125;</code></pre><h1 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h1><p>加载资源有很多API，大家可以参考API手册进行操作，加载API包含：</p><pre><code>AssetDatabase.LoadAssetAtPathAssetDatabase.LoadMainAssetAtPathAssetDatabase.LoadAllAssetRepresentationsAtPathAssetDatabase.LoadAllAssetsAtPath</code></pre><p>参考下面案例进行使用：</p><pre><code>using UnityEngine;    using UnityEditor;    public class ImportAsset &#123;        [MenuItem (&quot;AssetDatabase/LoadAssetExample&quot;)]    static void ImportExample ()        &#123;            Texture2D t = AssetDatabase.LoadAssetAtPath(&quot;Assets/Textures/texture.jpg&quot;, typeof(Texture2D)) as Texture2D;        &#125;    &#125;</code></pre><h1 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h1><h2 id="更改提交至数据库"><a href="#更改提交至数据库" class="headerlink" title="更改提交至数据库"></a>更改提交至数据库</h2><p>这里提前声明一下，修改完资源后应该调用AssetDatabase.Refresh 将更改提交至数据库，并使其显示在工程中。</p><h2 id="创建资源"><a href="#创建资源" class="headerlink" title="创建资源"></a>创建资源</h2><p>创建文件的API是：<strong>CreateAsset</strong>  </p><pre><code>Material material = new Material (Shader.Find(“Specular”));AssetDatabase.CreateAsset(material, “Assets/MyMaterial.mat”);    if(AssetDatabase.Contains(material))    //判断是否包含这个资源    Debug.Log(“Material asset created”);</code></pre><p>##创建文件夹<br>创建文件夹：<strong>CreateFolder</strong>  </p><pre><code>ret = AssetDatabase.CreateFolder(&quot;Assets&quot;, &quot;NewFolder&quot;);if(AssetDatabase.GUIDToAssetPath(ret) != &quot;&quot;)    Debug.Log(&quot;Folder asset created&quot;);else    Debug.Log(&quot;Couldn‘t find the GUID for the path&quot;);</code></pre><h2 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h2><p>给文件夹重新命名：<strong>RenameAsset</strong>  </p><pre><code>ret = AssetDatabase.RenameAsset(“Assets/MyMaterial.mat”, “MyMaterialNew”);if(ret == “”)    Debug.Log(“Material asset renamed to MyMaterialNew”);    else    Debug.Log(ret);</code></pre><h2 id="移动资源位置"><a href="#移动资源位置" class="headerlink" title="移动资源位置"></a>移动资源位置</h2><p>移动资源所在的位置：<strong>MoveAsset</strong><br>得到资源所在路径：GetAssetPath</p><pre><code>ret = AssetDatabase.MoveAsset(AssetDatabase.GetAssetPath(material), &quot;Assets/NewFolder/MyMaterialNew.mat&quot;);if(ret == &quot;&quot;)    Debug.Log(&quot;Material asset moved to NewFolder/MyMaterialNew.mat&quot;);else    Debug.Log(ret);</code></pre><h2 id="复制资源"><a href="#复制资源" class="headerlink" title="复制资源"></a>复制资源</h2><p>复制一个资源：<strong>CopyAsset</strong></p><pre><code>if(AssetDatabase.CopyAsset(AssetDatabase.GetAssetPath(material), &quot;Assets/MyMaterialNew.mat&quot;))    Debug.Log(&quot;Material asset copied as Assets/MyMaterialNew.mat&quot;);else    Debug.Log(&quot;Couldn‘t copy the material&quot;);</code></pre><h2 id="移动到回收站"><a href="#移动到回收站" class="headerlink" title="移动到回收站"></a>移动到回收站</h2><p>把资源移动到回收站：<strong>MoveAssetToTrash</strong></p><pre><code>if(AssetDatabase.MoveAssetToTrash(AssetDatabase.GetAssetPath(MaterialCopy)))    Debug.Log(&quot;MaterialCopy asset moved to trash&quot;);</code></pre><h2 id="删除资源"><a href="#删除资源" class="headerlink" title="删除资源"></a>删除资源</h2><p>删除一个资源或文件夹：DeleteAsset</p><pre><code>if(AssetDatabase.DeleteAsset(AssetDatabase.GetAssetPath(material)))    Debug.Log(&quot;Material asset deleted&quot;);if(AssetDatabase.DeleteAsset(&quot;Assets/NewFolder&quot;))    Debug.Log(&quot;NewFolder deleted&quot;);</code></pre><p>官方API网址：<a href="https://docs.unity3d.com/ScriptReference/AssetDatabase.html"><font color=steelblue size=3><strong>https://docs.unity3d.com/ScriptReference/AssetDatabase.html</strong></font></a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;unity中有个类，叫做AssetDatabase，这是一个在编辑器(Editor)下使用的一个类，是一个允许您访问工程中资源的API。这个</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Unity编辑器扩展" scheme="http://yoursite.com/tags/Unity%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——JSON数据转化为Excel表格</title>
    <link href="http://yoursite.com/2019/09/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94JSON%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8C%96%E4%B8%BAExcel%E8%A1%A8%E6%A0%BC/"/>
    <id>http://yoursite.com/2019/09/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94JSON%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8C%96%E4%B8%BAExcel%E8%A1%A8%E6%A0%BC/</id>
    <published>2019-09-30T02:41:20.000Z</published>
    <updated>2021-12-27T03:39:09.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作者今天接到一个工作，需要把一个从其他地方接收过来的json数据观察规律，因为数据比较多，不可能一个一个观察记录，作者想的是把接收过来的数据全部保存到表格中，因为表格处理数据还是比较方便观察的，很省事。废话不多说了，直接上代码。  </p><h1 id="准备资源"><a href="#准备资源" class="headerlink" title="准备资源"></a>准备资源</h1><p>需要一个dll，这里提供下载链接：<br><a href="https://pan.baidu.com/s/1Z8YZJgezbAeQGDO2pGiFrA"><font color=steelblue size=3>org.in2bits.MyXls.Dll</font></a><br><strong>解压密码：fuck</strong></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>首先把dll导入到自己的项目中，这里就不用做过多的解释了。<br>接着直接放代码：  </p><pre><code>using org.in2bits.MyXls;using QF.Extensions;using UnityEngine;namespace QFramework.MFO&#123;    public class JsonToExcelSystem    &#123;        //保留当前创建的xls文档        private XlsDocument newXls;        //保留当前操作的对应的sheet中的单元格        private Cells newCells;        //当前sheet所添加的行        private int nowRow;        /// &lt;summary&gt;        /// 创建新的Xls文件        /// &lt;/summary&gt;        public void CreateExcelFile(string filePath,string fileName,            string author = &quot;LianBai&quot;,string subject = &quot;Test&quot;)        &#123;              XlsDocument xls = new XlsDocument();    //创建一个新的xls文档            xls.FileName = filePath+fileName;                //设置文件名字(路径+名字)            xls.SummaryInformation.Author = author; //设置xls文件作者信息            xls.SummaryInformation.Subject = subject;   //设置xls文件主题信息            newXls = xls;            //Worksheet sheet = xls.Workbook.Worksheets.AddNamed(sheetName);  //添加一个sheet页面        &#125;        /// &lt;summary&gt;        /// 添加一个新的sheet,并赋予开头        /// &lt;/summary&gt;        public void AddNewSheet(string sheetName, params string[] param)        &#123;            if (newXls == null)            &#123;                Debug.LogError(&quot;LianBai:Please create new xls&quot;);            &#125;            else            &#123;                Worksheet sheet = newXls.Workbook.Worksheets.AddNamed(sheetName);   //添加一个新的sheet                newCells = sheet.Cells; //修改当前操作的单元格                int index = 1;                      param.ForEach(tipName =&gt;        //遍历添加标头                &#123;                    newCells.Add(1, index, tipName);                    index++;                &#125;);                nowRow = 2;     //初始化从第二行添加数据            &#125;        &#125;        /// &lt;summary&gt;        /// 往创建的sheet里添加数据        /// &lt;/summary&gt;        public void AddData(params object[] param)        &#123;            if (newXls == null || newCells == null)     //判断文件是否被创建            &#123;                Debug.LogError(&quot;LianBai:Please create new xls or sheet&quot;);            &#125;            else            &#123;                int index = 1;                param.ForEach(data =&gt;           //遍历添加数据                &#123;                    newCells.Add(nowRow, index, data);                    index++;                &#125;);                nowRow++;                   //添加一行后往下添加            &#125;        &#125;        /// &lt;summary&gt;        /// 保存成文件        /// &lt;/summary&gt;        public void SaveXls()        &#123;            newXls.Save();        &#125;            &#125;&#125;</code></pre><p>上述代码都有注释，也就不做过多的解释了。</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>下面来看看作者自己写的一个案例：<br>先看看json数据：  </p><pre><code>[  &#123;    &quot;playerid&quot;: 2,    &quot;playericoname&quot;: &quot;PlayerIcon_2&quot;,    &quot;playerprefabname&quot;: &quot;Player_2&quot;  &#125;,  &#123;    &quot;playerid&quot;: 3,    &quot;playericoname&quot;: &quot;PlayerIcon_3&quot;,    &quot;playerprefabname&quot;: &quot;Player_3&quot;  &#125;,  &#123;    &quot;playerid&quot;: 4,    &quot;playericoname&quot;: &quot;PlayerIcon_4&quot;,    &quot;playerprefabname&quot;: &quot;Player_4&quot;  &#125;,  &#123;    &quot;playerid&quot;: 5,    &quot;playericoname&quot;: &quot;PlayerIcon_5&quot;,    &quot;playerprefabname&quot;: &quot;Player_5&quot;  &#125;]</code></pre><p>接着看作者写的案例代码，其中josn读取利用的是QF框架中的，QF是一个非常强大的框架：<br>代码如下：  </p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;namespace QFramework.MFO&#123;    public class MyJsonToExcelExample : MonoBehaviour    &#123;        private JsonToExcelSystem myJsonToExcelSystem = new JsonToExcelSystem();        private string path;        private string fileName = &quot;LianBai&quot;;                      //文件名字        private List&lt;PlayerData&gt; posData = new List&lt;PlayerData&gt;(); //用来保存json数据        // Start is called before the first frame update        void Start()        &#123;            path = Application.dataPath + &quot;/Prints/&quot;;    //文件保存路径            var jsonText = ResLoadManage.Instance.mResLoader.LoadSync&lt;TextAsset&gt;(&quot;playeritem&quot;).text;    //读取本地的json文件            posData = jsonText.FromJson&lt;List&lt;PlayerData&gt;&gt;();    //保存json数据            myJsonToExcelSystem.CreateExcelFile(path,fileName); //创建文件            myJsonToExcelSystem.AddNewSheet(&quot;lianbai&quot;,&quot;ID&quot;,&quot;IocName&quot;,&quot;PrefabName&quot;); //创建sheet并且赋值表头            posData.ForEach(data =&gt;         //遍历数据            &#123;                myJsonToExcelSystem.AddData(data.playerid,data.playericoname,data.playerprefabname);    //把数据写入到表格中            &#125;);            myJsonToExcelSystem.SaveXls();  //保存文件        &#125;    &#125;&#125;</code></pre><p>运行后的结果如下：<br><img src="http://file.liangxiegame.com/df26006d-9f6f-4bd3-8e6c-5243301474aa.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;作者今天接到一个工作，需要把一个从其他地方接收过来的json数据观察规律，因为数据比较多，不可能一个一个观察记录，作者想的是把接收过来的数据</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="JSON" scheme="http://yoursite.com/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——2D游戏开发常用插件集合</title>
    <link href="http://yoursite.com/2019/09/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%942D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2019/09/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%942D%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E9%9B%86%E5%90%88/</id>
    <published>2019-09-28T12:50:08.000Z</published>
    <updated>2021-12-27T03:39:09.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Unity以开发3D游戏见长，早期版本的Unity在开发2D游戏时不慎方便，因此Asset Store出现了很多2D游戏开发引擎。现在Unity对2D游戏的支持越来越好，而这些开发2D游戏的Unity插件也得到了更多开发者的喜爱。</p><h1 id="Rex-Engine-Classic-2D-Platformer-Engine"><a href="#Rex-Engine-Classic-2D-Platformer-Engine" class="headerlink" title="Rex Engine: Classic 2D Platformer Engine"></a>Rex Engine: Classic 2D Platformer Engine</h1><p>下载地址：<a href="https://assetstore.unity.com/packages/templates/systems/rex-engine-classic-2d-platformer-engine-92333?aid=1101l4bPZ&utm_source=aff"><font color=steelblue size=3>点击这里</font></a><br>Rex Engine: Classic 2D Platformer Engine是一款在Unity内部专门制作2D平台游戏的游戏引擎。<br><img src="http://file.liangxiegame.com/06051a4e-9428-4cc7-86aa-62b2782950d4.png">   </p><h1 id="TopDown-Engine"><a href="#TopDown-Engine" class="headerlink" title="TopDown Engine"></a>TopDown Engine</h1><p>下载地址：<a href="https://assetstore.unity.com/packages/templates/systems/topdown-engine-89636?aid=1101l4bPZ&utm_source=aff"><font color=steelblue size=3>点击这里</font></a><br>TopDown Engine和Corgi Engine来自同一开发者，是制作2D/3D动作类游戏的最佳引擎。<br><img src="http://file.liangxiegame.com/d55f87c3-4c73-442e-bccb-d5cd18aba35e.png">  </p><h1 id="Platformer-PRO-2"><a href="#Platformer-PRO-2" class="headerlink" title="Platformer PRO 2"></a>Platformer PRO 2</h1><p>下载地址：<a href="https://assetstore.unity.com/packages/templates/systems/platformer-pro-2-140510?aid=1101l4bPZ&utm_source=aff"><font color=steelblue size=3>点击这里</font></a><br>Platformer PRO 2是一款制作2D/2.5D的平台游戏引擎，内部集成了大量功能，包括跳跃等运动系统。<br><img src="http://file.liangxiegame.com/47cecac4-2f43-47b0-94d1-fae9ce3da5bd.png">  </p><h1 id="Corgi-Engine-–-2D-2-5D-Platformer"><a href="#Corgi-Engine-–-2D-2-5D-Platformer" class="headerlink" title="Corgi Engine – 2D + 2.5D Platformer"></a>Corgi Engine – 2D + 2.5D Platformer</h1><p>下载地址：<a href="https://assetstore.unity.com/packages/templates/systems/corgi-engine-2d-2-5d-platformer-26617?aid=1101l4bPZ&utm_source=aff"><font color=steelblue size=3>点击这里</font></a><br>Corgi Engine是一款制作2D/2.5D的平台游戏引擎，内部集成了若干有趣的游戏，Corgi Engine弥补了Unity制作2D游戏的短板。<br><img src="http://file.liangxiegame.com/753b12fa-cb85-4897-9d28-21ebba9730be.png">  </p><h1 id="DoozyUI-Complete-UI-Management-System"><a href="#DoozyUI-Complete-UI-Management-System" class="headerlink" title="DoozyUI: Complete UI Management System"></a>DoozyUI: Complete UI Management System</h1><p>下载地址：<a href="https://assetstore.unity.com/packages/tools/gui/doozyui-complete-ui-management-system-138361?aid=1101l4bPZ&utm_source=aff"><font color=steelblue size=3>点击这里</font></a><br>DoozyUI是Unity内部的一个UI管理插件。<br><img src="http://file.liangxiegame.com/df376645-503b-4471-a8b3-36ba8fdf4c66.png">  </p><h1 id="Fingers-–-Touch-Gestures-for-Unity"><a href="#Fingers-–-Touch-Gestures-for-Unity" class="headerlink" title="Fingers – Touch Gestures for Unity"></a>Fingers – Touch Gestures for Unity</h1><p>下载地址：<a href="https://assetstore.unity.com/packages/tools/input-management/fingers-touch-gestures-for-unity-41076?aid=1101l4bPZ&utm_source=aff"><font color=steelblue size=3>点击这里</font></a><br>Fingers Touch Gestures是一款处理处理手势输入的插件，对手机游戏制作很有必要。<br><img src="http://file.liangxiegame.com/b9e85b2f-5cbd-4482-9745-77ff7998ead1.png">   </p><h1 id="RPG-Map-Editor"><a href="#RPG-Map-Editor" class="headerlink" title="RPG Map Editor"></a>RPG Map Editor</h1><p>下载地址：<a href="https://assetstore.unity.com/packages/templates/systems/rpg-map-editor-25657"><font color=steelblue size=3>点击这里</font></a><br>制作RPG游戏地图的插件，简单易用非常推荐。<br><img src="http://file.liangxiegame.com/0982f53c-449a-4aea-b1f2-2a51d25b796b.png">  </p><h1 id="Super-Tilemap-Editor"><a href="#Super-Tilemap-Editor" class="headerlink" title="Super Tilemap Editor"></a>Super Tilemap Editor</h1><p>下载地址：<a href="https://assetstore.unity.com/packages/tools/level-design/super-tilemap-editor-56339"><font color=steelblue size=3>点击这里</font></a><br>Super Tilemap Editor是一款制作Tilemap的插件，功能强大而且使用方便。<br><img src="http://file.liangxiegame.com/8a82f6d6-0e3d-48a9-8f9d-6e91121296f0.png"><br>Unity优质的插件和资源电子书:<br>链接: <a href="https://pan.baidu.com/s/14gF7nlWU65V-YJFexSczDQ">https://pan.baidu.com/s/14gF7nlWU65V-YJFexSczDQ</a><br>提取码: fuck<br>nity插件和素材资源按照分类做了汇总网站：<a href="http://gamedevplugins.com/"><font color=steelblue size=3>游戏开发插件之家</font></a>   </p><pre><code>参考博客：https://www.jianshu.com/p/6659944272a3</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Unity以开发3D游戏见长，早期版本的Unity在开发2D游戏时不慎方便，因此Asset Store出现了很多2D游戏开发引擎。现在Uni</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="插件" scheme="http://yoursite.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——IOS后台推送</title>
    <link href="http://yoursite.com/2019/09/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94IOS%E5%90%8E%E5%8F%B0%E6%8E%A8%E9%80%81/"/>
    <id>http://yoursite.com/2019/09/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94IOS%E5%90%8E%E5%8F%B0%E6%8E%A8%E9%80%81/</id>
    <published>2019-09-28T09:09:59.000Z</published>
    <updated>2021-12-27T03:39:09.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IOS本地消息通知"><a href="#IOS本地消息通知" class="headerlink" title="IOS本地消息通知"></a>IOS本地消息通知</h1><p>相信用过IOS的都会知道，IOS的软件在关闭后也会收到通知消息，软件上面有红点并且还会接到通知消息。<br>先带大家看看效果：  </p><h2 id="红点"><a href="#红点" class="headerlink" title="红点"></a>红点</h2><p><img src="http://file.liangxiegame.com/d1844fda-c9d3-4190-851c-f59908891ebb.png">   </p><h2 id="消息通知"><a href="#消息通知" class="headerlink" title="消息通知"></a>消息通知</h2><p><img src="http://file.liangxiegame.com/c25f8f72-e202-4964-b128-e7686c3f4275.png">  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>好了，大家来看看代码：  </p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;using System.Runtime.InteropServices;using System;using UnityEngine.iOS; //引入命名空间public class UnityToIOSManager : MonoBehaviour&#123;    static UnityToIOSManager mInstance;    static long lastTime;    int PushIndex;//推送    string PushText; //推送信息    private void Awake()    &#123;        Screen.sleepTimeout = SleepTimeout.NeverSleep;//游戏运行时禁止休眠，游戏在前台时可以保持屏幕长亮        if (mInstance == null)            mInstance = this;        //先清空本地消息，然后注册        UnityEngine.iOS.NotificationServices.RegisterForNotifications(NotificationType.Badge | NotificationType.Alert | NotificationType.Sound);        CleanNotification();        DontDestroyOnLoad(this);    &#125;//当有多条推送时，每次进入游戏时更换推送消息    private void Push()    &#123;        #region 推送条目记录        PushIndex = PlayerPrefs.GetInt(&quot;Push&quot;);        PushIndex++;        if (PushIndex &gt; 4)            PushIndex = 1;        PlayerPrefs.SetInt(&quot;Push&quot;, PushIndex);        PlayerPrefs.Save();        PushText = LanguageMananger.GetPushText(PushIndex);        #endregion    &#125;    //后台消息通知    //本地推送    public static void NotificationMessage(string message, int hour, bool isRepeatDay)    &#123;        int year = System.DateTime.Now.Year;        int month = System.DateTime.Now.Month;        int day = System.DateTime.Now.Day;        System.DateTime newDate = new System.DateTime(year, month, day, hour, 0, 0);        NotificationMessage(message, newDate, isRepeatDay);    &#125;    //本地推送 你可以传入一个固定的推送时间    public static void NotificationMessage(string message, System.DateTime newDate, bool isRepeatDay)    &#123;        if (isRepeatDay &amp;&amp; newDate &lt;= System.DateTime.Now)        &#123;            newDate = newDate.AddDays(1);        &#125;        //推送时间需要大于当前时间        if (newDate &gt; System.DateTime.Now)        &#123;            UnityEngine.iOS.LocalNotification localNotification = new UnityEngine.iOS.LocalNotification();            localNotification.fireDate = newDate;            localNotification.alertBody = message;            localNotification.applicationIconBadgeNumber = 1;            localNotification.hasAction = true;            if (isRepeatDay)            &#123;                //是否每天定期循环                localNotification.repeatCalendar = UnityEngine.iOS.CalendarIdentifier.ChineseCalendar;                localNotification.repeatInterval = UnityEngine.iOS.CalendarUnit.Day;            &#125;            localNotification.soundName = UnityEngine.iOS.LocalNotification.defaultSoundName;            UnityEngine.iOS.NotificationServices.ScheduleLocalNotification(localNotification);        &#125;    &#125;    void OnApplicationPause(bool paused)    &#123;        //程序进入后台时        if (paused)        &#123;            Push();            //每天中午12点推送            NotificationMessage(PushText, 19, true);            //10s后发送            NotificationMessage(&quot;10秒后发送&quot;,System.DateTime.Now.AddSeconds(10),false);            //时间戳            TimeSpan ts = DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, 0);            lastTime = Convert.ToInt64(ts.TotalSeconds);        &#125;        else        &#123;            //程序从后台进入前台时            CleanNotification();            TimeSpan ts = DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, 0);            long nowTime = Convert.ToInt64(ts.TotalSeconds);            if(nowTime - lastTime &gt; 180)            &#123;                //这个是判断程序退出到后台超出多久之后                //然后进行其他操作，播放广告，或是提醒什么的            &#125;        &#125;    &#125;    //清空所有本地消息    void CleanNotification()    &#123;        UnityEngine.iOS.LocalNotification l = new UnityEngine.iOS.LocalNotification();        l.applicationIconBadgeNumber = -1;        UnityEngine.iOS.NotificationServices.PresentLocalNotificationNow(l);        Invoke(&quot;WaitOneFrameClear&quot;,0);    &#125;    //延迟一帧执行，不然没法清理    void WaitOneFrameClear()    &#123;        UnityEngine.iOS.NotificationServices.CancelAllLocalNotifications();        UnityEngine.iOS.NotificationServices.ClearLocalNotifications();    &#125;&#125;</code></pre><hr><pre><code>参考文章：http://www.xuanyusong.com/archives/2632?replytocom=591072         https://blog.csdn.net/shuangkui5355/article/details/79064241</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IOS本地消息通知&quot;&gt;&lt;a href=&quot;#IOS本地消息通知&quot; class=&quot;headerlink&quot; title=&quot;IOS本地消息通知&quot;&gt;&lt;/a&gt;IOS本地消息通知&lt;/h1&gt;&lt;p&gt;相信用过IOS的都会知道，IOS的软件在关闭后也会收到通知消息，软件上面有红点并且还</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Unity4IOS" scheme="http://yoursite.com/tags/Unity4IOS/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——AssetBundle自动标记</title>
    <link href="http://yoursite.com/2019/09/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94AssetBundle%E8%87%AA%E5%8A%A8%E6%A0%87%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/09/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94AssetBundle%E8%87%AA%E5%8A%A8%E6%A0%87%E8%AE%B0/</id>
    <published>2019-09-28T08:35:10.000Z</published>
    <updated>2021-12-27T03:39:09.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>当我们想把资源打包成AB的时候，需要把资源一个一个标记AB名字，其实大多数名字都是资源名字，如果资源一旦很多，就需要花费大量的时间，为了提高开发效率，我们肯定希望能把需要热更的资源一键标记资源名字。  </p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>自动打标记无非就是给我一个资源路径，我通过这个路径将里面的所有的资源文件遍历一遍，然后通过 AssetImporter 这个 API 设置每个文件的 assetbundleName 和 assetBundleVariant 属性，当然在设置属性的时候提前分好类，决定将哪些资源放到一个 AssetBundle 包内。然后记录一下要打多少个 AssetBundle 包，以及该包所在的目录，方便以后查找加载。<br>废话不多说，直接上代码：  </p><pre><code> # region 自动做标记[MenuItem(&quot;AssetBundle/Set AssetBundle Lables&quot; ,false , 100)]public static void SetAssetBundleLables()&#123;    //移除掉所有没有使用的标记    AssetDatabase.RemoveUnusedAssetBundleNames();    string assetDirectory = &quot;Assets/Res&quot;;    DirectoryInfo directoryInfo = new DirectoryInfo(assetDirectory);    DirectoryInfo[] scenesDirectories = directoryInfo.GetDirectories();    foreach (var tempDir in scenesDirectories)    &#123;        string sceneDirectory = assetDirectory + &quot;/&quot; + tempDir.Name;        DirectoryInfo sceneDirectoryInfo = new DirectoryInfo(sceneDirectory);        if (sceneDirectoryInfo == null)        &#123;            Debug.Log(sceneDirectoryInfo + &quot;不存在&quot;);            return;        &#125;        else        &#123;            Dictionary&lt;string , string&gt; namePathDictionary = new Dictionary&lt;string, string&gt;();            int index = sceneDirectory.LastIndexOf(&quot;/&quot;);            string sceneName = sceneDirectory.Substring(index + 1);            OnSceneFileSystemInfo(sceneDirectoryInfo , sceneName , namePathDictionary);            OnWriteConfig(sceneName , namePathDictionary);        &#125;    &#125;    AssetDatabase.Refresh();    Debug.Log(&quot;设置标记成功...&quot;);&#125;/// &lt;summary&gt;/// 记录配置文件/// &lt;/summary&gt;/// &lt;param name=&quot;sceneDirectory&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;namePathDictionary&quot;&gt;&lt;/param&gt;private static void OnWriteConfig(string sceneName , Dictionary&lt;string , string&gt; namePathDictionary)&#123;    string path = Application.dataPath + &quot;/AssetBundles/&quot; + sceneName ;    if (!Directory.Exists(path)) Directory.CreateDirectory(path);    Debug.Log(path);    using (FileStream fs = new FileStream(path + &quot;/Record.txt&quot;, FileMode.OpenOrCreate , FileAccess.Write))    &#123;        using (StreamWriter sw = new StreamWriter(fs))        &#123;            sw.WriteLine(namePathDictionary.Count);            foreach (KeyValuePair&lt;string , string&gt; kv in namePathDictionary)            &#123;                Debug.Log(kv.Value);                sw.WriteLine(kv.Key+&quot;/&quot;+kv.Value);            &#125;        &#125;    &#125;&#125;private static void OnSceneFileSystemInfo(FileSystemInfo fileSystemInfo , string sceneNama , Dictionary&lt;string, string&gt; namePathDictionary)&#123;    if (!fileSystemInfo.Exists)    &#123;        Debug.Log(fileSystemInfo + &quot;不存在&quot;);        return;    &#125;    DirectoryInfo directoryInfo = fileSystemInfo as DirectoryInfo;    FileSystemInfo[] fileSystemInfos = directoryInfo.GetFileSystemInfos();    foreach (var systemInfo in fileSystemInfos)    &#123;        FileInfo fileInfo = systemInfo as FileInfo;        if (fileInfo == null)        &#123;            OnSceneFileSystemInfo(systemInfo, sceneNama , namePathDictionary);        &#125;        else        &#123;            SetLables(fileInfo, sceneNama , namePathDictionary);        &#125;    &#125;&#125;/// &lt;summary&gt;/// 修改资源 assetbundle lables/// &lt;/summary&gt;private static void SetLables(FileInfo fileInfo , string sceneName , Dictionary&lt;string, string&gt; namePathDictionary)&#123;    if(fileInfo.Extension == &quot;.meta&quot;)return;    string bundleName = GetBundleName(fileInfo , sceneName);    int index = fileInfo.FullName.IndexOf(&quot;Assets&quot;);    string assetPath = fileInfo.FullName.Substring(index);    AssetImporter assetImporter = AssetImporter.GetAtPath(assetPath);    assetImporter.assetBundleName = bundleName;    if (fileInfo.Extension == &quot;.unity&quot;)        assetImporter.assetBundleVariant = &quot;u3d&quot;;    else        assetImporter.assetBundleVariant = &quot;assetbundle&quot;;    string folderName;    if (bundleName.Contains(&quot;/&quot;))        folderName = bundleName.Split(&#39;/&#39;)[1];    else        folderName = bundleName;    string bundlePath = assetImporter.assetBundleName + &quot;.&quot; + assetImporter.assetBundleVariant;    if (!namePathDictionary.ContainsKey(folderName))        namePathDictionary.Add(folderName, bundlePath);&#125;private static string GetBundleName(FileInfo fileInfo, string sceneName)&#123;    string path = fileInfo.FullName;    int index = path.IndexOf(sceneName) + sceneName.Length;    string bundlePath = path.Substring(index + 1);    bundlePath = bundlePath.Replace(@&quot;\&quot;, &quot;/&quot;);    if (bundlePath.Contains(&quot;/&quot;))    &#123;        string[] tmp = bundlePath.Split(&#39;/&#39;);        return sceneName + &quot;/&quot; + tmp[0];    &#125;    return sceneName;&#125;#endregion</code></pre><h1 id="一键打包"><a href="#一键打包" class="headerlink" title="一键打包"></a>一键打包</h1><p>一键打包<br>根据刚才我们设置好的标记，Unity 就可以识别到我们想要打包的资源，官方有个打包 AssetBundle 的插件（ AssetBundle Browser ），你可以用那款插件打包。<br>作自己也写了一个但是不是很好，这个东西可以用官方的代替。也可以根据自己的需求改一下。我这里选择的压缩方式是不压缩（ BuildAssetBundleOptions.None 这个选项）。  </p><pre><code>#region 打包static void BuildAssetBundles(string outPath , BuildTarget target)&#123;    if (!Directory.Exists(outPath)) Directory.CreateDirectory(outPath);    BuildPipeline.BuildAssetBundles(outPath, BuildAssetBundleOptions.None, target);&#125;[MenuItem(&quot;AssetBundle/CreateAndroidAssetBundles&quot;, false, 200)]public static void BuildAndroidAssetBundles()&#123;    string outPath = &quot;Assets/AssetBundles/Android&quot;;    BuildAssetBundles(outPath , BuildTarget.Android);&#125;[MenuItem(&quot;AssetBundle/CreateIOSAssetBundles&quot;, false, 201)]public static void BuildIOSAssetBundles()&#123;    string outPath = &quot;Assets/AssetBundles/IOS&quot;;    BuildAssetBundles(outPath, BuildTarget.iOS);&#125;[MenuItem(&quot;AssetBundle/CreateStandaloneWindows64AssetBundles&quot;, false, 202)]public static void BuildStandaloneWindows64AssetBundles()&#123;    string outPath = &quot;Assets/AssetBundles/StandaloneWindows64&quot;;    BuildAssetBundles(outPath, BuildTarget.StandaloneWindows64);&#125;#endregion</code></pre><h1 id="一键删除"><a href="#一键删除" class="headerlink" title="一键删除"></a>一键删除</h1><p>把目标路径删除掉就 OK 了。  </p><pre><code>#region 一键删除[MenuItem(&quot;AssetBundle/Delete All&quot;)]static void DeletAssetBundles()&#123;    string outPuth = &quot;Assets/AssetBundles&quot;;    Directory .Delete(outPuth , true);    File.Delete(outPuth+ &quot;.meta&quot;);    AssetDatabase.Refresh();&#125;#endregion参考文章：https://zhuanlan.zhihu.com/p/39994056</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h1&gt;&lt;p&gt;当我们想把资源打包成AB的时候，需要把资源一个一个标记AB名字，其实大多数名字都是资源名字，如果资源一旦很多，就需要花费大量的时间，为了提高</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="AssetBundle" scheme="http://yoursite.com/tags/AssetBundle/"/>
    
  </entry>
  
  <entry>
    <title>IOC入门</title>
    <link href="http://yoursite.com/2019/09/27/Unity/IOC%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/09/27/Unity/IOC%E5%85%A5%E9%97%A8/</id>
    <published>2019-09-27T01:10:01.000Z</published>
    <updated>2021-12-27T03:39:09.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="IOC简介"><a href="#IOC简介" class="headerlink" title="IOC简介"></a>IOC简介</h2><p>IOC全称为Invertuon Of Control，也就是控制反转。<br>控制反转是一种设计思想。而不是具体的技术。<br>IOC这种设计思想有很多方式实现，最常见的实现方式就是DI。  </p><h2 id="DI简介"><a href="#DI简介" class="headerlink" title="DI简介"></a>DI简介</h2><p>DI的全称是Dependency Injection，也就是依赖注入，是IOC思想的一种实现。  </p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>什么是依赖？看下面这段代码：  </p><pre><code>public class A&#123;  public B b = new B();&#125;</code></pre><p>上述代码中就是A依赖B。<br>我再这里理解为，A对象里面持有B对象，如果B对象不存在，那么A就无法成立，所以是A对象依赖B。  </p><h3 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h3><p>什么是注入呢？看下面这段代码：  </p><pre><code>public class A&#123;  public B b = null;&#125;public class B &#123;&#125;void Main()&#123;  var a = new A();  var b = new B();  a.b = b;&#125;</code></pre><p>从上面可以看出总共有两个对象，分别是a和b。可以看出现在的A对象是依赖B对象的。<br>**a.b=b;**这句代码就是将b对象注入到a对象的b成员中。<br>有时候可以把注入就理解成设置值。<br>依赖注入也就是吧某个对象依赖的对象进行赋值。  </p><h1 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h1><h2 id="QF中的IOC"><a href="#QF中的IOC" class="headerlink" title="QF中的IOC"></a>QF中的IOC</h2><p>QF是一种框架，是作者最近正在学习的一种框架，这个框架不要求会，我们就拿QF中的DI来进行详细的了解一下DI。<br>我们在使用DI方案的时候一般都离不开DI容器这个概念。育德时候DI容易也叫做IOC容器。就是：DIContainer 和 IOCContainer。<br>下面我们来看看QF中是如何使用IOC的。  </p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;namespace QF.Master.Example&#123;        public class ServiceA    &#123;        public void Say()        &#123;            Debug.Log(&quot;I am ServiceA:&quot; + this.GetHashCode());        &#125;    &#125;    public class IOCExample : MonoBehaviour     &#123;        // 声明为需要注入的对象        [Inject]         public ServiceA A &#123;get;set;&#125;        void Start ()         &#123;            // 创建实例容器            var container = new QFrameworkContainer();            // 注册类型            container.Register&lt;ServiceA&gt;();            // 注入对象（会自动查找 Inject Atrributet的对象)            container.Inject(this);            // 注入之后，就可以直接使用 A 对象了            A.Say();                &#125;    &#125;&#125;</code></pre><p>上面是完整的案例，我们只要仔细看下面的代码：  </p><pre><code>// 创建实例容器var container = new QFrameworkContainer();// 注册类型container.Register&lt;ServiceA&gt;();// 注入对象（会自动查找 Inject Atrributet的对象)container.Inject(this);// 注入之后，就可以直接使用 A 对象了A.Say();</code></pre><p>首先我们创建了一个容器，并且在容器里注册了一个ServiceA对象。这些其实都是可以自己写一个脚本进行封装的。<br>接下来我们来看注入：**container.Inject(this);**这句就是注入对象，注入的就是刚才注册的对象。<br>接下来我们就可以使用this对象里的ServiceA对象了，为啥注入到A对象了，这里是框架给设计好了，只要在对应的对象上面添加[Inject]就代表是需要注入的对象。注入的时候就会对其进行赋值。<br>我们可以看下面的图进行理解：<br><img src="http://file.liangxiegame.com/b4cd45e1-29c7-402a-852e-7d30fe0705ef.png"><br>这是QF框架中的使用方法，我们不用会这种方法，因为只是针对QF框架的，我们学习的是IOC的这种思想。  </p><h2 id="DI容器的强大之处"><a href="#DI容器的强大之处" class="headerlink" title="DI容器的强大之处"></a>DI容器的强大之处</h2><h3 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h3><p>一般情况下DI容器会提供如下的API：  </p><pre><code>注册类型：Register&lt;TSource,TTarget&gt;注入:Inject(object obj)解析:Resolve&lt;T&gt;()</code></pre><p>注册和注入在刚才代码中已经有体现了。<br>在 DI Container 中，Resolve 实际上是根据类型返回实例。<br>DI容器的职责很简单，就是管理依赖和注入依赖。<br>DI容器中的容器代表的就是存储依赖的容器，容器里面装的就是依赖。<br>一般的DI容器利用的其实就是Dictonary&lt;Type,object&gt;来作为核心数据结构。<br>根据Type就可以得到依赖的对象，然后通过Inject注入到对象中。  </p><h3 id="强大之处"><a href="#强大之处" class="headerlink" title="强大之处"></a>强大之处</h3><p>有了单例这个工具，当我们需要写一个独立模块的时候，很容易用单例就实现了。而且通过单例（或静态类）实现的独立模块，与其他模块之间的交互会变得非常容易。<br>这种结构好于直接撸的结构，毕竟它有一定的扩展性（只需实现单例），维护性上也还可以（模块独立），但是它很容易达到瓶颈，尤其是当单例的数量逐渐随着项目变多的时候。<br>因为单例的获取是没有限制的，任何层级的代码都可以获取到任何层级的单例，如下图示：<br><img src="http://file.liangxiegame.com/2056ec16-a56a-40de-b9fa-76536a162082.png"><br>虽然我们在预定上分了很多层，但是当我们的模块数量超过一定数量时，约定就很难遵循，因为我们访问模块的时候就需要去看一遍层级的示意图：<br><img src="http://file.liangxiegame.com/0ed6d9fd-8478-402c-8c1e-236e4f973d8d.png"><br>这就造成项目达到一定规模，约定就变成了限制，让我们很难遵循。<br>从约定上，来说，我们怎么约定都可以，而约定的图示，就是上边的图。那些分层都是一些抽象的概念，比如游戏流程、主逻辑层、业务模块、框架层、底层，这些都是约定的结构。一般都是存在于文档上，并不会通过技术手段表达。<br>而从技术限制这个角度来说，单例的访问是没有限制的，就算是用最佳实践，也是没有限制的。而且单例难以表达约定上的分层的那些概念，因为只要一个模块变成单例了，那么这个模块就在技术上失去了层次关系。<br>如下图：<br><img src="http://file.liangxiegame.com/3e9c0a55-66d1-481c-a531-8704e1127da7.png"><br>如图所示，在使用单例的时候蓝牙和商店模块就在同一层级了，就失去了层级的约定。<br>使用单例时，项目结构的设计非常依赖于约定（文档等等）。<br>在项目规模比较少的时候，是没问题的，因为模块数量也比较少，但是一旦项目规模变大，模块数量变多，那么约定就会越来越难以遵循，就会非常容易导致项目结构的崩溃。<br>这个时候，有一种很简单的解决方式，就是最顶层模块都用单例，然后一些底层的模块，作为顶层的成员变量，从而达到逻辑层无法直接访问底层模块，而是必须通过顶层模块间接地使用底层模块服务。<br>如下图：<br><img src="http://file.liangxiegame.com/fd7000a1-4223-4972-8998-c8934d0d4fbf.png"><br>这样就解决了单例结构无法表达层级的问题，但是同时也失去了单例带来的种种好处，比如易扩展，维护性（模块独立）。<br>现在不容易扩展模块了，因为要扩展模块需要考虑依赖关系，也不容易维护了，因为模块不独立了。<br>而这里不容易维护指的是各个模块不容易单独维护了，但是整体项目会更容易维护。<br>接下来就体现DI Container 的作用了，它的出现可以让各个模块容易维护，也容易扩展，同时让整个项目也同样容易维护，而且可以通过技术限制来分担一部分约定。  </p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>从上面解决单例问题的图我们可以看到，有大量的依赖关系，这个依赖关系我们可以理解成对象的持有或者变量。<br>就是因为这些依赖关系，造成了此结构的维护性和扩展性降低了。因为模块本身也是对象，对象就有声明周期，那么对象和是去new就很重要。<br>我们来看看下面的代码：  </p><pre><code>public  class ModuleA&#123;  public ModuleB ModuleB;&#125;public class ModuleB&#123;&#125;</code></pre><p>从代码中我们可以知道ModuleA是依赖ModuleB，这样我们在使用ModuleA的时候要考虑A中ModuleB是不是有值。<br>创建ModuleB我们可以考虑在ModuleA内部创建和外部创建两种情况：  </p><h3 id="在ModuleA内部创建"><a href="#在ModuleA内部创建" class="headerlink" title="在ModuleA内部创建"></a>在ModuleA内部创建</h3><p>看下列代码：</p><pre><code>public  class ModuleA&#123;  public ModuleB ModuleB = new ModuleB();&#125;</code></pre><p>这种方式也很简单，创建ModuleA的时候ModuleB一定被创建了，但是此时的ModuleB是比较难共用的。  </p><h3 id="在ModuleA外部创建"><a href="#在ModuleA外部创建" class="headerlink" title="在ModuleA外部创建"></a>在ModuleA外部创建</h3><p>看下列代码：</p><pre><code>void main()&#123;  var moduleA = new ModuleA();  moduleA.ModuleB = new ModuleB();&#125;</code></pre><p>这样看起来没问题，因为在外部创建过程中，我们非常清晰地知道，moduleA.ModuleB 是有实例的。 但是我们看下在 ModuleA 内部使用 ModuleB 时的情况，代码如下:  </p><pre><code>public class ModuleA&#123;  public ModuleB ModuleB;  ...  void XXX()  &#123;    ModuleB. // 在这里会想 ModuleB 到底有没有值？在哪里设置的值？  &#125;&#125;</code></pre><p>接下来我们看看单例的解决方案：</p><pre><code>public class ModuleA&#123;  void XXX()  &#123;    ModuleB.Instance.DoSomething();  &#125;&#125;</code></pre><p>这样就不用考虑ModuleB的创建过程。<br>现在这种结构就是有大量的依赖，不易维护不易扩展也都出现在这个依赖上，因为依赖要考虑依赖对象的创建过程。  </p><h3 id="使用-DI-Container-管理依赖"><a href="#使用-DI-Container-管理依赖" class="headerlink" title="使用 DI Container 管理依赖"></a>使用 DI Container 管理依赖</h3><p>利用DI代码就变成下面的方式了：  </p><pre><code>public class ModuleA&#123;  [Inject]  public ModuleB ModuleB &#123;get;set;&#125;  void XXX()  &#123;    ModuleB.DoSomeThing(); // 放心用，因为不用考虑依赖的创建过程。  &#125;&#125;</code></pre><p>我们只需要在启动程序的时候进行注册：  </p><pre><code>public static QFrameworkContainer Container &#123;get;private set;&#125;void Main()&#123;  Container = new Contaner();  Container.Register&lt;ModuleB&gt;();&#125;</code></pre><p>但是我们在创建ModuleA的时候需要注入对象：</p><pre><code>void MethodA()&#123;  App.Container.Inject(new ModuleA());&#125;</code></pre><p>使用 DIContainer之后我们的结构就变成了下图所示：<br><img src="http://file.liangxiegame.com/000d5697-89dd-417c-93cc-8cfa1fc50d18.png"><br>我们只需要，在模块内部声明模块作为变量，而不需要考虑创建过程，这样就导致每个模块都是可独立测试的（易维护），而扩展一个模块，不需要用单例实现，而是注册到类型容器即可，扩展性比单例还容易。这就是 DI Container 的最核心的优势。  </p><h1 id="域"><a href="#域" class="headerlink" title="域"></a>域</h1><p>我们来了解DIContainer 的一个基础知识：域</p><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>域这个概念我们在学习C#的时候接触过，域的俗称就是代码块：  </p><pre><code>public class A// 类范围内的域&#123;  public void Main()  // 方法范围内的域  &#123;  &#125;&#125;</code></pre><p>从上面代码的注释就可以看出，代码块其实就是域<br>C# 的域的特性就是内部的域中的代码可以调用外部域中的变量。  </p><h2 id="DIContainer中的域"><a href="#DIContainer中的域" class="headerlink" title="DIContainer中的域"></a>DIContainer中的域</h2><p>首先我们要考虑一个问题，每次DIContainer在注入实例的时候，注入的是新的还是返回的同一个实例呢？<br>而这个问题所描述的行为指的是 DIContainer 的域。<br>我们来看看QF中是如何注入：  </p><pre><code>当注册依赖时，使用 Register&lt;Type&gt;() 方法时，每次注入都会创建新的实例。当注册依赖时，使用 RegisterInstance(object obj) 方法时，每次注入都会使用 obj 实例。</code></pre><p>我们来看看演示的代码：</p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;namespace QF.Master.Example&#123;    public class SomeService     &#123;        public void Description()        &#123;            Debug.Log(&quot;SomeService:&quot; + this.GetHashCode());        &#125;    &#125;    public class SomeObject    &#123;        public void Description()        &#123;            Debug.Log(&quot;SomeObject:&quot; + this.GetHashCode());        &#125;    &#125;    public class IOCScopeExample : MonoBehaviour &#123;        [Inject]        public SomeObject ObjA &#123;get;set;&#125;        [Inject]        public SomeObject ObjB &#123;get;set;&#125;        [Inject]        public SomeObject ObjC &#123;get;set;&#125;        [Inject]        public SomeService ServiceA &#123;get;set;&#125;        [Inject]        public SomeService ServiceB &#123;get;set;&#125;        void Start ()         &#123;            var container = new QFrameworkContainer();            // 每次注入都创建新的实例            container.Register&lt;SomeObject&gt;();            // 每次注入都使用同一个实例            container.RegisterInstance(new SomeService());            // 注入            container.Inject(this);            ObjA.Description();            ObjB.Description();            ObjC.Description();            ServiceA.Description();            ServiceB.Description();        &#125;    &#125;&#125;</code></pre><p>接下来我们看看运行的结果：<br><img src="http://file.liangxiegame.com/848bb7c8-aa25-4bcc-9924-1d7b74a69314.png"><br>我们不难看到过 Register<T>() 注册的依赖，每次注入时创建新的实例，而通过 RegisterInstance(object obj) 注册的依赖，每次注入都返回同一个 obj 实例。<br>总结如下：</p><pre><code>Register&lt;T&gt;，每次注入时创建新的实例。RegisterInstance(object obj)，每次注入时，返回同一个 obj 对象。</code></pre><h1 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h1><p>依赖倒置原则，即：Dependency Inversion Principle，很多时候缩写成 DIP。<br>这个原则包含了两个主题：  </p><pre><code>高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念。抽象接口不应该依赖于实现，而实现依赖于抽象接口</code></pre><h2 id="高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念"><a href="#高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念" class="headerlink" title="高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念"></a>高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念</h2><p>我们来拿一个司机开车的例子，代码如下：  </p><pre><code>public class Driver&#123;  // 司机的职责是开车  public void Drive(Benz benz)  &#123;    benz.Run();  &#125;&#125;public class Benz&#123;  public void Run()  &#123;    Debug.Log(&quot;奔驰汽车开始运行&quot;)  &#125;&#125;void Main()&#123;  var lucas = new Driver();  var benz = new Benz();  lucas.Drive(benz);&#125;</code></pre><p>目前A同学负责开发Driver类，B同学负责开发Benz类。这时候突然多了一个需求，那就是有一个同学的车换成了宝马，那我们需要重新创建一个BMW类。<br>然而因为A同学和B同学开发的类耦合性太强了，所以都需要重新改一下代码，这时候看看这句话：高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念。这样我们把车和司机都依赖于抽象，更改后的代码是：  </p><pre><code>public class Driver&#123;  // 司机的职责是开车  public void Drive(ICar car)  &#123;    car.Run();  &#125;&#125;public interface ICar&#123;  void Run();&#125;//public class Benz : ICar//&#123;//  public void Run()//  &#123;//    Debug.Log(&quot;奔驰汽车开始运行&quot;)//  &#125;//&#125;public class BMW : ICar&#123;  public void Run()  &#123;    Debug.Log(&quot;宝马汽车开始运行&quot;)  &#125;&#125;void Main()&#123;  var lucas = new Driver();  var bmw = new BMW();  lucas.Drive(bmw);&#125;</code></pre><p>从上面代码可以看出，当更换车的时候，不需要修改高层的代码，只需要把车的类更换掉就行了。<br>实际上，要完全实现”高层模块不应该依赖于低层模块，两者都应该依赖于抽象概念“这一个主题的话，Driver 类也应该抽象出来一个 IDriver，不过对于目前的结构来说没有必要。  </p><h2 id="抽象接口不应该依赖于实现，而实现依赖于抽象接口"><a href="#抽象接口不应该依赖于实现，而实现依赖于抽象接口" class="headerlink" title="抽象接口不应该依赖于实现，而实现依赖于抽象接口"></a>抽象接口不应该依赖于实现，而实现依赖于抽象接口</h2><p>我们直接上代码：</p><pre><code>var lucas = new Driver();ICar car = new BMW();lucas.Drive(car);</code></pre><p>其中的 ICar car = new BMW() 就实现了“实现依赖于抽象接口”这一主题。<br>依赖这个概念需要再次更新了，上文中说到司机需要车才能当好司机，所以司机依赖车，那么现在 BMW 需要实现 ICar 接口，才能正常使用，那么 BMW 类依赖 ICar 接口，（实现依赖抽象接口)。<br>实际上依赖倒置原则的两个主题都在说一件事情，两个类之间的交互通过抽象（接口、抽象类）来完成。<br>而通过一个抽象，可以将两个类的变化隔离。即 A 类修改或扩展甚至是替换都不影响 B，反过来也是如此。<br>通过依赖倒置原则可以提高整个系统的灵活性和扩展性还有维护性。  </p><h1 id="通过DIContainer实现DIP"><a href="#通过DIContainer实现DIP" class="headerlink" title="通过DIContainer实现DIP"></a>通过DIContainer实现DIP</h1><p>我们这时候来想想，其实依赖也就等于需求了。<br>而 QF 中的 DIContainer 支持前两种依赖管理，而市面上有个 IOC 容器，叫做 Zenject，支持以上全部的依赖关系。  </p><h2 id="DIContainer-中的接口依赖管理（QF）"><a href="#DIContainer-中的接口依赖管理（QF）" class="headerlink" title="DIContainer 中的接口依赖管理（QF）"></a>DIContainer 中的接口依赖管理（QF）</h2><p>在上文中，我们说过QF中的依赖注入的时候DIContainer提供了两个API，分别是Register 与 RegisterInstance，分别是注入的时候是新的还是说同一个。<br>实际上这两者都有一些重载，即支持接口依赖的注册。<br>多说无用，放出来代码大家来体会一下：  </p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;namespace QF.Master.Example&#123;    public interface ILoginService    &#123;        void Login();    &#125;    public class LoginService : ILoginService    &#123;        public void Login()        &#123;            Debug.Log(&quot;登录成功&quot;);        &#125;    &#125;    public class IOCInterfaceExample : MonoBehaviour     &#123;        [Inject]        public ILoginService LoginService &#123;get;set;&#125;        void Start ()         &#123;            var container = new QFrameworkContainer();            container.RegisterInstance&lt;ILoginService&gt;(new LoginService());            // Register 也支持注册接口依赖            //container.Register&lt;ILoginService,LoginService&gt;();            container.Inject(this);            LoginService.Login();        &#125;    &#125;&#125;</code></pre><p>代码很简单，代码中可以根据接口注入具体的实例，使脚本可以依赖 ILoginService 接口而不依赖于 LoginService 类。  </p><h1 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h1><p>在上文我们已经了解了依赖倒置原则和依赖注入的方案。了解了上面两个概念。这样会让我们更容易了解控制反转。  </p><h2 id="控制正转"><a href="#控制正转" class="headerlink" title="控制正转"></a>控制正转</h2><p>有反转就有正转，我们先来看看正转的代码：  </p><pre><code>public class ModuleA&#123;  public ModuleB B = new ModuleB();&#125;public class ModuleB&#123;&#125;</code></pre><p>这个就是正转，就是依赖的对象在内部进行创建，其实这不叫正转，这是正常的控制过程。<br>控制的意思其实就是依赖的对象创建的过程。也就是上述代码中的B的创建控制过程。<br>正转的过程就是被依赖对象B的创建是由依赖对象A控制，谁依赖谁创建。<br>控制反转就好理解了，就是被依赖对象B的创建是由外部控制了，就不需要依赖对象A进行控制创建了。<br>控制反转代码如下：  </p><pre><code>public class ModuleA&#123;  public ModuleB B;&#125;public class ModuleB&#123;&#125;void Main()&#123;  var moduleA = new ModuleA();  // 对象创建过程由外部控制  moduleA.B = new ModuleB();&#125;</code></pre><p><strong>控制反转意思是类依赖对象创建的过程由外部控制，而不是在类内部控制。</strong>  </p><h1 id="依赖注入与控制反转"><a href="#依赖注入与控制反转" class="headerlink" title="依赖注入与控制反转"></a>依赖注入与控制反转</h1><pre><code>控制反转：依赖对象的创建过程交给外部控制。 依赖注入：依赖对象在外部进行设置。</code></pre><p>控制反转是设计原则，或者说是设计模式，而依赖注入是控制反转的具体实现。<br>控制反转的具体实现除了有常用的依赖注入还有一种方案叫依赖查找，这里我们不介绍。<br>控制反转和依赖注入有一些细微的差别，控制反转的重点在于依赖对象创建过程的控制，而依赖注入的重点在于依赖对象如何设置，实际上这两个概念都在说，依赖对象的创建和设置都在外边搞，不要在类内部搞。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;h2 id=&quot;IOC简介&quot;&gt;&lt;a href=&quot;#IOC简介&quot; class=&quot;headerlink&quot; title=&quot;IOC简介&quot;&gt;&lt;/a&gt;IOC简</summary>
      
    
    
    
    <category term="Unity" scheme="http://yoursite.com/categories/Unity/"/>
    
    
    <category term="IOC" scheme="http://yoursite.com/tags/IOC/"/>
    
  </entry>
  
  <entry>
    <title>NUnit单元测试</title>
    <link href="http://yoursite.com/2019/09/23/Unity/NUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2019/09/23/Unity/NUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</id>
    <published>2019-09-23T01:00:31.000Z</published>
    <updated>2021-12-27T03:39:09.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><p><font size=4><strong>单元测试环境： NSubstitute</strong></font><br><font size=4><strong>编写脚本环境： rider 2020.1.4</strong></font><br><font size=4><strong>Unity环境: unity2019.4.3f1(LTS)</strong></font>    </p><p>首先下载<a href="https://github.com/nsubstitute/nsubstitute/downloads"><font color=steelblue size=3>NSubstitute</font></a>插件。<br>然后把下载的文件中的NSubstitute.dll放进需要单元测试的项目中。  </p><h1 id="配置项目中的程序集"><a href="#配置项目中的程序集" class="headerlink" title="配置项目中的程序集"></a>配置项目中的程序集</h1><p>导入需要的dll文件后，点击Unity菜单中的<strong>Window/General/Test Runner</strong>,会弹出创建界面。<br><img src="http://file.liangxiegame.com/068a79ae-72a7-49bf-904c-2e20e67a921e.png"><br>在TestRunner界面中的右上角三个点的菜单上点击选择<strong>Enable playmode  tests…</strong>,然后打开PlayMode界面就可以了。<br><img src="http://file.liangxiegame.com/c24e5014-2852-492c-8476-e15006ccc222.png">  </p><h1 id="单元测试Assert类主要静态成员"><a href="#单元测试Assert类主要静态成员" class="headerlink" title="单元测试Assert类主要静态成员"></a>单元测试Assert类主要静态成员</h1><pre><code>AreEqual：方法被重载了N多次，主要功能是判断两个值是否相等；如果两个值不相等，则测试失败。AreNotEqual：方法被重载了N多次，主要功能是判断两个值是否不相等；如果两个值相等，则测试失败。AreNotSame：引用的对象是否不相同；如果两个输入内容引用相同的对象，则测试失败.AreSame：引用的对象是否相同；如果两个输入内容引用不相同的对象，则测试失败Fail：断言失败。 Inconclusive：表示无法证明为 true 或 false 的测试结果IsFalse：指定的条件是否为 false；如果该条件为 true，则测试失败。IsTrue：指定的条件是否为 true；如果该条件为 false，则测试失败IsInstanceofType：测试指定的对象是否为所需类型的实例；如果所需的实例不在该对象的继承层次结构中，则测试失 IsNotInstanceofType: 测试指定的对象是否为所需类型的实例；如果所需的实例在该对象的继承层次结构中，则测试失败IsNull：测试指定的对象是否为非空IsNotNull：测试指定的对象是否为非空</code></pre><h1 id="单元测试脚本"><a href="#单元测试脚本" class="headerlink" title="单元测试脚本"></a>单元测试脚本</h1><h2 id="创建第一个测试脚本"><a href="#创建第一个测试脚本" class="headerlink" title="创建第一个测试脚本"></a>创建第一个测试脚本</h2><pre><code>    public interface ICalculator      &#123;        int Add(int a, int b);        string Mode &#123; get; set; &#125;        event EventHandler PoweringUp;    &#125;    [Test]    public void Test_GetSubstitute()    //NSubstitute创建类型实例    &#123;        ICalculator calculator = Substitute.For&lt;ICalculator&gt;();    //创建实例    &#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;配置环境&quot;&gt;&lt;a href=&quot;#配置环境&quot; class=&quot;headerlink&quot; title=&quot;配置环境&quot;&gt;&lt;/a&gt;配置环境&lt;/h1&gt;&lt;p&gt;&lt;font size=4&gt;&lt;strong&gt;单元测试环境： NSubstitute&lt;/strong&gt;&lt;/font&gt;&lt;br&gt;&lt;f</summary>
      
    
    
    
    <category term="Unity" scheme="http://yoursite.com/categories/Unity/"/>
    
    
    <category term="NUnit" scheme="http://yoursite.com/tags/NUnit/"/>
    
  </entry>
  
  <entry>
    <title>UGUI</title>
    <link href="http://yoursite.com/2019/09/23/Unity/UGUI/"/>
    <id>http://yoursite.com/2019/09/23/Unity/UGUI/</id>
    <published>2019-09-23T01:00:31.000Z</published>
    <updated>2021-12-27T03:39:09.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h1><h2 id="Render-Mode"><a href="#Render-Mode" class="headerlink" title="Render Mode"></a>Render Mode</h2><p>Screen Space – overlay:不需要UI相机，UI永远显示最前面。<br>Screen Space- Camera：需要提供一个UICamera,如果UI前面需要加特效，只要深度大于UICamera就行了。<br>World Space：适用于3D的UI。  </p><h2 id="Pixel-Perfect"><a href="#Pixel-Perfect" class="headerlink" title="Pixel Perfect"></a>Pixel Perfect</h2><p>启用可以使元素看起来清晰并防止模糊。</p><h2 id="Sort-Order"><a href="#Sort-Order" class="headerlink" title="Sort Order"></a>Sort Order</h2><p>Canvas的深度，数值越大，优先级越高；优先级高的遮挡优先级低的。  </p><h2 id="Terget-Display"><a href="#Terget-Display" class="headerlink" title="Terget Display"></a>Terget Display</h2><p>使Canvas渲染到指定的显示中。支持的辅助显示器最大数量为8。</p><h2 id="Additional-Shader-Channels"><a href="#Additional-Shader-Channels" class="headerlink" title="Additional Shader Channels"></a>Additional Shader Channels</h2><p>提供给Shader使用的参数。</p><h2 id="Render-Camera"><a href="#Render-Camera" class="headerlink" title="Render Camera"></a>Render Camera</h2><p>指定Canvas渲染在哪一个摄像机上。</p><h2 id="Plane-Distance"><a href="#Plane-Distance" class="headerlink" title="Plane Distance"></a>Plane Distance</h2><p>当Camera的Projection为Orthograhic时，值得变化仅仅改变Canvas的Pos Z；<br>当Camera的Projection为Perspective时，值得变化不仅仅改变Canvas的Pos Z,还会改变Scale;<br>当Plane Distance等于Camera的Clipping Planes的Near时，相当于Render Mode是Screen Space-Overlay的效果，当Plane Distance等于Camera的Clipping Planes的Far时，Canvas在所有物体的后面。  </p><h2 id="Sorting-Layer"><a href="#Sorting-Layer" class="headerlink" title="Sorting Layer"></a>Sorting Layer</h2><p>可为UGUI设置画布深度，在下拉菜单中点击“Add Sorting Layer”进入标签和层的设置界面，点击+或者-即可添加和删除，画布所使用的Sorting Layer越往下，显示的优先级越高。   </p><h2 id="Order-in-Layer"><a href="#Order-in-Layer" class="headerlink" title="Order in Layer"></a>Order in Layer</h2><p>在相同深度的Layer中区别显示层级关系的设定，相同的Layer中Order in Layer越高，显示的优先级也就越高。  </p><h2 id="Event-Camera"><a href="#Event-Camera" class="headerlink" title="Event Camera"></a>Event Camera</h2><p>在World Space模式下，Event Camera为空也可以执行按钮点击事件  </p><h1 id="Canvas-Scaler"><a href="#Canvas-Scaler" class="headerlink" title="Canvas Scaler"></a>Canvas Scaler</h1><h2 id="UI-Scale-Mode-——-Constant-Pixel-Size"><a href="#UI-Scale-Mode-——-Constant-Pixel-Size" class="headerlink" title="UI Scale Mode —— Constant Pixel Size"></a>UI Scale Mode —— Constant Pixel Size</h2><p>不管屏幕Size如何变化，都会保持UI像素Size不变。<br>Scale Factor:设置UI的缩放比例，值为1表示不缩放。<br>Reference Pixels Per Unit:UI元素每个单元需要Sprite途中的多少像素填充。  </p><h2 id="UI-Scale-Mode-——-Scale-With-Screen-Size"><a href="#UI-Scale-Mode-——-Scale-With-Screen-Size" class="headerlink" title="UI Scale Mode —— Scale With Screen Size"></a>UI Scale Mode —— Scale With Screen Size</h2><p>UI根据屏幕的size来调整自己的size。<br>Reference Resolution:默认参考的分辨率，一般设置为当下市场中主流设备的分辨率，它是参考标准，其他的分辨率的，会根据它来进行缩放。<br>Screen Match Mode:如果当前屏幕的分辨率与参考标准值不符时，应选择一种适应匹配模式来缩放Canvas。   </p><pre><code>1.Match Width Or Height当Match的值为0时，指UI大小只取决于屏幕的宽度，如果当前屏幕的宽度是参考标准宽度的n倍，则UI整体缩放为参考标准的n倍，当Match的值为1时，指UI大小只取决于屏幕的高度；当Match的值在0~1之间时，通过上述两个比例权重加成来进行计算。  2.Expand这种模式比较适合屏幕实际的Size大于参考标准时，需要将UI扩充到大屏幕中，为尽可能保证显示效果，该模式会选择变化较小的一个方向，作为放大Canvas的标准，儿另外一个方向的变化则在整体缩放后进行补偿性的变化。3.Shrink与Expand恰好相反，这种模式比较适合屏幕的实际Size大小参考标准时，需要将UI压缩到小屏幕中，原理与Expand类似。</code></pre><h2 id="UI-Scale-Mode-——-Constant-Physical-Size"><a href="#UI-Scale-Mode-——-Constant-Physical-Size" class="headerlink" title="UI Scale Mode —— Constant Physical Size"></a>UI Scale Mode —— Constant Physical Size</h2><p>不管屏幕的Size还是分辨率如何，都会保持UI的物理Size不变<br>Physical Unit：设置物理尺寸单位<br>Fallback Screen DPI:当前屏幕分辨率不明确时而采用的分辨率；<br>Default Sprite DPI：精灵图片每英寸的默认像素</p><h1 id="Graphic-Raycaster"><a href="#Graphic-Raycaster" class="headerlink" title="Graphic Raycaster"></a>Graphic Raycaster</h1><p>用于检测头像Canvas的射线。<br>Ignore Reversed Graphics:忽略颠倒的图形的射线检测，即旋转180°后的图片不会与射线发生交互<br>Blocked Objects：会阻挡图形射线的对象类型，需要有collider组件。<br>Blocked Mask：会阻挡图形射线的Layer。</p><h1 id="LayoutGroup"><a href="#LayoutGroup" class="headerlink" title="LayoutGroup"></a>LayoutGroup</h1><h2 id="Grid-Layout-Group"><a href="#Grid-Layout-Group" class="headerlink" title="Grid Layout Group"></a>Grid Layout Group</h2><p>Padding:间隔<br>CellSize:子物体大小<br>Spacing：子物体之间的间隔<br>Start Corner:子物体排列的角度<br>Start Axis:子物体排列方向<br>Child Alignment:子物体整体位于什么方位<br>Constraint: </p><pre><code>Flexible:灵活的，按照父物体长宽自动横竖行Fixed Column Count:指定列数Fixed Row Count:指定行数</code></pre><h2 id="Horizontak-Vertical-Layout-Group"><a href="#Horizontak-Vertical-Layout-Group" class="headerlink" title="Horizontak(Vertical) Layout Group"></a>Horizontak(Vertical) Layout Group</h2><p>child force expand：是否强制拉伸长宽到父物体大小。单独使用很难实现理想效果，所以要配合Content Size Fitter组件配合使用。<br>Content Size Fitter:</p><pre><code>Horizontal Fit:子物体横向适配Vertical Fit:子物体竖向适配</code></pre><p>Layout Element:</p><pre><code>Min Width:最小宽度Min Height:最小高度Preferred Width:首选宽度Flexible Width:灵活的宽度Flexible Height:灵活的高度</code></pre><h2 id="Content-Size-Fitter"><a href="#Content-Size-Fitter" class="headerlink" title="Content Size Fitter"></a>Content Size Fitter</h2><p>一般和Layout Group配合使用</p><h2 id="Aspect-Ratio-Fitter"><a href="#Aspect-Ratio-Fitter" class="headerlink" title="Aspect Ratio Fitter"></a>Aspect Ratio Fitter</h2><p>Aspect Mode:宽高比模式（宽控制高，高不可修改）<br>Height Controls Width:高控制宽<br>Fitln Parent:宽或高和父物体一样，另一个小于父物体<br>Envelope Parent：宽或高和父物体一样，另一个包围父物体<br>Aspect Ratio:宽高比例  </p><h1 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h1><h2 id="Source-Image"><a href="#Source-Image" class="headerlink" title="Source Image"></a>Source Image</h2><p>指定要系那是的目标图片资源，只支持Sprite类型的图片。</p><h2 id="Color"><a href="#Color" class="headerlink" title="Color"></a>Color</h2><p>设置Color属性值，会改变图片显示的色调。</p><h2 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h2><p>设定用于渲染图片的材质</p><h2 id="RaycastTarget"><a href="#RaycastTarget" class="headerlink" title="RaycastTarget"></a>RaycastTarget</h2><p>决定是否接收射线碰撞检测</p><h2 id="Image-Type"><a href="#Image-Type" class="headerlink" title="Image Type"></a>Image Type</h2><p>用于设定图片显示的类型，如Simple/Sliced/Tiled/Filled。  </p><h3 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h3><p>图片根据Image的比例按照原来比例进行伸缩改变。</p><h3 id="Sliced"><a href="#Sliced" class="headerlink" title="Sliced"></a>Sliced</h3><p>九宫格，经过九宫格处理的图片，在九宫格的4个角落不进行改变，并且4个边只进行单向的伸缩。<br>在属性面板中点击Sprite Editor按钮即可进行图片的九宫格编辑。<br>Fill Center选项如果取消勾选，Image的显示就不会完成，只会显示切片的边缘图片。  </p><h3 id="Tiled"><a href="#Tiled" class="headerlink" title="Tiled"></a>Tiled</h3><p>此模式下Sprite本身大小会保持不变，但是sprite会像铺地板一样填充整个Image。  </p><h3 id="Filled"><a href="#Filled" class="headerlink" title="Filled"></a>Filled</h3><p>此模式一般用作“CD”效果的技能按钮等，让Image以一定的展现方式显示部分。<br>Fill Method:指定呈现方式（Horizontal水平、Vertical垂直、Radial90(1/4圆呈现)，半圆，整圆）<br>Fill Origin:指定填充显现操作的起点。<br>Fill Amount:指定填充的进度<br>Clock Wise:针对圆类型的填充显示方式，取消与勾选该项，会“翻转”填充显示“方向”<br>Preserve Aspect:根据Sprite宽高比，缩放Image  </p><h1 id="Canvas-Group"><a href="#Canvas-Group" class="headerlink" title="Canvas Group"></a>Canvas Group</h1><h2 id="Alpha"><a href="#Alpha" class="headerlink" title="Alpha"></a>Alpha</h2><p>该组件UI元素的透明度。需要注意，每个UI最终的透明度是由此值和自身的alpha数值相乘得到。  </p><h2 id="Interactable"><a href="#Interactable" class="headerlink" title="Interactable"></a>Interactable</h2><p>是否需要交互，通知作用于该组全部UI元素  </p><h2 id="BlockRaycasts"><a href="#BlockRaycasts" class="headerlink" title="BlockRaycasts"></a>BlockRaycasts</h2><p>如果需要图形射线检测，勾选后，可将此组件作为一个射线碰撞盒。注意不适用于Physics.Raycast  </p><h2 id="Ignore-Parent-Groups"><a href="#Ignore-Parent-Groups" class="headerlink" title="Ignore Parent Groups"></a>Ignore Parent Groups</h2><p>是否需要忽略父级对象中的Canvas Group的设置（勾选则忽略）  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Canvas&quot;&gt;&lt;a href=&quot;#Canvas&quot; class=&quot;headerlink&quot; title=&quot;Canvas&quot;&gt;&lt;/a&gt;Canvas&lt;/h1&gt;&lt;h2 id=&quot;Render-Mode&quot;&gt;&lt;a href=&quot;#Render-Mode&quot; class=&quot;header</summary>
      
    
    
    
    <category term="Unity" scheme="http://yoursite.com/categories/Unity/"/>
    
    
    <category term="UGUI" scheme="http://yoursite.com/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>UniRx入门</title>
    <link href="http://yoursite.com/2019/09/23/Unity/UniRx%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/09/23/Unity/UniRx%E5%85%A5%E9%97%A8/</id>
    <published>2019-09-23T01:00:31.000Z</published>
    <updated>2021-12-27T03:39:09.481Z</updated>
    
    <content type="html"><![CDATA[<pre><code>UniRx - Unity响应式编程插件  插件作者Yoshifumi Kawai(neuecc) 本篇参照博客：1.凉鞋小班博客            2.https://blog.csdn.net/zhenghongzhi6/article/details/79229585</code></pre><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="UniRx简介"><a href="#UniRx简介" class="headerlink" title="UniRx简介"></a>UniRx简介</h2><p>UniRx 是 Unity Reactive Extensions 的缩写，意思是 Unity 的响应式扩展集。重写了.Net的响应式扩展。<br>.Net官方的Rx很棒，但是在Unity中无法使用，并且与IOS的IL2CPP有兼容性问题。这个库这些问题并且添加了一些Unity专属的工具类。<br>支持的平台有：PC/Mac/Android/iOS/WP8/WindowsStore/等等，并且支持Unity4.6之后的所有版本。  </p><p><strong>UniRx 在 Unity Asset Store 的地址(免费)：<a href="http://u3d.as/content/neuecc/uni-rx-reactive-extensions-for-unity/7tT">http://u3d.as/content/neuecc/uni-rx-reactive-extensions-for-unity/7tT</a></strong>  </p><h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p>响应式是什么意思：一旦A做了事情，B就得到了通知。<br>为什么unirx是响应式：因为UniRx通过观察者模式实现了这种响应。  </p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>在C#语法中对静态this关键字进行了扩展，类似于Linq的关键字扩展。<br>例：<br>    Observable.EveryUpdate() // 每一帧发送一次通知<br>      .Where(<em>=&gt;Timer.frameCount % 5 == 0) // Linq Where 关键字，每 5 帧发送一次通知<br>      .Subscribe(</em>=&gt;Debug.Log(“Every 5 Frame”)) // 订阅 输出</p><h2 id="为什么用Rx"><a href="#为什么用Rx" class="headerlink" title="为什么用Rx"></a>为什么用Rx</h2><p>拿网络操作进行举例：<br>网络操作需要用到WWW和Coroutine。但是使用Coroutine会遇到下面列问题<br>  1.协程不能有返回值，因为返回类型必须是IEnumerator<br>  2.协程不能处理异常，因为 yield return 语句没办法被 try-catch<br>这样就会造成代码大面试的强耦合。<br>游戏循环 (every Update, OnCollisionEnter, etc), 传感器数据 (Kinect, Leap Motion, VR Input, etc.) 都是事件。Rx将事件转化为响应式的序列，通过LINQ操作可以很简单地组合起来，还支持时间操作。  </p><p>Unity通常是单线程，但是UniRx可以让多线程更容易。</p><p>UniRx 可以简化 uGUI 的编程，所有的UI事件 (clicked, valuechanged, etc) 可以转化为 UniRx 的事件流。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Reactive Extensions 指的就是： 观察者模式 + Linq。</p><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>代码如下：</p><pre><code>using UnityEngine;using UniRx;namespace QF.Master.Example&#123;    public class UniRxBasicUsage : MonoBehaviour    &#123;        void Start()        &#123;            Observable.EveryUpdate()                .Where(_ =&gt; Time.frameCount % 5 == 0)                .Subscribe(_=&gt; Debug.Log(&quot;hello&quot;));        &#125;    &#125;&#125;</code></pre><p>运行结果：<br><img src="http://file.liangxiegame.com/7d00ea36-8058-4b6d-87d6-d2e27d2e6cb2.png">  </p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>主要代码：</p><pre><code>Observable.EveryUpdate()  .Where(_ =&gt; Time.frameCount % 5 == 0)  .Subscribe(_=&gt; Debug.Log(&quot;hello&quot;));</code></pre><p>代码分为三部分，分别是:</p><pre><code>Observable：Observable.EveryUpdate()Linq 操作符：Where(_ =&gt; Time.frameCount % 5 == 0)订阅、注册事件的处理：Subscribe(_=&gt; Debug.Log(&quot;Hello&quot;))</code></pre><p>以上是一个 UniRx 的基本使用格式，每个 UniRx 的完整使用，都会包含以上三个部分。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式分别有:观察者（Observer）、主题（Subject）、通知（Notify）、订阅（Subscribe）。<br>Observable 中文的意思是可观察者的，是一个形容词。<br>主题（Subject）就是可观察的主体。<br>对比下列代码</p><pre><code>Observable.EveryUpdate()    // Observable  .Where(_ =&gt; Time.frameCount % 5 == 0)        //可以不写，代表没有限制条件  .Subscribe(_=&gt; Debug.Log(&quot;hello&quot;));    // Subscribe</code></pre><p>代码中的 EveryUpdate 意思是：每次执行 Update 时，发送一次通知（Notify）。<br>发送的通知由 Subscribe 中的 lambda 表达式接收。  </p><h3 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h3><pre><code>Where(_ =&gt; Time.frameCount % 5 == 0)</code></pre><p>Where 是相当于一个条件过滤，意思是，当 Where 方法中的 lambda 表达式返回 true 时，则保留，否则丢弃。<br>Where 是一个 Linq 操作符。<br>举例：</p><pre><code>var ages = new int[] &#123; 1,2,3&#125;;var ageList = ages.Where(age=&gt;age &gt;= 2).ToList();// 此时 ageList 为 [2,3]</code></pre><h2 id="UniRx-中的-Linq-操作符"><a href="#UniRx-中的-Linq-操作符" class="headerlink" title="UniRx 中的 Linq 操作符"></a>UniRx 中的 Linq 操作符</h2><p>Linq 有大量的类似 Where 这样的操作符，而 UniRx 也同样支持了大量的操作符，不过 UniRx 是在自己的库中实现的，与 C# 的 Linq 操作符并不是完全一致的。<br>我们知道 C# 中的 Linq 操作符是查询内存数据用的，这里的内存数据指的是各种可枚举集合（IEnumrable），比如 Array,Queue,Stack,Dictionary 等所有实现 IEnumrable 接口的类。<br>而 UniRx 中的 Linq 操作符是用来查询各种事件源的 (IObservable)，比如 Observable.EveryUpdate() 返回的对象就是一个 IObservable 对象。<br>C# 中的 Where 操作符是过滤一个一个数据。<br>而 UniRx 中的 Where 操作符是过滤一个一个通知（事件）  </p><h2 id="Subscribe"><a href="#Subscribe" class="headerlink" title="Subscribe"></a>Subscribe</h2><pre><code>.Subscribe(_=&gt; Debug.Log(&quot;hello&quot;));</code></pre><p>Subscribe就是订阅的意思，在代码中其实是被订阅的意思，意思就是被<strong>观察者</strong>订阅。<br>代码结构目前是：</p><pre><code>Observable.Linq.Subcribe(callback)</code></pre><p>讲到这里，观察者模式中，我们看到了<strong>主题（Observable）、订阅（Subscribe）、通知（Notify）</strong>，但是还没有**观察者(Observer)**。<br>我们来看看Subscribe的底层是如何定义的  </p><pre><code>public static XXXYYYZZZ Subscribe(IObserver observer)&#123;  ...&#125;</code></pre><p>Subscribe 的参数实际上就是一个观察者，而在最上层的 API 中，UniRx 将 Observer 简化为了一个委托。<br><img src="http://file.liangxiegame.com/a682675e-98a6-4c60-af78-5d5801f066f1.png">  </p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>UniRx 的最核心的三个概念分别是：<br>Observable（可观察的）<br>Linq 操作符<br>Subscribe（Observer）<br>这是UniRx最基础的三个概念，只要熟练掌握这三个概念就可以运用UniRx的所有API了。<br>niRx 有大量的 Observable 和 Linq 操作符，我们学习的 EveryUpdate 只是其中一个 Observable。  </p><h1 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h1><h2 id="TimeSpan-延迟功能"><a href="#TimeSpan-延迟功能" class="headerlink" title="TimeSpan(延迟功能)"></a>TimeSpan(延迟功能)</h2><p>代码如下：</p><pre><code>using UnityEngine;using UniRx;using System;public class UniRxTimerExample : MonoBehaviour &#123;    void Start ()     &#123;        Debug.Log(&quot;此时:&quot; + DateTime.Now);        Observable.Timer(TimeSpan.FromSeconds(2.0f))             .Subscribe(_=&gt;Debug.Log(&quot;此时:&quot; + DateTime.Now));    &#125;&#125;</code></pre><h2 id="AddTo-MonoBehaviour"><a href="#AddTo-MonoBehaviour" class="headerlink" title="AddTo(MonoBehaviour)"></a>AddTo(MonoBehaviour)</h2><p>上述延迟有个问题，就是如果延迟期间gameobject被销毁，就会访问到NULL数据<br>UniRx 提供了一个方案：生命周期绑定<br>当 GameObject 销毁时，自动销毁延时任务：AddoTo(MonoBehaviour)  </p><pre><code>using UnityEngine;using UniRx;using System;public class UniRxTimerExample : MonoBehaviour &#123;    void Start ()     &#123;        Debug.Log(&quot;此时:&quot; + DateTime.Now);        Observable.Timer(TimeSpan.FromSeconds(2.0f))            .Subscribe(_=&gt; Debug.Log(&quot;此时:&quot;  + DateTime.Now))            .AddTo(this);        Observable.Timer(TimeSpan.FromSeconds(0.5f))            .Subscribe(_=&gt; Destroy(gameObject));    &#125;&#125;</code></pre><p>运行的结果:(2s后就没有输出了)<br><img src="http://file.liangxiegame.com/64db9c51-30fa-458c-bc64-366bfa4d6b3a.png"></p><h2 id="IDisposable"><a href="#IDisposable" class="headerlink" title="IDisposable"></a>IDisposable</h2><p>而 AddTo 实际上是 UniRx 对 IDisposable(.NET中用于释放对象资源的接口) 的一个静态扩展，也就是说所有的实现 IDisposable 接口的对象都可以使用 AddTo 将销毁绑定到 MonoBehaviour 或 GameObject 上。<br>而 Observbale.Timer 在 Subscribe 之后能够调用 AddTo 是因为 Subscribe 方法返回了一个 IDisposable 对象。  </p><pre><code>public static IDisposable Subscribe&lt;T&gt;(this IObservable&lt;T&gt; source, Action&lt;T&gt; onNext)&#123;    ...&#125;</code></pre><p>使用 IDisposable 和 AddTo 这对组合我们可以在做模块或库设计的时候非常容易实现生命周期绑定的功能，IDisposable 实际上可以充当一个卸载过程。 </p><h1 id="Subject使用"><a href="#Subject使用" class="headerlink" title="Subject使用"></a>Subject使用</h1><h2 id="Subject-Observable"><a href="#Subject-Observable" class="headerlink" title="Subject Observable"></a>Subject Observable</h2><p>Subject 即主题，UniRx 是提供了具体的 Subject 这个概念的。<br>举例代码如下：  </p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;using UniRx;public class UniRxSubjectExample : MonoBehaviour &#123;    void Start ()     &#123;        var subject = new Subject&lt;int&gt;();        subject.Subscribe(number =&gt; &#123;            Debug.Log(number);        &#125;);        subject.OnNext(1);        subject.OnNext(2);        subject.OnNext(3);    &#125;&#125;</code></pre><p>Subject是一个Observable，是一个事件源，是可以被订阅的(Subscribe).<br>而 Subject 是一个泛型类，可以制定要发送通知的类型。<br>代码中指定了发送类型为int。  </p><pre><code>var subject = new Subject&lt;int&gt;();</code></pre><p>而指定什么类型，那么在订阅的时候就会接收到什么类型的数据  </p><pre><code>subject.Subscribe(number =&gt; &#123;  Debug.Log(number);&#125;);</code></pre><p>一个 subject 光是创建对象和被订阅是没什么用的，要让 subject 发送数据，代码如下:</p><pre><code>subject.OnNext(1);subject.OnNext(2);subject.OnNext(3);</code></pre><p>运行结果如下：<br><img src="http://file.liangxiegame.com/42e52357-4f57-4b0e-820a-d5c32d4628d8.png">  </p><h2 id="Subjecrt是什么？"><a href="#Subjecrt是什么？" class="headerlink" title="Subjecrt是什么？"></a>Subjecrt是什么？</h2><p>在 UniRx 中 Subject 是一个 Observable（事件源），它可以让我们通过做少的代码实现观察者模式。  </p><h2 id="Subject-与委托相比有什么不同？"><a href="#Subject-与委托相比有什么不同？" class="headerlink" title="Subject 与委托相比有什么不同？"></a>Subject 与委托相比有什么不同？</h2><p>在使用上，Subject 与委托的使用方式差不多，两者之间共同的地方有：</p><blockquote><p>需要声明，定义参数类型<br>需要注册、订阅<br>委托需要调用，而 Subject 需要通过 OnNext 发送数据。<br>委托给人的感觉是一根线，而 Subject 给人感觉是一个管道。<br>委托不同的地方有：<br>可以定义多个接收参数<br>接收数据之后比较难以再组织整理  </p></blockquote><p>Subject 不同的地方有：  </p><blockquote><p>只能定一个一个参数类型<br>接收数据之后可以使用 Linq 对数据进行再组织整理   </p></blockquote><h1 id="OnNext-与-IObserver"><a href="#OnNext-与-IObserver" class="headerlink" title="OnNext 与 IObserver"></a>OnNext 与 IObserver</h1><h2 id="OnNext简介"><a href="#OnNext简介" class="headerlink" title="OnNext简介"></a>OnNext简介</h2><p>从前面内容可以推测出Subject 继承了 Observable。<br>真实情况底层代码<strong>Subject</strong>实现了一个<strong>IObservable</strong>接口  </p><pre><code>namespace UniRx&#123;    public interface IObservable&lt;T&gt;    &#123;        IDisposable Subscribe(IObserver&lt;T&gt; observer);    &#125;&#125;</code></pre><p>从代码中可以看出**IObservable.Subscribe(IObserver)**结构<br>OnNext 没有在 IObservable 中定义，但是在 IObserver 中定义了，IObserver 代码如下：</p><pre><code>using System;namespace UniRx&#123;    public interface IObserver&lt;T&gt;    &#123;        void OnCompleted();        void OnError(Exception error);        void OnNext(T value);    &#125;&#125;</code></pre><p>Subject 既是 Observable 也是 Observer。它同时实现了 IObservable 和 IObserver 两个接口。</p><p>这样 Subject 就能做到，既可以被订阅（Subscribe），又可以让我们通过其 OnNext 方法传输数据。</p><p>到此，大家可能会比较乱，IObservable 和 IObserver 分不清楚。</p><p>没关系，IObservable 和 IObserver 在接下来的文章中会着重介绍，因为它俩是 UniRx 的两个核心接口。</p><h2 id="OnNext-是什么？"><a href="#OnNext-是什么？" class="headerlink" title="OnNext 是什么？"></a>OnNext 是什么？</h2><p>OnNext 是 IObserver 定义的 API，在 UniRx 内部，OnNext 是被 IObservable 调用的。当 IObservable 每次发送事件时，都是通过 OnNext 向 IObserver 发送事件了，如下图所示：<br><img src="http://file.liangxiegame.com/e881f6d8-991f-4cda-83c7-d8664526f928.png"><br>而 Subject 既是 IObservable 又是 IObserver 所以既可以通过 OnNext 传输数据，又可以被 Subscribe。<br>Subject 就是这样的一个特殊的存在。 </p><h1 id="IObserver"><a href="#IObserver" class="headerlink" title="IObserver"></a>IObserver</h1><p>底层代码：  </p><pre><code>using System;namespace UniRx&#123;    public interface IObserver&lt;T&gt;    &#123;        void OnCompleted();        void OnError(Exception error);        void OnNext(T value);    &#125;&#125;</code></pre><h2 id="OnComplete"><a href="#OnComplete" class="headerlink" title="OnComplete"></a>OnComplete</h2><p>OnCompleted意思是，当完成时，也就是说当 Observable 发送完事件时会调用 IObserver 的 OnCompleted 的方法。<br>Observable.EveryUpdate 没有完成的时刻,所以是不会接收Oncomplete事件。<br>在<strong>UniRx</strong>中我们就知道有两种 Observable 了，即<strong>可结束的（比如 Observable.Timer）</strong>和不可结束的<strong>（Observable.EveryUpdate）</strong>。<br>OnCompleted 是在Subscribe 的第二个参数中使用。<br>我们知道 Subscribe 可以传入一个委托，次委托实际上是对应的是 OnNext 事件，那么第二个<strong>无参委托</strong>则是对应的是 OnCompleted 事件。  </p><pre><code>using UnityEngine;using UniRx;using System;public class UniRxOnCompletedExample : MonoBehaviour &#123;    void Start ()     &#123;            Observable.Timer(TimeSpan.FromSeconds(3.0f))            .Subscribe(_ =&gt; Debug.Log(&quot;Delayed 3 seconds&quot;),()=&gt;Debug.Log(&quot;completed&quot;));    &#125;&#125;</code></pre><h2 id="OnNext"><a href="#OnNext" class="headerlink" title="OnNext"></a>OnNext</h2><p>Subscribe 的第一个有参委托就是接收的是 OnNext 事件，这里就不多说了。</p><h2 id="OnError"><a href="#OnError" class="headerlink" title="OnError"></a>OnError</h2><p>Observable（事件源）会发送一些异常或错误，这个时候错误和异常就会发送到 IObserver 的 OnError 中，而 OnError 的使用也非常简单，即：Subscribe 的第二个<strong>有参委托</strong>接收的就是 OnError 事件  </p><h1 id="ReactiveProperty"><a href="#ReactiveProperty" class="headerlink" title="ReactiveProperty"></a>ReactiveProperty</h1><p>ReactiveProperty 即响应式属性，它是一个 Property(属性)，同时也是响应式的，说明它是一个可以被 Subscribe 的 Property。  </p><h2 id="C-中的Property"><a href="#C-中的Property" class="headerlink" title="C#中的Property"></a>C#中的Property</h2><pre><code>public class SomeClass&#123;  public int Age &#123;get;set;&#125;&#125;</code></pre><p>SomeClass 中的 Age 是一个 Property（属性）  </p><h2 id="UniRx中的Property"><a href="#UniRx中的Property" class="headerlink" title="UniRx中的Property"></a>UniRx中的Property</h2><pre><code>public class SomeClass&#123;  public ReactiveProperty&lt;int&gt; Age = new ReactiveProperty&lt;int&gt;();&#125;</code></pre><p>ReactiveProperty 的作用与 C# 的 Property 作用是一致的，就是可以设置值和获取值。<br>得到值的方法是：<strong>属性名.Value</strong><br>测试代码：</p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;using UniRx;public class UniRxReactiveProperty : MonoBehaviour &#123;    ReactiveProperty&lt;int&gt; mAge = new ReactiveProperty&lt;int&gt;();    void Start () &#123;        mAge.Subscribe(age=&gt;Debug.Log(age));        mAge.Value = 10;        mAge.Value = 10;        mAge.Value = 10;        mAge.Value = 11;    &#125;&#125;</code></pre><p>得到结果：<br><img src="http://file.liangxiegame.com/5f57e47e-695e-4490-8b6e-45753ce51715.png"><br>这里多输出了一个 0，这是因为，ReactiveProperty 会把初始默认值当做第一次值改变发送给 Subscribe 的委托。<br>解决方法Skip(1)：</p><pre><code> mAge.Skip(1)     .Subscribe(age=&gt;Debug.Log(age));</code></pre><p>这里我们要注意一下，ReactiveProperty 把初始值当做值改变事件发送是合理的，因为有的时候我们是需要得到初始值的，那么至于大家在使用时需不需要初始值，大家可以自行决定，而屏蔽掉初始值的方式就是通过 Skip 操作符。  </p><h2 id="Skip"><a href="#Skip" class="headerlink" title="Skip"></a>Skip</h2><p>skip 是 Linq 的操作符，意思是忽略，而 Skip 的参数是 Count，就是说可以通过 Count 来决定忽略多少个数据、事件。<br>在 ReactiveProperty 的用例代码中，Skip 的 Count 参数为 1，意思是忽略 1 个数据、事件。  </p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>ReactiveProperty 是一个事件源（Observable），而 Skip 是一个 Linq 操作符。<br>ReactiveProperty 是经常使用的设计工具，笔者常用它来写 Model 层的代码。  </p><h1 id="ReactiveCollection"><a href="#ReactiveCollection" class="headerlink" title="ReactiveCollection"></a>ReactiveCollection</h1><p>这是一种List形式的属性，用法和ReactiveProperty差不多：  </p><pre><code>public ReactiveCollection&lt;PlayerData&gt; mPlayerDataList = new ReactiveCollection&lt;PlayerData&gt;();</code></pre><p>是支持类似于List的Add一类的函数的。这里先不用做过多的详解   </p><h1 id="基于UniRx的事件系统"><a href="#基于UniRx的事件系统" class="headerlink" title="基于UniRx的事件系统"></a>基于UniRx的事件系统</h1><h2 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h2><p>代码：  </p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;using System;using UniRx;public class UniRxTypeEventSystem &#123;    /// &lt;summary&gt;    /// 接口 只负责存储在字典中    /// &lt;/summary&gt;    interface IRegisterations    &#123;    &#125;    /// &lt;summary&gt;    /// 多个注册    /// &lt;/summary&gt;    class Registerations&lt;T&gt; : IRegisterations    &#123;        /// &lt;summary&gt;        /// 不需要 List&lt;Action&lt;T&gt;&gt; 了        /// 因为委托本身就可以一对多注册        /// &lt;/summary&gt;        public Subject&lt;T&gt; Subject = new Subject&lt;T&gt;();    &#125;    /// &lt;summary&gt;    ///     /// &lt;/summary&gt;    private static Dictionary&lt;Type, IRegisterations&gt; mTypeEventDict = new Dictionary&lt;Type, IRegisterations&gt;();    /// &lt;summary&gt;    /// 注册事件    /// &lt;/summary&gt;    /// &lt;param name=&quot;onReceive&quot;&gt;&lt;/param&gt;    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;    public static Subject&lt;T&gt; GetEvent&lt;T&gt;()    &#123;        var type = typeof(T);        IRegisterations registerations = null;        if (mTypeEventDict.TryGetValue(type, out registerations))        &#123;            var reg = registerations as Registerations&lt;T&gt;;            return reg.Subject;        &#125;        else        &#123;            var reg = new Registerations&lt;T&gt;();            mTypeEventDict.Add(type, reg);            return reg.Subject;        &#125;    &#125;    /// &lt;summary&gt;    /// 发送事件    /// &lt;/summary&gt;    /// &lt;param name=&quot;t&quot;&gt;&lt;/param&gt;    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;    public static void Send&lt;T&gt;(T t)    &#123;        var type = typeof(T);        IRegisterations registerations = null;        if (mTypeEventDict.TryGetValue(type, out registerations))        &#123;            var reg = registerations as Registerations&lt;T&gt;;            reg.Subject.OnNext(t);        &#125;    &#125;&#125;</code></pre><p>调用方法：</p><pre><code>using System.Collections;using System.Collections.Generic;using System;using UnityEngine;using UniRx;public class UniRxTypeEventSystemTest : MonoBehaviour&#123;    class A    &#123;    &#125;    class B    &#123;        public int    Age;        public string Name;    &#125;    IDisposable mEventADisposable;    private void Start()    &#123;        mEventADisposable = UniRxTypeEventSystem.GetEvent&lt;A&gt;()            .Subscribe(ReceiveA); // 可以获取 IDisposable 对象        UniRxTypeEventSystem.GetEvent&lt;B&gt;()            .Subscribe(ReceiveB)            .AddTo(this); // 可以绑定    &#125;    void ReceiveA(A a)    &#123;        Debug.Log(&quot;received A&quot;);    &#125;    void ReceiveB(B b)    &#123;        Debug.LogFormat(&quot;received B:&#123;0&#125; &#123;1&#125;&quot;, b.Name, b.Age);    &#125;    private void Update()    &#123;        if (Input.GetMouseButtonDown(0))        &#123;            UniRxTypeEventSystem.Send(new A());        &#125;        if (Input.GetMouseButtonDown(1))        &#123;            UniRxTypeEventSystem.Send(new B()            &#123;                Age = 10,                Name = &quot;凉鞋&quot;            &#125;);        &#125;        if (Input.GetKeyDown(KeyCode.U))        &#123;            mEventADisposable.Dispose();        &#125;    &#125;&#125;</code></pre><h2 id="案例二（自写）"><a href="#案例二（自写）" class="headerlink" title="案例二（自写）"></a>案例二（自写）</h2><pre><code>using System;using System.Collections;using System.Collections.Generic;using QF;using UniRx;using UnityEngine;/// &lt;summary&gt;/// 接口 只负责存储在字典中/// &lt;/summary&gt;interface IRegisterations&#123;&#125;/// &lt;summary&gt;/// 多个注册/// &lt;/summary&gt;class Registerations : IRegisterations&#123;    /// &lt;summary&gt;    /// 委托本身就可以一对多注册    /// &lt;/summary&gt;    public Subject&lt;object[]&gt; Subject = new Subject&lt;object[]&gt;();&#125;public class MyEventSystem&#123;    /// &lt;summary&gt;    /// 存储已经注册的事件    /// &lt;/summary&gt;    private static Dictionary&lt;MyEventType, IRegisterations&gt; mTypeEventDict         = new Dictionary&lt;MyEventType, IRegisterations&gt;();    /// &lt;summary&gt;    /// 注册事件    /// &lt;/summary&gt;    public static Subject&lt;object[]&gt; GetEvent(MyEventType type)    &#123;        IRegisterations registerations = null;        if (mTypeEventDict.TryGetValue(type, out registerations))        &#123;            var reg = registerations as Registerations;            return reg.Subject;        &#125;        else        &#123;            var reg = new Registerations();            mTypeEventDict.Add(type, reg);            return reg.Subject;        &#125;    &#125;    /// &lt;summary&gt;    /// 发送事件    /// &lt;/summary&gt;    public static void Send(MyEventType type, params object[] param)    &#123;        IRegisterations registerations = null;        if (mTypeEventDict.TryGetValue(type, out registerations))        &#123;            var reg = registerations as Registerations;            reg.Subject.OnNext(param);        &#125;    &#125;    &#125;</code></pre><p>调用方法：</p><pre><code>MyEventSystem.Send(MyEventType.SelectNewPlayer, date);MyEventSystem.GetEvent(MyEventType.SelectNewPlayer)            .Subscribe(ChangePlayerShow)            .AddTo(this);</code></pre><h1 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h1><p>使用 ObservableWWW 进行异步网络操作。它的 Get/Post 方法返回可订阅(Subscribe)的 IObservables:  </p><pre><code>ObservableWWW.Get(&quot;http://google.co.jp/&quot;)             .Subscribe(                 x =&gt; Debug.Log(x.Substring(0, 100)), // onSuccess                 ex =&gt; Debug.LogException(ex)); // onError</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code&gt;UniRx - Unity响应式编程插件  
插件作者Yoshifumi Kawai(neuecc) 
本篇参照博客：1.凉鞋小班博客
            2.https://blog.csdn.net/zhenghongzhi6/article/det</summary>
      
    
    
    
    <category term="Unity" scheme="http://yoursite.com/categories/Unity/"/>
    
    
    <category term="UniRx" scheme="http://yoursite.com/tags/UniRx/"/>
    
  </entry>
  
</feed>
