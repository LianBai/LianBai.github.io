<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LianBai</title>
  
  <subtitle>手握日月摘星辰，世间无我这般人。</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-09-02T09:32:07.533Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LianBai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity杂文——Android设备唯一标识</title>
    <link href="http://yoursite.com/2022/09/02/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Android%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86/"/>
    <id>http://yoursite.com/2022/09/02/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Android%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86/</id>
    <published>2022-09-02T09:18:27.000Z</published>
    <updated>2022-09-02T09:32:07.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>获取设备唯一标识的方法。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>需要的变量： </p><pre><code>//设备唯一标识private static String deviceId;//设备唯一标识文件名字private static String deviceIdFileName = &quot;all_in_sdk&quot;;//设备唯一标识缓存关键字keyprivate static String deviceIdKey = &quot;DeviceId&quot;;//设备唯一标识正则private static final Pattern ANDROID_ID_PATTERN = Pattern.compile(&quot;^[0-9a-fA-F]&#123;16&#125;$&quot;);</code></pre><p>获取的方法：</p><pre><code>public static String getDeviceId() &#123;    if(m_Activity == null)&#123;        m_Activity = UnityPlayer.currentActivity;    &#125;    Application application = m_Activity.getApplication();    if (application == null)        return &quot;&quot;;    if (deviceId != null)        return deviceId;    deviceId = getSPValue((Context)application, deviceIdKey);    if (!TextUtils.isEmpty(deviceId))        return deviceId;    deviceId = getAndroidIdAsDeviceId((Context)application);    if (!TextUtils.isEmpty(deviceId)) &#123;        saveSPValue((Context)application, deviceIdKey, deviceId);        return deviceId;    &#125;    deviceId = generateSoftDeviceId();    if (!TextUtils.isEmpty(deviceId)) &#123;        saveSPValue((Context)application, deviceIdKey, deviceId);        return deviceId;    &#125;    return deviceId;&#125;private static String getSPValue(Context paramContext, String paramString) &#123;    SharedPreferences sharedPreferences = paramContext.getSharedPreferences(deviceIdFileName, 0);    return sharedPreferences.getString(paramString, null);&#125;private static String getAndroidIdAsDeviceId(Context paramContext) &#123;    String str = Settings.Secure.getString(paramContext.getContentResolver(), &quot;android_id&quot;);    if (isLegalAndroidId(str, true))        return &quot;ANDROID_&quot; + str;    return null;&#125;private static String generateSoftDeviceId() &#123;    String str1 = Build.SERIAL;    String str2 = !TextUtils.isEmpty(str1) ? str1 : &quot;NA&quot;;    try &#123;        long l1 = 1152921504606846976L;        long l2 = randomLong(Long.MAX_VALUE - l1) + l1;        return String.format(&quot;ANDROID_%1$s_%2$s&quot;, new Object[] &#123; Long.toHexString(l2), str2 &#125;);    &#125; catch (Throwable throwable) &#123;        return String.format(&quot;ANDROID_%1$s_%2$s&quot;, new Object[] &#123; &quot;NA&quot; + Long.toHexString(System.currentTimeMillis()), str2 &#125;);    &#125;&#125;private static void saveSPValue(Context paramContext, String paramString1, String paramString2) &#123;    SharedPreferences sharedPreferences = paramContext.getSharedPreferences(deviceIdFileName, 0);    sharedPreferences.edit().putString(paramString1, paramString2).apply();&#125;private static long randomLong(long paramLong) &#123;    if (Build.VERSION.SDK_INT &gt;= 21)        return ThreadLocalRandom.current().nextLong(paramLong);    return (long)((new Random()).nextDouble() * (paramLong - 1L));&#125;private static boolean isLegalAndroidId(String paramString, boolean paramBoolean) &#123;    if (paramBoolean)        return (!TextUtils.isEmpty(paramString) &amp;&amp; ANDROID_ID_PATTERN                .matcher(paramString).find());    return (!TextUtils.isEmpty(paramString) &amp;&amp; ANDROID_ID_PATTERN            .matcher(paramString).find());&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;获取设备唯一标识的方法。&lt;/p&gt;
&lt;h1 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——UI父节点随子节点自适应</title>
    <link href="http://yoursite.com/2022/08/24/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UI%E7%88%B6%E8%8A%82%E7%82%B9%E9%9A%8F%E5%AD%90%E8%8A%82%E7%82%B9%E8%87%AA%E9%80%82%E5%BA%94/"/>
    <id>http://yoursite.com/2022/08/24/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UI%E7%88%B6%E8%8A%82%E7%82%B9%E9%9A%8F%E5%AD%90%E8%8A%82%E7%82%B9%E8%87%AA%E9%80%82%E5%BA%94/</id>
    <published>2022-08-24T11:56:54.000Z</published>
    <updated>2022-08-24T12:11:41.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在UI的开发过程中，经常会遇到Image随子节点的文字变化自动缩放，就是拿Image当背景。笔者遇到这种问题每次都是利用Layout+Content Size Fitter来完成的，笔者想了想每次都要加两个组件，并且Layout只用到了随自己点自适应的功能，于是笔者便想办法把两个功能合成一个脚本来实现需求，于是便有了下面的脚本。  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>代码如下： </p><pre><code>using System;using UnityEngine;using UnityEngine.EventSystems;using UnityEngine.UI;/// &lt;summary&gt;/// 未完成，暂时别用/// &lt;/summary&gt;[AddComponentMenu(&quot;Layout/Rect Transform Fitter&quot;, 142)][ExecuteAlways][RequireComponent(typeof(RectTransform))]public class RectTransformFit : UIBehaviour, ILayoutGroup&#123;    [SerializeField] protected RectTransform m_RectChildren;    [SerializeField] protected RectOffset m_Padding = new RectOffset();    [SerializeField] protected TextAnchor m_ChildAlignment = TextAnchor.UpperLeft;    [SerializeField] protected bool m_ChildControlWidth = false;    [SerializeField] protected bool m_ChildControlHeight = false;    [SerializeField] protected ContentSizeFitter.FitMode m_HorizontalFit = ContentSizeFitter.FitMode.Unconstrained;    [SerializeField] protected ContentSizeFitter.FitMode m_VerticalFit = ContentSizeFitter.FitMode.Unconstrained;    public RectOffset padding    &#123;        get =&gt; m_Padding;        set =&gt; SetProperty(ref m_Padding, value);    &#125;    public TextAnchor childAlignment &#123; get =&gt; m_ChildAlignment;        set =&gt; SetProperty(ref m_ChildAlignment, value);    &#125;    public bool childControlWidth    &#123;        get =&gt; m_ChildControlWidth;        set =&gt; SetProperty(ref m_ChildControlWidth, value);    &#125;    public bool childControlHeight    &#123;        get =&gt; m_ChildControlHeight;        set =&gt; SetProperty(ref m_ChildControlHeight, value);    &#125;    public ContentSizeFitter.FitMode horizontalFit    &#123;        get =&gt; m_HorizontalFit;        set        &#123;            if (SetPropertyUtility.SetStruct(ref m_HorizontalFit, value)) SetDirty();        &#125;    &#125;    public ContentSizeFitter.FitMode verticalFit    &#123;        get =&gt; m_VerticalFit;        set        &#123;            if (SetPropertyUtility.SetStruct(ref m_VerticalFit, value)) SetDirty();        &#125;    &#125;    [NonSerialized] private RectTransform m_Rect;    protected RectTransform rectTransform    &#123;        get        &#123;            if (m_Rect == null)                m_Rect = GetComponent&lt;RectTransform&gt;();            return m_Rect;        &#125;    &#125;#pragma warning disable 649    private DrivenRectTransformTracker m_Tracker;#pragma warning restore 649    private void OnEnable()    &#123;        m_Rect ??= GetComponent&lt;RectTransform&gt;();        SetDirty();    &#125;    protected override void OnRectTransformDimensionsChange()    &#123;        SetDirty();    &#125;    protected override void OnDisable()    &#123;        m_Tracker.Clear();        base.OnDisable();    &#125;    /// &lt;summary&gt;    /// Calculate and apply the horizontal component of the size to the RectTransform    /// &lt;/summary&gt;    public void SetLayoutHorizontal()    &#123;        m_Tracker.Clear();        if (m_RectChildren == null || !m_ChildControlWidth)        &#123;            SetDirty();            return;        &#125;        HandleSelfFittingAlongAxis(0, m_RectChildren);    &#125;    /// &lt;summary&gt;    /// Calculate and apply the vertical component of the size to the RectTransform    /// &lt;/summary&gt;    public void SetLayoutVertical()    &#123;        if (m_RectChildren == null || !m_ChildControlHeight)        &#123;            SetDirty();            return;        &#125;        HandleSelfFittingAlongAxis(1, m_RectChildren);    &#125;    private void HandleSelfFittingAlongAxis(int axis, RectTransform rectChild)    &#123;        if (rectChild == null) return;        var fitting = (axis == 0 ? horizontalFit : verticalFit);        if (fitting == ContentSizeFitter.FitMode.Unconstrained)        &#123;            // Keep a reference to the tracked transform, but don&#39;t control its properties:            m_Tracker.Add(this, rectChild, DrivenTransformProperties.None);            return;        &#125;        m_Tracker.Add(this, rectChild,            (axis == 0 ? DrivenTransformProperties.SizeDeltaX : DrivenTransformProperties.SizeDeltaY));        // Set size to min or preferred size        rectChild.SetSizeWithCurrentAnchors((RectTransform.Axis)axis,            fitting == ContentSizeFitter.FitMode.MinSize                ? LayoutUtility.GetMinSize(rectChild, axis)                : LayoutUtility.GetPreferredSize(rectChild, axis));        SetDirty();    &#125;    /// &lt;summary&gt;    /// Helper method used to set a given property if it has changed.    /// &lt;/summary&gt;    /// &lt;param name=&quot;currentValue&quot;&gt;A reference to the member value.&lt;/param&gt;    /// &lt;param name=&quot;newValue&quot;&gt;The new value.&lt;/param&gt;    protected void SetProperty&lt;T&gt;(ref T currentValue, T newValue)    &#123;        if ((currentValue == null &amp;&amp; newValue == null) || (currentValue != null &amp;&amp; currentValue.Equals(newValue)))            return;        currentValue = newValue;        SetDirty();    &#125;    protected void SetDirty()    &#123;        if (!IsActive())            return;        RefreshRect();        LayoutRebuilder.MarkLayoutForRebuild(m_RectChildren);        LayoutRebuilder.MarkLayoutForRebuild(m_Rect);    &#125;    public void RefreshRect()    &#123;        if (m_RectChildren == null) return;        Vector2 anchoredPos;        var childSize = m_RectChildren.sizeDelta;        var width = childSize.x + padding.left + padding.right;        var height = childSize.y + padding.top + padding.bottom;        var rectSize = rectTransform.sizeDelta;        if (horizontalFit != ContentSizeFitter.FitMode.Unconstrained &amp;&amp;            verticalFit != ContentSizeFitter.FitMode.Unconstrained)        &#123;            rectTransform.sizeDelta = new Vector2(width, height);        &#125;        else if (horizontalFit != ContentSizeFitter.FitMode.Unconstrained)        &#123;            rectTransform.sizeDelta = new Vector2(width, rectSize.y);        &#125;        else if (verticalFit != ContentSizeFitter.FitMode.Unconstrained)        &#123;            rectTransform.sizeDelta = new Vector2(rectSize.x, height);        &#125;        rectSize = rectTransform.sizeDelta;        var oldPos = rectTransform.anchoredPosition;        var oldPivot = rectTransform.pivot;        switch (m_ChildAlignment)        &#123;            case TextAnchor.UpperLeft:                rectTransform.pivot = new Vector2(0, 1);                anchoredPos = new Vector2(padding.left, -padding.top);                break;            case TextAnchor.UpperCenter:                rectTransform.pivot = new Vector2(0.5f, 1);                anchoredPos = new Vector2(0, -padding.top);                break;            case TextAnchor.UpperRight:                rectTransform.pivot = new Vector2(1, 1);                anchoredPos = new Vector2(-padding.right, -padding.top);                break;            case TextAnchor.MiddleLeft:                rectTransform.pivot = new Vector2(0, 0.5f);                anchoredPos = new Vector2(padding.left, 0);                break;            case TextAnchor.MiddleCenter:                rectTransform.pivot = new Vector2(0.5f, 0);                anchoredPos = new Vector2(0, 0);                break;            case TextAnchor.MiddleRight:                rectTransform.pivot = new Vector2(1, 0);                anchoredPos = new Vector2(-padding.right, 0);                break;            case TextAnchor.LowerLeft:                rectTransform.pivot = new Vector2(0, 0);                anchoredPos = new Vector2(padding.left, padding.bottom);                break;            case TextAnchor.LowerCenter:                rectTransform.pivot = new Vector2(0.5f, 0);                anchoredPos = new Vector2(0, padding.bottom);                break;            case TextAnchor.LowerRight:                rectTransform.pivot = new Vector2(1, 0);                anchoredPos = new Vector2(-padding.right, padding.bottom);                break;            default:                throw new ArgumentOutOfRangeException();        &#125;        var pivot = rectTransform.pivot;        rectTransform.anchoredPosition = new Vector2(oldPos.x + rectSize.x * (pivot.x - oldPivot.x),            oldPos.y + rectSize.y * (pivot.y - oldPivot.y));        m_RectChildren.anchorMax = pivot;        m_RectChildren.anchorMin = pivot;        m_RectChildren.pivot = pivot;        m_RectChildren.anchoredPosition = anchoredPos;    &#125;#if UNITY_EDITOR    protected override void OnValidate()    &#123;        SetDirty();    &#125;#endif&#125;</code></pre><h1 id="需要支持的脚本（源码抄来的SetPropertyUtility）"><a href="#需要支持的脚本（源码抄来的SetPropertyUtility）" class="headerlink" title="需要支持的脚本（源码抄来的SetPropertyUtility）"></a>需要支持的脚本（源码抄来的SetPropertyUtility）</h1><pre><code>using System;using System.Collections.Generic;using UnityEngine;internal static class SetPropertyUtility&#123;    private const float Tolerance = 0.000001f;                 //通过此值判断值是否发生变化    public static bool SetColor(ref Color currentValue, Color newValue)    &#123;        if (Math.Abs(currentValue.r - newValue.r) &lt; Tolerance &amp;&amp;            Math.Abs(currentValue.g - newValue.g) &lt; Tolerance &amp;&amp;            Math.Abs(currentValue.b - newValue.b) &lt; Tolerance &amp;&amp;            Math.Abs(currentValue.a - newValue.a) &lt; Tolerance)            return false;        currentValue = newValue;        return true;    &#125;    public static bool SetStruct&lt;T&gt;(ref T currentValue, T newValue) where T : struct    &#123;        if (EqualityComparer&lt;T&gt;.Default.Equals(currentValue, newValue))            return false;        currentValue = newValue;        return true;    &#125;    public static bool SetClass&lt;T&gt;(ref T currentValue, T newValue) where T : class    &#123;        if ((currentValue == null &amp;&amp; newValue == null) || (currentValue != null &amp;&amp; currentValue.Equals(newValue)))            return false;        currentValue = newValue;        return true;    &#125;&#125;</code></pre><h1 id="编辑器显示Editor代码"><a href="#编辑器显示Editor代码" class="headerlink" title="编辑器显示Editor代码"></a>编辑器显示Editor代码</h1><p>代码如下： </p><pre><code>using System;using UnityEditor;using UnityEditor.UI;using UnityEngine;[CustomEditor(typeof(RectTransformFit))]public class RectTransformFitEditor : SelfControllerEditor&#123;    SerializedProperty m_Padding;    SerializedProperty m_ChildAlignment;    SerializedProperty m_RectChildren;    SerializedProperty m_HorizontalFit;    SerializedProperty m_VerticalFit;    SerializedProperty m_ChildControlWidth;    SerializedProperty m_ChildControlHeight;    protected void OnEnable()    &#123;        m_Padding = serializedObject.FindProperty(&quot;m_Padding&quot;);        m_ChildAlignment = serializedObject.FindProperty(&quot;m_ChildAlignment&quot;);        m_RectChildren = serializedObject.FindProperty(&quot;m_RectChildren&quot;);        m_ChildControlWidth = serializedObject.FindProperty(&quot;m_ChildControlWidth&quot;);        m_ChildControlHeight = serializedObject.FindProperty(&quot;m_ChildControlHeight&quot;);        m_HorizontalFit = serializedObject.FindProperty(&quot;m_HorizontalFit&quot;);        m_VerticalFit = serializedObject.FindProperty(&quot;m_VerticalFit&quot;);    &#125;    public override void OnInspectorGUI()    &#123;        serializedObject.Update();        EditorGUILayout.PropertyField(m_Padding, true);        EditorGUILayout.PropertyField(m_ChildAlignment, true);        EditorGUILayout.PropertyField(m_RectChildren, true);        Rect rect = EditorGUILayout.GetControlRect();        rect = EditorGUI.PrefixLabel(rect, -1, EditorGUIUtility.TrTextContent(&quot;Control Child Size&quot;));        rect.width = Mathf.Max(50, (rect.width - 4) / 3);        EditorGUIUtility.labelWidth = 50;        ToggleLeft(rect, m_ChildControlWidth, EditorGUIUtility.TrTextContent(&quot;Width&quot;));        rect.x += rect.width + 2;        ToggleLeft(rect, m_ChildControlHeight, EditorGUIUtility.TrTextContent(&quot;Height&quot;));        EditorGUIUtility.labelWidth = 0;        EditorGUILayout.PropertyField(m_HorizontalFit, true);        EditorGUILayout.PropertyField(m_VerticalFit, true);        serializedObject.ApplyModifiedProperties();    &#125;    void ToggleLeft(Rect position, SerializedProperty property, GUIContent label)    &#123;        bool toggle = property.boolValue;        EditorGUI.showMixedValue = property.hasMultipleDifferentValues;        EditorGUI.BeginChangeCheck();        int oldIndent = EditorGUI.indentLevel;        EditorGUI.indentLevel = 0;        toggle = EditorGUI.ToggleLeft(position, label, toggle);        EditorGUI.indentLevel = oldIndent;        if (EditorGUI.EndChangeCheck())        &#123;            property.boolValue = property.hasMultipleDifferentValues || !property.boolValue;        &#125;        EditorGUI.showMixedValue = false;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在UI的开发过程中，经常会遇到Image随子节点的文字变化自动缩放，就是拿Image当背景。笔者遇到这种问题每次都是利用Layout+Con</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="UGUI" scheme="http://yoursite.com/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>hexo图床图片无法显示</title>
    <link href="http://yoursite.com/2022/08/20/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/hexo%E5%9B%BE%E5%BA%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2022/08/20/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/hexo%E5%9B%BE%E5%BA%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/</id>
    <published>2022-08-20T10:05:02.000Z</published>
    <updated>2022-08-20T10:15:38.397Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>今天更新自己博客的时候发现新博客的图片都无法显示，这个听说只存在于没有域名的博客中，笔者因为没有域名，所以不清除是不是。  </p><blockquote><p>图床：gitee<br>博客：github+hexo<br>原因猜测：gitee开始对图床进行限制，没有域名的博客也访问不到图床的图片  </p></blockquote><p>#解决方法 </p><h2 id="方法一（不推荐）"><a href="#方法一（不推荐）" class="headerlink" title="方法一（不推荐）"></a>方法一（不推荐）</h2><p>最快捷的解决方案就是再自己博客的文章开头加上下面代码   </p><pre><code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</code></pre><p>看下面举例  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1660990253369-2022-8-2018:10:54.png"></p><h2 id="方法二（推荐）"><a href="#方法二（推荐）" class="headerlink" title="方法二（推荐）"></a>方法二（推荐）</h2><p>在自己播放的主题文件加里直接加上就不需要了，具体路径：<br>拿3-hexo主题举例：<br>在**…\themes\3-hexo\layout_partial\header.ejs**文件里加入刚才的代码，如下：  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1660990452909-2022-8-2018:14:13.png">  </p><p>其他主题文件在类似位置：<strong>hexo\themes...\layout_partial\head.ejs</strong><br>其他主题的文件名字应该叫：<strong>head.ejs</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;今天更新自己博客的时候发现新博客的图片都无法显示</summary>
      
    
    
    
    <category term="搭建博客" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="hexo博客" scheme="http://yoursite.com/tags/hexo%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——Unity的Animation无法播放</title>
    <link href="http://yoursite.com/2022/08/20/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Unity%E7%9A%84Animation%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE/"/>
    <id>http://yoursite.com/2022/08/20/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Unity%E7%9A%84Animation%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE/</id>
    <published>2022-08-20T06:57:28.000Z</published>
    <updated>2022-08-20T09:52:46.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>笔者再开发过程中，有个功能需求是在游戏中移动Camera，笔者采用了两种方式，第一种是K动画用动画播放，另一种是用曲线表示运动节奏直线运动。第二种方式和本文无关，主要阐述第一种方式在播放Animation的时候无法播放的问题。  </p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者采用的是Animation的方式播放动画，笔者并未采用Animator，是在游戏中进行动态添加Animation组件，然后根据资源名字动态加载动画资源进行播放，下面是案例代码：  </p><pre><code>public float LookAtAnim(string animName)&#123;    if (!m_Transfrom.TryGetComponent(out Animation animation))    &#123;        animation = m_Transfrom.gameObject.AddComponent&lt;Animation&gt;();    &#125;    var clip = animation.GetClip(animName);    if (clip == null)    &#123;        clip = ResManager.LoadAsset&lt;AnimationClip&gt;(animName);        animation.AddClip(clip, animName);    &#125;    animation.clip = clip;    animation.Play(animName);    return clip.length;&#125;</code></pre><p>但是笔者在运行过程中发现编辑器并不能正常播放动画，通过断点调试，笔者发现在添加动画clip的时候并不能添加到Animation的clip列表里，于是笔者通过各种百度，谷歌等搜索发现需要打开Animation的legacy，修改后的代码如下：</p><pre><code>public float LookAtAnim(string animName)&#123;    ...    if (clip == null)    &#123;        clip = ResManager.LoadAsset&lt;AnimationClip&gt;(animName);        clip.legacy = true;        animation.AddClip(clip, animName);    &#125;    ...&#125;</code></pre><p>这时候动画播放正常了，但是笔者打包成apk后，在模拟器上依旧无法正常播放，笔者打印日志发现动画都正常添加了，于是笔者便尝试解决问题。  </p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>笔者思考**clip.legacy &#x3D; true;**这行代码的作用，于是笔者发现有可能是动画的问题，首先打开inspector的debug模式   </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1660979445735-2022-8-2015:10:46.png"><br>然后发现有些动画的Legacy是打开的，有些是关闭的，于是笔者都手动打开了  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1660979791351-2022-8-2015:16:31.png"><br>发现模拟器依旧没办法播放，最后发现真机上只需要把这个关闭就可以了。<br>笔者最终抛弃了Animation的方法，因为还需要手动加载资源，笔者采用了Animator的方式进行播放。代码如下：  </p><pre><code>/// &lt;summary&gt;/// 播放相机动画/// &lt;/summary&gt;/// &lt;param name=&quot;animName&quot;&gt;动画名字&lt;/param&gt;public float LookAtAnim(string animName)&#123;    SetAnimatorVisible(true);    m_Animator.Play(animName);    return (from animationClip in m_Animator.runtimeAnimatorController.animationClips        where animationClip.name == animName        select animationClip.length).FirstOrDefault();&#125;public void SetAnimatorVisible(bool visible)&#123;    if (m_Animator != null &amp;&amp; m_Animator.enabled == visible) return;    if(visible)    &#123;        if(m_Animator == null)        &#123;            m_Animator = m_Transfrom.gameObject.AddComponent&lt;Animator&gt;();            m_Animator.runtimeAnimatorController =                ResManager.LoadAsset&lt;RuntimeAnimatorController&gt;(TableGlobal.CameraController);        &#125;        else        &#123;            m_Animator.enabled = true;        &#125;    &#125;    else if (m_Animator != null)    &#123;        m_Animator.DOKill();        m_Animator.enabled = false;    &#125;&#125;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>切记要把动画资源的Legacy关闭，否则Animator也无法播放动画片段</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;笔者再开发过程中，有个功能需求是在游戏中移动Camera，笔者采用了两种方式，第一种是K动画用动画播放，另一种是用曲线表示运动节奏直线运动。</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Animation" scheme="http://yoursite.com/tags/Animation/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——根据条件禁用编辑器菜单</title>
    <link href="http://yoursite.com/2022/03/24/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E7%A6%81%E7%94%A8%E7%BC%96%E8%BE%91%E5%99%A8%E8%8F%9C%E5%8D%95/"/>
    <id>http://yoursite.com/2022/03/24/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E7%A6%81%E7%94%A8%E7%BC%96%E8%BE%91%E5%99%A8%E8%8F%9C%E5%8D%95/</id>
    <published>2022-03-24T06:20:07.000Z</published>
    <updated>2022-08-20T09:54:08.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>unity编辑器扩展菜单功能是我们开发中经常使用的，笔者在开发过程中想在特定条件下在启用指定的菜单，不满足条件的时候就禁用菜单，于是笔者找到了解决的办法。  </p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><pre><code>[MenuItem(&quot;Assets/MyMenuTest&quot;, false, 81)]public static void MyMenuTest()&#123;    //菜单执行事件&#125;[MenuItem(&quot;Assets/MyMenuTest&quot;, true)]public static bool IsShowMyMenu()&#123;    //获取自己的条件并return条件即可    return false;&#125;</code></pre><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1648103657696-2022-3-2414:34:18.png">  </p><p>只需要保证MenuItem的菜单路径一样的，把第二个参数改为true代表的是否是控制一个验证函数，根据自己的条件进行返回即可控制。   </p><p>下面是官网给的参数设置<br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1648103567771-2022-3-2414:32:48.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;unity编辑器扩展菜单功能是我们开发中经常使用的，笔者在开发过程中想在特定条件下在启用指定的菜单，不满足条件的时候就禁用菜单，于是笔者找到</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——自动创建asset资源文件</title>
    <link href="http://yoursite.com/2022/03/21/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BAasset%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2022/03/21/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BAasset%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/</id>
    <published>2022-03-21T06:36:13.000Z</published>
    <updated>2022-03-21T06:51:04.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Unity保存数据的方式有很多，比如我们经常用的json，xml和Txt，笔者今天讲到的是另外一种保存方式，asset文件，这个是unity提供的一种新的保存数据的方式，笔者也是刚使用没多久，这里就不详细进行介绍了，笔者今天主要是介绍一键自动创建对应的asset文件。  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code> public class CreateAssetEditor&#123;    [MenuItem(&quot;Assets/Create/CreateAsset&quot;,false,81)]    public static void OnCreateAsset()    &#123;        foreach (var guid in Selection.assetGUIDs)        &#123;            var path = AssetDatabase.GUIDToAssetPath(guid);            var pathSplit = path.Split(&#39;/&#39;);            var className = pathSplit[pathSplit.Length - 1].Replace(&quot;.cs&quot;, &quot;&quot;);            var classType = GetClassByClassName(className);            var assetPath = path.Replace(&quot;.cs&quot;, &quot;.asset&quot;);            if (File.Exists(assetPath))            &#123;                LBLogWrapper.Error(&quot;创建失败，资源已经存在&quot;);            &#125;            else if (classType != null)             &#123;                var classInst = ScriptableObject.CreateInstance(classType);                AssetDatabase.CreateAsset(classInst,assetPath);            &#125;            else            &#123;                LBLogWrapper.Error(&quot;创建失败，脚本不可创建&quot;);            &#125;        &#125;    &#125;        [MenuItem(&quot;Assets/Create/CreateAsset&quot;,true)]    private static bool IsValidateFun()    &#123;        return (from guid in Selection.assetGUIDs            select AssetDatabase.GUIDToAssetPath(guid)            into path            select path.Split(&#39;/&#39;)            into pathSplit            select pathSplit[pathSplit.Length - 1]).Any(className =&gt; className.Contains(&quot;.cs&quot;));    &#125;    /// &lt;summary&gt;    /// 通过类名获取对应的类    /// &lt;/summary&gt;    /// &lt;param name=&quot;className&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    private static Type GetClassByClassName(string className)    &#123;        var allAssemblies = AppDomain.CurrentDomain.GetAssemblies();        return allAssemblies.SelectMany(assembly =&gt; assembly.GetTypes()).FirstOrDefault(type =&gt;            type.Name == className &amp;&amp; type.IsSubclassOf(typeof(ScriptableObject)));    &#125;&#125;</code></pre><p>脚本的原理很简单，就是获取当前选择的脚本，判断是否可以创建asset文件，如果可以就是通过类名获取对应的类对象和，这里需要注意的是，<font color="red">文件名字必须等于类名</font>，然后通过类名获取对应的类型，就可以生成对应的asset文件了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Unity保存数据的方式有很多，比如我们经常用的json，xml和Txt，笔者今天讲到的是另外一种保存方式，asset文件，这个是unity</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="asset" scheme="http://yoursite.com/tags/asset/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——通过类名获取对应的Type</title>
    <link href="http://yoursite.com/2022/03/11/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E7%B1%BB%E5%90%8D%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E7%9A%84Type/"/>
    <id>http://yoursite.com/2022/03/11/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E7%B1%BB%E5%90%8D%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E7%9A%84Type/</id>
    <published>2022-03-11T07:36:03.000Z</published>
    <updated>2022-03-11T08:06:58.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者在编辑器开发过程中遇到一个问题，笔者想通过一个类的名字获取对应的类的Type然后再做一系列的操作，但是笔者发现无法直接获取，于是笔者通过不断的尝试通过下面的方法获取到了，如果有更好的方法欢迎告诉笔者。  </p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>话不多说，先上代码：  </p><pre><code>[MenuItem(&quot;Assets/GetType&quot;,false,81)]public static void GetClassTypeByClassTypeName()&#123;    const string className = &quot;TestScripts&quot;;    //方法一（在同一程序集内并且非自身Class才能获取到）    var type = Type.GetType(className);    Debug.LogError(type);        var allAssemblies = AppDomain.CurrentDomain.GetAssemblies();        //方法二（有特殊情况会获取不到，笔者没找到获取不到的原因）    type = allAssemblies.Select(assembly =&gt; assembly.GetType(className)).FirstOrDefault(assembly =&gt; assembly != null);    Debug.LogError(type);        //方法三（如果存在类重名的情况有概率获取错误，可以通过路径做限制）    type = allAssemblies.SelectMany(assembly =&gt; assembly.GetTypes()).FirstOrDefault(type1 =&gt; type1.Name == className);    Debug.LogError(type);&#125;</code></pre><p>运行结果如下  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1646985481130-2022-3-1115:58:02.png">  </p><p>方法一和方法二的获取条件都有限制，因此笔者建议使用方法三进行获取。  </p><h1 id="获取方式讲解"><a href="#获取方式讲解" class="headerlink" title="获取方式讲解"></a>获取方式讲解</h1><p>方法一是直接在当前程序集进行获取的。<br>方法二是通过遍历当前程序的所有程序集，然后通过程序集直接GetType进行获取<br>方法三是类似于方法二，得到所有的程序集再遍历程序集中的Type，判断名字是否相同来得到对应的Type</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;笔者在编辑器开发过程中遇到一个问题，笔者想通过一个类的名字获取对应的类的Type然后再做一系列的操作，但是笔者发现无法直接获取，于是笔者通过</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="C#反射" scheme="http://yoursite.com/tags/C-%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——按行删除字符串</title>
    <link href="http://yoursite.com/2022/03/10/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2022/03/10/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-03-10T09:02:29.000Z</published>
    <updated>2022-03-10T09:07:58.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>笔者在项目开发过程中需要做一个聊天的假数据显示，是用于demo的，于是笔者就直接用string字符串来模拟显示的数据，但是当聊天内容过多的时候就需要删除历史的聊天内容，于是笔者就想按照行数删除字符串，发现string并不包含这种接口，于是写下了下面的代码。  </p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><pre><code>private static string DeleteStrLine(string text, int startLine, int lineCount)&#123;    var curIndex = 0;    int? remStartIndex = null;    var sum = 1;    while (sum &lt; startLine + lineCount)     &#123;        if (sum == startLine) remStartIndex = curIndex;                curIndex = text.IndexOf(&quot;\n&quot;, curIndex, StringComparison.Ordinal);        if (curIndex &lt; 0)        &#123;            curIndex = text.Length;            break;        &#125;        curIndex++;        sum++;    &#125;    if (remStartIndex == null)    &#123;        return text;    &#125;    text = text.Remove(remStartIndex.Value, curIndex - remStartIndex.Value);    return text;&#125;</code></pre><p>上述代码是笔者的解决方案，原理很简单，遍历查找字符串的换行字符**”\n”**,然后记录下索引，根据传入的需要删除的行数找到对应的索引，最后使用Remove函数按照开始和结束的索引进行删除。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;笔者在项目开发过程中需要做一个聊天的假数据显示，是用于demo的，于是笔者就直接用string字符串来模拟显示的数据，但是当聊天内容过多的时</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>StarUML使用笔记</title>
    <link href="http://yoursite.com/2022/03/04/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/StarUML%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/03/04/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/StarUML%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-04T07:46:19.000Z</published>
    <updated>2022-03-10T07:01:11.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图操作菜单"><a href="#图操作菜单" class="headerlink" title="图操作菜单"></a>图操作菜单</h1><h2 id="Add-Diagram"><a href="#Add-Diagram" class="headerlink" title="Add Diagram"></a>Add Diagram</h2><pre><code>Class Diagram                   类图Package Diagram                 包图Object Diagram                  对象图Composite Structure Diagram     复合结构图Component Diagram               组件图Deployment Diagram              展开图Use Case Diagram                用例图Sequence Diagram                时序图Communication Diagram           交流图Statechart Diagram              状态图Activity Diagram                活动图Profile DiagramER Diagram                      E-R图Flowchart Diagram               流程图Data Flow Diagram               数据流程图</code></pre><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><pre><code>Tempalate Parameter     模板参数Attribute               属性Port                    端口Operation               操作Reception               接待Class                   类Interface               接口Signal                  信号DataType                数据类型PrimitiveType           原始类型Enumeration             枚举Artifact                工件Component               组件Node                    节点UseCaseActorInformationItemCollaborationInteraction             交互State Machine           状态机Activity                活动Opaque Behavior         不透明树Constraint              约束Requirement             要求Block                   块Value Type              数值类型Interface Block         接口块Constraint Block        约束快Tag                     标签</code></pre><h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1646381948452-2022-3-416:19:09.png">   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图操作菜单&quot;&gt;&lt;a href=&quot;#图操作菜单&quot; class=&quot;headerlink&quot; title=&quot;图操作菜单&quot;&gt;&lt;/a&gt;图操作菜单&lt;/h1&gt;&lt;h2 id=&quot;Add-Diagram&quot;&gt;&lt;a href=&quot;#Add-Diagram&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="个人笔记" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity杂文——String按行删除</title>
    <link href="http://yoursite.com/2022/03/03/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94string%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4/"/>
    <id>http://yoursite.com/2022/03/03/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94string%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4/</id>
    <published>2022-03-03T07:19:36.000Z</published>
    <updated>2022-03-04T02:16:15.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在unity开发过程中，如果一个string字符串有多行，如果我们想删除前面一行或者多行应该如何操作？  </p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><pre><code>private static string DeleteStrLine(string text, int startLine, int lineCount)&#123;    var curIndex = 0;    int? remStartIndex = null;    var sum = 1;    while (sum &lt; startLine + lineCount)     &#123;        if (sum == startLine) remStartIndex = curIndex;                curIndex = text.IndexOf(&quot;\n&quot;, curIndex, StringComparison.Ordinal);        if (curIndex &lt; 0)        &#123;            curIndex = text.Length;            break;        &#125;        curIndex++;        sum++;    &#125;    if (remStartIndex == null)    &#123;        return text;    &#125;    text = text.Remove(remStartIndex.Value, curIndex - remStartIndex.Value);    return text;&#125;</code></pre><p>思路就是通过<strong>IndexOf</strong>函数遍历找到需要删除的行对应的”\n”(换行)的索引，然后再通过<strong>Remove</strong>函数对开始和结束的索引进行删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;在unity开发过程中，如果一个string字符串有多行，如果我们想删除前面一行或者多行应该如何操作？  &lt;/p&gt;
&lt;h1 id=&quot;解决方案</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Unity笔记</title>
    <link href="http://yoursite.com/2022/03/03/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Unity%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/03/03/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Unity%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-03T07:14:26.000Z</published>
    <updated>2022-03-18T08:43:22.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p><strong>[Conditional(“XXX”)]</strong>: 指定XXX宏下进行编译<br><strong>[RuntimeInitializeOnLoadMethod]</strong>:游戏运行是就执行的方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;特性&quot;&gt;&lt;a href=&quot;#特性&quot; class=&quot;headerlink&quot; title=&quot;特性&quot;&gt;&lt;/a&gt;特性&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;[Conditional(“XXX”)]&lt;/strong&gt;: 指定XXX宏下进行编译&lt;br&gt;&lt;strong&gt;[Runtime</summary>
      
    
    
    
    <category term="个人笔记" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Unity" scheme="http://yoursite.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——扩展Inspector面板(二)</title>
    <link href="http://yoursite.com/2022/02/23/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95Inspector%E9%9D%A2%E6%9D%BF(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2022/02/23/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95Inspector%E9%9D%A2%E6%9D%BF(%E4%BA%8C)/</id>
    <published>2022-02-23T10:30:36.000Z</published>
    <updated>2022-02-25T02:08:27.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>上次笔者讲解了如何自定义Inspector面板的显示，但是这里还有一个问题，就是对于支持的字段我们可以绘制对应的属性，但是有些字段我们并不支持绘制，比如一些类定义的变量，我们又改如何绘制？下面笔者介绍一下如何绘制一些本身不支持的字段。  </p><h1 id="自定义绘制Inspector"><a href="#自定义绘制Inspector" class="headerlink" title="自定义绘制Inspector"></a>自定义绘制Inspector</h1><p>笔者依旧拿笔者写的动画编辑器作为案例来进行讲解。  </p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>存放文件的目录如下  </p><blockquote><p>—Asset<br>——Scripts<br>———Editor<br>————UIAnimManagerEditor.cs<br>————<font color="#00FF00">UIAnimTransformInfoEditor.cs</font><br>———Engine<br>————UIAnimManager.cs<br>————<font color="#00FF00">UIAnimInfoBase.cs</font><br>————<font color="#00FF00">UIAnimTransformInfo.cs</font>  </p></blockquote><h2 id="创建一个Transform的信息的类（UIAnimTransformInfo）"><a href="#创建一个Transform的信息的类（UIAnimTransformInfo）" class="headerlink" title="创建一个Transform的信息的类（UIAnimTransformInfo）"></a>创建一个Transform的信息的类（UIAnimTransformInfo）</h2><p>为了方便我们可以绘制动画信息在Inspector面板上，我们需要在信息类上加上**[Serializable]**标签方便我们序列化</p><pre><code>[Serializable]public class UIAnimTransformInfo&#123;        public Transform m_Transform;&#125;</code></pre><p>然后我们在UIAnimManager上添加我们的信息就可以了</p><pre><code>public class UIAnimManager : MonoBehaviour&#123;    public float m_SumTime;                                                     //总时间    public bool m_IsDefReversed;                                                //默认的是否倒放    public bool m_IsDefLoop;                                                    //默认的是否循环    public bool m_IsDefAutoPlay;                                                //默认的是否自动播放    public UIAnimTransformInfo m_UIAnimTransformInfo;                           //Transform动画信息        [NonSerialized]    public float m_CurTime;                                                     //当前时间    [NonSerialized]    public UIAnimPlayState m_UIAnimPlayState = UIAnimPlayState.Stop;            //当前状态    &#125;</code></pre><h2 id="默认绘制类中类对象的Inspector面板"><a href="#默认绘制类中类对象的Inspector面板" class="headerlink" title="默认绘制类中类对象的Inspector面板"></a>默认绘制类中类对象的Inspector面板</h2><p>我们可以通过绘制属性的方式直接绘制我们的变量，代码如下：  </p><pre><code>EditorGUILayout.PropertyField(m_UIAnimTransformInfo);</code></pre><p>效果如下：  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1645698365713-2022-2-2418:26:06.png">  </p><p>这个绘制是unity默认的绘制。  </p><h2 id="自定义绘制类中类对象的Inspector面板"><a href="#自定义绘制类中类对象的Inspector面板" class="headerlink" title="自定义绘制类中类对象的Inspector面板"></a>自定义绘制类中类对象的Inspector面板</h2><p>如果我们类中的对象不想使用自定义的绘制，我们可以采用CustomPropertyDrawer这个属性标签来绑定我们类的绘制编辑器类。<br>代码如下  </p><pre><code>[CustomPropertyDrawer(typeof(UIAnimTransformInfo))]public class UIAnimTransformInfoEditor : PropertyDrawer&#123;    /// &lt;summary&gt;    /// 获取属性绘制的高度    /// &lt;/summary&gt;    /// &lt;param name=&quot;property&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;label&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public override float GetPropertyHeight(SerializedProperty property, GUIContent label)    &#123;        return EditorGUI.GetPropertyHeight(property);    &#125;    /// &lt;summary&gt;    /// 绘制自定义的面板    /// &lt;/summary&gt;    /// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;property&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;label&quot;&gt;&lt;/param&gt;    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)    &#123;            &#125;&#125;</code></pre><p>上述代码中，GetPropertyHeight函数是用来设置绘制面板的高度的，然后OnGUI的函数是写自定义的绘制的。  </p><font size="5" color="FF0000">提示：   在GetPropertyHeight函数离，如果类比较复杂，通过EditorGUI.GetPropertyHeight(property)获取的高度会出错，最好把属性里的需要绘制的字段分别获取高度再加一起返回。  在OnGUI函数里绘制的时候不能采用GUILayout和EditorGuiLayout的绘制方式，因为这个是给Rect进行绘制的，每次绘制的时候只需要计算宽度，然后绘制后坐标再自己移动绘制下一个。举例代码如下：</font>  <pre><code>/// &lt;summary&gt;/// 绘制单个可滑动的列表/// &lt;/summary&gt;/// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;property&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;uiReorderableList&quot;&gt;&lt;/param&gt;public static void OnReorderableListPropertyItemGUI(ref Rect position, SerializedProperty property,ReorderableList uiReorderableList)&#123;    position.height = GetReorderableListHeight(property);    uiReorderableList.DoList(position);    position.y += position.height;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;上次笔者讲解了如何自定义Inspector面板的显示，但是这里还有一个问题，就是对于支持的字段我们可以绘制对应的属性，但是有些字段我们并不支</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Unity编辑器" scheme="http://yoursite.com/tags/Unity%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——扩展Inspector面板(一)</title>
    <link href="http://yoursite.com/2022/02/18/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95Inspector%E9%9D%A2%E6%9D%BF(%E4%B8%80)/"/>
    <id>http://yoursite.com/2022/02/18/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95Inspector%E9%9D%A2%E6%9D%BF(%E4%B8%80)/</id>
    <published>2022-02-18T05:45:59.000Z</published>
    <updated>2022-02-18T07:23:45.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在使用unity的时候我们会经常使用到inspector面板来查看我们选中对象的信息，也会经常修改一些信息，但是，untiy默认的指挥显示我们组件上序列化的信息，也并不是所有的序列化的信息都显示，我们只需要添加**[HideInInspector]**标签就可以隐藏信息。但是这些并不能满足我们修改信息的需求，unity也为我们提供了自动绘制面板，这样我们不仅仅有修改字段的功能，还可以添加更多的功能了。  </p><h1 id="自定义绘制Inspector"><a href="#自定义绘制Inspector" class="headerlink" title="自定义绘制Inspector"></a>自定义绘制Inspector</h1><p>笔者是以自己写的一个UI的动画控制器为例来讲解的。  </p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>存放文件的目录如下  </p><blockquote><p>—Asset<br>——Scripts<br>———Editor<br>————UIAnimManagerEditor.cs<br>———Engine<br>————UIAnimManager.cs  </p></blockquote><h2 id="组件脚本"><a href="#组件脚本" class="headerlink" title="组件脚本"></a>组件脚本</h2><p>首先我们先创建一个需要绘制的脚本：  </p><pre><code>/// &lt;summary&gt;/// 动画播放状态/// &lt;/summary&gt;public enum UIAnimPlayState&#123;    Stop,                   //停止    Playing,                //播放中    Pause,                  //暂停    Finish,                 //完成&#125;/// &lt;summary&gt;/// 动画播放控制器/// &lt;/summary&gt;public class UIAnimManager : MonoBehaviour&#123;    public float m_SumTime;                                                     //总时间    public bool m_IsDefReversed;                                                //默认的是否倒放    public bool m_IsDefLoop;                                                    //默认的是否循环    public bool m_IsDefAutoPlay;                                                //默认的是否自动播放        [NonSerialized]    public float m_CurTime;                                                     //当前时间    [NonSerialized]    public UIAnimPlayState m_UIAnimPlayState = UIAnimPlayState.Stop;            //当前状态&#125;</code></pre><p>下面我们来看看默认的inspector的面板显示：  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1645165132213-2022-2-1814:18:53.png"></p><p>不仅仅**[HideInInspector]<strong>标签会隐藏字段，</strong>[NonSerialized]**标记没有序列化的字段也不会显示出来。  </p><h2 id="绘制Inspector面板脚本-CustomEditor"><a href="#绘制Inspector面板脚本-CustomEditor" class="headerlink" title="绘制Inspector面板脚本(CustomEditor)"></a>绘制Inspector面板脚本(CustomEditor)</h2><pre><code>[CustomEditor(typeof(UIAnimManager))]public class UIAnimManagerEditor : UnityEditor.Editor&#123;    #region 字段    private UIAnimManager m_UIAnimManager;                                      //面板的脚本        private SerializedProperty m_IsDefReversed;                                 //是否倒放    private SerializedProperty m_IsDefLoop;                                     //是否循环    private SerializedProperty m_IsDefAutoPlay;                                 //是否自动播放    #endregion        #region 继承方法    private void OnEnable()    &#123;        m_UIAnimManager = (UIAnimManager) target;                               //获取绑定的脚本                m_IsDefReversed = serializedObject.FindProperty(&quot;m_IsDefReversed&quot;);     //获取m_IsDefReversed字段        m_IsDefLoop = serializedObject.FindProperty(&quot;m_IsDefLoop&quot;);             //获取m_IsDefLoop字段        m_IsDefAutoPlay = serializedObject.FindProperty(&quot;m_IsDefAutoPlay&quot;);     //获取m_IsDefAutoPlay字段    &#125;    /// &lt;summary&gt;    /// 自定义绘制Inspector面板    /// &lt;/summary&gt;    public override void OnInspectorGUI()    &#123;        OnPropertyFieldGUI();    &#125;    #endregion        #region 自定义方法    /// &lt;summary&gt;    /// 绘制属性字段    /// &lt;/summary&gt;    private void OnPropertyFieldGUI()    &#123;        EditorGUI.BeginChangeCheck();                                       //监听面板是否发生变化        &#123;            EditorGUILayout.PropertyField(m_IsDefReversed);                 //绘制m_IsDefReversed属性            EditorGUILayout.PropertyField(m_IsDefLoop);                     //绘制m_IsDefLoop属性            EditorGUILayout.PropertyField(m_IsDefAutoPlay);                    //绘制m_IsAutoPlay属性        &#125;        if (EditorGUI.EndChangeCheck())                                     //如果发生变化为true        &#123;            EditorUtility.SetDirty(target);                                 //标记用于触发保存            serializedObject.ApplyModifiedProperties();                     //更新序列化的数据        &#125;    &#125;    #endregion&#125;</code></pre><p>如上述代码，编写脚本只需要类上面打上**[CustomEditor(typeof(UIAnimManager))]<strong>即可，中间的UIAnimManager换成需要绑定的类即可，然后在代码中继承</strong>OnInspectorGUI**方法，在这个方法里绘制自己想绘制的面板。<br>绘制样子如下：  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1645168657839-2022-2-1815:17:38.png">  </p><h2 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h2><p>首先开<strong>OnEnable</strong>函数里：  </p><blockquote><p>m_UIAnimManager &#x3D; (UIAnimManager) target;获取当前绑定的脚本对象<br>serializedObject.FindProperty是获取脚本上的属性，是拿这些属性绘制的  </p></blockquote><p><strong>OnInspectorGUI</strong>函数就是我们编写绘制Inspector面板的函数，在代码里我们可以编写untiy提供的编辑器代码，笔者这里只是通过EditorGUILayout.PropertyField来绘制属性，也可以使用其他unity的编辑器绘制代码，这里就不举例了。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在使用unity的时候我们会经常使用到inspector面板来查看我们选中对象的信息，也会经常修改一些信息，但是，untiy默认的指挥显示我</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Unity编辑器" scheme="http://yoursite.com/tags/Unity%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>解决Hexo博客提交Warning</title>
    <link href="http://yoursite.com/2022/01/29/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E8%A7%A3%E5%86%B3Hexo%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4Warning/"/>
    <id>http://yoursite.com/2022/01/29/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E8%A7%A3%E5%86%B3Hexo%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4Warning/</id>
    <published>2022-01-29T07:19:22.000Z</published>
    <updated>2022-01-29T07:26:23.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Warning-Accessing-non-existent-property-‘XXX’-of-module-exports-inside-circular-dependency"><a href="#Warning-Accessing-non-existent-property-‘XXX’-of-module-exports-inside-circular-dependency" class="headerlink" title="Warning: Accessing non-existent property ‘XXX’ of module exports inside circular dependency"></a>Warning: Accessing non-existent property ‘XXX’ of module exports inside circular dependency</h1><p>笔者在更新本地npm和node后，提交hexo博客的时候遇到了这个问题。原因在于本地node的版本太高导致的。  </p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>降低node的版本，选择一个低版本的node，node的12版本应该就可以。  </p><p><a href="https://nodejs.org/download/release/"><font color="steelblue" size="5">node各版本下载</font></a>  </p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>笔者并不想更新node版本，于是笔者找到了第二种解决方案，在博客目录下：  </p><pre><code>myBlog\node_modules\nib\node_modules\stylus\lib\nodes\index.jsmyBlog\node_modules\stylus\lib\nodes\index.js.</code></pre><p>上面两个路径下的<strong>index.js</strong>文件的前面分别添加下面代码即可。(两个文件都需要添加)  </p><pre><code>exports.lineno = null;exports.column = null;exports.filename = null;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Warning-Accessing-non-existent-property-‘XXX’-of-module-exports-inside-circular-dependency&quot;&gt;&lt;a href=&quot;#Warning-Accessing-non-existent</summary>
      
    
    
    
    <category term="搭建博客" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客Warning" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2Warning/"/>
    
  </entry>
  
  <entry>
    <title>UnityECS入门(三)——写一个简单的ECS</title>
    <link href="http://yoursite.com/2022/01/29/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%B8%89)%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84ECS/"/>
    <id>http://yoursite.com/2022/01/29/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%B8%89)%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84ECS/</id>
    <published>2022-01-29T03:12:57.000Z</published>
    <updated>2022-02-17T06:34:47.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><pre><code>unity: 2020.3.18f1Entities: 0.17.0Jobs: 0.8.0</code></pre><h1 id="SimpleECS"><a href="#SimpleECS" class="headerlink" title="SimpleECS"></a>SimpleECS</h1><p>一个简单的ECS应该包括Entity、Component和System，接下来笔者就带着大家写一个简单的ECS。  </p><h2 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h2><p>unity的<strong>Entity是已经封装好的，不需要自己创建</strong>。笔者一开始也没有理解，每个实例不一样，为啥不是自己制作Entity，笔者目前的理解是Entity就像一个没有任何属性的GameObject，我们是通过给这个空的GameObject添加Component来组成我们理解的实体对象。<br>下面我们来分析一下Entity，源码如下：  </p><pre><code>using System;namespace Unity.Entities&#123;        public struct Entity : IEquatable&lt;Entity&gt;, IComparable&lt;Entity&gt;    &#123;                public int Index;        public int Version;        public static bool operator==(Entity lhs, Entity rhs)        &#123;            return lhs.Index == rhs.Index &amp;&amp; lhs.Version == rhs.Version;        &#125;        public static bool operator!=(Entity lhs, Entity rhs)        &#123;            return !(lhs == rhs);        &#125;        public int CompareTo(Entity other)        &#123;            return Index - other.Index;        &#125;        public override bool Equals(object compare)        &#123;            return this == (Entity)compare;        public override int GetHashCode()        &#123;            return Index;        &#125;        public static Entity Null =&gt; new Entity();        public bool Equals(Entity entity)        &#123;            return entity.Index == Index &amp;&amp; entity.Version == Version;        &#125;        public override string ToString()        &#123;            return Equals(Entity.Null) ? &quot;Entity.Null&quot; : $&quot;Entity(&#123;Index&#125;:&#123;Version&#125;)&quot;;        &#125;    &#125;&#125;</code></pre><p>上面的代码重要部分是两个字段，<strong>Index</strong>和<strong>Version</strong>。<br>Index其实不难理解，笔者在上一篇文章提起过，Entity绑定的component是统一放在一个Chunk上的，为了提高访问的速度，当我们想要操作一个Entity的Component的时候，我们是通过Index在EntityDataManager中查找所在的Chunk和IndexInChunk。<br>Version是一个类似于版本号的东西，就像版本号会递增一样，Entity每次被回收的时候这个值会+1。用途的话，笔者猜测可能是当我们回调一个实例的时候，可以判断实例是否已经被回收了或者改变了。  </p><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><pre><code>[GenerateAuthoringComponent]public struct SimpleEcsComp : IComponentData&#123;    public float m_MoveSpeed;&#125;</code></pre><p>Component可以理解为Entity具有的属性或者组件，一个Entity是可以绑定多个Component的，就像一个GameObject上挂很多组件一样。<br>Component一般定义成struct，并且继承IComponentData或者ISharedComponentData这两个接口。   </p><h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>在以前的UnityECS版本里存在ComponentSystem和JobSystem两种System，但是目前已经被Unity弃用，这里就不介绍了，在新的ECS版本里，System采用的是<strong>SystemBase</strong>。  </p><pre><code>public class SimpleEcsSystem : SystemBase&#123;    protected override void OnUpdate()    &#123;        var deltaTime = Time.DeltaTime;        Entities.ForEach((ref Translation translation, ref SimpleEcsComp simpleEcsComp) =&gt;        &#123;            translation.Value.y += simpleEcsComp.m_MoveSpeed * deltaTime;            if (translation.Value.y &gt; 5f)            &#123;                simpleEcsComp.m_MoveSpeed = -math.abs(simpleEcsComp.m_MoveSpeed);            &#125;            else if (translation.Value.y &lt; -5f)            &#123;                simpleEcsComp.m_MoveSpeed = math.abs(simpleEcsComp.m_MoveSpeed);            &#125;        &#125;).ScheduleParallel();    &#125;&#125;</code></pre><p>如上述代码，在System的中，在进行Entities.ForEach的时候，最后需要执行一下<strong>ScheduleParallel</strong>这个方法，这里是一种扩展方法，这里常用的不仅仅是ScheduleParallel，还有Run和Schedul两个方法。下面介绍一下方法的用途：  </p><blockquote><p>Run() : evaluates the entity query and invokes the lambda function for each selected entity immediately on the main thread. Calling Run() completes the system Dependency JobHandle before running, blocking the main thread, if necessary, while it waits for those jobs to finish.<br>Schedul(): schedules the work to be done in a single job (no matter how many entities are selected).<br>ScheduleParallel() – schedules the work to be done in parallel using the C# Job system. Each parallel job instance processes at least one chunk of entities at a time. In other words, if all the selected entities are in the same chunk, then only one job instance is spawned.   </p></blockquote><h2 id="运行结果如下"><a href="#运行结果如下" class="headerlink" title="运行结果如下"></a>运行结果如下</h2><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1645079644114-2022-2-1714:34:04.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;unity: 2020.3.18f1
Entities: 0.17.0
Jobs: 0.8.0
&lt;/code&gt;&lt;/pre&gt;
</summary>
      
    
    
    
    <category term="UnityECS" scheme="http://yoursite.com/categories/UnityECS/"/>
    
    
    <category term="ECS" scheme="http://yoursite.com/tags/ECS/"/>
    
  </entry>
  
  <entry>
    <title>给hexo博客添加访问密码</title>
    <link href="http://yoursite.com/2022/01/28/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E7%BB%99hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E5%AF%86%E7%A0%81/"/>
    <id>http://yoursite.com/2022/01/28/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E7%BB%99hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E5%AF%86%E7%A0%81/</id>
    <published>2022-01-28T07:31:45.000Z</published>
    <updated>2022-01-29T06:25:45.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔者记忆力比较差，于是笔者想有个空间能记录笔者一些私人的内容，于是笔者想起来比较经常会遇到一些加密的博客，笔者便想如果自己如果有一个博客能记录自己的私人内容，然后把博客进行加密即可，这样自己想要查看内容的额时候只需要访问隐私博客，然后输入密码就可以看到了。  </p><h1 id="安装Hexo-Blog-Encrypt"><a href="#安装Hexo-Blog-Encrypt" class="headerlink" title="安装Hexo-Blog-Encrypt"></a>安装Hexo-Blog-Encrypt</h1><p>hexo的博客添加密码其实只需要安装一个插件就可以了。<br>通过npm在hexo博客目录安装Hexo-Blog-Encrypt  </p><pre><code>npm install --save hexo-blog-encrypt</code></pre><h1 id="博客使用密码"><a href="#博客使用密码" class="headerlink" title="博客使用密码"></a>博客使用密码</h1><p>只需要在博客的开头使用  </p><pre><code>---title: Hello Worlddate: 2022-01-28 15:31:45password: 密码---</code></pre><p>还可以添加一些描述的标签  </p><pre><code>---title: Hello Worldtags:- 加密文章的tagdate: 2022-01-28 15:31:45password: 密码abstract: 这里有东西被加密了，需要输入密码查看哦。message: 您好，这里需要密码。wrong_pass_message: 抱歉，这个密码看着不太对，请再试试。wrong_hash_message: 抱歉，这个文章不能被纠正，不过您还是能看看解密后的内容。---</code></pre><h1 id="根目录添加配置文件"><a href="#根目录添加配置文件" class="headerlink" title="根目录添加配置文件"></a>根目录添加配置文件</h1><pre><code># 安全encrypt: # hexo-blog-encrypt  abstract: 这里有东西被加密了，需要输入密码查看哦。  message: 您好, 这里需要密码.  tags:  - &#123;name: tagName, password: 密码A&#125;  - &#123;name: tagName, password: 密码B&#125;  #密码主题 https://github.com/D0n9X1n/hexo-blog-encrypt#encrypt-theme  theme: wave  wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.  wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;笔者记忆力比较差，于是笔者想有个空间能记录笔者一些私人的内容，于是笔者想起来比较经常会遇到一些加密的博客，笔者便想如果自己如果有一个博客能记</summary>
      
    
    
    
    <category term="搭建博客" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客密码" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>私人密码记事本</title>
    <link href="http://yoursite.com/2022/01/28/%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E7%A7%81%E4%BA%BA%E5%AF%86%E7%A0%81%E8%AE%B0%E4%BA%8B%E6%9C%AC/"/>
    <id>http://yoursite.com/2022/01/28/%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E7%A7%81%E4%BA%BA%E5%AF%86%E7%A0%81%E8%AE%B0%E4%BA%8B%E6%9C%AC/</id>
    <published>2022-01-28T06:29:49.000Z</published>
    <updated>2022-03-21T06:48:28.810Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="cc6a9b7dc1bbcc64e5ac1500d2dc98a74b2b6ea72f2f82d16a29e29fd6db67c9">2521a7807bde158c25736a82631336cef69c8023285301a3fbc36dfb98f6e317a65e61edf2bc05b5baa81011208e99997530f84143591992a31d06652f4777d39959a148e1cfd3abdbdaf0d3f2e34d58f7cc4a7a4d87e2c556ca3bee9db959a81e9156e003fb37ca67f0de85901c11ac6d22be5894add73186b8200509861945e827fa50350b7d8e7c577510e0c7f04f999f2c26ccf897139fd3896f616588fd1afbe305ba2e0eac4c212d14101f3577f98d2c52bd2650565b00fda22f9f9d6e18218f7b1b4a22a0e965b89a31a8eea52e911983bfa6ae6004db1f1a5699761c2efa572cac178ada568024e657744802d586129440fce350e84fba64ccc11c973d7ebb4e04fcb64e5c5ab9c4b0509629a073ec697eb076f97dd6a9ae5c64bcb423c71f31a01b8aa8044055484a5201d0572d83b5a6391fd3a270d18fdb7d17d01ff2d23cac00ba56047285218a835ce4172b11027c94775635d7463afd0cab8b1b25505a63352dbfb365b57273bdab223ebf72a4bca76007d3c40b827ce80a11944e689953d7e40365179a7e9b2db8be89f4964fd29295a16c4f8026e7191aee9fe0639b67528076158033ef7edf80be5192940dea83c279ae298e0b01fd2adde565ca12689622ccc70176902c952c67f422a6ffc7fccec83ad91e6e209dae4768122c5ddb501fddcc3cdedf0cac41c896ac2773a30d382b340d22a11aa43707701c7af90c0d46f2dfeeeea41afcbc6effe67fb9a735d1f78ee28282e51657883e3690f434b9197814b29f982fc6184e12181a64ca685f9ae7302fc04edb89202a286e6bf9afab89c382f5cb4a4bad2718886584e91a49998f47ef08a085c1a279e8cce2f9044b21a96c143bb3e0f0f61eaba9a29bdd6ade0503f22c02a1759aeb4768e4434ba54a36c615f162085347582e43fc83c9413bcc05db78e2b2ac87e65d5f1df14c23f5eb27022322547da9</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这里有东西被加密了，需要输入密码查看哦。</summary>
    
    
    
    <category term="私人文件" scheme="http://yoursite.com/categories/%E7%A7%81%E4%BA%BA%E6%96%87%E4%BB%B6/"/>
    
    
    <category term="密码记事本" scheme="http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E8%AE%B0%E4%BA%8B%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>UnityECS入门(二)——简单讲解一下ECS</title>
    <link href="http://yoursite.com/2022/01/28/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%BA%8C)%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3%E4%B8%80%E4%B8%8BECS/"/>
    <id>http://yoursite.com/2022/01/28/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%BA%8C)%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3%E4%B8%80%E4%B8%8BECS/</id>
    <published>2022-01-28T05:17:37.000Z</published>
    <updated>2022-01-28T08:04:29.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇我们已经成功的配置好本地的环境了，接下来我们来简单的讲解一下ECS。(笔者也是初学者，如果有错误欢迎大家指出)  </p><h1 id="ECS简介"><a href="#ECS简介" class="headerlink" title="ECS简介"></a>ECS简介</h1><p>在写ECS之前我们先了解一下什么是ECS？  </p><h2 id="ECS是什么？"><a href="#ECS是什么？" class="headerlink" title="ECS是什么？"></a>ECS是什么？</h2><p>ECS的缩写就是Entity Component System。对应的就是实例、组件和系统。笔者认为这是和MVC框架类似，虽然作用不是一样的，但是都代表了一种思想。ECS的思想打破了我们面向对象的思想，让我们直接面向数据变成。以往的Unity提供给使用者的都是GameObject，让我们来面向对象思想，但是ECS则是把GameObject拆成了Entity和Component，然后由System再进行同意管理。  </p><h2 id="为什么使用ECS？"><a href="#为什么使用ECS？" class="headerlink" title="为什么使用ECS？"></a>为什么使用ECS？</h2><h3 id="在编写思想上"><a href="#在编写思想上" class="headerlink" title="在编写思想上"></a>在编写思想上</h3><p>笔者认为，现在的大部分游戏其实都是数据驱动的游戏，游戏的界面对象其实是给使用者提供的。一个好的程序猿应该做到真正的数据和显示分离，这样不管显示是什么样，数据都可以去应对，但其实这是理想化的，因为显示是很难统一的。  </p><h3 id="在编写代码上"><a href="#在编写代码上" class="headerlink" title="在编写代码上"></a>在编写代码上</h3><p>ECS为我们提供了面向数据编程的结构、强迫使我们数据和显示进行分离，这样虽然编写复杂了一些，但是我们的扩展性和适应性会有很大的提高。<br>Unity的MonoBehavior的class其实是非常笨重的，里面包含了大量的信息，我们在平时开发中其实用不到那么多信息，在ECS上我们只需要添加上我们需要用到的组件即可。  </p><h3 id="在内存管里方面"><a href="#在内存管里方面" class="headerlink" title="在内存管里方面"></a>在内存管里方面</h3><p>ECS引入了Archetype和Chuck两个概念，Archetype对应的是我们的Component，就是存放我们Entity需要的所有组件，然后多个Archetype会被封装成一个个的Archetype Chuck，然后在内存里按照顺序进行存放，如果一个Chuck存放满了，会在后面内存里创建新的Chuck，这样Component就是在一起的，每次查找Component的时候速度会大大提升。<br>下面我们来看一看内存结构图：  </p><p><img src="https://i0.hdslb.com/bfs/article/6cb305d158f9daf75ef880b035a26afdea2961af.png" alt="在这里插入图片描述"></p><p><img src="https://i0.hdslb.com/bfs/article/363335a8d53167863db8a0c040e29e37d2f9b269.png" alt="在这里插入图片描述">  </p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>Unity使用的是单线程，虽然里面会有携程一些，但其根本原理都是单线程，所以并不能完全发挥CPU，ECS引入了多线程的Job system，并且Job System会把Entities分发到CPU的线程上，这样就提高了CPU的利用率。  </p><h1 id="怎么使用ECS"><a href="#怎么使用ECS" class="headerlink" title="怎么使用ECS"></a>怎么使用ECS</h1><p>ECS主要提升的是CPU的性能，并不是所有的项目都适合使用ECS，因为ECS是新的思想，团队开发成本也是有一定提高的，笔者业主要是为了学习了解，拓展一下自己的思路。<br>接下来笔者会继续学习如何使用ECS。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在上一篇我们已经成功的配置好本地的环境了，接下来我们来简单的讲解一下ECS。(笔者也是初学者，如果有错误欢迎大家指出)  &lt;/p&gt;
&lt;h1 </summary>
      
    
    
    
    <category term="UnityECS" scheme="http://yoursite.com/categories/UnityECS/"/>
    
    
    <category term="ECS" scheme="http://yoursite.com/tags/ECS/"/>
    
  </entry>
  
  <entry>
    <title>UnityECS入门(一)——安装Unity官方的ECS</title>
    <link href="http://yoursite.com/2022/01/27/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%B8%80)%E2%80%94%E2%80%94%E5%AE%89%E8%A3%85Unity%E5%AE%98%E6%96%B9%E7%9A%84ECS/"/>
    <id>http://yoursite.com/2022/01/27/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%B8%80)%E2%80%94%E2%80%94%E5%AE%89%E8%A3%85Unity%E5%AE%98%E6%96%B9%E7%9A%84ECS/</id>
    <published>2022-01-27T05:49:25.000Z</published>
    <updated>2022-01-28T05:16:43.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>笔者最近准备学习Unity官方的ECS，笔者才刚开始学习，这里就先不卖弄了，笔者写这篇博客的主要目的是为了分享如何安装官方ECS。  </p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><pre><code>Unity 2020.3.18f1c1</code></pre><h1 id="安装Entitie-com-unity-entities"><a href="#安装Entitie-com-unity-entities" class="headerlink" title="安装Entitie(com.unity.entities)"></a>安装Entitie(com.unity.entities)</h1><p>unity的版本低于2020.1的可以直接在Package Manager里搜索Entitie就可以了。<br>在unity2020.1版本的时候，官方对unity的Package Manager做了一些整改，默认不再显示Preview Package了。<br>首先笔者先介绍如何打开显示Preview Package。<br><img src="https://img-blog.csdnimg.cn/a6e1dd43a96d4951834981e78c8054e2.png" alt="在这里插入图片描述">  </p><p><img src="https://img-blog.csdnimg.cn/74d2605b303549cbbcc895a4013b83e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IS455m9,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">  </p><p>虽然打开了Preview Package但是依旧会搜不到部分Preview Package的库，这是因为处于早期开发阶段和开发不活跃的包无法直接搜索到。<br>笔者这里便介绍另外一种方式，通过url的方式导入需要的库。笔者在文章后面也会放入一些无法搜到的库。<br><strong>通过URL安装需要本地安装git来进行下载</strong><br>Entitie的url是： <strong>com.unity.entities</strong><br>导入步骤如下：<br><img src="https://img-blog.csdnimg.cn/b093196413e44d178d9a5656aee4ed7e.png" alt="在这里插入图片描述">  </p><p><img src="https://img-blog.csdnimg.cn/126370bd43ae4f8ca103be329245adde.png" alt="在这里插入图片描述">  </p><h1 id="安装Jobs-com-unity-jobs"><a href="#安装Jobs-com-unity-jobs" class="headerlink" title="安装Jobs(com.unity.jobs)"></a>安装Jobs(com.unity.jobs)</h1><p>通过git url的方式输入com.unity.jobs即可安装，笔者安装entities的时候会自动安装jobs，如果没有安装可以使用这种方式安装。  </p><h1 id="安装HyBrid-Renderer-com-unity-rendering-hybrid"><a href="#安装HyBrid-Renderer-com-unity-rendering-hybrid" class="headerlink" title="安装HyBrid Renderer(com.unity.rendering.hybrid)"></a>安装HyBrid Renderer(com.unity.rendering.hybrid)</h1><p>学习ECS过程中还有可能用到HyBrid Renderer这个package，这里也提供一下对应的URL  </p><p><strong>com.unity.rendering.hybrid</strong>  </p><h1 id="安装Burst-com-unity-barracuda-burst"><a href="#安装Burst-com-unity-barracuda-burst" class="headerlink" title="安装Burst(com.unity.barracuda.burst)"></a>安装Burst(com.unity.barracuda.burst)</h1><p>直接在package manager里搜索Burst是可以搜到的</p><h1 id="安装Mathematics-com-unity-mathematics"><a href="#安装Mathematics-com-unity-mathematics" class="headerlink" title="安装Mathematics(com.unity.mathematics)"></a>安装Mathematics(com.unity.mathematics)</h1><p>直接在package manager里搜索Mathematics是可以搜到的，这里也放一下url </p><p><strong>com.unity.mathematics</strong></p><h1 id="无法搜到的Preview-Package的URL"><a href="#无法搜到的Preview-Package的URL" class="headerlink" title="无法搜到的Preview Package的URL"></a>无法搜到的Preview Package的URL</h1><p>com.ptc.vuforia.engine<br>com.unity.2d.entities<br>com.unity.ai.planner<br>com.unity.aovrecorder<br>com.unity.assetbundlebrowser<br>com.unity.assetgraph<br>com.unity.barracuda<br>com.unity.barracuda.burst<br>com.unity.build-report-inspector<br>com.unity.cloud.userreporting<br>com.unity.collections<br>com.unity.connect.share<br>com.unity.dots.editor<br>com.unity.entities<br>com.unity.film-tv.toolbox<br>com.unity.google.resonance.audio<br>com.unity.immediate-window<br>com.unity.mathematics<br>com.unity.meshsync<br>com.unity.multiplayer-hlapi<br>com.unity.package-manager-doctools<br>com.unity.package-manager-ui<br>com.unity.package-validation-suite<br>com.unity.physics<br>com.unity.platforms<br>com.unity.platforms.android<br>com.unity.platforms.linux<br>com.unity.platforms.macos<br>com.unity.platforms.web<br>com.unity.platforms.windows<br>com.unity.playablegraph-visualizer<br>com.unity.render-pipelines.lightweight<br>com.unity.rendering.hybrid<br>com.unity.renderstreaming<br>com.unity.scene-template<br>com.unity.simulation.client<br>com.unity.simulation.core<br>com.unity.simulation.capture<br>com.unity.simulation.games<br>com.unity.standardevents<br>com.unity.streaming-image-sequence<br>com.unity.test-framework.performance<br>com.unity.tiny.all<br>com.unity.transport<br>com.unity.upm.develop<br>com.unity.vectorgraphics<br>com.unity.webrtc<br>com.unity.xr.googlevr.android<br>com.unity.xr.googlevr.ios<br>com.unity.xr.legacyinputhelpers<br>com.unity.xr.oculus.android<br>com.unity.xr.oculus.standalone<br>com.unity.xr.openvr.standalone<br>com.unity.xr.arsubsystems<br>com.unity.xr.interactionsubsystems<br>com.unity.xr.windowsmr.metro  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;笔者最近准备学习Unity官方的ECS，笔者才刚开始学习，这里就先不卖弄了，笔者写这篇博客的主要目的是为了分享如何安装官方ECS。  &lt;/p</summary>
      
    
    
    
    <category term="UnityECS" scheme="http://yoursite.com/categories/UnityECS/"/>
    
    
    <category term="ECS" scheme="http://yoursite.com/tags/ECS/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——序列化AnimationCurve</title>
    <link href="http://yoursite.com/2022/01/25/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%BA%8F%E5%88%97%E5%8C%96AnimationCurve/"/>
    <id>http://yoursite.com/2022/01/25/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%BA%8F%E5%88%97%E5%8C%96AnimationCurve/</id>
    <published>2022-01-24T16:18:28.000Z</published>
    <updated>2022-01-27T06:26:58.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者在开发一个地图编辑器的过程中，需要配置一个摄像机的移动速度，这个时候策划提了一个需求，他希望能够通过设置曲线的方式来设置摄像机的移动，于是笔者便想到了unity编辑器自带的AnimationCurve就可以获得运动曲线，但是这里有个问题，我们编辑器配置后是需要保存下来的，笔者选择了利用json保存，但是json是没有办法序列化一个AnimationCurve对象的，json序列化是有规则的，这里就不介绍了。没有办法序列化我们需要的对象我们应该怎么办呢？  </p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>我们没有办法序列化我们需要的AnimationCurve，但是我们知道AnimationCurve是由很多个keyframe组成的，我们只需要保留下来keyframe，每次保存的时候只保存keeyfram数组，然后加载的时候通过添加保存的keyframe既可以生成我们需要的AnimationCurve了。<br>当笔者想去保存keyframe的时候，通过rider编辑器可以看到keyframe的类似源码，里面的字段都是私有的，依旧没有办法序列化，这个时候我们可以换一种方式，那就是自定义一个新的keyframe，然后通过自己的keyframe去生成需要的keyframe就可以了。<br>话不多说，直接上代码：<br>通过查看keyframe的源码，我们可以摘取我们需要的数据，然后自定义类即可。（这里定义struct，打包的时候序列化会出错，具体原因还未查明）  </p><pre><code>public class LBSerializeAnimCurveKeyFrame&#123;    #region 字段    public float m_Time;    public float m_Value;    public float m_InTangent;    public float m_OutTangent;    public int m_TangentMode;    public int m_WeightedMode;    public float m_InWeight;    public float m_OutWeight;    #endregion        #region 属性        #endregion        #region 方法        public LBSerializeAnimCurveKeyFrame(        float time,        float value,        float inTangent,        float outTangent,        float inWeight,        float outWeight)    &#123;        this.m_Time = time;        this.m_Value = value;        this.m_InTangent = inTangent;        this.m_OutTangent = outTangent;        this.m_WeightedMode = 3;        this.m_InWeight = inWeight;        this.m_OutWeight = outWeight;        this.m_TangentMode = 0;    &#125;    public static implicit operator LBSerializeAnimCurveKeyFrame(Keyframe keyframe)    &#123;        return new LBSerializeAnimCurveKeyFrame(keyframe);    &#125;        public static implicit operator Keyframe(LBSerializeAnimCurveKeyFrame keyframe)    &#123;        return new Keyframe(keyframe.m_Time, keyframe.m_Value, keyframe.m_InTangent, keyframe.m_OutTangent,            keyframe.m_InWeight, keyframe.m_OutWeight);    &#125;        #endregion&#125;</code></pre><p>上面就是笔者自己定义的keyframe，然后我们只需要在我们需要序列化的类添加上即可，示例如下：<br>首先查看我们需要序列化的数据应该怎么设计：  </p><pre><code>public class SerializeAnimationCurveData&#123;    #region 字段        public List&lt;LBSerializeAnimCurveKeyFrame&gt; m_AnimCurveKeyFrameList;        [IgnoreDataMember]    public AnimationCurve AnimCurve    &#123;        get        &#123;            Keyframe[] keyframeArray;            if (m_AnimCurveKeyFrameList != null)            &#123;                keyframeArray = new Keyframe[m_AnimCurveKeyFrameList.Count];                for (int i = 0; i &lt; m_AnimCurveKeyFrameList.Count; i++)                &#123;                    keyframeArray[i] = m_AnimCurveKeyFrameList[i];                &#125;            &#125;            else            &#123;                keyframeArray = AnimationCurve.Linear(0f, 0f, 1f, 1f).keys;            &#125;            return new AnimationCurve(keyframeArray);        &#125;        set        &#123;            m_AnimCurveKeyFrameList.Clear();            foreach (var keyframe in value.keys)            &#123;                m_AnimCurveKeyFrameList.Add(keyframe);            &#125;        &#125;    &#125;    #endregion    #region 方法    public SerializeAnimationCurveData()    &#123;        AnimCurve = AnimationCurve.Linear(0, 0, 1, 1);        m_AnimCurveKeyFrameList = new List&lt;LBSerializeAnimCurveKeyFrame&gt;();        foreach (var keyframe in AnimCurve.keys)        &#123;            m_AnimCurveKeyFrameList.Add(keyframe);        &#125;    &#125;    #endregion&#125;</code></pre><p>接着我们看一下如何编辑器上设置，笔者是在自定义的窗口上绘制的，其他面板也是类似：  </p><pre><code>private SerializeAnimationCurveData m_SerAnimCurveData;private void Awake()&#123;    m_SerAnimCurveData = new SerializeAnimationCurveData();&#125;private void OnGUI()&#123;    EditorGUILayout.BeginVertical(GUILayout.Width(400f));    &#123;        m_SerAnimCurveData.AnimCurve =            EditorGUILayout.CurveField(LBEditorLNG.SerAnimCurveTitle, m_SerAnimCurveData.AnimCurve);    &#125;    EditorGUILayout.EndVertical();&#125;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当我们想序列化一个字段的时候，如果字段不可以序列化，我们可以通过保留组成的数据，然后在反序列化的时候通过保留下来的数据重新组成我们需要的字段。如果字段也是封装好的私有字段，我们只需要自己重新设计一个类，用来保留这些字段。当我们需要一个成品的时候，如果我们没有办法保留成品，我们可以拆分这些，这样使用的时候重新组成就行了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;笔者在开发一个地图编辑器的过程中，需要配置一个摄像机的移动速度，这个时候策划提了一个需求，他希望能够通过设置曲线的方式来设置摄像机的移动，于</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="JSON" scheme="http://yoursite.com/tags/JSON/"/>
    
  </entry>
  
</feed>
