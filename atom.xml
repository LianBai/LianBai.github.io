<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LianBai</title>
  
  <subtitle>手握日月摘星辰，世间无我这般人。</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-03-11T08:06:58.604Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LianBai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity杂文——通过类名获取对应的Type</title>
    <link href="http://yoursite.com/2022/03/11/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E7%B1%BB%E5%90%8D%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E7%9A%84Type/"/>
    <id>http://yoursite.com/2022/03/11/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E7%B1%BB%E5%90%8D%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E7%9A%84Type/</id>
    <published>2022-03-11T07:36:03.000Z</published>
    <updated>2022-03-11T08:06:58.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者在编辑器开发过程中遇到一个问题，笔者想通过一个类的名字获取对应的类的Type然后再做一系列的操作，但是笔者发现无法直接获取，于是笔者通过不断的尝试通过下面的方法获取到了，如果有更好的方法欢迎告诉笔者。  </p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>话不多说，先上代码：  </p><pre><code>[MenuItem(&quot;Assets/GetType&quot;,false,81)]public static void GetClassTypeByClassTypeName()&#123;    const string className = &quot;TestScripts&quot;;    //方法一（在同一程序集内并且非自身Class才能获取到）    var type = Type.GetType(className);    Debug.LogError(type);        var allAssemblies = AppDomain.CurrentDomain.GetAssemblies();        //方法二（有特殊情况会获取不到，笔者没找到获取不到的原因）    type = allAssemblies.Select(assembly =&gt; assembly.GetType(className)).FirstOrDefault(assembly =&gt; assembly != null);    Debug.LogError(type);        //方法三（如果存在类重名的情况有概率获取错误，可以通过路径做限制）    type = allAssemblies.SelectMany(assembly =&gt; assembly.GetTypes()).FirstOrDefault(type1 =&gt; type1.Name == className);    Debug.LogError(type);&#125;</code></pre><p>运行结果如下  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1646985481130-2022-3-1115:58:02.png">  </p><p>方法一和方法二的获取条件都有限制，因此笔者建议使用方法三进行获取。  </p><h1 id="获取方式讲解"><a href="#获取方式讲解" class="headerlink" title="获取方式讲解"></a>获取方式讲解</h1><p>方法一是直接在当前程序集进行获取的。<br>方法二是通过遍历当前程序的所有程序集，然后通过程序集直接GetType进行获取<br>方法三是类似于方法二，得到所有的程序集再遍历程序集中的Type，判断名字是否相同来得到对应的Type</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;笔者在编辑器开发过程中遇到一个问题，笔者想通过一个类的名字获取对应的类的Type然后再做一系列的操作，但是笔者发现无法直接获取，于是笔者通过</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="C#反射" scheme="http://yoursite.com/tags/C-%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——按行删除字符串</title>
    <link href="http://yoursite.com/2022/03/10/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2022/03/10/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-03-10T09:02:29.000Z</published>
    <updated>2022-03-10T09:07:58.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>笔者在项目开发过程中需要做一个聊天的假数据显示，是用于demo的，于是笔者就直接用string字符串来模拟显示的数据，但是当聊天内容过多的时候就需要删除历史的聊天内容，于是笔者就想按照行数删除字符串，发现string并不包含这种接口，于是写下了下面的代码。  </p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><pre><code>private static string DeleteStrLine(string text, int startLine, int lineCount)&#123;    var curIndex = 0;    int? remStartIndex = null;    var sum = 1;    while (sum &lt; startLine + lineCount)     &#123;        if (sum == startLine) remStartIndex = curIndex;                curIndex = text.IndexOf(&quot;\n&quot;, curIndex, StringComparison.Ordinal);        if (curIndex &lt; 0)        &#123;            curIndex = text.Length;            break;        &#125;        curIndex++;        sum++;    &#125;    if (remStartIndex == null)    &#123;        return text;    &#125;    text = text.Remove(remStartIndex.Value, curIndex - remStartIndex.Value);    return text;&#125;</code></pre><p>上述代码是笔者的解决方案，原理很简单，遍历查找字符串的换行字符**”\n”**,然后记录下索引，根据传入的需要删除的行数找到对应的索引，最后使用Remove函数按照开始和结束的索引进行删除。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;笔者在项目开发过程中需要做一个聊天的假数据显示，是用于demo的，于是笔者就直接用string字符串来模拟显示的数据，但是当聊天内容过多的时</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>StarUML使用笔记</title>
    <link href="http://yoursite.com/2022/03/04/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/StarUML%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/03/04/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/StarUML%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-04T07:46:19.000Z</published>
    <updated>2022-03-10T07:01:11.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图操作菜单"><a href="#图操作菜单" class="headerlink" title="图操作菜单"></a>图操作菜单</h1><h2 id="Add-Diagram"><a href="#Add-Diagram" class="headerlink" title="Add Diagram"></a>Add Diagram</h2><pre><code>Class Diagram                   类图Package Diagram                 包图Object Diagram                  对象图Composite Structure Diagram     复合结构图Component Diagram               组件图Deployment Diagram              展开图Use Case Diagram                用例图Sequence Diagram                时序图Communication Diagram           交流图Statechart Diagram              状态图Activity Diagram                活动图Profile Diagram                    ER Diagram                      E-R图Flowchart Diagram               流程图Data Flow Diagram               数据流程图</code></pre><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><pre><code>Tempalate Parameter     模板参数Attribute               属性Port                    端口Operation               操作Reception               接待Class                   类Interface               接口Signal                  信号DataType                数据类型PrimitiveType           原始类型Enumeration             枚举Artifact                工件Component               组件Node                    节点UseCase                    ActorInformationItemCollaborationInteraction             交互State Machine           状态机    Activity                活动Opaque Behavior         不透明树    Constraint              约束Requirement             要求Block                   块Value Type              数值类型Interface Block         接口块Constraint Block        约束快Tag                     标签</code></pre><h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1646381948452-2022-3-416:19:09.png">   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图操作菜单&quot;&gt;&lt;a href=&quot;#图操作菜单&quot; class=&quot;headerlink&quot; title=&quot;图操作菜单&quot;&gt;&lt;/a&gt;图操作菜单&lt;/h1&gt;&lt;h2 id=&quot;Add-Diagram&quot;&gt;&lt;a href=&quot;#Add-Diagram&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="个人笔记" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity杂文——String按行删除</title>
    <link href="http://yoursite.com/2022/03/03/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94string%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4/"/>
    <id>http://yoursite.com/2022/03/03/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94string%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4/</id>
    <published>2022-03-03T07:19:36.000Z</published>
    <updated>2022-03-04T02:16:15.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在unity开发过程中，如果一个string字符串有多行，如果我们想删除前面一行或者多行应该如何操作？  </p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><pre><code>private static string DeleteStrLine(string text, int startLine, int lineCount)&#123;    var curIndex = 0;    int? remStartIndex = null;    var sum = 1;    while (sum &lt; startLine + lineCount)     &#123;        if (sum == startLine) remStartIndex = curIndex;                curIndex = text.IndexOf(&quot;\n&quot;, curIndex, StringComparison.Ordinal);        if (curIndex &lt; 0)        &#123;            curIndex = text.Length;            break;        &#125;        curIndex++;        sum++;    &#125;    if (remStartIndex == null)    &#123;        return text;    &#125;    text = text.Remove(remStartIndex.Value, curIndex - remStartIndex.Value);    return text;&#125;</code></pre><p>思路就是通过<strong>IndexOf</strong>函数遍历找到需要删除的行对应的”\n”(换行)的索引，然后再通过<strong>Remove</strong>函数对开始和结束的索引进行删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;在unity开发过程中，如果一个string字符串有多行，如果我们想删除前面一行或者多行应该如何操作？  &lt;/p&gt;
&lt;h1 id=&quot;解决方案</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Unity笔记</title>
    <link href="http://yoursite.com/2022/03/03/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Unity%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/03/03/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Unity%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-03T07:14:26.000Z</published>
    <updated>2022-03-03T07:16:07.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p><strong>[Conditional(“XXX”)]</strong>: 指定XXX宏下进行编译</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;特性&quot;&gt;&lt;a href=&quot;#特性&quot; class=&quot;headerlink&quot; title=&quot;特性&quot;&gt;&lt;/a&gt;特性&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;[Conditional(“XXX”)]&lt;/strong&gt;: 指定XXX宏下进行编译&lt;/p&gt;
</summary>
      
    
    
    
    <category term="个人笔记" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Unity" scheme="http://yoursite.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——扩展Inspector面板(二)</title>
    <link href="http://yoursite.com/2022/02/23/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95Inspector%E9%9D%A2%E6%9D%BF(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2022/02/23/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95Inspector%E9%9D%A2%E6%9D%BF(%E4%BA%8C)/</id>
    <published>2022-02-23T10:30:36.000Z</published>
    <updated>2022-02-25T02:08:27.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>上次笔者讲解了如何自定义Inspector面板的显示，但是这里还有一个问题，就是对于支持的字段我们可以绘制对应的属性，但是有些字段我们并不支持绘制，比如一些类定义的变量，我们又改如何绘制？下面笔者介绍一下如何绘制一些本身不支持的字段。  </p><h1 id="自定义绘制Inspector"><a href="#自定义绘制Inspector" class="headerlink" title="自定义绘制Inspector"></a>自定义绘制Inspector</h1><p>笔者依旧拿笔者写的动画编辑器作为案例来进行讲解。  </p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>存放文件的目录如下  </p><blockquote><p>—Asset<br>——Scripts<br>———Editor<br>————UIAnimManagerEditor.cs<br>————<font color=#00FF00>UIAnimTransformInfoEditor.cs</font><br>———Engine<br>————UIAnimManager.cs<br>————<font color=#00FF00>UIAnimInfoBase.cs</font><br>————<font color=#00FF00>UIAnimTransformInfo.cs</font>  </p></blockquote><h2 id="创建一个Transform的信息的类（UIAnimTransformInfo）"><a href="#创建一个Transform的信息的类（UIAnimTransformInfo）" class="headerlink" title="创建一个Transform的信息的类（UIAnimTransformInfo）"></a>创建一个Transform的信息的类（UIAnimTransformInfo）</h2><p>为了方便我们可以绘制动画信息在Inspector面板上，我们需要在信息类上加上**[Serializable]**标签方便我们序列化</p><pre><code>[Serializable]public class UIAnimTransformInfo&#123;        public Transform m_Transform;&#125;</code></pre><p>然后我们在UIAnimManager上添加我们的信息就可以了</p><pre><code>public class UIAnimManager : MonoBehaviour&#123;    public float m_SumTime;                                                     //总时间    public bool m_IsDefReversed;                                                //默认的是否倒放    public bool m_IsDefLoop;                                                    //默认的是否循环    public bool m_IsDefAutoPlay;                                                //默认的是否自动播放    public UIAnimTransformInfo m_UIAnimTransformInfo;                           //Transform动画信息        [NonSerialized]    public float m_CurTime;                                                     //当前时间    [NonSerialized]    public UIAnimPlayState m_UIAnimPlayState = UIAnimPlayState.Stop;            //当前状态    &#125;</code></pre><h2 id="默认绘制类中类对象的Inspector面板"><a href="#默认绘制类中类对象的Inspector面板" class="headerlink" title="默认绘制类中类对象的Inspector面板"></a>默认绘制类中类对象的Inspector面板</h2><p>我们可以通过绘制属性的方式直接绘制我们的变量，代码如下：  </p><pre><code>EditorGUILayout.PropertyField(m_UIAnimTransformInfo);</code></pre><p>效果如下：  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1645698365713-2022-2-2418:26:06.png">  </p><p>这个绘制是unity默认的绘制。  </p><h2 id="自定义绘制类中类对象的Inspector面板"><a href="#自定义绘制类中类对象的Inspector面板" class="headerlink" title="自定义绘制类中类对象的Inspector面板"></a>自定义绘制类中类对象的Inspector面板</h2><p>如果我们类中的对象不想使用自定义的绘制，我们可以采用CustomPropertyDrawer这个属性标签来绑定我们类的绘制编辑器类。<br>代码如下  </p><pre><code>[CustomPropertyDrawer(typeof(UIAnimTransformInfo))]public class UIAnimTransformInfoEditor : PropertyDrawer&#123;    /// &lt;summary&gt;    /// 获取属性绘制的高度    /// &lt;/summary&gt;    /// &lt;param name=&quot;property&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;label&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public override float GetPropertyHeight(SerializedProperty property, GUIContent label)    &#123;        return EditorGUI.GetPropertyHeight(property);    &#125;    /// &lt;summary&gt;    /// 绘制自定义的面板    /// &lt;/summary&gt;    /// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;property&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;label&quot;&gt;&lt;/param&gt;    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)    &#123;            &#125;&#125;</code></pre><p>上述代码中，GetPropertyHeight函数是用来设置绘制面板的高度的，然后OnGUI的函数是写自定义的绘制的。  </p><font size=5 color=FF0000>提示：   在GetPropertyHeight函数离，如果类比较复杂，通过EditorGUI.GetPropertyHeight(property)获取的高度会出错，最好把属性里的需要绘制的字段分别获取高度再加一起返回。  在OnGUI函数里绘制的时候不能采用GUILayout和EditorGuiLayout的绘制方式，因为这个是给Rect进行绘制的，每次绘制的时候只需要计算宽度，然后绘制后坐标再自己移动绘制下一个。举例代码如下：</font>  <pre><code>/// &lt;summary&gt;/// 绘制单个可滑动的列表/// &lt;/summary&gt;/// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;property&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;uiReorderableList&quot;&gt;&lt;/param&gt;public static void OnReorderableListPropertyItemGUI(ref Rect position, SerializedProperty property,ReorderableList uiReorderableList)&#123;    position.height = GetReorderableListHeight(property);    uiReorderableList.DoList(position);    position.y += position.height;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;上次笔者讲解了如何自定义Inspector面板的显示，但是这里还有一个问题，就是对于支持的字段我们可以绘制对应的属性，但是有些字段我们并不支</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Unity编辑器" scheme="http://yoursite.com/tags/Unity%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——扩展Inspector面板(一)</title>
    <link href="http://yoursite.com/2022/02/18/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95Inspector%E9%9D%A2%E6%9D%BF(%E4%B8%80)/"/>
    <id>http://yoursite.com/2022/02/18/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95Inspector%E9%9D%A2%E6%9D%BF(%E4%B8%80)/</id>
    <published>2022-02-18T05:45:59.000Z</published>
    <updated>2022-02-18T07:23:45.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在使用unity的时候我们会经常使用到inspector面板来查看我们选中对象的信息，也会经常修改一些信息，但是，untiy默认的指挥显示我们组件上序列化的信息，也并不是所有的序列化的信息都显示，我们只需要添加**[HideInInspector]**标签就可以隐藏信息。但是这些并不能满足我们修改信息的需求，unity也为我们提供了自动绘制面板，这样我们不仅仅有修改字段的功能，还可以添加更多的功能了。  </p><h1 id="自定义绘制Inspector"><a href="#自定义绘制Inspector" class="headerlink" title="自定义绘制Inspector"></a>自定义绘制Inspector</h1><p>笔者是以自己写的一个UI的动画控制器为例来讲解的。  </p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>存放文件的目录如下  </p><blockquote><p>—Asset<br>——Scripts<br>———Editor<br>————UIAnimManagerEditor.cs<br>———Engine<br>————UIAnimManager.cs  </p></blockquote><h2 id="组件脚本"><a href="#组件脚本" class="headerlink" title="组件脚本"></a>组件脚本</h2><p>首先我们先创建一个需要绘制的脚本：  </p><pre><code>/// &lt;summary&gt;/// 动画播放状态/// &lt;/summary&gt;public enum UIAnimPlayState&#123;    Stop,                   //停止    Playing,                //播放中    Pause,                  //暂停    Finish,                 //完成&#125;/// &lt;summary&gt;/// 动画播放控制器/// &lt;/summary&gt;public class UIAnimManager : MonoBehaviour&#123;    public float m_SumTime;                                                     //总时间    public bool m_IsDefReversed;                                                //默认的是否倒放    public bool m_IsDefLoop;                                                    //默认的是否循环    public bool m_IsDefAutoPlay;                                                //默认的是否自动播放        [NonSerialized]    public float m_CurTime;                                                     //当前时间    [NonSerialized]    public UIAnimPlayState m_UIAnimPlayState = UIAnimPlayState.Stop;            //当前状态&#125;</code></pre><p>下面我们来看看默认的inspector的面板显示：  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1645165132213-2022-2-1814:18:53.png"></p><p>不仅仅**[HideInInspector]<strong>标签会隐藏字段，</strong>[NonSerialized]**标记没有序列化的字段也不会显示出来。  </p><h2 id="绘制Inspector面板脚本-CustomEditor"><a href="#绘制Inspector面板脚本-CustomEditor" class="headerlink" title="绘制Inspector面板脚本(CustomEditor)"></a>绘制Inspector面板脚本(CustomEditor)</h2><pre><code>[CustomEditor(typeof(UIAnimManager))]public class UIAnimManagerEditor : UnityEditor.Editor&#123;    #region 字段    private UIAnimManager m_UIAnimManager;                                      //面板的脚本        private SerializedProperty m_IsDefReversed;                                 //是否倒放    private SerializedProperty m_IsDefLoop;                                     //是否循环    private SerializedProperty m_IsDefAutoPlay;                                 //是否自动播放    #endregion        #region 继承方法    private void OnEnable()    &#123;        m_UIAnimManager = (UIAnimManager) target;                               //获取绑定的脚本                m_IsDefReversed = serializedObject.FindProperty(&quot;m_IsDefReversed&quot;);     //获取m_IsDefReversed字段        m_IsDefLoop = serializedObject.FindProperty(&quot;m_IsDefLoop&quot;);             //获取m_IsDefLoop字段        m_IsDefAutoPlay = serializedObject.FindProperty(&quot;m_IsDefAutoPlay&quot;);     //获取m_IsDefAutoPlay字段    &#125;    /// &lt;summary&gt;    /// 自定义绘制Inspector面板    /// &lt;/summary&gt;    public override void OnInspectorGUI()    &#123;        OnPropertyFieldGUI();    &#125;    #endregion        #region 自定义方法    /// &lt;summary&gt;    /// 绘制属性字段    /// &lt;/summary&gt;    private void OnPropertyFieldGUI()    &#123;        EditorGUI.BeginChangeCheck();                                       //监听面板是否发生变化        &#123;            EditorGUILayout.PropertyField(m_IsDefReversed);                 //绘制m_IsDefReversed属性            EditorGUILayout.PropertyField(m_IsDefLoop);                     //绘制m_IsDefLoop属性            EditorGUILayout.PropertyField(m_IsDefAutoPlay);                    //绘制m_IsAutoPlay属性        &#125;        if (EditorGUI.EndChangeCheck())                                     //如果发生变化为true        &#123;            EditorUtility.SetDirty(target);                                 //标记用于触发保存            serializedObject.ApplyModifiedProperties();                     //更新序列化的数据        &#125;    &#125;    #endregion&#125;</code></pre><p>如上述代码，编写脚本只需要类上面打上**[CustomEditor(typeof(UIAnimManager))]<strong>即可，中间的UIAnimManager换成需要绑定的类即可，然后在代码中继承</strong>OnInspectorGUI**方法，在这个方法里绘制自己想绘制的面板。<br>绘制样子如下：  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1645168657839-2022-2-1815:17:38.png">  </p><h2 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h2><p>首先开<strong>OnEnable</strong>函数里：  </p><blockquote><p>m_UIAnimManager = (UIAnimManager) target;获取当前绑定的脚本对象<br>serializedObject.FindProperty是获取脚本上的属性，是拿这些属性绘制的  </p></blockquote><p><strong>OnInspectorGUI</strong>函数就是我们编写绘制Inspector面板的函数，在代码里我们可以编写untiy提供的编辑器代码，笔者这里只是通过EditorGUILayout.PropertyField来绘制属性，也可以使用其他unity的编辑器绘制代码，这里就不举例了。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在使用unity的时候我们会经常使用到inspector面板来查看我们选中对象的信息，也会经常修改一些信息，但是，untiy默认的指挥显示我</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Unity编辑器" scheme="http://yoursite.com/tags/Unity%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>解决Hexo博客提交Warning</title>
    <link href="http://yoursite.com/2022/01/29/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E8%A7%A3%E5%86%B3Hexo%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4Warning/"/>
    <id>http://yoursite.com/2022/01/29/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E8%A7%A3%E5%86%B3Hexo%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4Warning/</id>
    <published>2022-01-29T07:19:22.000Z</published>
    <updated>2022-01-29T07:26:23.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Warning-Accessing-non-existent-property-‘XXX’-of-module-exports-inside-circular-dependency"><a href="#Warning-Accessing-non-existent-property-‘XXX’-of-module-exports-inside-circular-dependency" class="headerlink" title="Warning: Accessing non-existent property ‘XXX’ of module exports inside circular dependency"></a>Warning: Accessing non-existent property ‘XXX’ of module exports inside circular dependency</h1><p>笔者在更新本地npm和node后，提交hexo博客的时候遇到了这个问题。原因在于本地node的版本太高导致的。  </p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>降低node的版本，选择一个低版本的node，node的12版本应该就可以。  </p><p><a href="https://nodejs.org/download/release/"><font color=steelblue size=5>node各版本下载</font></a>  </p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>笔者并不想更新node版本，于是笔者找到了第二种解决方案，在博客目录下：  </p><pre><code>myBlog\node_modules\nib\node_modules\stylus\lib\nodes\index.jsmyBlog\node_modules\stylus\lib\nodes\index.js.</code></pre><p>上面两个路径下的<strong>index.js</strong>文件的前面分别添加下面代码即可。(两个文件都需要添加)  </p><pre><code>exports.lineno = null;exports.column = null;exports.filename = null;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Warning-Accessing-non-existent-property-‘XXX’-of-module-exports-inside-circular-dependency&quot;&gt;&lt;a href=&quot;#Warning-Accessing-non-existent</summary>
      
    
    
    
    <category term="搭建博客" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客Warning" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2Warning/"/>
    
  </entry>
  
  <entry>
    <title>UnityECS入门(三)——写一个简单的ECS</title>
    <link href="http://yoursite.com/2022/01/29/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%B8%89)%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84ECS/"/>
    <id>http://yoursite.com/2022/01/29/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%B8%89)%E2%80%94%E2%80%94%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84ECS/</id>
    <published>2022-01-29T03:12:57.000Z</published>
    <updated>2022-02-17T06:34:47.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><pre><code>unity: 2020.3.18f1Entities: 0.17.0Jobs: 0.8.0</code></pre><h1 id="SimpleECS"><a href="#SimpleECS" class="headerlink" title="SimpleECS"></a>SimpleECS</h1><p>一个简单的ECS应该包括Entity、Component和System，接下来笔者就带着大家写一个简单的ECS。  </p><h2 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h2><p>unity的<strong>Entity是已经封装好的，不需要自己创建</strong>。笔者一开始也没有理解，每个实例不一样，为啥不是自己制作Entity，笔者目前的理解是Entity就像一个没有任何属性的GameObject，我们是通过给这个空的GameObject添加Component来组成我们理解的实体对象。<br>下面我们来分析一下Entity，源码如下：  </p><pre><code>using System;namespace Unity.Entities&#123;        public struct Entity : IEquatable&lt;Entity&gt;, IComparable&lt;Entity&gt;    &#123;                public int Index;        public int Version;        public static bool operator==(Entity lhs, Entity rhs)        &#123;            return lhs.Index == rhs.Index &amp;&amp; lhs.Version == rhs.Version;        &#125;        public static bool operator!=(Entity lhs, Entity rhs)        &#123;            return !(lhs == rhs);        &#125;        public int CompareTo(Entity other)        &#123;            return Index - other.Index;        &#125;        public override bool Equals(object compare)        &#123;            return this == (Entity)compare;        public override int GetHashCode()        &#123;            return Index;        &#125;        public static Entity Null =&gt; new Entity();        public bool Equals(Entity entity)        &#123;            return entity.Index == Index &amp;&amp; entity.Version == Version;        &#125;        public override string ToString()        &#123;            return Equals(Entity.Null) ? &quot;Entity.Null&quot; : $&quot;Entity(&#123;Index&#125;:&#123;Version&#125;)&quot;;        &#125;    &#125;&#125;</code></pre><p>上面的代码重要部分是两个字段，<strong>Index</strong>和<strong>Version</strong>。<br>Index其实不难理解，笔者在上一篇文章提起过，Entity绑定的component是统一放在一个Chunk上的，为了提高访问的速度，当我们想要操作一个Entity的Component的时候，我们是通过Index在EntityDataManager中查找所在的Chunk和IndexInChunk。<br>Version是一个类似于版本号的东西，就像版本号会递增一样，Entity每次被回收的时候这个值会+1。用途的话，笔者猜测可能是当我们回调一个实例的时候，可以判断实例是否已经被回收了或者改变了。  </p><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><pre><code>[GenerateAuthoringComponent]public struct SimpleEcsComp : IComponentData&#123;    public float m_MoveSpeed;&#125;</code></pre><p>Component可以理解为Entity具有的属性或者组件，一个Entity是可以绑定多个Component的，就像一个GameObject上挂很多组件一样。<br>Component一般定义成struct，并且继承IComponentData或者ISharedComponentData这两个接口。   </p><h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>在以前的UnityECS版本里存在ComponentSystem和JobSystem两种System，但是目前已经被Unity弃用，这里就不介绍了，在新的ECS版本里，System采用的是<strong>SystemBase</strong>。  </p><pre><code>public class SimpleEcsSystem : SystemBase&#123;    protected override void OnUpdate()    &#123;        var deltaTime = Time.DeltaTime;        Entities.ForEach((ref Translation translation, ref SimpleEcsComp simpleEcsComp) =&gt;        &#123;            translation.Value.y += simpleEcsComp.m_MoveSpeed * deltaTime;            if (translation.Value.y &gt; 5f)            &#123;                simpleEcsComp.m_MoveSpeed = -math.abs(simpleEcsComp.m_MoveSpeed);            &#125;            else if (translation.Value.y &lt; -5f)            &#123;                simpleEcsComp.m_MoveSpeed = math.abs(simpleEcsComp.m_MoveSpeed);            &#125;        &#125;).ScheduleParallel();    &#125;&#125;</code></pre><p>如上述代码，在System的中，在进行Entities.ForEach的时候，最后需要执行一下<strong>ScheduleParallel</strong>这个方法，这里是一种扩展方法，这里常用的不仅仅是ScheduleParallel，还有Run和Schedul两个方法。下面介绍一下方法的用途：  </p><blockquote><p>Run() : evaluates the entity query and invokes the lambda function for each selected entity immediately on the main thread. Calling Run() completes the system Dependency JobHandle before running, blocking the main thread, if necessary, while it waits for those jobs to finish.<br>Schedul(): schedules the work to be done in a single job (no matter how many entities are selected).<br>ScheduleParallel() – schedules the work to be done in parallel using the C# Job system. Each parallel job instance processes at least one chunk of entities at a time. In other words, if all the selected entities are in the same chunk, then only one job instance is spawned.   </p></blockquote><h2 id="运行结果如下"><a href="#运行结果如下" class="headerlink" title="运行结果如下"></a>运行结果如下</h2><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1645079644114-2022-2-1714:34:04.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;unity: 2020.3.18f1
Entities: 0.17.0
Jobs: 0.8.0
&lt;/code&gt;&lt;/pre&gt;
</summary>
      
    
    
    
    <category term="UnityECS" scheme="http://yoursite.com/categories/UnityECS/"/>
    
    
    <category term="ECS" scheme="http://yoursite.com/tags/ECS/"/>
    
  </entry>
  
  <entry>
    <title>给hexo博客添加访问密码</title>
    <link href="http://yoursite.com/2022/01/28/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E7%BB%99hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E5%AF%86%E7%A0%81/"/>
    <id>http://yoursite.com/2022/01/28/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E7%BB%99hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AE%BF%E9%97%AE%E5%AF%86%E7%A0%81/</id>
    <published>2022-01-28T07:31:45.000Z</published>
    <updated>2022-01-29T06:25:45.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔者记忆力比较差，于是笔者想有个空间能记录笔者一些私人的内容，于是笔者想起来比较经常会遇到一些加密的博客，笔者便想如果自己如果有一个博客能记录自己的私人内容，然后把博客进行加密即可，这样自己想要查看内容的额时候只需要访问隐私博客，然后输入密码就可以看到了。  </p><h1 id="安装Hexo-Blog-Encrypt"><a href="#安装Hexo-Blog-Encrypt" class="headerlink" title="安装Hexo-Blog-Encrypt"></a>安装Hexo-Blog-Encrypt</h1><p>hexo的博客添加密码其实只需要安装一个插件就可以了。<br>通过npm在hexo博客目录安装Hexo-Blog-Encrypt  </p><pre><code>npm install --save hexo-blog-encrypt</code></pre><h1 id="博客使用密码"><a href="#博客使用密码" class="headerlink" title="博客使用密码"></a>博客使用密码</h1><p>只需要在博客的开头使用  </p><pre><code>---title: Hello Worlddate: 2022-01-28 15:31:45password: 密码---</code></pre><p>还可以添加一些描述的标签  </p><pre><code>---title: Hello Worldtags:- 加密文章的tagdate: 2022-01-28 15:31:45password: 密码abstract: 这里有东西被加密了，需要输入密码查看哦。message: 您好，这里需要密码。wrong_pass_message: 抱歉，这个密码看着不太对，请再试试。wrong_hash_message: 抱歉，这个文章不能被纠正，不过您还是能看看解密后的内容。---</code></pre><h1 id="根目录添加配置文件"><a href="#根目录添加配置文件" class="headerlink" title="根目录添加配置文件"></a>根目录添加配置文件</h1><pre><code># 安全encrypt: # hexo-blog-encrypt  abstract: 这里有东西被加密了，需要输入密码查看哦。  message: 您好, 这里需要密码.  tags:  - &#123;name: tagName, password: 密码A&#125;  - &#123;name: tagName, password: 密码B&#125;  #密码主题 https://github.com/D0n9X1n/hexo-blog-encrypt#encrypt-theme  theme: wave      wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.  wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;笔者记忆力比较差，于是笔者想有个空间能记录笔者一些私人的内容，于是笔者想起来比较经常会遇到一些加密的博客，笔者便想如果自己如果有一个博客能记</summary>
      
    
    
    
    <category term="搭建博客" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客密码" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>私人密码记事本</title>
    <link href="http://yoursite.com/2022/01/28/%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E7%A7%81%E4%BA%BA%E5%AF%86%E7%A0%81%E8%AE%B0%E4%BA%8B%E6%9C%AC/"/>
    <id>http://yoursite.com/2022/01/28/%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E7%A7%81%E4%BA%BA%E5%AF%86%E7%A0%81%E8%AE%B0%E4%BA%8B%E6%9C%AC/</id>
    <published>2022-01-28T06:29:49.000Z</published>
    <updated>2022-03-10T09:15:49.718Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="18f311e1e626c485ef15e534108659a03c7e407b9880fb06c4f85828d8471924">2521a7807bde158c25736a82631336cef69c8023285301a3fbc36dfb98f6e317a65e61edf2bc05b5baa81011208e99997530f84143591992a31d06652f4777d39959a148e1cfd3abdbdaf0d3f2e34d58f7cc4a7a4d87e2c556ca3bee9db959a81e9156e003fb37ca67f0de85901c11ac6d22be5894add73186b8200509861945e827fa50350b7d8e7c577510e0c7f04f999f2c26ccf897139fd3896f616588fd1afbe305ba2e0eac4c212d14101f3577f98d2c52bd2650565b00fda22f9f9d6e18218f7b1b4a22a0e965b89a31a8eea52e911983bfa6ae6004db1f1a5699761c2efa572cac178ada568024e657744802d586129440fce350e84fba64ccc11c973d7ebb4e04fcb64e5c5ab9c4b0509629a073ec697eb076f97dd6a9ae5c64bcb423c71f31a01b8aa8044055484a5201d0572d83b5a6391fd3a270d18fdb7d17d01ff2d23cac00ba56047285218a835ce4172b11027c94775635d7463afd0cab8b1b25505a63352dbfb365b57273bdab223ebf72a4bca76007d3c40b827ce80a11944e689953d7e40365179a7e9b2db8be89f4964fd29295a16c4f8026e7191aee9fe0639b67528076158033ef7edf80be5192940dea83c279ae298e0b01fd2add222d876196d3d2ccf7b233662285b96d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这里有东西被加密了，需要输入密码查看哦。</summary>
    
    
    
    <category term="私人文件" scheme="http://yoursite.com/categories/%E7%A7%81%E4%BA%BA%E6%96%87%E4%BB%B6/"/>
    
    
    <category term="密码记事本" scheme="http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E8%AE%B0%E4%BA%8B%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>UnityECS入门(二)——简单讲解一下ECS</title>
    <link href="http://yoursite.com/2022/01/28/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%BA%8C)%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3%E4%B8%80%E4%B8%8BECS/"/>
    <id>http://yoursite.com/2022/01/28/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%BA%8C)%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3%E4%B8%80%E4%B8%8BECS/</id>
    <published>2022-01-28T05:17:37.000Z</published>
    <updated>2022-01-28T08:04:29.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇我们已经成功的配置好本地的环境了，接下来我们来简单的讲解一下ECS。(笔者也是初学者，如果有错误欢迎大家指出)  </p><h1 id="ECS简介"><a href="#ECS简介" class="headerlink" title="ECS简介"></a>ECS简介</h1><p>在写ECS之前我们先了解一下什么是ECS？  </p><h2 id="ECS是什么？"><a href="#ECS是什么？" class="headerlink" title="ECS是什么？"></a>ECS是什么？</h2><p>ECS的缩写就是Entity Component System。对应的就是实例、组件和系统。笔者认为这是和MVC框架类似，虽然作用不是一样的，但是都代表了一种思想。ECS的思想打破了我们面向对象的思想，让我们直接面向数据变成。以往的Unity提供给使用者的都是GameObject，让我们来面向对象思想，但是ECS则是把GameObject拆成了Entity和Component，然后由System再进行同意管理。  </p><h2 id="为什么使用ECS？"><a href="#为什么使用ECS？" class="headerlink" title="为什么使用ECS？"></a>为什么使用ECS？</h2><h3 id="在编写思想上"><a href="#在编写思想上" class="headerlink" title="在编写思想上"></a>在编写思想上</h3><p>笔者认为，现在的大部分游戏其实都是数据驱动的游戏，游戏的界面对象其实是给使用者提供的。一个好的程序猿应该做到真正的数据和显示分离，这样不管显示是什么样，数据都可以去应对，但其实这是理想化的，因为显示是很难统一的。  </p><h3 id="在编写代码上"><a href="#在编写代码上" class="headerlink" title="在编写代码上"></a>在编写代码上</h3><p>ECS为我们提供了面向数据编程的结构、强迫使我们数据和显示进行分离，这样虽然编写复杂了一些，但是我们的扩展性和适应性会有很大的提高。<br>Unity的MonoBehavior的class其实是非常笨重的，里面包含了大量的信息，我们在平时开发中其实用不到那么多信息，在ECS上我们只需要添加上我们需要用到的组件即可。  </p><h3 id="在内存管里方面"><a href="#在内存管里方面" class="headerlink" title="在内存管里方面"></a>在内存管里方面</h3><p>ECS引入了Archetype和Chuck两个概念，Archetype对应的是我们的Component，就是存放我们Entity需要的所有组件，然后多个Archetype会被封装成一个个的Archetype Chuck，然后在内存里按照顺序进行存放，如果一个Chuck存放满了，会在后面内存里创建新的Chuck，这样Component就是在一起的，每次查找Component的时候速度会大大提升。<br>下面我们来看一看内存结构图：  </p><p><img src="https://i0.hdslb.com/bfs/article/6cb305d158f9daf75ef880b035a26afdea2961af.png" alt="在这里插入图片描述"></p><p><img src="https://i0.hdslb.com/bfs/article/363335a8d53167863db8a0c040e29e37d2f9b269.png" alt="在这里插入图片描述">  </p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>Unity使用的是单线程，虽然里面会有携程一些，但其根本原理都是单线程，所以并不能完全发挥CPU，ECS引入了多线程的Job system，并且Job System会把Entities分发到CPU的线程上，这样就提高了CPU的利用率。  </p><h1 id="怎么使用ECS"><a href="#怎么使用ECS" class="headerlink" title="怎么使用ECS"></a>怎么使用ECS</h1><p>ECS主要提升的是CPU的性能，并不是所有的项目都适合使用ECS，因为ECS是新的思想，团队开发成本也是有一定提高的，笔者业主要是为了学习了解，拓展一下自己的思路。<br>接下来笔者会继续学习如何使用ECS。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在上一篇我们已经成功的配置好本地的环境了，接下来我们来简单的讲解一下ECS。(笔者也是初学者，如果有错误欢迎大家指出)  &lt;/p&gt;
&lt;h1 </summary>
      
    
    
    
    <category term="UnityECS" scheme="http://yoursite.com/categories/UnityECS/"/>
    
    
    <category term="ECS" scheme="http://yoursite.com/tags/ECS/"/>
    
  </entry>
  
  <entry>
    <title>UnityECS入门(一)——安装Unity官方的ECS</title>
    <link href="http://yoursite.com/2022/01/27/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%B8%80)%E2%80%94%E2%80%94%E5%AE%89%E8%A3%85Unity%E5%AE%98%E6%96%B9%E7%9A%84ECS/"/>
    <id>http://yoursite.com/2022/01/27/UnityECS/UnityECS%E5%85%A5%E9%97%A8(%E4%B8%80)%E2%80%94%E2%80%94%E5%AE%89%E8%A3%85Unity%E5%AE%98%E6%96%B9%E7%9A%84ECS/</id>
    <published>2022-01-27T05:49:25.000Z</published>
    <updated>2022-01-28T05:16:43.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>笔者最近准备学习Unity官方的ECS，笔者才刚开始学习，这里就先不卖弄了，笔者写这篇博客的主要目的是为了分享如何安装官方ECS。  </p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><pre><code>Unity 2020.3.18f1c1</code></pre><h1 id="安装Entitie-com-unity-entities"><a href="#安装Entitie-com-unity-entities" class="headerlink" title="安装Entitie(com.unity.entities)"></a>安装Entitie(com.unity.entities)</h1><p>unity的版本低于2020.1的可以直接在Package Manager里搜索Entitie就可以了。<br>在unity2020.1版本的时候，官方对unity的Package Manager做了一些整改，默认不再显示Preview Package了。<br>首先笔者先介绍如何打开显示Preview Package。<br><img src="https://img-blog.csdnimg.cn/a6e1dd43a96d4951834981e78c8054e2.png" alt="在这里插入图片描述">  </p><p><img src="https://img-blog.csdnimg.cn/74d2605b303549cbbcc895a4013b83e3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6IS455m9,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">  </p><p>虽然打开了Preview Package但是依旧会搜不到部分Preview Package的库，这是因为处于早期开发阶段和开发不活跃的包无法直接搜索到。<br>笔者这里便介绍另外一种方式，通过url的方式导入需要的库。笔者在文章后面也会放入一些无法搜到的库。<br><strong>通过URL安装需要本地安装git来进行下载</strong><br>Entitie的url是： <strong>com.unity.entities</strong><br>导入步骤如下：<br><img src="https://img-blog.csdnimg.cn/b093196413e44d178d9a5656aee4ed7e.png" alt="在这里插入图片描述">  </p><p><img src="https://img-blog.csdnimg.cn/126370bd43ae4f8ca103be329245adde.png" alt="在这里插入图片描述">  </p><h1 id="安装Jobs-com-unity-jobs"><a href="#安装Jobs-com-unity-jobs" class="headerlink" title="安装Jobs(com.unity.jobs)"></a>安装Jobs(com.unity.jobs)</h1><p>通过git url的方式输入com.unity.jobs即可安装，笔者安装entities的时候会自动安装jobs，如果没有安装可以使用这种方式安装。  </p><h1 id="安装HyBrid-Renderer-com-unity-rendering-hybrid"><a href="#安装HyBrid-Renderer-com-unity-rendering-hybrid" class="headerlink" title="安装HyBrid Renderer(com.unity.rendering.hybrid)"></a>安装HyBrid Renderer(com.unity.rendering.hybrid)</h1><p>学习ECS过程中还有可能用到HyBrid Renderer这个package，这里也提供一下对应的URL  </p><p><strong>com.unity.rendering.hybrid</strong>  </p><h1 id="安装Burst-com-unity-barracuda-burst"><a href="#安装Burst-com-unity-barracuda-burst" class="headerlink" title="安装Burst(com.unity.barracuda.burst)"></a>安装Burst(com.unity.barracuda.burst)</h1><p>直接在package manager里搜索Burst是可以搜到的</p><h1 id="安装Mathematics-com-unity-mathematics"><a href="#安装Mathematics-com-unity-mathematics" class="headerlink" title="安装Mathematics(com.unity.mathematics)"></a>安装Mathematics(com.unity.mathematics)</h1><p>直接在package manager里搜索Mathematics是可以搜到的，这里也放一下url </p><p><strong>com.unity.mathematics</strong></p><h1 id="无法搜到的Preview-Package的URL"><a href="#无法搜到的Preview-Package的URL" class="headerlink" title="无法搜到的Preview Package的URL"></a>无法搜到的Preview Package的URL</h1><p>com.ptc.vuforia.engine<br>com.unity.2d.entities<br>com.unity.ai.planner<br>com.unity.aovrecorder<br>com.unity.assetbundlebrowser<br>com.unity.assetgraph<br>com.unity.barracuda<br>com.unity.barracuda.burst<br>com.unity.build-report-inspector<br>com.unity.cloud.userreporting<br>com.unity.collections<br>com.unity.connect.share<br>com.unity.dots.editor<br>com.unity.entities<br>com.unity.film-tv.toolbox<br>com.unity.google.resonance.audio<br>com.unity.immediate-window<br>com.unity.mathematics<br>com.unity.meshsync<br>com.unity.multiplayer-hlapi<br>com.unity.package-manager-doctools<br>com.unity.package-manager-ui<br>com.unity.package-validation-suite<br>com.unity.physics<br>com.unity.platforms<br>com.unity.platforms.android<br>com.unity.platforms.linux<br>com.unity.platforms.macos<br>com.unity.platforms.web<br>com.unity.platforms.windows<br>com.unity.playablegraph-visualizer<br>com.unity.render-pipelines.lightweight<br>com.unity.rendering.hybrid<br>com.unity.renderstreaming<br>com.unity.scene-template<br>com.unity.simulation.client<br>com.unity.simulation.core<br>com.unity.simulation.capture<br>com.unity.simulation.games<br>com.unity.standardevents<br>com.unity.streaming-image-sequence<br>com.unity.test-framework.performance<br>com.unity.tiny.all<br>com.unity.transport<br>com.unity.upm.develop<br>com.unity.vectorgraphics<br>com.unity.webrtc<br>com.unity.xr.googlevr.android<br>com.unity.xr.googlevr.ios<br>com.unity.xr.legacyinputhelpers<br>com.unity.xr.oculus.android<br>com.unity.xr.oculus.standalone<br>com.unity.xr.openvr.standalone<br>com.unity.xr.arsubsystems<br>com.unity.xr.interactionsubsystems<br>com.unity.xr.windowsmr.metro  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;笔者最近准备学习Unity官方的ECS，笔者才刚开始学习，这里就先不卖弄了，笔者写这篇博客的主要目的是为了分享如何安装官方ECS。  &lt;/p</summary>
      
    
    
    
    <category term="UnityECS" scheme="http://yoursite.com/categories/UnityECS/"/>
    
    
    <category term="ECS" scheme="http://yoursite.com/tags/ECS/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——序列化AnimationCurve</title>
    <link href="http://yoursite.com/2022/01/25/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%BA%8F%E5%88%97%E5%8C%96AnimationCurve/"/>
    <id>http://yoursite.com/2022/01/25/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%BA%8F%E5%88%97%E5%8C%96AnimationCurve/</id>
    <published>2022-01-24T16:18:28.000Z</published>
    <updated>2022-01-27T06:26:58.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者在开发一个地图编辑器的过程中，需要配置一个摄像机的移动速度，这个时候策划提了一个需求，他希望能够通过设置曲线的方式来设置摄像机的移动，于是笔者便想到了unity编辑器自带的AnimationCurve就可以获得运动曲线，但是这里有个问题，我们编辑器配置后是需要保存下来的，笔者选择了利用json保存，但是json是没有办法序列化一个AnimationCurve对象的，json序列化是有规则的，这里就不介绍了。没有办法序列化我们需要的对象我们应该怎么办呢？  </p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>我们没有办法序列化我们需要的AnimationCurve，但是我们知道AnimationCurve是由很多个keyframe组成的，我们只需要保留下来keyframe，每次保存的时候只保存keeyfram数组，然后加载的时候通过添加保存的keyframe既可以生成我们需要的AnimationCurve了。<br>当笔者想去保存keyframe的时候，通过rider编辑器可以看到keyframe的类似源码，里面的字段都是私有的，依旧没有办法序列化，这个时候我们可以换一种方式，那就是自定义一个新的keyframe，然后通过自己的keyframe去生成需要的keyframe就可以了。<br>话不多说，直接上代码：<br>通过查看keyframe的源码，我们可以摘取我们需要的数据，然后自定义类即可。（这里定义struct，打包的时候序列化会出错，具体原因还未查明）  </p><pre><code>public class LBSerializeAnimCurveKeyFrame&#123;    #region 字段    public float m_Time;    public float m_Value;    public float m_InTangent;    public float m_OutTangent;    public int m_TangentMode;    public int m_WeightedMode;    public float m_InWeight;    public float m_OutWeight;    #endregion        #region 属性        #endregion        #region 方法        public LBSerializeAnimCurveKeyFrame(        float time,        float value,        float inTangent,        float outTangent,        float inWeight,        float outWeight)    &#123;        this.m_Time = time;        this.m_Value = value;        this.m_InTangent = inTangent;        this.m_OutTangent = outTangent;        this.m_WeightedMode = 3;        this.m_InWeight = inWeight;        this.m_OutWeight = outWeight;        this.m_TangentMode = 0;    &#125;    public static implicit operator LBSerializeAnimCurveKeyFrame(Keyframe keyframe)    &#123;        return new LBSerializeAnimCurveKeyFrame(keyframe);    &#125;        public static implicit operator Keyframe(LBSerializeAnimCurveKeyFrame keyframe)    &#123;        return new Keyframe(keyframe.m_Time, keyframe.m_Value, keyframe.m_InTangent, keyframe.m_OutTangent,            keyframe.m_InWeight, keyframe.m_OutWeight);    &#125;        #endregion&#125;</code></pre><p>上面就是笔者自己定义的keyframe，然后我们只需要在我们需要序列化的类添加上即可，示例如下：<br>首先查看我们需要序列化的数据应该怎么设计：  </p><pre><code>public class SerializeAnimationCurveData&#123;    #region 字段        public List&lt;LBSerializeAnimCurveKeyFrame&gt; m_AnimCurveKeyFrameList;        [IgnoreDataMember]    public AnimationCurve AnimCurve    &#123;        get        &#123;            Keyframe[] keyframeArray;            if (m_AnimCurveKeyFrameList != null)            &#123;                keyframeArray = new Keyframe[m_AnimCurveKeyFrameList.Count];                for (int i = 0; i &lt; m_AnimCurveKeyFrameList.Count; i++)                &#123;                    keyframeArray[i] = m_AnimCurveKeyFrameList[i];                &#125;            &#125;            else            &#123;                keyframeArray = AnimationCurve.Linear(0f, 0f, 1f, 1f).keys;            &#125;            return new AnimationCurve(keyframeArray);        &#125;        set        &#123;            m_AnimCurveKeyFrameList.Clear();            foreach (var keyframe in value.keys)            &#123;                m_AnimCurveKeyFrameList.Add(keyframe);            &#125;        &#125;    &#125;    #endregion    #region 方法    public SerializeAnimationCurveData()    &#123;        AnimCurve = AnimationCurve.Linear(0, 0, 1, 1);        m_AnimCurveKeyFrameList = new List&lt;LBSerializeAnimCurveKeyFrame&gt;();        foreach (var keyframe in AnimCurve.keys)        &#123;            m_AnimCurveKeyFrameList.Add(keyframe);        &#125;    &#125;    #endregion&#125;</code></pre><p>接着我们看一下如何编辑器上设置，笔者是在自定义的窗口上绘制的，其他面板也是类似：  </p><pre><code>private SerializeAnimationCurveData m_SerAnimCurveData;private void Awake()&#123;    m_SerAnimCurveData = new SerializeAnimationCurveData();&#125;private void OnGUI()&#123;    EditorGUILayout.BeginVertical(GUILayout.Width(400f));    &#123;        m_SerAnimCurveData.AnimCurve =            EditorGUILayout.CurveField(LBEditorLNG.SerAnimCurveTitle, m_SerAnimCurveData.AnimCurve);    &#125;    EditorGUILayout.EndVertical();&#125;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当我们想序列化一个字段的时候，如果字段不可以序列化，我们可以通过保留组成的数据，然后在反序列化的时候通过保留下来的数据重新组成我们需要的字段。如果字段也是封装好的私有字段，我们只需要自己重新设计一个类，用来保留这些字段。当我们需要一个成品的时候，如果我们没有办法保留成品，我们可以拆分这些，这样使用的时候重新组成就行了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;笔者在开发一个地图编辑器的过程中，需要配置一个摄像机的移动速度，这个时候策划提了一个需求，他希望能够通过设置曲线的方式来设置摄像机的移动，于</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="JSON" scheme="http://yoursite.com/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——基于UGUI的UI拖拽监听</title>
    <link href="http://yoursite.com/2022/01/13/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EUGUI%E7%9A%84UI%E6%8B%96%E6%8B%BD%E7%9B%91%E5%90%AC/"/>
    <id>http://yoursite.com/2022/01/13/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8EUGUI%E7%9A%84UI%E6%8B%96%E6%8B%BD%E7%9B%91%E5%90%AC/</id>
    <published>2022-01-13T15:46:06.000Z</published>
    <updated>2022-01-14T01:57:54.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果一个UI的面板想监听拖拽事件通常会有两种方式：  </p><blockquote><ol><li>继承IBeginDragHandler，IDragHandler，IEndDragHandler接口，然后实现自己需要的逻辑。（此方法需要脚本继承MonoBehaviour）  </li><li>监听Input的输入，通过判断按下和按住来实现自己拖拽的逻辑。  </li></ol></blockquote><p>已经有写好的放发笔者为什么还要写这边文章呢，是因为笔者目前参与的项目中的UI框架，面板的脚本都不是继承MonoBeehaviour的，都是通过统一管理的，这样的方式的好处就是UI的初始化和Update的一些都可以自己控制。面板的View都是通过绑定的方式进行操作的，了解框架的应该都知道，这样的好处有很多，这里就不过多介绍了。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>如果一个UI面板是通过绑定的方式进行的，没有继承MonoBehaviour，有不想在Update里写大量的逻辑，我们想见监听一个UI的拖拽应该怎么操作呢。  </p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>我们只需要自己写一个继承MonoBehaviour的脚本，然后脚本继承这些接口，在脚本里添加拖拽需要的一些参数，然后脚本里添加我们需要注册的委托就可以了，我们的面板脚本可以绑定面板的UI，我们只需要通过UI物体获取我们需要的拖拽脚本组件，然后注册我们需要的一些委托就可以了。脚本如下：  </p><pre><code>using System;using UnityEngine;using UnityEngine.EventSystems;public class UDragEvent : MonoBehaviour,IBeginDragHandler,IDragHandler,IEndDragHandler&#123;    private bool m_IsDraging;    public bool IsDraging    &#123;        get =&gt; m_IsDraging;        private set =&gt; m_IsDraging = value;    &#125;    public Action&lt;PointerEventData&gt; OnBeginDragEvent;    public Action&lt;PointerEventData&gt; OnDragEvent;    public Action&lt;PointerEventData&gt; OnEndDragEvent;    public void OnBeginDrag(PointerEventData eventData)    &#123;        OnBeginDragEvent?.Invoke(eventData);        m_IsDraging = true;    &#125;    public void OnDrag(PointerEventData eventData)    &#123;        OnDragEvent?.Invoke(eventData);    &#125;    public void OnEndDrag(PointerEventData eventData)    &#123;        OnEndDragEvent?.Invoke(eventData);        m_IsDraging = false;    &#125;&#125;</code></pre><p>上述脚本非常简单，只是把一些接口转换成了委托，然后在需要监听拖拽的组件上放上挂上这个脚本，在面板的控制脚本里获取这个脚本，然后绑定上对应的委托就可以使用了。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当我们使用一个接口或者方法的时候，如果我们没有办法直接调用，我们不仅仅只考虑找和它相同功能的方法替换掉，我们还可以通过转换的方式，间接的使用我们需要的。笔者就是通过委托的方式简介的使用了拖拽的接口。不仅仅是拖拽，很多接口我们都可以这样间接使用。也不仅仅是接口，很多开发者遇到的阻挡，我们不应该考虑换路，我们也要考虑能不能跨过阻挡或者绕过阻挡。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;如果一个UI的面板想监听拖拽事件通常会有两种方式：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;继承IBeginDragHand</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="UGUI" scheme="http://yoursite.com/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——自定义创建模板脚本</title>
    <link href="http://yoursite.com/2022/01/13/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%9B%E5%BB%BA%E6%A8%A1%E6%9D%BF%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2022/01/13/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%9B%E5%BB%BA%E6%A8%A1%E6%9D%BF%E8%84%9A%E6%9C%AC/</id>
    <published>2022-01-13T06:33:29.000Z</published>
    <updated>2022-01-18T09:39:48.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>相信大多数Unity开发人员在创建脚本的时候，经常会修改自从生成的脚本内容，比如去掉继承的MonoBehavior,添加命名空间，或者继承固定的接口、类等。这样重复的工作看似花费不了多少时间，但是如果每次创建都需要修改，还是有点麻烦的，所以如果我们能按照我们自定一的模板脚本去创建脚本就可以了。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者在团队开发中发现，每次创建UI的脚本的时候都需要固定修改继承，和添加一些标签等，这些重复性的工作笔者想了想可不可按照自定义的模板创建脚本。笔者发现unity自带的在unity安装目录下创建模板脚本有很大的缺点，只能创建C#脚本，并且只可以自己使用，并不可以上传到项目的库进行团队使用，于是笔者参考网上的一些文章写了下面的解决方案。  </p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>首先我们在创建一个Editor Default Resources目录，这个目录是提供为编辑器模式使用的资源路径，加载此目录的资源文件代码如下：<br><strong>EditorGUIUtility.Load(filePath)</strong><br>加载后通过as转换成需要的类型就可以了<br>笔者模板文件存放的目录如下：<br>—Assets<br>——Editor Default Resources<br>———CustomScriptTemplate<br>————C# Script-NewNoMonoBehaviourScript.text  </p><p>模板文件的内容如下：  </p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;namespace #NAMESPACE#&#123;    public class #SCRIPTNAME#    &#123;        #region 字段                #endregion                #region 属性                #endregion                #region 方法                                #endregion    &#125;&#125;</code></pre><h2 id="在选中的目录里创建模板脚本"><a href="#在选中的目录里创建模板脚本" class="headerlink" title="在选中的目录里创建模板脚本"></a>在选中的目录里创建模板脚本</h2><p>制作的原理就是通过读取模板文件的内容，然后将内容写入新的脚本中，监听编辑结束后替换新模板中的固定字符串就可以了。<br>直接上代码：  </p><pre><code>using System.Text;using System.Text.RegularExpressions;using UnityEditor;using UnityEditor.Compilation;using UnityEditor.ProjectWindowCallback;using UnityEngine;public static class CreatNewCShapScript&#123;        /// &lt;summary&gt;        /// 创建不继承MonoBehaviour脚本        /// &lt;/summary&gt;        [MenuItem(&quot;Assets/Create/C# Scripts Menu/C# NoMonoBehaviourScript&quot;, false,81)]        public static void CreatNoMonoBehaviourScript()        &#123;            //参数为传递给CreateEventCSScriptAsset类action方法的参数            ProjectWindowUtil.StartNameEditingIfProjectWindowExists(0,                ScriptableObject.CreateInstance&lt;CreateNewCShapScriptAsset&gt;(),                GetSelectPathOrFallback() + &quot;/NewNoMonoBehaviourScript.cs&quot;, null,                &quot;CustomScriptTemplate/C# Script-NewNoMonoBehaviourScript.txt&quot;);        &#125;        /// &lt;summary&gt;        /// 取得要创建文件的路径        /// &lt;/summary&gt;        /// &lt;returns&gt;&lt;/returns&gt;        public static string GetSelectPathOrFallback()        &#123;            string path = &quot;Assets&quot;;            //遍历选中的资源以获得路径            //Selection.GetFiltered是过滤选择文件或文件夹下的物体，assets表示只返回选择对象本身            foreach (UnityEngine.Object obj in Selection.GetFiltered(typeof(UnityEngine.Object), SelectionMode.Assets))            &#123;                path = AssetDatabase.GetAssetPath(obj);                if (!string.IsNullOrEmpty(path) &amp;&amp; File.Exists(path))                &#123;                    path = Path.GetDirectoryName(path);                    break;                &#125;            &#125;            return path;        &#125;        /// &lt;summary&gt;        /// 创建脚本文件的委托类        /// &lt;/summary&gt;        class CreateNewCShapScriptAsset : EndNameEditAction        &#123;            public override void Action(int instanceId, string pathName, string resourceFile)            &#123;                UnityEngine.Object obj = CreateScriptAssetFromTemplate(pathName, resourceFile);                         //创建资源                ProjectWindowUtil.ShowCreatedAsset(obj);                                                                //高亮显示资源            &#125;                        internal static UnityEngine.Object CreateScriptAssetFromTemplate(string pathName, string resourceFile)            &#123;                string fullPath = Path.GetFullPath(pathName);                                                           //获取要创建资源的绝对路径                string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(pathName);                           //获取文件名，不含扩展名                var textAsset = EditorGUIUtility.Load(resourceFile) as TextAsset;                string resourceFileText = textAsset.text;                resourceFileText = Regex.Replace(resourceFileText, &quot;#NAMESPACE#&quot;,                    CompilationPipeline.GetAssemblyRootNamespaceFromScriptPath(pathName));                resourceFileText = Regex.Replace(resourceFileText, &quot;#SCRIPTNAME#&quot;, fileNameWithoutExtension);              //将模板类中的类名替换成你创建的文件名                bool encoderShouldEmitUTF8Identifier = true;                                                            //参数指定是否提供 Unicode 字节顺序标记                bool throwOnInvalidBytes = false;                                                                       //是否在检测到无效的编码时引发异常                UTF8Encoding encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier, throwOnInvalidBytes);                bool append = false;                StreamWriter streamWriter = new StreamWriter(fullPath, append, encoding);                               //写入文件                streamWriter.Write(resourceFileText);                streamWriter.Close();                AssetDatabase.ImportAsset(pathName);                                                                    //刷新资源管理器                AssetDatabase.Refresh();                return AssetDatabase.LoadAssetAtPath(pathName, typeof(UnityEngine.Object));            &#125;        &#125;&#125;</code></pre><p>此代码有一个比较重要的一点就是获取文件所在的程序集的命名空间名字，因为要自动添加命名空间，最后找到了对应的API，通过**CompilationPipeline.GetAssemblyRootNamespaceFromScriptPath(pathName)**获取地址路径下的命名空间名字，然后动态替换就可以了。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;相信大多数Unity开发人员在创建脚本的时候，经常会修改自从生成的脚本内容，比如去掉继承的MonoBehavior,添加命名空间，或者继承固</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Unity工具" scheme="http://yoursite.com/tags/Unity%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Unity游戏开发知识点整理</title>
    <link href="http://yoursite.com/2022/01/12/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2022/01/12/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</id>
    <published>2022-01-12T12:23:29.000Z</published>
    <updated>2022-03-10T09:21:00.185Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="b31de94b1b8ad2dfcf914293b4e9b1ff6a3c9b7c7c6a0a512e32663b79f2f41e">2521a7807bde158c25736a82631336cef69c8023285301a3fbc36dfb98f6e317c9ac81c4d12edc8947dcaf8a0861a8948c1801f937c078349c26b44a4a8fc585f88e9b911e5ffe98e4c7f9fdd9db222ae42632ebcf17f27ad48bcdbcc168d62b44e4aa373d5c24a839a3c0b319a63a5c182a88b811178548b0323f67228629e8c978bed10d73398b17c41064f9b6c6b9c4a8e92bbf93b54102424c20a36908de17235eddb55912cd10dbe5b4f4fc656c45f4c077f0f23f660968530007a6c6fbfbcdff10375bdffd4321b5b82773bcd088f7a1c51e06d244212df83f4e2fa546ff493f5e44d4c75888c14742d5570e8e4277ef8915d02f74abcd84e16acfc24822e91881090fce77477bea1fa43493eb058c5de05e45e54d89275c297d3633bbda9813e4cb1ec72e59ec04b79a4bd604967ff4f5d7c92efa492f4bf5cc5c15e20b15ea904d22c5f083f3cc59fa46268420092fb77ce4ee7bba66bcc83a746b6c804ee413d84d822db9a22facd3538179d30a4ffeec47b94ea4cfe3f7eba065c685e4f98b48ea411e84e289d0f8dd28511bfbcd46566226414f81c1ec5a225a1e3d95853103a6e958a587ba5a9326fa27a1e38bae31fc14deab24639cbce5d3f369b444aa55927f2969ec552de62824cf0caef81e11f8266bbd9d60846fe5e17aaeb3c4cbdcef4939661409abff0658a92cbaa0261f835790653d8d88fcff6e95cfff50df65694559fee34c94a5ac2d1f4167f77a829dbf7e26d227e00f6b5acaaa64ed8d27e281ed718f75b49ee1e3ade9fa64b2ed6dbfcb867a3e924e897438c221380e732232bc85e1600d771725f919c13b71132b96838f8cedcda8613760af5bcedf047bf052d2cfb212014f7ab112811f0dc04d2bdd718710aa8923e4b7d095d85ffa6b4ac60477ec26f99ad8eae42f6f684252f59b780d870f2c9e5e8132b4fe401c75d88a549d6a268727784eb4ecb729c03b057df4c68a73c89681edcd0ecbc1e5c483365dc361958efb0175a4b916b4434038c606c50d40e3798f53b72a0f90a1e58a4c88edf7832064ed063b6331de873ec5d591ef1dd933b2a3a08a44433ce5d8a5619d5b38d892b8a7dfd4ddb526bfc60a61d2c673e130ebcc49b37f8dc014bd6efd66b05aa1220201178c80ace74f0d2913ccf28455ff63b918c97ff2ec632d957490912e08ae29ca1b741cc34a75b52ad655ce1ef31d7400271feb69eb538ad782a1dbb7272737adf16bc3c706f05e2d8c680c1199f1a1d770d73967959ad696232cf1cd685b90f8f07b94ec3f0e2cc1fb0865806f1a5e05817fc480b6832ccbff394d5615f194d36e81610cdf417b6e3cfba49555e41fae7b1220df3bc191c6e6347f6131049a8acf811a6d94cfaa8f4b3e9dab1b8d1fabf2b85bd1c3ae8e37454da6bf6dea061f65aa330877dfacad126910b286833835ebd759e77b1dfbbb3f9354af910187c2672ad8e211dc9fa17d2bb3ebfe94114154eb2370488235637dd9892f3a924cf6370be836d34b11d5c28a30aa616fddca438a208980bdcdbcf225ca13b76c1405a175914c770efb31a0b31c5e2852fed7cc8778fc0e10ff0c26e66057fc41b82820f69f391488047b969f377689d2feb04c4d1e32a46eeb93a660a1ee4988ef1917864e7a150d90f6435129ea313801c9d25f842a3f75aa8e2a3c7b4a02bc25f9b280347c1badee42de2d3614b801395112e6b100cd4dc0e6805a831b946794c4c13a65ae41d4a3166a1c75edf9880cd9957987a21c2d63906bb2e68adf66916b82b2ad13065a4d536623bfcbf05de8027c344aca1e907ba6df1f8773098346e00971cc55f5c05ecab515c377adee4dd3c74d07746c983c115daa1c5114fedfe9f9d777b2b26e4f32e0f288f6ee2fabaee3862901c0bcc5fbdec349872b2a002c99bc49ffbce6bde484b50e95d5cf8b803f358021e2ee1649f87abcb7b059a99581871e6a77c913b70e6da146d2e15cd90bc8c7ae1c3d80dcb07338e116e5097600d63c9a9c64a0360ed5f0a3c6ed97c1589050eea8fd4d20d4b50aee246682e08d049764355b3e85dd4ddaae425664c76826bd726eb99537fe3f8e968895f69613faa68a837eeb4153792974a6be68993f8ef2b14b7a904d66bedfbb6aaf09e443e9d339cfa7bf289585b3e5b10d37056d1525233b7212024b1e94a58a9cef49bce875f4b6e70121106065047ad895eba32a0807fc52205fab52ec0e419f5416874255c99163620874aba27764c2f27b50fceed97bf7d5486cd88ed2e8dcadd9fc35bd00e7be5276e70be83479e1246911f386779ab8e7868b37c140fe86d9f74380dbe35b4e32b88016f3338603b5c45fdec8c82f634bf5f09c8b63631e37bb7fc54a9fbb162b9083d7b9decda441cf19ab76b27a87a17a913a513b19c3e7d664e145c12ab6fe80aad77054acd6d3f4507969017819b9e541cc67d3674bf33a2378b958b5df6efbfa8664d33bd35d082d0f982ac4026cf064d848a5d6b1c09a3890c9ecb2e4a069aaad60a82709305d84cebd882874920cc622333188f6717f30d5e853774b464a8367475507ed313eefd896e2f716dba67437c608928f29eedb79303aab811442920950ff496040cfa94c39bd44f9e491841b19fd48e6610fceed602840bcbed884ef88389b752be74dc41cf1ca44544dc1e0283fc143235b9dababb6e873dee6c991d59c032c6ac1b39b139bce2f75ab36dfe6894ee4e26092f8ba0ca3a1f9de21c9501aed5c37ce89c9d2bddd865af03c39694810de43be6476be3665af392bab514e6ec1ec346a8cad1dad8f80d3e0bda1b9c1fec09dcf5c15b49a993a1c4eea5af61d05fc192b805ba2a17495703470f3cbce5001ff72be3d3a8da9a4e06758ce15e544eb7b202631a769ea7a3479440d515acb2e559dd8b6829b4d4a13128db01d0ac20fc85b48083781f1fb2429693bc4830497462277832bb67176a5f204fb2831308ca19e33c6a9fcb66cb50aa177fcf5b1191b11b4a85b5e0a1051a313e623aa631bc4d84e4a61088ac22b1b97fc2d1e120767b06f7c378edf48184d6f3db86eb3aa308c1f2790463ef05f3b457b444c0513034aa50bc2417cd04d2c50494a35cdfd7ddee0d4c4ea4bb962738ac045064eb69398b599e6887bad6e0be05484946a08ddcce5b8c321b91b6740306390ba31e5320a6357fe4b11a0925cf3e25fd4858096dde022ed8e272ceeb8056ce4b11d43694ea662feda4eaf2a065af25b9ac8d6905cd424b0614b9467431dac304ecbd4a54defa680a0eb78e4f26d86ba87bc130141adf57ee576ad02a89327bed75f17cb8f2c9068d5cfc64713e3544e2ed0767d4c3e33249a005ac5b3df9fbe8372bf8a8366a8d22f2c58dd519df8fd7d9d3ec502bacea4eb509be81156bb3531a91c5d3a995c3f56874c5c787940b6d826c429380f608d65a47f0cc290ed44d2bf3e4a434f5b04f9848f4534150ecf7de64528f2c53ebe86dc282b4ec0f45c926338b3f8b66b8d14a8b7763aa1894c43dccdf90011fc868be864dbc72f8ddb04a8ba2200273fa161684845c140bece7e79697239f0c67200740622e039f2b89a34be3d657f391bd5ecbda4b48844fbfa3e715ba8a66ed5a1a11e8dafba36944741ace0db2247ed4970f5f359919273ff19160bbea6b5344bb717038334c54da9e26cd3b56ffd01a003a0d74e4ae2ffd6918c5a23ad27f0805cc219f534a3af7705d45d3479f2aa0fc62d470083f65444977cf6e411d0e76df19f962f54e7dee752ee99ea6ae1dbfa2de786251c4a1323ebec68618b9cd118ac7cf9ec626d9989fefc75a4b9faaed8a3817e2d4f81277a0293b9437df06364cdae9e84904ebe75cdee65abc96ccec9ee76c6e5ac0943e360afe84712c8ca46aaa64ffd9cac733037cc46ddef976e182748fdd1d10bdbf90bd835f8c43ba6887e4ecbaa09884e879abe42ff56c7b81993cbaddd87d34a8c9c3ffe9784db00a4b7c02624d8b1903f7950f672b33b2b14e741da7a72aee7a1ba481e684ec6607ed81590a84ff827309277b75ab077d12b72bd5eb7004c5d4e6bceb4660af156cc4cc0ed1befe48cf48e687483628a0150dc04c66c43991964fdda00ba9e2becef3dcc1f777685a1bd38de24d8b3a4c7317e5831e2de4a5fdeaf5d617937b883f4c308b6d4eeb9fb867d0c52941b17c1857ce9305cad0968283c057132b59348b241cafc64d70cb56bea7cd6a1d067cbd396afde82e36a8d16735fb98dc3a5a10980678b464dd9fbff6c6d554a3a0826cb272d349b920d27caad48c4e23f977b35e32fa6a6c8b5a840960ac9427b74f9f969461a7f1ceab64bc817d37087ae82259bfa69c1f416ff24b20307496e9135654c6f83fd5fd1ba96bb23aba10623bdb190de3d3d99c6efb4f85363d117c49f4a85a9c0d53d3992d41d0ecf1ed83426161a81483ba622761348c4525351ba6b786cb144b450368c1af54ac9ce3f3bd3ccace525b6c7fc1282c5df225060a930c7f3e1c17f4d44da52e21ce010f709578d33cfbf7a2c579f3e7cb6316ffa958005bcb6252ef4380851dc492b0e626af30ec2c1cf502b92ead8c411c9fb6f6604442a9f1e85f8181a334b81a73202b4d563f9c257689b1f4d2782fad1d56620111b68ed8c29f62122ee8ab7743bea3fb6f1c84a05e82ce623c7387fe6ad91196dde96a1320e9fc2c709d151fb8fc39e1b2445a368be3425dbf020b0c24646f1de34815083539a5d7f2c16342e0e32088db327781b28df04ccbc9dc25df6a1c22498d2e4079530bc71c9e7ca8a8945abdbbf30e440afac2f51a218f587fc6b55355d0988bd069f9053caea90ba31356655db67e8e8296754e4a1435c8a9919008c4a9fc2345dd4d55c15292e9e5098124f12f39f67d811dd4a4f5370c15114341c1171c9d34fa42a54b290f8a83c51d5c9d9d1b403710bf72f9788bc7a1c6b7de61a979b97a3398f804bdde97e01db339a220e7d0fe5cd006ec648c1bf65e35b53334a2b0b20d68c29e5f3b58dbef987f7d8e4da323bd00f1ed6caaa77bb13e9053ac6d60996a1f6fd4d61f6e35afe65073b8f789496cefabd14850171d1b17ec7cf3cce0a7d6817ac4637a51519768522b9cd928d5c28a5aca4501041bc20668b7f5f0d7b28cd57df9f487ca8ff9991a1ac9e435f08876f30214a1577710b96fdc14bb70d3494256f99f4cd471ba80d500da00cf5493b86002a599e273c55d8ea3c29abc422f983595f61b2a58fbe460e74562c40604fe79e070449ea1113d92a174c27365325dc4a5471ce403e9ce77da44ba3c292b638696c9d1318b3c0da184b8d6244ad92871a3b5eb05c82896d5466d1df756f78d7c21dd2250e8f67d8054be1ebd0a7971df814a1953afd0b98c81e15b2cf2ffdf432595c0a82e521091a5b4c05d50104c41bde5d47b05a4fc766d13471aa4390bc69fa3462c6af46ba3db6415d4009259772ede515497dc40bbf846ebdffc06ee5ed95767ddc280da1aaf2ba7582f90c5e1deeeec41705687bea1864780d075b154fe3af9afb092ff02d134009d4c19db279323b1ba72841b3627502e126757cca99398affbb0ec6ef9e388ee679e3dc60b5fcece355edc98b4c18ce73f2bc7b36487652ce6dc56274f3448681fbb2882fffff1caa9d434f79c537624109aa5c208ee990a26016e879c181644279ac8332b44ab453d7fec00f7bc34fd76e56b6342e7fad0fd7c2f1e605e618887291925f8ae7ecbe1c278c5f41058c5e84b3e2158f2d143c88c1fb687099211b420ba2310566398d0fc8ad11fe07d7806301f172d0d06510dbc44bfca6adad823d4b5a2e8b20a6dd2c0bfdae7ebbc44e58c9d0428bcfdc2d1c5dbcdb49302eb35f1f26f6cf2055e0c0b80f2007dc3251d1aab4c607ba53bfbfa25aca8fa7cbf224022c93aec292ef3fb701e0eb5a2cabbbd9bbeba9203e3e4145d8b596d07df3ddd9e610e05a920f0880f8c1bab0b2d4cd40f713bf6185e7bc7ab3a755225b2d77dfeacb4dbcc3cd80011659abedf4231b8b1c854044f468ee6164dc795409d4a55aff97fec7162d78f13a10c442feed9acd0e80371b742745ce7d6387627021ebd1d4a40237a0b6652252da0bbd6547b30bdb49f48671cd2b7398cde8853b19f86a303b58781599f25a2e8785b688e8b80e4f3a971cd6676a60ab177de3602de9df234bd36b425b57a88333ddcd2bd9e23d8925b428e1891445f2e78a44314c8aa1a4a4f111e461e0ff80c2ffb8449f3a0ef3ce3a0bb53d62c739f6567e663639f9f65aac8b67f578bcc71eb6ab7fca1936565f084af0aec4812c5ab4de4ee66044d162ae42ade6a9bb564b838f306d395de14b5ceafd3def1f88300569c07359f908d25f9191216e91868d1e3183a4bf1539657d1200af38f4cbf003671a5dd707cddc5d24d1d45012abfc2dcc947cca3bdbb92b3f6b18dbcf4d3c00a8fcac0d4472840de6ef91c99d020c65f5dbd31c9c1d427ed7e9f11b33814da925d4aaef3a6c6e2398000500cc8315e22429b7750ef2fc6ea74d3df0ea4830167ac1bf3f05b71eeeea86c5ac4b0246c338e8a76fb33ac30ab1ca0fb6f1f197793e73d5e7b5636d90b48faf6185e801b2c7372366652af569781adf4301b98c5bef7e3951bbe332ae86e7260f1e1383b744296ef67734fd07232403bd18c350ef3478d9cfed71c2de01824bf73c2c2578ec76029b741aec7caa4e4ac42a924c758365a736a9653e1788537cc30abcad849e2a1e197fc171727604d9dee8af0737c6a769a383902d2d2ca9d4fc01ebb021c0076b10bfd92443ec7f05898ff272f1370550d2823840200b35154974b3dcd0cdb7075cde19dcd6b96330c1069222b6f1780346e410e147b2a0f05c1fea3cc754c88763a8e267103a6fdd2cd23aceb82ff85e0bc41774763c1fa2cad15ce9750afbba76f7d3a774fd065052c009e2c17211ef3094bb4c7045ff9c1f4200861c7011110ed361a4f17806db1b01a4b15bc026fe9327b3cd251e25fd8cd51374734a04f8cdcd0521930f576d5e429098a8ed67ef2375604feab36e654702a9d82a84074588d4ccd3ae7f38c2ccc8985e7fe72f577d1bb00379fb9de593571373770451f640ed8e4ac57c62ee391ac1c4f1e2d7444051d5fab49dce51f910ec34802a93c0b1b60e1c39776a86bf26ee2ce4658876f8d7c8df1b889facca01978ad2f115bfcb977c1011e0640fe92441194c35f8ea2e46137cf9d070581e31e80f578af0a13c3ee50f141d6abc49f64567ae01fab5efdfeb68acd1ffdb40e0f8d23fe1fd41a359c1399caab48a33d1f94d40377a9037eabb672d9e3ea130e03c3cd57d5802398e79e9bc8cdaf026adb06ed5b2efb2834ee9c8ee4966a23a42557f62d23c5808255cfd74aed047285d85acffad6897bb0a0b1745a603f22c556a89caaa63b724595deeec99274d72364ec863b023a84f3fa547daa213f6da12c2730bbe031edcb4ba12f337b9d2484a8ae8bbe31148ff1413cdb3e6cb03a28b7fb05fc789ff05ff5cb8f115ae773cfb99036bb4fb6bba9589d3e553f97715ccf4924ad5cefba91b80aa34bb416d8da7de15a02b8a7964b378d8d61dd03fbecad00cc4c96956ac462bb21d7dce3b46bb06dfcd337116e9d322bb2f401260ff113a3fba74eafb41d951a9791610295f9f159f00bb924cd3097666927f5ebc03382565a0ace5ce62064a87fd2969269e3cd9ade9610061897c29d7de4b015ccfdc3ad95315c673588c73fd2a041966573f3fd0e1dd6ca2f4258d0e32cccfb63753cda52f6841565c60931d1e56539d7b18565e1c0a899e35d27928c47d188cea2f608138caab01b4a4f0e8c0855f5b79448b1b0fde110d93e116878e4015e0059b1a2494c2f412c24ca254828b29525b0cf397ae43b0a6121384dfc08f1e286f215b6746451dd69f65a0fcc2f4b943ba9d53a23bde9b347cabb88c735ced8792c5e484537900eda2e9def81fb506110fe3e94c7cbe6fffc55c80ddd55095576683dc88ebc93ba761219065d891451c985bd4b157a6cce1b38bb16512cdac23b48c4ca56968faa6184f544e646bc7ea0fc2120b2096820075201f22ade6ed3929484b81ca767c45daebe4679d323c1630a679180cbe7a3493c5267060e4d582b34954c60b5ed5528d31a159edfe45681806a48f8a79fd0e2ae43e4d070069654e7d8a2758856f46bf86af9687a0629b1de416da7b9fb0b5781c5496c74ce9de865f2d48e7150415c5277b4ce8ef26a002365acbae686c9698776518a8302b033dc413c8a90005509fbc44f6efdcdd3ea229d0ae75ae56908fc781bcaf39399ab6977475b2c1460d93a6d42994309c9500ea9e1b30b0805b4933094d26b8aa469b728f47a9bc374fcb169b7d153964e5fbe20d69fc0163a446aa6b8c9b5effba1d96937db7cc18292ff19d3badfadfbc38975ccc147a0d8fd3e4605a3780a3a54661820921ad056b82a5b3a3acbee2e38519b0a23de4868d83bd2cb37113e9542ef92002260ce5aa3535b07610c0738d3d1afa20fe67408f8f419d586a64b3bb0656cffe2a00938590b9ef1672bb8136813383de3413cce173876e827957b854d806aea5116d2931af16be0cd15e5d43c26a3c8dd2266abed9b12548eea529af5e03293b440da41174a67f97c04128c8ed753a60c7c67925d12b2d906d648fd3c4eefe9a6ccd60cc1cc6568ad78645e08e751d8a249230a88a6af57c61ea430e6a7a222b397a0563659eecca080246f6c14252b32db6da8dd718ea63b9a07d5b1d9502cc5f76261e28d8d86ca2b15943fc059edf90b7a996c03aa089a6b45daf0d2b068fb337afb4fa7a388354dad800939ed52cb42ecce01844782d45eb24d8732632f0122325e99899ce0ad449360d54e99e11dd0ac4ef53d45a560f18851d20f061d26d99853a825fcc2e98e82eaaac755e57118574f279ac94a4b22258610dcb61a2df0e4b058ea5bec211c0d8da2caf682da56a0f36f14596f330631e6141a9c18fb688a0f47487185682998f761a2d7818bdb9974cbb3d360369dab5905fed6ddd244fc73aaefa8b47e18a8eaf5d1a2f5507f51fa344a85000fc222718d14cb91a0c43ca5d1cef6b0ae8bd004e8b84492e9ee54c50cb3e0f624c148cebafebba25715171fd74d655af3929538ae5ad428737ee4be8de8fc709c919db97a463baf08780664260c5dfc23a98aa82de4a8955b58d697a7a10c0807858719870618b45a078dc47552c14cef0ae7db2691546a3cd99ec00cb7c7494898e7a867666eb018d2be6d384999318c35e6a22bf8005127d03cacf9b313a25b6af4f547fb8bb0d02a0eb9386a954b84e2c8912575aaf892f3f043879209a8053e72af9ec8ae95923d11bf2f495c6ec4eb4b194f51d83f4d0c9ca142c0d77f28ee5d05cd521a91079ea99c3e2d018a343f0741f939207073e29f348fd513096f70e1a8eef323a92d67ecfd4a9d7059c7414b3e5a9c7bcf3d68f30212ba11cc49cf97764a73870e4b4503ebdf3b9654c08f517f3f5563b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这里有东西被加密了，需要输入密码查看哦。</summary>
    
    
    
    <category term="个人笔记" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="unity知识点" scheme="http://yoursite.com/tags/unity%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——扩展变量增加OnValueChange功能</title>
    <link href="http://yoursite.com/2022/01/07/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95%E5%8F%98%E9%87%8F%E5%A2%9E%E5%8A%A0OnValueChange%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2022/01/07/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95%E5%8F%98%E9%87%8F%E5%A2%9E%E5%8A%A0OnValueChange%E5%8A%9F%E8%83%BD/</id>
    <published>2022-01-07T06:00:09.000Z</published>
    <updated>2022-01-07T06:31:58.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔者参与的项目的UI框架并没有采用MVC结构，而是把MVC中的C去掉了，只使用了MV，把C的逻辑拆分了一下，分别分为M里的C和V里的C，分别写在了对应的M或者V里面，V是根据M里的数据变化从而进行变化的。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>C#自带的属性并没有数据变化响应的事件或者委托，笔者的UI结构是需要根据数据变化进行更新的，所以笔者希望属性能有一个类似于OnValueChange的功能。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="方法一（使用委托）"><a href="#方法一（使用委托）" class="headerlink" title="方法一（使用委托）"></a>方法一（使用委托）</h2><p>这种方式是自己增加一个变量的委托事，然后在属性的set方法里进行响应对应的委托，每次需要监听数据变化的时候注册一下对应的委托就可以了。<br>缺点：变量需要定义成委托，并且每个需要监听变化的变量都需要增加一个委托的变量。<br>代码如下：  </p><pre><code>public class ExtendProperty&#123;    private int m_Value;    public Action&lt;int, int&gt; OnValueChange;    public int Value    &#123;        get =&gt; m_Value;        set        &#123;            OnValueChange?.Invoke(m_Value, value);            m_Value = value;        &#125;    &#125;&#125;</code></pre><p>根据代码可以看出，如果是属性使用只需要两个变量，但是如果是字段使用就需要三个变量了。<br>使用方法如下：  </p><pre><code> void Start()&#123;    ExtendProperty property = new ExtendProperty();    property.Value = 10;    property.OnValueChange += OnValueChange;    property.Value = 20;&#125;private void OnValueChange(int arg1, int arg2)&#123;    Debug.Log(string.Format(&quot;&#123;0&#125;-&#123;1&#125;&quot;, arg1, arg2));&#125;</code></pre><h2 id="方法二（推荐）"><a href="#方法二（推荐）" class="headerlink" title="方法二（推荐）"></a>方法二（推荐）</h2><p>方法一的缺点很明显，如果是少数变量使用还可以，但是如果大量的变量都需要监听会比较麻烦，于是笔者就找到了另外的解决办法，笔者自定义一个类，然后变量都使用这个类定义，在类里面进行变量监听就可以了。<br>代码如下：  </p><pre><code>public class ExtendProperty&lt;T&gt;&#123;    private T m_Value;    public Action&lt;T, T&gt; OnValueChange;    public T Value    &#123;        get =&gt; m_Value;        set        &#123;            OnValueChange?.Invoke(m_Value, value);            m_Value = value;        &#125;    &#125;    public ExtendProperty(T value)    &#123;        m_Value = value;    &#125;        public ExtendProperty()    &#123;        m_Value = default;    &#125;        public static implicit operator T(ExtendProperty&lt;T&gt; vl)    &#123;        return vl.Value;    &#125;&#125;</code></pre><p>缺点：定义普通变量的时候都需要初始化，不会默认赋值，并且每次使用变量的时候都不是直接赋值，而是采用property.Value = value的方式赋值。<br>使用案例如下：  </p><pre><code>ExtendProperty&lt;int&gt; property = new ExtendProperty&lt;int&gt;(10);property.OnValueChange += OnValueChange;property.Value = 20;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>采用OnValue的方式是一种简单的响应式框架，类似于UniRx，笔者在使用方法二的时候一直在想办法解决如何让使用者使用的时候像普通变量一样赋值而不是采用.Value的方式赋值，奈何一直找不到能拿到赋值的左值的方法。第二种方式更像是把第一种方式整合成一个对象，从而减少代码量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;笔者参与的项目的UI框架并没有采用MVC结构，而是把MVC中的C去掉了，只使用了MV，把C的逻辑拆分了一下，分别分为M里的C和V里的C，分别</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="C#-Property" scheme="http://yoursite.com/tags/C-Property/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——解决Unity修改Prefab的参数不生效，无法保存</title>
    <link href="http://yoursite.com/2021/12/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3Unity%E4%BF%AE%E6%94%B9Prefab%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%8D%E7%94%9F%E6%95%88%EF%BC%8C%E6%97%A0%E6%B3%95%E4%BF%9D%E5%AD%98/"/>
    <id>http://yoursite.com/2021/12/30/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%A7%A3%E5%86%B3Unity%E4%BF%AE%E6%94%B9Prefab%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%8D%E7%94%9F%E6%95%88%EF%BC%8C%E6%97%A0%E6%B3%95%E4%BF%9D%E5%AD%98/</id>
    <published>2021-12-30T02:06:39.000Z</published>
    <updated>2022-01-07T06:30:40.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔者刚入职一家公司，团队的项目在UI方面处理和外面大部分框架都差不多，都是采用绑定的方式处理UI面板，笔者在开发UI面板的时候发现，笔者修改绑定的脚本的数据的时候，发现无法触发prefab的保存，所以不管从场景还是资源中修改参数，在重新打开的时候都没有生效。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者经过一系列的搜索，最后发现是因为笔者所在团队的框架，修改prefab上绑定面板的脚本是通过这个脚本的编辑器扩展脚本中的OnInspectorGUI方法中进行赋值的，但是在这个方法中通过代码赋值的数据都无法触发Prefab的修改，所以无法进行保存，因此下次再打开prefab的时候依旧不生效。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="方法一（不建议使用）"><a href="#方法一（不建议使用）" class="headerlink" title="方法一（不建议使用）"></a>方法一（不建议使用）</h2><p>这个方法是笔者同事用的方法，采用的方式是通过其他方式触发Prefab的修改，从而进行Apply或者Save，这个时候进行保存就会把修改进行保存。笔者同事是Prefab拖到场景中，通过设置Prefab的显示隐藏，触发修改，然后保存。笔者在测试过程中是通过增加节点再删除触发的。这个方法并不推荐使用，因为每次修改都需要想办法触发保存。  </p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>这个方法是在OnInspectorGUI函数中，在调用参数修改的地方，通过**Undo.RecordObject(object,”value change”)**的方法,然后在修改的时候发现就可以触发了，这个方法笔者是从度娘那里学到的方法，笔者并没有采用成功是因为笔者框架的Object是System.Object,但是接口要求的是UnityEngine.Object，因此笔者如果修改会修改大量代码。并且据说这个方法不是百分百生效。  </p><h2 id="方法三（推荐）"><a href="#方法三（推荐）" class="headerlink" title="方法三（推荐）"></a>方法三（推荐）</h2><p>这个方法是在OnInspectorGUI函数中，在调用参数修改的地方，通过**EditorUtility.SetDirty(obj);**的方法监听赋的值就可以了，这是笔者采用的发放，这样修改就可以直接保存了。不过此方法有个确定，就是修改后无法使用ctrl+z进行回退，本身修改也是无法回退，据说方法二是可以支持回退的。  </p><pre><code>[CustomEditor(typeof(XXX))]public class XXXEditor : Editor&#123;    public override void OnInspectorGUI()    &#123;        ...        XXX xxx = value as XXX;        if (#change#)        //数据发生变化        &#123;            xxx.Value = object;            EditorUtility.SetDirty(object);        &#125;        ...    &#125;&#125;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>笔者的方法依旧存在无法回退的方法，如果那位大佬有好的方法可以联系笔者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;笔者刚入职一家公司，团队的项目在UI方面处理和外面大部分框架都差不多，都是采用绑定的方式处理UI面板，笔者在开发UI面板的时候发现，笔者修改</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Prefab" scheme="http://yoursite.com/tags/Prefab/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——海外开发踩坑笔记</title>
    <link href="http://yoursite.com/2021/07/09/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%B5%B7%E5%A4%96%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/07/09/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%B5%B7%E5%A4%96%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</id>
    <published>2021-07-09T10:25:32.000Z</published>
    <updated>2021-12-27T03:39:09.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><h2 id="Gradle版本问题"><a href="#Gradle版本问题" class="headerlink" title="Gradle版本问题"></a>Gradle版本问题</h2><p>本地打包的大部分错误都是因为这个问题，这是因为笔者接入的SDK自定义了gradle的插件版本，这个再unity本身其实已经定义过了，但是自己是可以通过修改build.gradle进行修改的。查看unity本身gradel的插件版本的路径是：Editor\Data\PlaybackEngines\AndroidPlayer\Tools\GradleTemplates\baseProjectTemplate.gradle,以2019.4.28版本为例，里面代码为：  </p><pre><code>// GENERATED BY UNITY. REMOVE THIS COMMENT TO PREVENT OVERWRITING WHEN EXPORTING AGAINallprojects &#123;    buildscript &#123;        ***        dependencies &#123;            ***            classpath &#39;com.android.tools.build:gradle:3.4.0&#39;            **BUILD_SCRIPT_DEPS**        &#125;    &#125;    ***&#125;***</code></pre><p>如上图，可以看到插件版本为3.4.0，如果unity里本身修改了baseProjectTemplate.gradle就按照修改后的来，这个文件夹内所有的gradle和properties都是默认的，如果程序里修改就按照程序里的来。修改的方法在Editor–&gt;ProjectSettings–&gt;Player–&gt;Publishing Settings，如下图所示：  </p><p>  <img src="https://file.liangxiegame.com/f69ca480-57fe-4313-8391-4318b1cead9a.png" alt="image.png">   </p><p>如上图，其实就是对应编辑器文件夹下的gradle文件，如果打勾就会在pluging/Android文件夹下生成对应的文件，就可以直接修改，不再按照unity默认的来，就可以修改配置了。</p><p>经过上面的介绍已经知道如何查看并修改unity的gradle插件版本，下面就是修改对应的gradle版本。首先打开Editor–&gt;Preference–&gt;External Tools就可以看到Android的打包环境配置。  </p><p><img src="https://file.liangxiegame.com/13b80d7b-6dd0-4fdd-8199-82222a81d8e2.png" alt="image.png">   </p><p>2020版本以后的Unity是默认路径下就自己配置好环境，选择默认就可以，但是依旧可能会存在环境不存在或者版本不对，所以可以自己配置，这样修改也方便。这里有需要特别关注的一点也是大部分打包失败的原因，就是gradle的版本和对应的插件版本是有对照关系的，必须对照上才能正常打包。对应关系如下图：  </p><p><img src="https://file.liangxiegame.com/10319033-5e95-4d83-a544-060a7ff6cac3.png" alt="image.png">   </p><p>只要配置好对应的关系就行了。  </p><h2 id="NDK版本问题"><a href="#NDK版本问题" class="headerlink" title="NDK版本问题"></a>NDK版本问题</h2><p>在打包的时候也遇到了NDK版本不对无法打包的问题，打包失败会提示打包需要的版本，下载对应的版本即可，笔者打包的时候需要的是版本19，但是下载19版本依旧无法打包，这是因为版本的小版本依旧对不上，这里可以不用找对应的小版本，只要对应的大版本一样，在自己ndk安装目录下，找到source.properties文件，编辑文件，如下，修改对应的<strong>Pkg.Revision</strong>即可。  </p><pre><code>Pkg.Desc = Android NDKPkg.Revision = 19.0.5232133</code></pre><h2 id="maven仓库下载问题"><a href="#maven仓库下载问题" class="headerlink" title="maven仓库下载问题"></a>maven仓库下载问题</h2><p>这个问题是打包的时候并没有找到对应的maven仓库，笔者接入的SDK需要的maven都写在了launcherTemplate文件里，但是打包的时候并没有找到仓库，这是因为maven的仓库应该写在mainTemplate文件里，在launcherTemplate文件里可能会存在没有下载到的情况。  </p><h2 id="API版本问题API"><a href="#API版本问题API" class="headerlink" title="API版本问题API"></a>API版本问题API</h2><p>这里牵扯到两个API的版本，分别是minSdkVersion和targetSdkVersion，打包的时候会报错版本问题，这里只需要在Editor–&gt;ProjectSettings–&gt;Player–&gt;Other Settings里修改对应的Minimum API Level和Target API Level，修改到要求的版本或者更高的版本即可。  </p><p><img src="https://file.liangxiegame.com/8f76046e-d068-4e4a-a7f0-09db7505453d.png" alt="image.png">   </p><h2 id="APK-obb分包无法运行问题"><a href="#APK-obb分包无法运行问题" class="headerlink" title="APK+obb分包无法运行问题"></a>APK+obb分包无法运行问题</h2><p>因为Google商店对上传的apk有内存限制，要求是100M以内，这里推荐使用的是APk+OBB进行分包，根据最新的要求是要求使用AAB包，这里先介绍APK+OBB的分包遇到的问题。  </p><p>分开打包的方法是Editor–&gt;ProjectSettings–&gt;Player–&gt;Publishing Settings里，勾选上最下面的Split Application Binary。 </p><p><img src="https://file.liangxiegame.com/1ce243b5-e799-4710-a446-0e141fc2a4c1.png" alt="image.png">    </p><p>这个是可以代码控制的：  </p><pre><code>PlayerSettings.Android.useAPKExpansionFiles = true;</code></pre><p>分包后如何在手机上运行呢，这里只需要安装分包后的APK，然后在手机上运行，发现第一次运行不成功，这是因为资源都在OBB中，所以无法正常运行，这里只需要吧自己的OBB改好名字放在对应的文件夹就行了。然后再运行就可以了。   </p><p>文件夹地址：手机目录\Android\obb&quot;APP的包名”<br>OBB文件的名字: main.安卓内部版本号.APP包名.obb (举例：main.102.com.XXX.XXX.XXX.obb)</p><h2 id="打包AAB报错-FileNotFoundException-Temp-launcher-aab-does-not-exist"><a href="#打包AAB报错-FileNotFoundException-Temp-launcher-aab-does-not-exist" class="headerlink" title="打包AAB报错:FileNotFoundException: Temp...\launcher.aab does not exist"></a>打包AAB报错:FileNotFoundException: Temp...\launcher.aab does not exist</h2><p>打包aab的方法就是打开File–&gt;Build Settings的面板，然后勾选上Build AppBundle(Google Play)再进行打包就可以了。  </p><p><img src="https://file.liangxiegame.com/09a6726f-1fd1-4805-be17-d0bbb3ad5481.png" alt="image.png">   </p><p>这个报错网上查了一下原因，说的是因为gradle版本过高，导致unity内部逻辑出错的问题。笔者的gradle的版本确实比unity自带的版本过高，于是利用网上给的解决方案解决了。解决方法是在launcher的gradle的defaultConfig里添加下面代码，笔者不导出安卓工程于是就在launcherTemplate的defaultConfig里添加了下列的代码。  </p><pre><code>defaultConfig &#123;    ***    //打包abb的话需要这个    tasks.whenTaskAdded &#123;        task -&gt;        if (task.name.startsWith(&quot;bundle&quot;)) &#123;                   def renameTaskName = &quot;rename$&#123;task.name.capitalize()&#125;Aab&quot;            def flavor = task.name.substring(&quot;bundle&quot;.length()).uncapitalize()            tasks.create(renameTaskName, Copy) &#123;                       def path = &quot;$&#123;buildDir&#125;/outputs/bundle/$&#123;flavor&#125;/&quot;                from(path)                include &quot;launcher-release.aab&quot;                destinationDir file(&quot;$&#123;buildDir&#125;/outputs/bundle/$&#123;flavor&#125;/&quot;)                rename &quot;launcher-release.aab&quot;, &quot;launcher.aab&quot;            &#125;                 task.finalizedBy(renameTaskName)        &#125;    &#125;&#125;</code></pre><h2 id="AAB格式手机安装方法"><a href="#AAB格式手机安装方法" class="headerlink" title="AAB格式手机安装方法"></a>AAB格式手机安装方法</h2><p>首先需要把aab格式的安装包解析成apks格式的安装包，在解析的时候需要一个jar的包，这个jar包是bundletool-all-1.6.1，版本不要求一定是1.6.1，解析的方法是下面CMD的命令：  </p><pre><code>java -jar &lt;bundletool.jar的路径&gt; build-apks --bundle=&lt;.aab文件的路径&gt; --output=&lt;输出.apks的路径&gt; --ks=&lt;打包.aab文件时的秘钥文件路径，如果.aab文件时没有使用秘钥则可以省去秘钥环节的配置&gt; --ks-pass=pass:&lt;秘钥密码&gt; --ks-key-alias=&lt;秘钥别名&gt; --key-pass=pass:&lt;秘钥别名密码&gt; --device-spec=&lt;要输出的目标sdkVersion的APK的json配置文件路径&gt;</code></pre><p>举例：  </p><pre><code>java -jar C:\Users\XX\Desktop\bundletool-all-1.0.0.jar build-apks --bundle=C:\Users\XX\Desktop\test23.aab --output=C:\Users\XX\Desktop\test23.apks --ks=G:\Client\Trunk\key\user.keystore --ks-pass=pass:abcdef --ks-key-alias=yunzhong --key-pass=pass:abcdef --device-spec=C:\Users\XX\Desktop\config.json</code></pre><p>然后手机链接电脑，打开调试模式，接着调用CMD的安装命令：  </p><pre><code>java -jar C:\Users\XX\Desktop\bundletool-all-1.6.1.jar install-apks --apks=C:\Users\XX\Desktop\test23.apks  </code></pre><p>安装结束后手机上就存在自己需要的安装包了。  </p><h2 id="报错Illegal-usage-of-unity-detected-shutdown-unity"><a href="#报错Illegal-usage-of-unity-detected-shutdown-unity" class="headerlink" title="报错Illegal usage of unity detected, shutdown unity"></a>报错Illegal usage of unity detected, shutdown unity</h2><p>分包之后笔者运行发现APP直接闪退，看了半天日志最后发现了一句报错是Illegal usage of unity detected, shutdown unity。笔者使用的是unity2019.4.26f1c1(中国版，以后的中国版本后面都会有个c)。通过百度发现Unity中国版2019.4版本再分割obb编译的时候会导致这个错误，其他版本还没试过，不知道会不会有这个问题。发现只需要使用国际版本即可。  </p><h2 id="报错DSL-element-‘useProguard’-is-obsolete-and-will-be-removed-soon-Use-‘android-enableR8’-in-gradle-pro"><a href="#报错DSL-element-‘useProguard’-is-obsolete-and-will-be-removed-soon-Use-‘android-enableR8’-in-gradle-pro" class="headerlink" title="报错DSL element ‘useProguard’ is obsolete and will be removed soon. Use ‘android.enableR8’ in gradle.pro"></a>报错DSL element ‘useProguard’ is obsolete and will be removed soon. Use ‘android.enableR8’ in gradle.pro</h2><p>出现这个警告是因为build.gradle里配置了 ‘useProguard’属性，而这个属性将很快被移除，使用‘android.enableR8’来代替。这里只需要在gradleTemplate.properties文件后面添加下面一句话就可以了： </p><pre><code>android.enableR8 = true</code></pre><h2 id="报错自己定义的Application丢失"><a href="#报错自己定义的Application丢失" class="headerlink" title="报错自己定义的Application丢失"></a>报错自己定义的Application丢失</h2><p>打包后出现自己写的Application脚本丢失，这个大部分是因为AndroidManifest没有配置自己的Application，配置方法这里就不多做介绍，网上很多介绍。笔者这里遇到的并不是因为没有配置，是因为笔者接入的SDK是继承的MultiDexApplication，这里需要注意的是如果您的 minSdkVersion 设为 21 或更高版本，系统会默认启用 MultiDex，并且您不需要 MultiDex 库。<br>不过，如果您的 minSdkVersion 设为 20 或更低版本，您必须使用 MultiDex 库并对应用项目进行以下修改：</p><pre><code>android &#123;    defaultConfig &#123;        ...        multiDexEnabled true    &#125;    ...&#125;dependencies &#123;    implementation &quot;androidx.multidex:multidex:2.0.1&quot;&#125;</code></pre><p>此时重新编译打包后发现果然打包出多个dex文件，在安卓6.0上测试完美运行，并且用360加固以后5.0以上都能正常运行。<br>但是坑来了 ：在5.0，5.1系统上一运行就奔溃！<br>后来知道在高版本系统上使用art支持多dex，而低版本dalvik默认先加载主dex，如果启动时需要的类不在主dex内就会报错ClassNotFoundException。 解压apk发现里面有上百个dex文件，一般不会拆分如此多，百度查阅后得知：<br>对于dex 的–multi-dex 选项设置与预编译的library工程有冲突,如果你的应用中包含引用的lirary工程,需要将预编译设置为false:<br>在 build.gradle中添加  </p><pre><code>dexOptions&#123;    preDexLibraries = false&#125;</code></pre><h1 id="SDK遇到问题"><a href="#SDK遇到问题" class="headerlink" title="SDK遇到问题"></a>SDK遇到问题</h1><h2 id="华为手机出现水滴屏无法适配的问题"><a href="#华为手机出现水滴屏无法适配的问题" class="headerlink" title="华为手机出现水滴屏无法适配的问题"></a>华为手机出现水滴屏无法适配的问题</h2><p>笔者的项目要求手机在遇到水滴屏或者刘海屏的时候，上面显示黑条不进行渲染就可以，笔者查了一下unity的设置方法，发现只需要不勾选Editor–&gt;ProjectSettings–&gt;Resolution and Presentation里的Render outside safe area即可。  </p><p><img src="https://file.liangxiegame.com/45f3375d-4006-40a8-a599-3efb2978e578.png" alt="image.png">   </p><p>但是笔者发现APP在某个测试的华为手机上依旧渲染了，最后发现是接入的SDK里设置了华为手机的屏幕渲染。在华为手机Android8.0的适配方案是在AndroidManfiest里面添加下面的话即可，笔者发现接入的SDK设置了这个，于是去掉就没有问题了。  </p><pre><code>&lt;meta-data android:name=&quot;android.notch_support&quot; android:value=&quot;true&quot;/&gt; </code></pre><p>这里列举一下小米手机的适配方案是：  </p><pre><code>&lt;meta-data android:name=&quot;notch.config&quot; android:value=&quot;portrait|landscape&quot;/&gt;</code></pre><h2 id="如何修改build-gradle"><a href="#如何修改build-gradle" class="headerlink" title="如何修改build.gradle"></a>如何修改build.gradle</h2><p>关于对Android的gradle的脚本进行修改，其实上面已经介绍了。Pluging/Android文件夹下的XXXTemplate对应的其实就是导出android工程下的build.gradle，修改对应的Template就是修改对应的build.gradle。  </p><h2 id="如何添加Android需要的java脚本"><a href="#如何添加Android需要的java脚本" class="headerlink" title="如何添加Android需要的java脚本"></a>如何添加Android需要的java脚本</h2><p>首先导出一个安卓工程，然后用AndroidStudio打开导出的Android工程，然后直接在安卓工程里写对应的脚本，脚本完成后直接复制到unity工程中pluging下Android文件夹下面。这里因为每次都要复制文件，所以笔者写了一个脚本直接一键复制所有的bat脚本。脚本内容如下：  </p><pre><code>@echo offset filePath=unityLibrary\src\main\java\com\ksset targetFilePath=..\..\project\Assets\Plugins\Androidfor /R %filePath% %%i in (*.java) do (    xcopy /y /c /h /r %%i %targetFilePath%    echo %%i)pause</code></pre><p>后来发现每次改好脚本后，还需要找到这个bat文件执行，于是笔者简化了这个步骤，笔者添加了一个unity的编辑器脚本，用于执行这个bat文件。脚本内容如下：  </p><pre><code>public static void SyncAndroidJava2()&#123;    var filepath = FileEditorTools.FormatPath(Application.dataPath + &quot;/../../android/AndroidBDSDK_R/&quot;);    RunBat(&quot;CopyJavaScripts.bat&quot;, &quot;&quot;, filepath);&#125;//cmd是执行的脚本的名字    args是参数，可以直接设置为“”        workingDir是执行bat文件所在文件夹路径public static System.Diagnostics.Process CreateShellExProcess(string cmd, string args, string workingDir = &quot;&quot;)&#123;    var pStartInfo = new System.Diagnostics.ProcessStartInfo(cmd);    pStartInfo.Arguments = args;    pStartInfo.CreateNoWindow = false;    pStartInfo.UseShellExecute = true;    pStartInfo.RedirectStandardError = false;    pStartInfo.RedirectStandardInput = false;    pStartInfo.RedirectStandardOutput = false;    if (!string.IsNullOrEmpty(workingDir))        pStartInfo.WorkingDirectory = workingDir;    return System.Diagnostics.Process.Start(pStartInfo);&#125;public static void RunBat(string batfile, string args, string workingDir = &quot;&quot;)&#123;    var p = CreateShellExProcess(batfile, args, workingDir);    p.Close();&#125;</code></pre><p>在执行bat脚本的时候笔者发现，自己完全可以写一个复制用的脚本，就不需要再依靠bat脚本进行执行。脚本如下：<br>    public static void SyncAndroidJava()<br>    {<br>        var filepath = FileEditorTools.FormatPath(Application.dataPath + “/../../android/AndroidBDSDK_R/unityLibrary/src/main/java/com/ks/“);            //需要复制的java文件所在的文件夹<br>        var folderpath = Application.dataPath + “/Plugins/Android/“;            //复制到的文件位置<br>        var filelist = FileEditorTools.GetallFile(filepath, “.java”);</p><pre><code>    var curcount = 0;    var sumcount = filelist.Count;        EditorUtility.DisplayProgressBar(&quot;同步Android的Java脚本&quot;, &quot;开始复制文字...&quot;, 0);    foreach (var javafile in filelist)    &#123;        EditorUtility.DisplayProgressBar(&quot;复制文件&quot;, javafile.FullName, (float)curcount / sumcount);        // 判断目标目录是否存在如果不存在则新建        try        &#123;            FileEditorTools.CopyFileToFolder(javafile,folderpath);        &#125;        catch (Exception e)        &#123;            Debug.LogError(e);            EditorUtility.ClearProgressBar();            return;        &#125;        Debug.Log(javafile.FullName);        curcount++;    &#125;    EditorUtility.ClearProgressBar();&#125;public class FileEditorTools&#123;    // 文件列表    private static List&lt;FileInfo&gt; _FileList = new List&lt;FileInfo&gt;();        #region   公有方法    /// &lt;summary&gt;    /// 获得目录下所有文件或指定文件类型文件(包含所有子文件夹)    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;文件夹路径&lt;/param&gt;    /// &lt;param name=&quot;extName&quot;&gt;扩展名可以多个 例如[.mp4] [.mp3] [.wma] 等&lt;/param&gt;    /// &lt;returns&gt;List&lt;FileInfo&gt;&lt;/returns&gt;    public static List&lt;FileInfo&gt; GetallFile(string path, string extName)    &#123;        //检查目录是否存在        if (!string.IsNullOrWhiteSpace(path))        &#123;            if (Directory.Exists(path))            &#123;                GetallfilesOfDir(path, extName);            &#125;            else            &#123;                Directory.CreateDirectory(path);            &#125;        &#125;        else        &#123;            //注意这里的EverydayLog.Write()是我自定义的日志文件，可以根据需要保留或删除            Debug.LogError(&quot;GetAllFileOfFolder/GetallFile()/存储视频文件的路径为空，请检查！！！&quot; );        &#125;        return _FileList;    &#125;    public static void CopyFileToFolder(FileInfo fileinfo,string fildername)    &#123;        var destfilename = FormatPath(fildername+fileinfo.Name);        File.Copy(fileinfo.FullName, destfilename, true);    &#125;        public static string FormatPath(string path)    &#123;        path = path.Replace(&quot;/&quot;, &quot;\\&quot;);        if (Application.platform == RuntimePlatform.OSXEditor)            path = path.Replace(&quot;\\&quot;, &quot;/&quot;);        return path;    &#125;    #endregion        #region   私有方法    /// &lt;summary&gt;    /// 递归获取指定类型文件,包含子文件夹    /// &lt;/summary&gt;    /// &lt;param name=&quot;path&quot;&gt;指定文件夹的路径&lt;/param&gt;    /// &lt;param name=&quot;extName&quot;&gt;文件拓展名&lt;/param&gt;    private static void GetallfilesOfDir(string path, string extName)    &#123;        try        &#123;            string[] dir = Directory.GetDirectories(path); //文件夹列表               DirectoryInfo fdir = new DirectoryInfo(path);            FileInfo[] file = fdir.GetFiles();            if (file.Length != 0 || dir.Length != 0) //当前目录文件或文件夹不为空                               &#123;                foreach (FileInfo f in file) //显示当前目录所有文件                   &#123;                    if (extName.ToLower().IndexOf(f.Extension.ToLower()) &gt;= 0)                    &#123;                        _FileList.Add(f);                    &#125;                &#125;                foreach (string d in dir)                &#123;                    GetallfilesOfDir(d, extName);//递归                   &#125;            &#125;        &#125;        catch (Exception ex)        &#123;            //注意这里的EverydayLog.Write()是我自定义的日志文件，可以根据需要保留或删除            Debug.LogError(&quot;/GetAllFileOfFolder()/GetallfilesOfDir()/获取指定路径：&quot;+path+&quot;   下的文件失败！！！，错误信息=&quot;+ex.Message);        &#125;    &#125;    #endregion    &#125;</code></pre><h2 id="设备唯一标识"><a href="#设备唯一标识" class="headerlink" title="设备唯一标识"></a>设备唯一标识</h2><p>这里的设备唯一标识一开始笔者用的是设备的OAID，后来发现有些设备并不能获取到设别的OAID，并且换位的手机如果打开了”关闭广告追踪“，那么获取的OAID所以这个并不能作为设别的唯一标识，网上有很多进行多数据拼接的方法，于是笔者从自己公司的SDK摘取了或者设备唯一标识的方法，这是一个比较简单的方法，就是先获取设备的androidID，如果获取不到就会自己保存一个数据到文件里，然后每次从文件里读取就行了。  </p><pre><code>private static String deviceId;public String GetDeviceID() &#123;    Application yourApplicatoin = this;            //这里只是举个例子，这里需要大家获取一下自己的Application    if (yourApplicatoin.getApplicationContext() == null) //这里是获取Application的实例，如果没有就可以直接返回空        return &quot;&quot;;    else &#123;        String var1;        if ((var1 = deviceId) != null)            //先判断deviceID是否已经赋值过了，如果已经赋值就直接返回就行了            return var1;        else &#123;            deviceId = getSPValue(yourApplicatoin, &quot;DeviceId&quot;);    //如果没有就先从文件里获取一下            if (!TextUtils.isEmpty(deviceId)) &#123;                    //如果获取到了就直接返回                return deviceId;            &#125; else &#123;                deviceId = getAndroidIdAsDeviceId(yourApplicatoin);    //如果文件里没有就先尝试获取一下androidID作为设备唯一标识                if (!TextUtils.isEmpty(deviceId)) &#123;                    //获取到了就进行保存并返回这个标识                    saveSPValue(yourApplicatoin, &quot;DeviceId&quot;, deviceId);                        return deviceId;                &#125; else &#123;                    deviceId = generateSoftDeviceId();                //如果没有获取到就通过自己的混合加密方式进行缓存                    if (!TextUtils.isEmpty(deviceId)) &#123;                //如果不为空就保存然后返回标识                        saveSPValue(yourApplicatoin, &quot;DeviceId&quot;, deviceId);                        return deviceId;                    &#125; else &#123;                                        //如果都没获取到就是特殊情况，直接返回                        return deviceId;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="保存DeviceID到文件里"><a href="#保存DeviceID到文件里" class="headerlink" title="保存DeviceID到文件里"></a>保存DeviceID到文件里</h2><p>通过getSharedPreferences方法将deviceid保存到文件里。</p><pre><code>private static void saveSPValue(Context mycontext, String datakey, String datavalue) &#123;    mycontext.getSharedPreferences(&quot;myappsdkdeviceid&quot;, 0).edit().putString(&quot;datakey&quot;, datavalue).apply();&#125;</code></pre><p>myappsdkdeviceid是文件名字，datakey是保存的关键字名字，然后datavalue是储存的值，就是我们要储存的deviceid。  </p><h2 id="从文件里获取DeviceID"><a href="#从文件里获取DeviceID" class="headerlink" title="从文件里获取DeviceID"></a>从文件里获取DeviceID</h2><pre><code>private static String getSPValue(Context mycontext, String datakey) &#123;    return var0.getSharedPreferences(&quot;myappsdkdeviceid&quot;, 0).getString(datakey, (String)null);&#125;</code></pre><p>myappsdkdeviceid是文件名字，datakey是保存的关键字名字。 </p><h2 id="获取设备的AndroidID"><a href="#获取设备的AndroidID" class="headerlink" title="获取设备的AndroidID"></a>获取设备的AndroidID</h2><pre><code>private static String getAndroidIdAsDeviceId(Context mycontext) &#123;    String andid = Settings.Secure.getString(mycontext.getContentResolver(), &quot;android_id&quot;);    //获取设备的AndroidID    return isLegalAndroidId(andid) ? &quot;ANDROID_&quot; + andid : null;                //如果符合条件就添加前缀，不符合就返回空&#125;private static final Pattern ANDROID_ID_PATTERN = Pattern.compile(&quot;^[0-9a-fA-F]&#123;16&#125;$&quot;);private static boolean isLegalAndroidId(String andid) &#123;                                return !TextUtils.isEmpty(andid) &amp;&amp; ANDROID_ID_PATTERN.matcher(andid).find();&#125;</code></pre><p>第二个函数是判断获得到的android是否不为空并且符合正则表达式的规则  </p><h2 id="自定义的设备唯一标识"><a href="#自定义的设备唯一标识" class="headerlink" title="自定义的设备唯一标识"></a>自定义的设备唯一标识</h2><pre><code>private static long randomLong(long var0) &#123;    return Build.VERSION.SDK_INT &gt;= 21 ? ThreadLocalRandom.current().nextLong(var0) : (long)((new Random()).nextDouble() * (double)(var0 - 1L));&#125;private static String generateSoftDeviceId() &#123;    String arg0  = Build.SERIAL;            //首先获取序列号    if (TextUtils.isEmpty(arg0)) &#123;            //如果没有获取到序列化就赋值为&quot;NA&quot;        arg0 = &quot;NA&quot;;    &#125;    long arg1 = 2564562216496361285L;        //设置两个随机的long型的数据    long arg2 = 8545649582269949258L;    arg2 = randomLong(arg2);        //获取一个随机数，获取失败就调回去重新获取    arg1 += arg2;    String var8 = &quot;ANDROID_%1$s_%2$s&quot;;        //设置一下格式    Object[] arg3 = new Object[2];    arg3[0] = Long.toHexString(arg1);        //设置第一个参数    try &#123;        arg3[1] = arg0;                        //设置第二个参数        return String.format(var8, arg3);    &#125; catch (Throwable var3) &#123;    &#125;    Object[] arg4;                            //如果上述存在问题就根据时间设置一个随机数    Object[] arg5 = arg4 = new Object[2];    arg5[0] = &quot;NA&quot; + Long.toHexString(System.currentTimeMillis());    arg5[1] = arg0;    return String.format(&quot;ANDROID_%1$s_%2$s&quot;, arg4);&#125;</code></pre><h1 id="AWS-亚马逊-的CDN上传"><a href="#AWS-亚马逊-的CDN上传" class="headerlink" title="AWS(亚马逊)的CDN上传"></a>AWS(亚马逊)的CDN上传</h1><h2 id="网页上传"><a href="#网页上传" class="headerlink" title="网页上传"></a>网页上传</h2><p>这种上传方式就是访问网页，然后按照需求把自己需要上传的文件上传到对应网页的进行上传。  </p><h2 id="自动上传"><a href="#自动上传" class="headerlink" title="自动上传"></a>自动上传</h2><p>笔者采用的是利用python环境然后写的bat脚本进行上传。  </p><h2 id="Python环境配置"><a href="#Python环境配置" class="headerlink" title="Python环境配置"></a>Python环境配置</h2><p>首先需要在Python虚拟环境中安装 AWS CLI  </p><pre><code>$ pip install awscli</code></pre><p>这里介绍一个python比较好的版本管理工具，可以管理本地多版本的python。<a href="https://www.jianshu.com/p/d66fce9a7bdc"><font color=steelblue size=3>pyenv</font></a>   </p><h2 id="aws版本查看"><a href="#aws版本查看" class="headerlink" title="aws版本查看"></a>aws版本查看</h2><pre><code>$ aws --version</code></pre><p><img src="https://file.liangxiegame.com/12c0d1cf-5a76-4322-bbb6-55654310b33d.png" alt="image.png">   </p><h2 id="更新aws"><a href="#更新aws" class="headerlink" title="更新aws"></a>更新aws</h2><pre><code>$ aws install awscli --upgrade</code></pre><h2 id="卸载aws"><a href="#卸载aws" class="headerlink" title="卸载aws"></a>卸载aws</h2><pre><code>$ pip uninstall awscli  </code></pre><h2 id="配置AWS-CLI"><a href="#配置AWS-CLI" class="headerlink" title="配置AWS CLI"></a>配置AWS CLI</h2><pre><code>$ aws configureAWS Access Key ID [None]: *******AWS Secret Access Key [None]: *******Default region name [None]: us-east-2Default output format [None]: json</code></pre><p>这里分辨需要填上对应的参数，上面的ID和Key就是自己页面申请aws给提供的。下面的json也只输出的格式，这里最关键的其实是<strong>Default region name</strong>，这里并不是随便填的，而是填上aws终端节点对应的区域代码。  </p><p><img src="https://file.liangxiegame.com/63176da0-0361-49ed-8413-00163af95287.png" alt="image.png">   </p><p>这里其实会再打开终端的目录生成一个.aws文件夹，里面会有config和credentials两个文件就是我们的配置文件了。  </p><h2 id="aws与s3配合使用"><a href="#aws与s3配合使用" class="headerlink" title="aws与s3配合使用"></a>aws与s3配合使用</h2><p>想要使用aws cli上传文件需要与s3配合使用。  </p><h3 id="列举自己的库"><a href="#列举自己的库" class="headerlink" title="列举自己的库"></a>列举自己的库</h3><pre><code>$ aws s3 ls  </code></pre><h3 id="列举库中文件夹内容"><a href="#列举库中文件夹内容" class="headerlink" title="列举库中文件夹内容"></a>列举库中文件夹内容</h3><pre><code>$ aws s3 ls s3://my-bucket  </code></pre><h3 id="上传文件到s3的库"><a href="#上传文件到s3的库" class="headerlink" title="上传文件到s3的库"></a>上传文件到s3的库</h3><pre><code>$aws s3 cp my-file s3://my-bucket/my-folder</code></pre><p>如果每次都使用上面的命令传输文件还是比较麻烦的，所以笔者自己写了一个简单的bat脚本，可以更方便的上传文件  </p><pre><code>@echo offset filePath=..\resource\cdnfileroot\resource\packres\default-pack\android-defaultset cdnPath=s3://cyber-era-cdn/resource/packres/default-pack/android-defaultcall cd %filePath%for %%i in (*.zip) do (    call aws s3 cp %%i %cdnPath%/%%i    echo %%i)pause</code></pre><h1 id="海外文本替换"><a href="#海外文本替换" class="headerlink" title="海外文本替换"></a>海外文本替换</h1><h2 id="提取Prefab中文字到表里"><a href="#提取Prefab中文字到表里" class="headerlink" title="提取Prefab中文字到表里"></a>提取Prefab中文字到表里</h2><p>这里是把prefab上的文字全部提取到一个自定定义的Language表里。首先需要读取自定义的Language表里的数据，这是为了去重用的。然后加载本地所有的prefab，再遍历prefab所有的节点，然后判断是否包含Text的组件，如果包含文字就把文字记录在自己的字典中。在放进字典中是需要排重的。<br>加载Prefab的代码  </p><pre><code>private static void doLoadPrefab(bool clearText,bool onlyFindText = false)        //两个参数分别是是否清除Text组件和是否之查找文本，下面会有详细介绍&#123;    ...    if (string.IsNullOrEmpty(ExportExcel.excelFolder))        //接下来是查找自己的需要导入的表，不存在就创建一个新的表    &#123;        excelPath = EditorUtility.OpenFilePanel(&quot;选择SVN中的ProgramLanguage表&quot;,&quot;&quot;,&quot;&quot;);    &#125;    else    &#123;        excelPath = ExportExcel.excelFolder + &quot;/ProgramLanguage.xlsx&quot;;    &#125;    if (!string.IsNullOrEmpty(excelPath))    &#123;        ReadExcel();                                        //进行读取加载表格        LoadAllPrefabText(clearText,onlyFindText);            //进行加载所有prefab的文本内容        if (clearText)                                        //如果是清除文本组件的就只是需要清除字典        &#123;            textDesAddDic.Clear();        &#125;        else                                                //如果不是清除的就把读取内容写入到表格中        &#123;            WroadExcel();        &#125;    &#125;&#125;</code></pre><p>读取Language代码如下:  </p><pre><code>private static int exKey;private static string exValue;public static void ReadExcel()&#123;    var attrArr = File.GetAttributes(excelPath);            //这个是获取表格的属性，因为有些表格可能是只读属性，需要修改    File.SetAttributes(excelPath, FileAttributes.Normal);    //把表格的属性设置成普通属性，这样就一定能写入了，之所以不是去掉只读属性是因为只是单独修改可读属性不知道为何还是不能写入，就先设置为普通的属性了    textDesDic.Clear();                                        //清空自己的字典    excelFile = new FileInfo(excelPath);                    //接着就是获取表格文件    using (ExcelPackage excelPackage = new ExcelPackage(excelFile))        //下面就是循环读取表格内容然后写入到字典中    &#123;        var worksheet = excelPackage.Workbook.Worksheets[1];        for (int i = startRow; i &lt;= worksheet.Dimension.End.Row; i++)        &#123;            exKey = worksheet.Cells[i, keyColumn].GetValue&lt;int&gt;();            exValue = worksheet.Cells[i, valueVolumn].GetValue&lt;string&gt;();            startTextIndex = Mathf.Max(exKey, startTextIndex);            textDesDic.Add(exKey, exValue);        &#125;    &#125;    textDesAddDic.Clear();                                    //接着就是把第二个增加的字典清空，是为了记录新增的文字    File.SetAttributes(excelPath, attrArr);                    //然后就是把文件属性设置为原来的属性&#125;</code></pre><p>写入Language和读取类似，只是把原来的遍历读取变成遍历新增字典，然后一行一行写入。代码如下:  </p><pre><code>public static void WroadExcel()&#123;    var attrArr = File.GetAttributes(excelPath);    File.SetAttributes(excelPath, FileAttributes.Normal);    excelFile = new FileInfo(excelPath);    using (ExcelPackage excelPackage = new ExcelPackage(excelFile))    &#123;        var worksheet = excelPackage.Workbook.Worksheets[1];        var curRow = worksheet.Dimension.End.Row;        foreach (var textdespair in textDesAddDic)        &#123;            worksheet.Cells[++curRow, keyColumn].Value = textdespair.Key;            worksheet.Cells[curRow, valueVolumn].Value = textdespair.Value;        &#125;                excelPackage.Save();                                //保存表    &#125;        File.SetAttributes(excelPath, attrArr);        textDesAddDic.Clear();&#125;</code></pre><p>加载prefab中的Text文本，代码如下:  </p><pre><code>static StringBuilder newTexts = new StringBuilder();public static void LoadAllPrefabText(bool isClearText,bool onlyFindTxt = false)&#123;    newTexts.Clear();                            //清空字符串    textDesAddDic.Clear();                        //清空新增的字典    var sdirs =GetAllPrefabFiles();                //获取Prefab的存在文件夹    EditorUtility.DisplayProgressBar(&quot;Progress&quot;, &quot;LoadPrefabTxtDes...&quot;, 0);        //打开一个进度掉，为了方便查看加载进度使用    var asstIds = AssetDatabase.FindAssets(&quot;t:Prefab&quot;, sdirs);                    //得到所有Prefab的资源    int count = 0;                                //初始化加载的进度    for (int i = 0; i &lt; asstIds.Length; i++)    //循环遍历一下自己加载出来的prefab    &#123;        string path = AssetDatabase.GUIDToAssetPath(asstIds[i]);            //得到prefab资源的路径        //Debug.LogError(&quot;try deal with path &quot;+path);                                var pfb = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(path);            //根据路径加载对应的prefab        var texts = pfb.GetComponentsInChildren&lt;Text&gt;(true);                //得到prefab上所有节点的Text组件        if (texts == null || texts.Length &lt;= 0)                                //如果不存在就跳过，遍历到下一个prefab        &#123;            //Debug.LogError(&quot;asset no texts: &quot;+path);            continue;        &#125;        foreach (var item in texts)                                            //遍历prefab中的Text组件        &#123;            textDes = item.text;                                            //获取组件上的文字            if (textDes.IsNullOrWhitespace())                                //如果文字为空就跳过到下一个                continue;                        var langTextComp = item.gameObject.GetComponent&lt;MutiLangText&gt;();//获取Text文本上的脚本，自己写的替换文本的脚本            if (langTextComp &amp;&amp; onlyFindTxt)                                //如果存在脚本并且只是查找文本，说明已经添加过就可以直接跳过了            &#123;                continue;                //Debug.LogError(&quot;has Added MutiText: &quot;+item.name);            &#125;            bool addComP = false;                                            //标记是否增加组件为false            if (isClearText)                                                //判断是否需要清除自己的替换语言脚本            &#123;                if (!textDesDic.ContainsValue(textDes))                        //判断表里是否已经存在文本                &#123;                    item.text = &quot;&quot;;                                            //如果不存在就先清除文字                    if (langTextComp)                                        //如果不存在自己的脚本就一并删除                    &#123;                        //TODO  remove  comp                        DestroyImmediate(langTextComp);                    &#125;                &#125;                else                                                        //如果表里存在就从字典里获取到表里的ID                &#123;                    curDesId = textDesDic.Where(q =&gt; q.Value == textDes).Select(q =&gt; q.Key).ToArray()[0];                    addComP = true;                                            //标记需要增加组件                &#125;            &#125;            else                                                            //如果不是清除文本            &#123;                if (onlyFindTxt)                                            //如果只是查找文本                &#123;                    if (!textDesDic.ContainsValue(textDes))                    //如果字典中不存在就记录下来                    &#123;                        newTexts.AppendLine(textDes);                    &#125;                    continue;                &#125;                if (!textDesDic.ContainsValue(textDes))                        //如果字典中不存在，就往字典中添加，并且在新增字典中增加                &#123;                    textDesDic.Add(++startTextIndex, textDes);                    textDesAddDic.Add(startTextIndex,textDes);                    curDesId = startTextIndex;                &#125;                else                                                        //如果存在就记录下来文本对应的ID                &#123;                    curDesId = textDesDic.Where(q =&gt; q.Value == textDes).Select(q =&gt; q.Key).ToArray()[0];                &#125;                                if(!langTextComp)                                            //如果并没有增加切换语言脚本就标记需要增加脚本                &#123;                    addComP = true;                &#125;            &#125;            if (addComP &amp;&amp; !langTextComp)                                    //如果需要增加并且组件不存在，就增加一下自己的脚本                    &#123;                langTextComp = item.gameObject.AddComponent&lt;MutiLangText&gt;();                langTextComp.baseText = item;            &#125;                        if (langTextComp)                                                //如果存在组件就更新一下ID                langTextComp.languageID = curDesId;        &#125;        PrefabUtility.SavePrefabAsset(pfb, out bool success);                //修改完毕保存prefab就可以了        if (success)                                                        //记录加载进度，然后更新进度条        &#123;            count++;        &#125;        EditorUtility.DisplayProgressBar(&quot;LoadPrefabTxtDes Progress&quot;, pfb.name, count / (float)asstIds.Length);    &#125;    if (newTexts.Length &gt; 0)                                                //如果有新增的文字就记录下来    &#123;        Debug.LogError(&quot;write new text: &quot;+newTexts.Length);        File.WriteAllText(ExportExcel.excelFolder + &quot;/newText.txt&quot;,newTexts.ToString());    &#125;    EditorUtility.ClearProgressBar();                                        //结束之后清除加载进度条&#125;</code></pre><p>获取Prefab文件路径的代码：  </p><pre><code>private static string[] GetAllPrefabFiles()&#123;    string sdir = &quot;Assets/XXX/XXX&quot;;    List&lt;string&gt; sdirlist = new List&lt;string&gt;();    sdirlist.Add(sdir);    sdirlist.Add(&quot;Assets/Resources/RootPrefab&quot;);       return sdirlist.ToArray();    &#125;</code></pre><h2 id="查找代码中的中文"><a href="#查找代码中的中文" class="headerlink" title="查找代码中的中文"></a>查找代码中的中文</h2><p>因为一开始没有考虑到会做海外，并且写的代码不规范，所以存在一部分中文是在代码里。这部分中文代码是不好查找的，所以写了一个小脚本，可以快速标记到中文代码的位置，这个脚本可以解决大部分，但是仍旧是存在找不到的问题的。下面来看代码:  </p><p>首先会打开一个面板用来选择代码脚本所在的文件路径</p><pre><code>[MenuItem(&quot;Tools/ReplaceText/FindScriptsLanguage&quot;)]public static void Pack()&#123;    Rect wr = new Rect(300, 400, 400, 100);    FindChineseWindow window = (FindChineseWindow)EditorWindow.GetWindowWithRect(typeof(FindChineseWindow), wr, true, &quot;查找项目中的中文字符&quot;);    window.Show();&#125;public class FindChineseWindow : EditorWindow&#123;    private ArrayList csList = new ArrayList();    private int eachFrameFind = 4;    private int currentIndex = 0;    private bool isBeginUpdate = false;    private string outputText;    public string filePath = &quot;/Scripts&quot;;    private string strForShader = &quot;&quot;;    //这个是需要忽略检测的文件夹    private List&lt;string&gt; ingoreFileInfoDirNameList = new List&lt;string&gt; &#123;&quot;GMConsole&quot;, &quot;LogicWorld&quot;, &quot;NetWork&quot;, &quot;SDK&quot;&#125;;    //这个是需要忽略的代码文件名    private List&lt;string&gt; ingoreFileInfoNameList = new List&lt;string&gt; &#123;&quot;LocalLanguage&quot;&#125;;    //这个是需要忽略的代码包含的字符串    private List&lt;string&gt; ingoreScriptesDesList = new List&lt;string&gt; &#123;&quot;Debug&quot;, &quot;LogWrapper&quot;, &quot;Tooltip&quot;, &quot;throw new&quot;&#125;;    //获取需要检测的文件    private void GetAllFile(DirectoryInfo dir)    &#123;        FileInfo[] allFile = dir.GetFiles();        foreach (FileInfo fi in allFile)        &#123;            if (ingoreFileInfoDirNameList.Where(str =&gt; fi.DirectoryName.Contains(str)).Count() &gt; 0)                 continue;            if (ingoreFileInfoNameList.Where(str =&gt; fi.Name.Contains(str)).Count() &gt; 0)                 continue;            if (fi.FullName.IndexOf(&quot;.meta&quot;) == -1 &amp;&amp; fi.FullName.IndexOf(&quot;.cs&quot;) != -1)            &#123;                csList.Add(fi.DirectoryName + &quot;/&quot; + fi.Name);            &#125;        &#125;        DirectoryInfo[] allDir = dir.GetDirectories();        foreach (DirectoryInfo d in allDir)        //遍历子文件夹        &#123;            GetAllFile(d);        &#125;    &#125;    public void OnGUI()            //面板显示的代码    &#123;        filePath = EditorGUILayout.TextField(&quot;路径：&quot;, filePath);        //输入路径        EditorGUILayout.Space();        EditorGUILayout.Space();        if (GUILayout.Button(&quot;开始遍历目录&quot;))                                //显示的按钮        &#123;            csList.Clear();            DirectoryInfo d = new DirectoryInfo(Application.dataPath + filePath);    //从绝对路径读取文件            GetAllFile(d);                                                //获取所有的文件            //GetAllFile(d);            outputText = &quot;游戏内代码文件的数量：&quot; + csList.Count;            isBeginUpdate = true;            outputText = &quot;开始遍历项目&quot;;        &#125;        GUILayout.Label(outputText, EditorStyles.boldLabel);    &#125;    private bool HasChinese(string str)                //这是个判断是否是中文的方法    &#123;        return Regex.IsMatch(str, @&quot;[\u4e00-\u9fa5]&quot;);    &#125;    private Regex regex = new Regex(&quot;\&quot;[^\&quot;]*\&quot;&quot;);    private void printChinese(string path)            //开始输出中文文字所在位置    &#123;        if (File.Exists(path))        &#123;            string[] fileContents = File.ReadAllLines(path, Encoding.Default);            int count = fileContents.Length;            for (int i = 0; i &lt; count; i++)            &#123;                string printStr = fileContents[i].Trim();                if (printStr.IndexOf(&quot;//&quot;) == 0) //说明是注释                    continue;                if (ingoreScriptesDesList.Where(str =&gt; printStr.Contains(str)).Count() &gt; 0) //说明是需要排除的代码                    continue;                MatchCollection matches = regex.Matches(printStr);                foreach (Match match in matches)                &#123;                    if (HasChinese(match.Value))                    &#123;                        string[] fullPath = path.Split(&#39;/&#39;);                        path = fullPath[fullPath.Length - 1];                        Debug.Log(&quot;路径:&quot; + path + &quot; 行数:&quot; + i + &quot; 内容:&quot; + printStr);                        break;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;打包&quot;&gt;&lt;a href=&quot;#打包&quot; class=&quot;headerlink&quot; title=&quot;打包&quot;&gt;&lt;/a&gt;打包&lt;/h1&gt;&lt;h2 id=&quot;Gradle版本问题&quot;&gt;&lt;a href=&quot;#Gradle版本问题&quot; class=&quot;headerlink&quot; title=&quot;Gradl</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="海外Google" scheme="http://yoursite.com/tags/%E6%B5%B7%E5%A4%96Google/"/>
    
  </entry>
  
</feed>
