<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LianBai</title>
  
  <subtitle>手握日月摘星辰，世间无我这般人。</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-05-16T17:09:33.635Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LianBai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity杂文——脚本创建辅助ScriptBuilder</title>
    <link href="http://yoursite.com/2023/05/17/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%84%9A%E6%9C%AC%E5%88%9B%E5%BB%BA%E8%BE%85%E5%8A%A9ScriptBuilder/"/>
    <id>http://yoursite.com/2023/05/17/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%84%9A%E6%9C%AC%E5%88%9B%E5%BB%BA%E8%BE%85%E5%8A%A9ScriptBuilder/</id>
    <published>2023-05-16T16:38:43.000Z</published>
    <updated>2023-05-16T17:09:33.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一个辅助快速生成需要的C#脚本的脚本。主要是快速生成引用，命名空间，类和方法一些。</p><h1 id="脚本和解析"><a href="#脚本和解析" class="headerlink" title="脚本和解析"></a>脚本和解析</h1><pre><code>public class ScriptBuilder&#123;    /// &lt;summary&gt;    /// 脚本的字符串    /// &lt;/summary&gt;    private StringBuilder m_Builder = new StringBuilder();    /// &lt;summary&gt;    /// 空白地字符串    /// &lt;/summary&gt;    private StringBuilder m_Blank = new StringBuilder();    /// &lt;summary&gt;    /// 用于判断是否在方法内生成脚本    /// &lt;/summary&gt;    public bool MarkInMethod &#123; get; set; &#125;    /// &lt;summary&gt;    /// 增加一行数据    /// &lt;/summary&gt;    /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;    public void AppendLine(string message)    &#123;        m_Builder.Append(m_Blank);        m_Builder.AppendLine(message);    &#125;    /// &lt;summary&gt;    /// 开始增加空白    /// &lt;/summary&gt;    private void BeginBlank()    &#123;        m_Blank.Append(&#39;\t&#39;);    &#125;    /// &lt;summary&gt;    /// 结束增加空白    /// &lt;/summary&gt;    private void EndBlank()    &#123;        m_Blank.Remove(m_Blank.Length - 1, 1);    &#125;    /// &lt;summary&gt;    ///开始增加命名空间    /// &lt;/summary&gt;    /// &lt;param name=&quot;name&quot;&gt;命名空间的名字&lt;/param&gt;    public void BeginNamespace(string name)    &#123;        BeginBrace($&quot;namespace &#123;name&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 结束增加命名空间    /// &lt;/summary&gt;    public void EndNamespace()    &#123;        EndBrace();    &#125;    /// &lt;summary&gt;    /// 开始增加类    /// &lt;/summary&gt;    /// &lt;param name=&quot;modifier&quot;&gt;类的修饰字符串&lt;/param&gt;    /// &lt;param name=&quot;className&quot;&gt;类的名字&lt;/param&gt;    /// &lt;param name=&quot;superclass&quot;&gt;继承类的名字&lt;/param&gt;    public void BeginClass(string modifier, string className, string superclass)    &#123;        BeginBrace($&quot;public &#123;modifier&#125; class &#123;className&#125; : &#123;superclass&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 开始增加类    /// &lt;/summary&gt;    /// &lt;param name=&quot;modifier&quot;&gt;类的修饰字符串&lt;/param&gt;    /// &lt;param name=&quot;className&quot;&gt;类的名字&lt;/param&gt;    public void BeginClass(string modifier, string className)    &#123;        BeginBrace($&quot;public &#123;modifier&#125; class &#123;className&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 开始增加类    /// &lt;/summary&gt;    /// &lt;param name=&quot;className&quot;&gt;类的名字&lt;/param&gt;    public void BeginClass(string className)    &#123;        BeginBrace($&quot;public class &#123;className&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 结束类    /// &lt;/summary&gt;    public void EndClass()    &#123;        EndBrace();    &#125;    /// &lt;summary&gt;    /// 开始增加方法    /// &lt;/summary&gt;    /// &lt;param name=&quot;method&quot;&gt;方法名&lt;/param&gt;    /// &lt;param name=&quot;permission&quot;&gt;访问权限&lt;/param&gt;    /// &lt;param name=&quot;returnType&quot;&gt;返回类型&lt;/param&gt;    /// &lt;param name=&quot;modifier&quot;&gt;修饰符&lt;/param&gt;    public void BeginMethod(string method, string permission = &quot;public&quot;, string returnType = &quot;void&quot;,        string modifier = &quot;&quot;)    &#123;        MarkInMethod = true;        BeginBrace(string.IsNullOrEmpty(modifier)            ? $&quot;&#123;permission&#125; &#123;returnType&#125; &#123;method&#125;&quot;            : $&quot;&#123;permission&#125; &#123;modifier&#125; &#123;returnType&#125; &#123;method&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 结束方法    /// &lt;/summary&gt;    public void EndMethod()    &#123;        EndBrace();        MarkInMethod = false;    &#125;    /// &lt;summary&gt;    /// 开始属性    /// &lt;/summary&gt;    /// &lt;param name=&quot;property&quot;&gt;属性名字&lt;/param&gt;    public void BeginProperty(string property)    &#123;        BeginBrace(property);    &#125;    /// &lt;summary&gt;    /// 结束属性    /// &lt;/summary&gt;    public void EndProperty()    &#123;        EndBrace();    &#125;    /// &lt;summary&gt;    /// 大括号的开始    /// &lt;/summary&gt;    /// &lt;param name=&quot;code&quot;&gt;&lt;/param&gt;    public void BeginBrace(string code)    &#123;        AppendLine($&quot;&#123;code&#125;&quot;);        AppendLine(&quot;&#123;&quot;);        BeginBlank();    &#125;    /// &lt;summary&gt;    /// 结束大括号    /// &lt;/summary&gt;    public void EndBrace()    &#123;        EndBlank();        AppendLine(&quot;&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 开始字段    /// &lt;/summary&gt;    /// &lt;param name=&quot;code&quot;&gt;Field的名字&lt;/param&gt;    public void BeginField(string code)    &#123;        AppendLine($&quot;&#123;code&#125;&quot;);        AppendLine(&quot;&#123;&quot;);        BeginBlank();    &#125;    /// &lt;summary&gt;    /// 结束字段    /// &lt;/summary&gt;    public void EndField()    &#123;        EndBlank();        AppendLine(&quot;&#125;;&quot;);    &#125;    /// &lt;summary&gt;    /// 开始Region    /// &lt;/summary&gt;    /// &lt;param name=&quot;name&quot;&gt;Region的名字&lt;/param&gt;    public void BeginRegion(string name)    &#123;        AppendLine($&quot;#region &#123;name&#125;&quot;);    &#125;    /// &lt;summary&gt;    /// 结束Region    /// &lt;/summary&gt;    public void EndRegion()    &#123;        AppendLine(&quot;#endregion&quot;);    &#125;    /// &lt;summary&gt;    /// 转成字符串    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public override string ToString()    &#123;        return m_Builder.ToString();    &#125;&#125;</code></pre><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>上述方法就是辅助的脚本，下面是举例调用方法作为参考  </p><pre><code>// 获取类脚本的路径var scriptPath = AssetDatabase.GUIDToAssetPath(kGUID);var sb = new ScriptBuilder();sb.BeginNamespace(typeof(StorageKeyConst).Namespace);sb.BeginClass(&quot;static&quot;, &quot;StorageKeyConst&quot;);if (DataStorageEditorTools.Instance.DataStorageEditorDataRootList.Count &gt; 0)&#123;    sb.BeginRegion(&quot;RootKeys&quot;);    sb.AppendLine(string.Empty);    AddListScripts(sb, DataStorageEditorTools.Instance.DataStorageEditorDataRootList);    sb.AppendLine(string.Empty);    sb.EndRegion();    sb.AppendLine(string.Empty);&#125;if (DataStorageEditorTools.Instance.DataStorageEditorDataList.Count &gt; 0)&#123;    sb.BeginRegion(&quot;Keys&quot;);    sb.AppendLine(string.Empty);    AddListScripts(sb, DataStorageEditorTools.Instance.DataStorageEditorDataList);    sb.AppendLine(string.Empty);    sb.EndRegion();&#125;sb.EndClass();sb.EndNamespace();File.WriteAllText(scriptPath, sb.ToString(), Encoding.UTF8);AssetDatabase.SaveAssets();AssetDatabase.Refresh();</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;一个辅助快速生成需要的C#脚本的脚本。主要是快速生成引用，命名空间，类和方法一些。&lt;/p&gt;
&lt;h1 id=&quot;脚本和解析&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity杂文——阿拉伯数字转罗马数字</title>
    <link href="http://yoursite.com/2022/12/29/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2022/12/29/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</id>
    <published>2022-12-29T09:40:31.000Z</published>
    <updated>2022-12-29T09:43:19.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>开发中美术想把一些数字换成罗马数字，于是笔者便从网上找到了一种将阿拉伯数字转成罗马数字的方法。  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>/// &lt;summary&gt;/// 数字转罗马数字/// &lt;/summary&gt;/// &lt;param name=&quot;num&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string IntToRoman(int num)&#123;    var res = string.Empty;    var val = new List&lt;int&gt; &#123; 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 &#125;;    var str = new List&lt;string&gt; &#123; &quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot; &#125;;    for(var i = 0;i &lt; val.Count; ++i)    &#123;        while(num &gt;= val[i])        &#123;            num -= val[i];            res += str[i];        &#125;    &#125;    return res;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;开发中美术想把一些数字换成罗马数字，于是笔者便从网上找到了一种将阿拉伯数字转成罗马数字的方法。  &lt;/p&gt;
&lt;h1 id=&quot;代码&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="字符串处理" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——编辑器Foldout右键菜单</title>
    <link href="http://yoursite.com/2022/12/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E5%99%A8Foldout%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/"/>
    <id>http://yoursite.com/2022/12/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E5%99%A8Foldout%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/</id>
    <published>2022-12-28T03:09:37.000Z</published>
    <updated>2022-12-28T03:18:14.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在用编辑器开发工具的时候，我们经常会用到折叠的Foldout，这里就不对Foldout做详细的介绍了，本文主要分享如何对Foldout做一个扩展，笔者在开发中常常需要的一个右键菜单的功能，这样我们就可以添加很多功能而不需要增加按钮，右键选择对应的菜单就行了。  </p><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/FoldoutRightClick-2022-12-2811:17:09.gif"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>var rect = GUILayoutUtility.GetRect(EditorGUIUtility.fieldWidth, EditorGUIUtility.fieldWidth, 18f, 18f,    EditorStyles.foldout);m_IsFoldout = EditorGUI.Foldout(rect, m_IsFoldout, &quot;标题&quot;);CreateNewGenericMenu(rect, new List&lt;string&gt; &#123; &quot;方法一&quot;, &quot;方法二&quot;, &quot;方法三&quot; &#125;, new List&lt;Action&gt;&#123;    (() =&gt; &#123;Debug.LogError(&quot;1&quot;);&#125;),    (() =&gt; &#123;Debug.LogError(&quot;2&quot;);&#125;),    (() =&gt; &#123;Debug.LogError(&quot;3&quot;);&#125;),&#125;);/// &lt;summary&gt;/// 绘制右键菜单/// &lt;/summary&gt;/// &lt;param name=&quot;btnRect&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;menuName&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;menuIsOn&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;menuCallBack&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public GenericMenu CreateNewGenericMenu(Rect btnRect, List&lt;string&gt; menuName, List&lt;Action&gt; menuCallBack,    List&lt;bool&gt; menuIsOn = null)&#123;    var menu = new GenericMenu();    var index = 0;    foreach (var action in menuCallBack)    &#123;        menu.AddItem(new GUIContent(menuName[index]), menuIsOn != null &amp;&amp; menuIsOn[index],            () =&gt; &#123; action?.Invoke(); &#125;);        index++;    &#125;    if (Event.current.button == 1 &amp;&amp; Event.current.type == EventType.MouseDown &amp;&amp;        btnRect.Contains(Event.current.mousePosition))    &#123;        menu.ShowAsContext();    &#125;    return menu;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在用编辑器开发工具的时候，我们经常会用到折叠的Foldout，这里就不对Foldout做详细的介绍了，本文主要分享如何对Foldout做一个</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——UI点击穿透</title>
    <link href="http://yoursite.com/2022/12/17/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UI%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F/"/>
    <id>http://yoursite.com/2022/12/17/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UI%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F/</id>
    <published>2022-12-17T02:11:15.000Z</published>
    <updated>2022-12-17T02:19:25.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>当UI打开一个小的提示tip的时候，常见的需求是点击其他任意地方就关闭tip，这个功能很常见，空白出响应点击，监听到就关闭tip，这里会发现一个问题，我们并不能响应tip面板底下的其他按钮，这样玩家在操作的时候就需要先关掉tip，然后再点一下按钮，这往往不是策划想要的，所以我们需要在点击空白处关闭的时候同时响应底下的按钮，这个时候就需要点击穿透事件。  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>using System.Collections.Generic;using UnityEngine;using UnityEngine.EventSystems;namespace ZHEngine.UI&#123;    public sealed class UTouchPass : MonoBehaviour, IPointerClickHandler,    IMoveHandler,IPointerDownHandler, IPointerUpHandler,IPointerEnterHandler,ISelectHandler, IDeselectHandler    , ISubmitHandler, IInitializePotentialDragHandler, IBeginDragHandler, IEndDragHandler, IDragHandler, IScrollHandler    &#123;        private GameObject CacheGameObject;        private readonly List&lt;RaycastResult&gt; result = new List&lt;RaycastResult&gt;();        public void OnPointerClick(PointerEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.pointerClickHandler);        &#125;        public void OnPointerDown(PointerEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.pointerDownHandler);            if (Input.GetButtonDown(&quot;Submit&quot;))               ExecuteEvents.Execute(eventData.pointerCurrentRaycast.gameObject, eventData, ExecuteEvents.submitHandler);        &#125;        public void OnPointerUp(PointerEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.pointerUpHandler);        &#125;        public void OnPointerEnter(PointerEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.pointerEnterHandler);        &#125;        public void OnSelect(BaseEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.selectHandler);        &#125;        public void OnDeselect(BaseEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.deselectHandler);        &#125;        public void OnSubmit(BaseEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.submitHandler);        &#125;        public void OnMove(AxisEventData eventData)        &#123;            PassEvent(eventData, ExecuteEvents.moveHandler);        &#125;        public void OnInitializePotentialDrag(PointerEventData eventData)        &#123;            CacheGameObject = PassEvent(eventData, ExecuteEvents.initializePotentialDrag);        &#125;        public void OnBeginDrag(PointerEventData eventData)        &#123;             PassEvent(eventData, ExecuteEvents.beginDragHandler);        &#125;        public void OnDrag(PointerEventData eventData)        &#123;            ExecuteEvents.Execute(CacheGameObject, eventData, ExecuteEvents.dragHandler);        &#125;        public void OnEndDrag(PointerEventData eventData)        &#123;            ExecuteEvents.Execute(CacheGameObject, eventData, ExecuteEvents.endDragHandler);            CacheGameObject = null;        &#125;        public void OnScroll(PointerEventData eventData)        &#123;            ExecuteEvents.Execute(CacheGameObject, eventData, ExecuteEvents.scrollHandler);        &#125;        private GameObject PassEvent&lt;T&gt;(BaseEventData data, ExecuteEvents.EventFunction&lt;T&gt; function) where T : IEventSystemHandler        &#123;            if (data is PointerEventData eventData)            &#123;                var pointerGo = eventData.pointerCurrentRaycast.gameObject                    ? eventData.pointerCurrentRaycast.gameObject                    : eventData.pointerDrag;                EventSystem.current.RaycastAll(eventData, result);                foreach (var item in result)                &#123;                    var go = item.gameObject;                    if (go != null &amp;&amp; go != pointerGo)                    &#123;                        var executeGo = ExecuteEvents.GetEventHandler&lt;T&gt;(go);                        if (executeGo)                        &#123;                            if (executeGo.TryGetComponent&lt;UTouchPass&gt;(out var __))                                return null;                            ExecuteEvents.Execute(executeGo, data, function);                            return executeGo;                        &#125;                        else                        &#123;                            if(go.TryGetComponent&lt;UnityEngine.UI.Graphic&gt;(out var com))                            &#123;                                if (com.raycastTarget) return null;                            &#125;                        &#125;                    &#125;                &#125;            &#125;            return null;        &#125;    &#125;&#125;</code></pre><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.xuanyusong.com/archives/4773">Unity3D研究院之UI完整透下事件（一百二十二）——雨松MOMO</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;当UI打开一个小的提示tip的时候，常见的需求是点击其他任意地方就关闭tip，这个功能很常见，空白出响应点击，监听到就关闭tip，这里会发现</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="UI" scheme="http://yoursite.com/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——编辑器下拉多选菜单</title>
    <link href="http://yoursite.com/2022/09/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8B%E6%8B%89%E5%A4%9A%E9%80%89%E8%8F%9C%E5%8D%95/"/>
    <id>http://yoursite.com/2022/09/28/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8B%E6%8B%89%E5%A4%9A%E9%80%89%E8%8F%9C%E5%8D%95/</id>
    <published>2022-09-27T16:10:39.000Z</published>
    <updated>2022-09-27T16:37:18.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>游戏编辑器工具开发中会经常遇到下拉菜单的需求，笔者也遇到了一种特殊的下拉菜单，是下拉后可以多选的菜单，于是笔者便记录下这种特殊菜单的开发脚本。</p><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/20220928_003131-2022-9-2800:34:48.gif">  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><pre><code>public enum DropdownMultiType&#123;    [InspectorName(&quot;无&quot;)] None = 0,    Everything = ~0,    [InspectorName(&quot;类型一&quot;)] Type1 = 1 &lt;&lt; 1,    [InspectorName(&quot;类型二&quot;)] Type2 = 1 &lt;&lt;2,    [InspectorName(&quot;类型三&quot;)] Type3 = 1&lt;&lt;3&#125;</code></pre><h2 id="调用脚本"><a href="#调用脚本" class="headerlink" title="调用脚本"></a>调用脚本</h2><pre><code>m_DropdownMultiType = (DropdownMultiType)EditorGUILayout.EnumFlagsField(m_DropdownMultiType, GUILayout.Width(120))；EditorGUILayout.LabelField($&quot;Type1：&#123;m_DropdownMultiType.HasFlag(DropdownMultiType.Type1)&#125;&quot;);EditorGUILayout.LabelField($&quot;Type2：&#123;m_DropdownMultiType.HasFlag(DropdownMultiType.Type2)&#125;&quot;);EditorGUILayout.LabelField($&quot;Type3：&#123;m_DropdownMultiType.HasFlag(DropdownMultiType.Type3)&#125;&quot;);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;游戏编辑器工具开发中会经常遇到下拉菜单的需求，笔者也遇到了一种特殊的下拉菜单，是下拉后可以多选的菜单，于是笔者便记录下这种特殊菜单的开发脚本</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>常用Python文件处理脚本</title>
    <link href="http://yoursite.com/2022/09/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%B8%B8%E7%94%A8Python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2022/09/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%B8%B8%E7%94%A8Python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/</id>
    <published>2022-09-11T14:50:02.000Z</published>
    <updated>2022-09-11T15:21:42.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Unity打包经常会用一些文件的复制粘贴到一些文件到自己指定的SDK目录，一开始我们使用的是bat脚本，但是笔者发现这个脚本没办法在打包机（MAC）上使用，于是笔者便想到了python脚本来实现。  </p><h1 id="引用的库"><a href="#引用的库" class="headerlink" title="引用的库"></a>引用的库</h1><pre><code>import sysimport osimport jsonimport shutil</code></pre><h1 id="利用json配置需要控制的文件或者文件夹"><a href="#利用json配置需要控制的文件或者文件夹" class="headerlink" title="利用json配置需要控制的文件或者文件夹"></a>利用json配置需要控制的文件或者文件夹</h1><pre><code>&#123;    &quot;remdir&quot;:[        &quot;data/libs/&quot;,        &quot;data/src/main/assets/&quot;        ],    &quot;copydir&quot;:[        &quot;../xarchive/android/unityLibrary/libs/&quot;,        &quot;../xarchive/android/unityLibrary/    ]&#125;</code></pre><h1 id="参数读取"><a href="#参数读取" class="headerlink" title="参数读取"></a>参数读取</h1><pre><code>if (len(sys.argv) &gt; 1):    isPAD = sys.argv[1]if(isPAD == &quot;0&quot;)    ...</code></pre><p>命令执行python脚本的时候通过读取<strong>sys.argv</strong>便可以读取到自己传入的参数，这里需要注意的是读取的都是字符串，所以笔者在读数字0的时候需要用到**”0”**。  </p><h1 id="读取Config配置文件（json）"><a href="#读取Config配置文件（json）" class="headerlink" title="读取Config配置文件（json）"></a>读取Config配置文件（json）</h1><pre><code>configFilePath = &quot;config.json&quot;;with open(configFilePath,&#39;r&#39;) as load_f:    load_dict = json.load(load_f)</code></pre><h1 id="删除目录文件或者文件夹"><a href="#删除目录文件或者文件夹" class="headerlink" title="删除目录文件或者文件夹"></a>删除目录文件或者文件夹</h1><pre><code>def path_remove(removepath):    for remdirPath in removepath:        try:            if os.path.exists(remdirPath):                if os.path.isdir(remdirPath):                    shutil.rmtree(remdirPath)                else:                    os.remove(remdirPath)                print(&quot;Remove Success: &quot;+remdirPath)        except OSError as e:            print(&quot;Error: %s : %s&quot; % (remdirPath, e.strerror))</code></pre><h1 id="复制文件或者文件夹到指定目录"><a href="#复制文件或者文件夹到指定目录" class="headerlink" title="复制文件或者文件夹到指定目录"></a>复制文件或者文件夹到指定目录</h1><pre><code>def proc_copy(old_path, new_path):    if os.path.exists(old_path):        if os.path.isdir(old_path):            shutil.copytree(old_path, new_path)        elif os.path.isfile(old_path):            shutil.copyfile(old_path, new_path)        print(&quot;Copy Success: &quot; + old_path)    else:        print(&quot;NOT FOUND: &#123;&#125;&quot;.format(old_path))def path_copy(copydir, pastedir):    for index in range(len(copydir)):        if os.path.exists(pastedir[index]):            if os.path.isdir(pastedir[index]):                shutil.rmtree(pastedir[index])        proc_copy(copydir[index],pastedir[index])</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Unity打包经常会用一些文件的复制粘贴到一些文件到自己指定的SDK目录，一开始我们使用的是bat脚本，但是笔者发现这个脚本没办法在打包机（</summary>
      
    
    
    
    <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——Android设备唯一标识</title>
    <link href="http://yoursite.com/2022/09/02/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Android%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86/"/>
    <id>http://yoursite.com/2022/09/02/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Android%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86/</id>
    <published>2022-09-02T09:18:27.000Z</published>
    <updated>2022-09-03T08:59:13.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>获取设备唯一标识的方法。</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>引用库的github地址：<a href="https://github.com/gzu-liyujiang/Android_CN_OAID/tree/master"><font color="steelblue" size="5">Android_CN_OAID</font></a><br>在Android最外层的bundel.gradle里添加下面依赖  </p><pre><code>allprojects &#123;    repositories &#123;        &#39;&#39;&#39;        maven &#123; url &#39;https://www.jitpack.io&#39; &#125;        ...    &#125;&#125;</code></pre><p>在app或者library的bundel.gradle添加下面依赖  </p><pre><code>dependencies &#123;implementation &#39;com.github.gzu-liyujiang:Android_CN_OAID:&lt;version&gt;&#39;&#125;</code></pre><p><version>这里换成自己需要的版本</version></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="引用的库的初始化"><a href="#引用的库的初始化" class="headerlink" title="引用的库的初始化"></a>引用的库的初始化</h2><p>在Application或者Active的onCreate里添加下面代码：  </p><pre><code>@Overridepublic void onCreate() &#123;    super.onCreate();    if (privacyPolicyAgreed) &#123;        ...        DeviceIdentifier.register(&lt;Application&gt;);        ...    &#125;&#125;</code></pre><p><Application>这里替换成自己程序的application</Application></p><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>需要的变量： </p><pre><code>//设备唯一标识private static String deviceId;//设备唯一标识文件名字private static String deviceIdFileName = &quot;all_in_sdk&quot;;//设备唯一标识缓存关键字keyprivate static String deviceIdKey = &quot;DeviceId&quot;;//设备唯一标识正则private static final Pattern ANDROID_ID_PATTERN = Pattern.compile(&quot;^[0-9a-fA-F]&#123;16&#125;$&quot;);</code></pre><p>获取的方法：</p><pre><code>//获取设备的唯一标识public static String GetDeviceID() &#123;    if(m_Activity == null)&#123;        m_Activity = UnityPlayer.currentActivity;    &#125;    Application application = m_Activity.getApplication();    if (application == null)        return &quot;&quot;;    if (deviceId != null)        return deviceId;    deviceId = getSPValue((Context)application, deviceIdKey);    if (!TextUtils.isEmpty(deviceId))        return deviceId;    deviceId = getAndroidIdAsDeviceId((Context)application);    if (!TextUtils.isEmpty(deviceId)) &#123;        saveSPValue((Context)application, deviceIdKey, deviceId);        return deviceId;    &#125;    deviceId = generateSoftDeviceId();    if (!TextUtils.isEmpty(deviceId)) &#123;        saveSPValue((Context)application, deviceIdKey, deviceId);        return deviceId;    &#125;    return deviceId;&#125;private static String getSPValue(Context paramContext, String paramString) &#123;    SharedPreferences sharedPreferences = paramContext.getSharedPreferences(deviceIdFileName, 0);    return sharedPreferences.getString(paramString, null);&#125;private static String getAndroidIdAsDeviceId(Context paramContext) &#123;    String str;    if(DeviceID.supportedOAID(m_Activity))    &#123;        str = DeviceIdentifier.getOAID(m_Activity);        if (isLegalAndroidId(str, true))            return str;    &#125;    str = DeviceIdentifier.getAndroidID(m_Activity);    if (isLegalAndroidId(str, true))        return str;    str = DeviceIdentifier.getIMEI(m_Activity);    if (isLegalAndroidId(str, true))        return str;    str = DeviceIdentifier.getWidevineID();    if (isLegalAndroidId(str, true))        return str;    str = DeviceIdentifier.getPseudoID();    if (isLegalAndroidId(str, true))        return str;    str = DeviceIdentifier.getGUID(m_Activity);    if (isLegalAndroidId(str, true))        return str;    return null;&#125;private static String generateSoftDeviceId() &#123;    String str1 = Build.SERIAL;    String str2 = !TextUtils.isEmpty(str1) ? str1 : &quot;NA&quot;;    try &#123;        long l1 = 1152921504606846976L;        long l2 = randomLong(Long.MAX_VALUE - l1) + l1;        return String.format(&quot;%1$s_%2$s&quot;, new Object[] &#123; Long.toHexString(l2), str2 &#125;);    &#125; catch (Throwable throwable) &#123;        return String.format(&quot;%1$s_%2$s&quot;, new Object[] &#123; &quot;NA&quot; + Long.toHexString(System.currentTimeMillis()), str2 &#125;);    &#125;&#125;private static void saveSPValue(Context paramContext, String paramString1, String paramString2) &#123;    SharedPreferences sharedPreferences = paramContext.getSharedPreferences(deviceIdFileName, 0);    sharedPreferences.edit().putString(paramString1, paramString2).apply();&#125;private static long randomLong(long paramLong) &#123;    if (Build.VERSION.SDK_INT &gt;= 21)        return ThreadLocalRandom.current().nextLong(paramLong);    return (long)((new Random()).nextDouble() * (paramLong - 1L));&#125;private static boolean isLegalAndroidId(String paramString, boolean paramBoolean) &#123;    if (paramBoolean)        return (!TextUtils.isEmpty(paramString) &amp;&amp; ANDROID_ID_PATTERN                .matcher(paramString).find());    return (!TextUtils.isEmpty(paramString) &amp;&amp; ANDROID_ID_PATTERN            .matcher(paramString).find());&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;获取设备唯一标识的方法。&lt;/p&gt;
&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——UI父节点随子节点自适应</title>
    <link href="http://yoursite.com/2022/08/24/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UI%E7%88%B6%E8%8A%82%E7%82%B9%E9%9A%8F%E5%AD%90%E8%8A%82%E7%82%B9%E8%87%AA%E9%80%82%E5%BA%94/"/>
    <id>http://yoursite.com/2022/08/24/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94UI%E7%88%B6%E8%8A%82%E7%82%B9%E9%9A%8F%E5%AD%90%E8%8A%82%E7%82%B9%E8%87%AA%E9%80%82%E5%BA%94/</id>
    <published>2022-08-24T11:56:54.000Z</published>
    <updated>2022-08-24T12:11:41.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在UI的开发过程中，经常会遇到Image随子节点的文字变化自动缩放，就是拿Image当背景。笔者遇到这种问题每次都是利用Layout+Content Size Fitter来完成的，笔者想了想每次都要加两个组件，并且Layout只用到了随自己点自适应的功能，于是笔者便想办法把两个功能合成一个脚本来实现需求，于是便有了下面的脚本。  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>代码如下： </p><pre><code>using System;using UnityEngine;using UnityEngine.EventSystems;using UnityEngine.UI;/// &lt;summary&gt;/// 未完成，暂时别用/// &lt;/summary&gt;[AddComponentMenu(&quot;Layout/Rect Transform Fitter&quot;, 142)][ExecuteAlways][RequireComponent(typeof(RectTransform))]public class RectTransformFit : UIBehaviour, ILayoutGroup&#123;    [SerializeField] protected RectTransform m_RectChildren;    [SerializeField] protected RectOffset m_Padding = new RectOffset();    [SerializeField] protected TextAnchor m_ChildAlignment = TextAnchor.UpperLeft;    [SerializeField] protected bool m_ChildControlWidth = false;    [SerializeField] protected bool m_ChildControlHeight = false;    [SerializeField] protected ContentSizeFitter.FitMode m_HorizontalFit = ContentSizeFitter.FitMode.Unconstrained;    [SerializeField] protected ContentSizeFitter.FitMode m_VerticalFit = ContentSizeFitter.FitMode.Unconstrained;    public RectOffset padding    &#123;        get =&gt; m_Padding;        set =&gt; SetProperty(ref m_Padding, value);    &#125;    public TextAnchor childAlignment &#123; get =&gt; m_ChildAlignment;        set =&gt; SetProperty(ref m_ChildAlignment, value);    &#125;    public bool childControlWidth    &#123;        get =&gt; m_ChildControlWidth;        set =&gt; SetProperty(ref m_ChildControlWidth, value);    &#125;    public bool childControlHeight    &#123;        get =&gt; m_ChildControlHeight;        set =&gt; SetProperty(ref m_ChildControlHeight, value);    &#125;    public ContentSizeFitter.FitMode horizontalFit    &#123;        get =&gt; m_HorizontalFit;        set        &#123;            if (SetPropertyUtility.SetStruct(ref m_HorizontalFit, value)) SetDirty();        &#125;    &#125;    public ContentSizeFitter.FitMode verticalFit    &#123;        get =&gt; m_VerticalFit;        set        &#123;            if (SetPropertyUtility.SetStruct(ref m_VerticalFit, value)) SetDirty();        &#125;    &#125;    [NonSerialized] private RectTransform m_Rect;    protected RectTransform rectTransform    &#123;        get        &#123;            if (m_Rect == null)                m_Rect = GetComponent&lt;RectTransform&gt;();            return m_Rect;        &#125;    &#125;#pragma warning disable 649    private DrivenRectTransformTracker m_Tracker;#pragma warning restore 649    private void OnEnable()    &#123;        m_Rect ??= GetComponent&lt;RectTransform&gt;();        SetDirty();    &#125;    protected override void OnRectTransformDimensionsChange()    &#123;        SetDirty();    &#125;    protected override void OnDisable()    &#123;        m_Tracker.Clear();        base.OnDisable();    &#125;    /// &lt;summary&gt;    /// Calculate and apply the horizontal component of the size to the RectTransform    /// &lt;/summary&gt;    public void SetLayoutHorizontal()    &#123;        m_Tracker.Clear();        if (m_RectChildren == null || !m_ChildControlWidth)        &#123;            SetDirty();            return;        &#125;        HandleSelfFittingAlongAxis(0, m_RectChildren);    &#125;    /// &lt;summary&gt;    /// Calculate and apply the vertical component of the size to the RectTransform    /// &lt;/summary&gt;    public void SetLayoutVertical()    &#123;        if (m_RectChildren == null || !m_ChildControlHeight)        &#123;            SetDirty();            return;        &#125;        HandleSelfFittingAlongAxis(1, m_RectChildren);    &#125;    private void HandleSelfFittingAlongAxis(int axis, RectTransform rectChild)    &#123;        if (rectChild == null) return;        var fitting = (axis == 0 ? horizontalFit : verticalFit);        if (fitting == ContentSizeFitter.FitMode.Unconstrained)        &#123;            // Keep a reference to the tracked transform, but don&#39;t control its properties:            m_Tracker.Add(this, rectChild, DrivenTransformProperties.None);            return;        &#125;        m_Tracker.Add(this, rectChild,            (axis == 0 ? DrivenTransformProperties.SizeDeltaX : DrivenTransformProperties.SizeDeltaY));        // Set size to min or preferred size        rectChild.SetSizeWithCurrentAnchors((RectTransform.Axis)axis,            fitting == ContentSizeFitter.FitMode.MinSize                ? LayoutUtility.GetMinSize(rectChild, axis)                : LayoutUtility.GetPreferredSize(rectChild, axis));        SetDirty();    &#125;    /// &lt;summary&gt;    /// Helper method used to set a given property if it has changed.    /// &lt;/summary&gt;    /// &lt;param name=&quot;currentValue&quot;&gt;A reference to the member value.&lt;/param&gt;    /// &lt;param name=&quot;newValue&quot;&gt;The new value.&lt;/param&gt;    protected void SetProperty&lt;T&gt;(ref T currentValue, T newValue)    &#123;        if ((currentValue == null &amp;&amp; newValue == null) || (currentValue != null &amp;&amp; currentValue.Equals(newValue)))            return;        currentValue = newValue;        SetDirty();    &#125;    protected void SetDirty()    &#123;        if (!IsActive())            return;        RefreshRect();        LayoutRebuilder.MarkLayoutForRebuild(m_RectChildren);        LayoutRebuilder.MarkLayoutForRebuild(m_Rect);    &#125;    public void RefreshRect()    &#123;        if (m_RectChildren == null) return;        Vector2 anchoredPos;        var childSize = m_RectChildren.sizeDelta;        var width = childSize.x + padding.left + padding.right;        var height = childSize.y + padding.top + padding.bottom;        var rectSize = rectTransform.sizeDelta;        if (horizontalFit != ContentSizeFitter.FitMode.Unconstrained &amp;&amp;            verticalFit != ContentSizeFitter.FitMode.Unconstrained)        &#123;            rectTransform.sizeDelta = new Vector2(width, height);        &#125;        else if (horizontalFit != ContentSizeFitter.FitMode.Unconstrained)        &#123;            rectTransform.sizeDelta = new Vector2(width, rectSize.y);        &#125;        else if (verticalFit != ContentSizeFitter.FitMode.Unconstrained)        &#123;            rectTransform.sizeDelta = new Vector2(rectSize.x, height);        &#125;        rectSize = rectTransform.sizeDelta;        var oldPos = rectTransform.anchoredPosition;        var oldPivot = rectTransform.pivot;        switch (m_ChildAlignment)        &#123;            case TextAnchor.UpperLeft:                rectTransform.pivot = new Vector2(0, 1);                anchoredPos = new Vector2(padding.left, -padding.top);                break;            case TextAnchor.UpperCenter:                rectTransform.pivot = new Vector2(0.5f, 1);                anchoredPos = new Vector2(0, -padding.top);                break;            case TextAnchor.UpperRight:                rectTransform.pivot = new Vector2(1, 1);                anchoredPos = new Vector2(-padding.right, -padding.top);                break;            case TextAnchor.MiddleLeft:                rectTransform.pivot = new Vector2(0, 0.5f);                anchoredPos = new Vector2(padding.left, 0);                break;            case TextAnchor.MiddleCenter:                rectTransform.pivot = new Vector2(0.5f, 0);                anchoredPos = new Vector2(0, 0);                break;            case TextAnchor.MiddleRight:                rectTransform.pivot = new Vector2(1, 0);                anchoredPos = new Vector2(-padding.right, 0);                break;            case TextAnchor.LowerLeft:                rectTransform.pivot = new Vector2(0, 0);                anchoredPos = new Vector2(padding.left, padding.bottom);                break;            case TextAnchor.LowerCenter:                rectTransform.pivot = new Vector2(0.5f, 0);                anchoredPos = new Vector2(0, padding.bottom);                break;            case TextAnchor.LowerRight:                rectTransform.pivot = new Vector2(1, 0);                anchoredPos = new Vector2(-padding.right, padding.bottom);                break;            default:                throw new ArgumentOutOfRangeException();        &#125;        var pivot = rectTransform.pivot;        rectTransform.anchoredPosition = new Vector2(oldPos.x + rectSize.x * (pivot.x - oldPivot.x),            oldPos.y + rectSize.y * (pivot.y - oldPivot.y));        m_RectChildren.anchorMax = pivot;        m_RectChildren.anchorMin = pivot;        m_RectChildren.pivot = pivot;        m_RectChildren.anchoredPosition = anchoredPos;    &#125;#if UNITY_EDITOR    protected override void OnValidate()    &#123;        SetDirty();    &#125;#endif&#125;</code></pre><h1 id="需要支持的脚本（源码抄来的SetPropertyUtility）"><a href="#需要支持的脚本（源码抄来的SetPropertyUtility）" class="headerlink" title="需要支持的脚本（源码抄来的SetPropertyUtility）"></a>需要支持的脚本（源码抄来的SetPropertyUtility）</h1><pre><code>using System;using System.Collections.Generic;using UnityEngine;internal static class SetPropertyUtility&#123;    private const float Tolerance = 0.000001f;                 //通过此值判断值是否发生变化    public static bool SetColor(ref Color currentValue, Color newValue)    &#123;        if (Math.Abs(currentValue.r - newValue.r) &lt; Tolerance &amp;&amp;            Math.Abs(currentValue.g - newValue.g) &lt; Tolerance &amp;&amp;            Math.Abs(currentValue.b - newValue.b) &lt; Tolerance &amp;&amp;            Math.Abs(currentValue.a - newValue.a) &lt; Tolerance)            return false;        currentValue = newValue;        return true;    &#125;    public static bool SetStruct&lt;T&gt;(ref T currentValue, T newValue) where T : struct    &#123;        if (EqualityComparer&lt;T&gt;.Default.Equals(currentValue, newValue))            return false;        currentValue = newValue;        return true;    &#125;    public static bool SetClass&lt;T&gt;(ref T currentValue, T newValue) where T : class    &#123;        if ((currentValue == null &amp;&amp; newValue == null) || (currentValue != null &amp;&amp; currentValue.Equals(newValue)))            return false;        currentValue = newValue;        return true;    &#125;&#125;</code></pre><h1 id="编辑器显示Editor代码"><a href="#编辑器显示Editor代码" class="headerlink" title="编辑器显示Editor代码"></a>编辑器显示Editor代码</h1><p>代码如下： </p><pre><code>using System;using UnityEditor;using UnityEditor.UI;using UnityEngine;[CustomEditor(typeof(RectTransformFit))]public class RectTransformFitEditor : SelfControllerEditor&#123;    SerializedProperty m_Padding;    SerializedProperty m_ChildAlignment;    SerializedProperty m_RectChildren;    SerializedProperty m_HorizontalFit;    SerializedProperty m_VerticalFit;    SerializedProperty m_ChildControlWidth;    SerializedProperty m_ChildControlHeight;    protected void OnEnable()    &#123;        m_Padding = serializedObject.FindProperty(&quot;m_Padding&quot;);        m_ChildAlignment = serializedObject.FindProperty(&quot;m_ChildAlignment&quot;);        m_RectChildren = serializedObject.FindProperty(&quot;m_RectChildren&quot;);        m_ChildControlWidth = serializedObject.FindProperty(&quot;m_ChildControlWidth&quot;);        m_ChildControlHeight = serializedObject.FindProperty(&quot;m_ChildControlHeight&quot;);        m_HorizontalFit = serializedObject.FindProperty(&quot;m_HorizontalFit&quot;);        m_VerticalFit = serializedObject.FindProperty(&quot;m_VerticalFit&quot;);    &#125;    public override void OnInspectorGUI()    &#123;        serializedObject.Update();        EditorGUILayout.PropertyField(m_Padding, true);        EditorGUILayout.PropertyField(m_ChildAlignment, true);        EditorGUILayout.PropertyField(m_RectChildren, true);        Rect rect = EditorGUILayout.GetControlRect();        rect = EditorGUI.PrefixLabel(rect, -1, EditorGUIUtility.TrTextContent(&quot;Control Child Size&quot;));        rect.width = Mathf.Max(50, (rect.width - 4) / 3);        EditorGUIUtility.labelWidth = 50;        ToggleLeft(rect, m_ChildControlWidth, EditorGUIUtility.TrTextContent(&quot;Width&quot;));        rect.x += rect.width + 2;        ToggleLeft(rect, m_ChildControlHeight, EditorGUIUtility.TrTextContent(&quot;Height&quot;));        EditorGUIUtility.labelWidth = 0;        EditorGUILayout.PropertyField(m_HorizontalFit, true);        EditorGUILayout.PropertyField(m_VerticalFit, true);        serializedObject.ApplyModifiedProperties();    &#125;    void ToggleLeft(Rect position, SerializedProperty property, GUIContent label)    &#123;        bool toggle = property.boolValue;        EditorGUI.showMixedValue = property.hasMultipleDifferentValues;        EditorGUI.BeginChangeCheck();        int oldIndent = EditorGUI.indentLevel;        EditorGUI.indentLevel = 0;        toggle = EditorGUI.ToggleLeft(position, label, toggle);        EditorGUI.indentLevel = oldIndent;        if (EditorGUI.EndChangeCheck())        &#123;            property.boolValue = property.hasMultipleDifferentValues || !property.boolValue;        &#125;        EditorGUI.showMixedValue = false;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在UI的开发过程中，经常会遇到Image随子节点的文字变化自动缩放，就是拿Image当背景。笔者遇到这种问题每次都是利用Layout+Con</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="UGUI" scheme="http://yoursite.com/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>hexo图床图片无法显示</title>
    <link href="http://yoursite.com/2022/08/20/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/hexo%E5%9B%BE%E5%BA%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2022/08/20/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/hexo%E5%9B%BE%E5%BA%8A%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/</id>
    <published>2022-08-20T10:05:02.000Z</published>
    <updated>2022-08-20T10:15:38.397Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>今天更新自己博客的时候发现新博客的图片都无法显示，这个听说只存在于没有域名的博客中，笔者因为没有域名，所以不清除是不是。  </p><blockquote><p>图床：gitee<br>博客：github+hexo<br>原因猜测：gitee开始对图床进行限制，没有域名的博客也访问不到图床的图片  </p></blockquote><p>#解决方法 </p><h2 id="方法一（不推荐）"><a href="#方法一（不推荐）" class="headerlink" title="方法一（不推荐）"></a>方法一（不推荐）</h2><p>最快捷的解决方案就是再自己博客的文章开头加上下面代码   </p><pre><code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</code></pre><p>看下面举例  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1660990253369-2022-8-2018:10:54.png"></p><h2 id="方法二（推荐）"><a href="#方法二（推荐）" class="headerlink" title="方法二（推荐）"></a>方法二（推荐）</h2><p>在自己播放的主题文件加里直接加上就不需要了，具体路径：<br>拿3-hexo主题举例：<br>在**…\themes\3-hexo\layout_partial\header.ejs**文件里加入刚才的代码，如下：  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1660990452909-2022-8-2018:14:13.png">  </p><p>其他主题文件在类似位置：<strong>hexo\themes...\layout_partial\head.ejs</strong><br>其他主题的文件名字应该叫：<strong>head.ejs</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;今天更新自己博客的时候发现新博客的图片都无法显示</summary>
      
    
    
    
    <category term="搭建博客" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="hexo博客" scheme="http://yoursite.com/tags/hexo%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——Unity的Animation无法播放</title>
    <link href="http://yoursite.com/2022/08/20/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Unity%E7%9A%84Animation%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE/"/>
    <id>http://yoursite.com/2022/08/20/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94Unity%E7%9A%84Animation%E6%97%A0%E6%B3%95%E6%92%AD%E6%94%BE/</id>
    <published>2022-08-20T06:57:28.000Z</published>
    <updated>2022-08-20T09:52:46.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>笔者再开发过程中，有个功能需求是在游戏中移动Camera，笔者采用了两种方式，第一种是K动画用动画播放，另一种是用曲线表示运动节奏直线运动。第二种方式和本文无关，主要阐述第一种方式在播放Animation的时候无法播放的问题。  </p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者采用的是Animation的方式播放动画，笔者并未采用Animator，是在游戏中进行动态添加Animation组件，然后根据资源名字动态加载动画资源进行播放，下面是案例代码：  </p><pre><code>public float LookAtAnim(string animName)&#123;    if (!m_Transfrom.TryGetComponent(out Animation animation))    &#123;        animation = m_Transfrom.gameObject.AddComponent&lt;Animation&gt;();    &#125;    var clip = animation.GetClip(animName);    if (clip == null)    &#123;        clip = ResManager.LoadAsset&lt;AnimationClip&gt;(animName);        animation.AddClip(clip, animName);    &#125;    animation.clip = clip;    animation.Play(animName);    return clip.length;&#125;</code></pre><p>但是笔者在运行过程中发现编辑器并不能正常播放动画，通过断点调试，笔者发现在添加动画clip的时候并不能添加到Animation的clip列表里，于是笔者通过各种百度，谷歌等搜索发现需要打开Animation的legacy，修改后的代码如下：</p><pre><code>public float LookAtAnim(string animName)&#123;    ...    if (clip == null)    &#123;        clip = ResManager.LoadAsset&lt;AnimationClip&gt;(animName);        clip.legacy = true;        animation.AddClip(clip, animName);    &#125;    ...&#125;</code></pre><p>这时候动画播放正常了，但是笔者打包成apk后，在模拟器上依旧无法正常播放，笔者打印日志发现动画都正常添加了，于是笔者便尝试解决问题。  </p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>笔者思考**clip.legacy &#x3D; true;**这行代码的作用，于是笔者发现有可能是动画的问题，首先打开inspector的debug模式   </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1660979445735-2022-8-2015:10:46.png"><br>然后发现有些动画的Legacy是打开的，有些是关闭的，于是笔者都手动打开了  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1660979791351-2022-8-2015:16:31.png"><br>发现模拟器依旧没办法播放，最后发现真机上只需要把这个关闭就可以了。<br>笔者最终抛弃了Animation的方法，因为还需要手动加载资源，笔者采用了Animator的方式进行播放。代码如下：  </p><pre><code>/// &lt;summary&gt;/// 播放相机动画/// &lt;/summary&gt;/// &lt;param name=&quot;animName&quot;&gt;动画名字&lt;/param&gt;public float LookAtAnim(string animName)&#123;    SetAnimatorVisible(true);    m_Animator.Play(animName);    return (from animationClip in m_Animator.runtimeAnimatorController.animationClips        where animationClip.name == animName        select animationClip.length).FirstOrDefault();&#125;public void SetAnimatorVisible(bool visible)&#123;    if (m_Animator != null &amp;&amp; m_Animator.enabled == visible) return;    if(visible)    &#123;        if(m_Animator == null)        &#123;            m_Animator = m_Transfrom.gameObject.AddComponent&lt;Animator&gt;();            m_Animator.runtimeAnimatorController =                ResManager.LoadAsset&lt;RuntimeAnimatorController&gt;(TableGlobal.CameraController);        &#125;        else        &#123;            m_Animator.enabled = true;        &#125;    &#125;    else if (m_Animator != null)    &#123;        m_Animator.DOKill();        m_Animator.enabled = false;    &#125;&#125;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>切记要把动画资源的Legacy关闭，否则Animator也无法播放动画片段</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;笔者再开发过程中，有个功能需求是在游戏中移动Camera，笔者采用了两种方式，第一种是K动画用动画播放，另一种是用曲线表示运动节奏直线运动。</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Animation" scheme="http://yoursite.com/tags/Animation/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——根据条件禁用编辑器菜单</title>
    <link href="http://yoursite.com/2022/03/24/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E7%A6%81%E7%94%A8%E7%BC%96%E8%BE%91%E5%99%A8%E8%8F%9C%E5%8D%95/"/>
    <id>http://yoursite.com/2022/03/24/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E7%A6%81%E7%94%A8%E7%BC%96%E8%BE%91%E5%99%A8%E8%8F%9C%E5%8D%95/</id>
    <published>2022-03-24T06:20:07.000Z</published>
    <updated>2022-08-20T09:54:08.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>unity编辑器扩展菜单功能是我们开发中经常使用的，笔者在开发过程中想在特定条件下在启用指定的菜单，不满足条件的时候就禁用菜单，于是笔者找到了解决的办法。  </p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><pre><code>[MenuItem(&quot;Assets/MyMenuTest&quot;, false, 81)]public static void MyMenuTest()&#123;    //菜单执行事件&#125;[MenuItem(&quot;Assets/MyMenuTest&quot;, true)]public static bool IsShowMyMenu()&#123;    //获取自己的条件并return条件即可    return false;&#125;</code></pre><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1648103657696-2022-3-2414:34:18.png">  </p><p>只需要保证MenuItem的菜单路径一样的，把第二个参数改为true代表的是否是控制一个验证函数，根据自己的条件进行返回即可控制。   </p><p>下面是官网给的参数设置<br><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1648103567771-2022-3-2414:32:48.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;unity编辑器扩展菜单功能是我们开发中经常使用的，笔者在开发过程中想在特定条件下在启用指定的菜单，不满足条件的时候就禁用菜单，于是笔者找到</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——自动创建asset资源文件</title>
    <link href="http://yoursite.com/2022/03/21/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BAasset%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2022/03/21/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BAasset%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/</id>
    <published>2022-03-21T06:36:13.000Z</published>
    <updated>2022-03-21T06:51:04.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Unity保存数据的方式有很多，比如我们经常用的json，xml和Txt，笔者今天讲到的是另外一种保存方式，asset文件，这个是unity提供的一种新的保存数据的方式，笔者也是刚使用没多久，这里就不详细进行介绍了，笔者今天主要是介绍一键自动创建对应的asset文件。  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code> public class CreateAssetEditor&#123;    [MenuItem(&quot;Assets/Create/CreateAsset&quot;,false,81)]    public static void OnCreateAsset()    &#123;        foreach (var guid in Selection.assetGUIDs)        &#123;            var path = AssetDatabase.GUIDToAssetPath(guid);            var pathSplit = path.Split(&#39;/&#39;);            var className = pathSplit[pathSplit.Length - 1].Replace(&quot;.cs&quot;, &quot;&quot;);            var classType = GetClassByClassName(className);            var assetPath = path.Replace(&quot;.cs&quot;, &quot;.asset&quot;);            if (File.Exists(assetPath))            &#123;                LBLogWrapper.Error(&quot;创建失败，资源已经存在&quot;);            &#125;            else if (classType != null)             &#123;                var classInst = ScriptableObject.CreateInstance(classType);                AssetDatabase.CreateAsset(classInst,assetPath);            &#125;            else            &#123;                LBLogWrapper.Error(&quot;创建失败，脚本不可创建&quot;);            &#125;        &#125;    &#125;        [MenuItem(&quot;Assets/Create/CreateAsset&quot;,true)]    private static bool IsValidateFun()    &#123;        return (from guid in Selection.assetGUIDs            select AssetDatabase.GUIDToAssetPath(guid)            into path            select path.Split(&#39;/&#39;)            into pathSplit            select pathSplit[pathSplit.Length - 1]).Any(className =&gt; className.Contains(&quot;.cs&quot;));    &#125;    /// &lt;summary&gt;    /// 通过类名获取对应的类    /// &lt;/summary&gt;    /// &lt;param name=&quot;className&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    private static Type GetClassByClassName(string className)    &#123;        var allAssemblies = AppDomain.CurrentDomain.GetAssemblies();        return allAssemblies.SelectMany(assembly =&gt; assembly.GetTypes()).FirstOrDefault(type =&gt;            type.Name == className &amp;&amp; type.IsSubclassOf(typeof(ScriptableObject)));    &#125;&#125;</code></pre><p>脚本的原理很简单，就是获取当前选择的脚本，判断是否可以创建asset文件，如果可以就是通过类名获取对应的类对象和，这里需要注意的是，<font color="red">文件名字必须等于类名</font>，然后通过类名获取对应的类型，就可以生成对应的asset文件了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Unity保存数据的方式有很多，比如我们经常用的json，xml和Txt，笔者今天讲到的是另外一种保存方式，asset文件，这个是unity</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="asset" scheme="http://yoursite.com/tags/asset/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——通过类名获取对应的Type</title>
    <link href="http://yoursite.com/2022/03/11/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E7%B1%BB%E5%90%8D%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E7%9A%84Type/"/>
    <id>http://yoursite.com/2022/03/11/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E7%B1%BB%E5%90%8D%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E7%9A%84Type/</id>
    <published>2022-03-11T07:36:03.000Z</published>
    <updated>2022-03-11T08:06:58.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>笔者在编辑器开发过程中遇到一个问题，笔者想通过一个类的名字获取对应的类的Type然后再做一系列的操作，但是笔者发现无法直接获取，于是笔者通过不断的尝试通过下面的方法获取到了，如果有更好的方法欢迎告诉笔者。  </p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>话不多说，先上代码：  </p><pre><code>[MenuItem(&quot;Assets/GetType&quot;,false,81)]public static void GetClassTypeByClassTypeName()&#123;    const string className = &quot;TestScripts&quot;;    //方法一（在同一程序集内并且非自身Class才能获取到）    var type = Type.GetType(className);    Debug.LogError(type);        var allAssemblies = AppDomain.CurrentDomain.GetAssemblies();        //方法二（有特殊情况会获取不到，笔者没找到获取不到的原因）    type = allAssemblies.Select(assembly =&gt; assembly.GetType(className)).FirstOrDefault(assembly =&gt; assembly != null);    Debug.LogError(type);        //方法三（如果存在类重名的情况有概率获取错误，可以通过路径做限制）    type = allAssemblies.SelectMany(assembly =&gt; assembly.GetTypes()).FirstOrDefault(type1 =&gt; type1.Name == className);    Debug.LogError(type);&#125;</code></pre><p>运行结果如下  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1646985481130-2022-3-1115:58:02.png">  </p><p>方法一和方法二的获取条件都有限制，因此笔者建议使用方法三进行获取。  </p><h1 id="获取方式讲解"><a href="#获取方式讲解" class="headerlink" title="获取方式讲解"></a>获取方式讲解</h1><p>方法一是直接在当前程序集进行获取的。<br>方法二是通过遍历当前程序的所有程序集，然后通过程序集直接GetType进行获取<br>方法三是类似于方法二，得到所有的程序集再遍历程序集中的Type，判断名字是否相同来得到对应的Type</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;笔者在编辑器开发过程中遇到一个问题，笔者想通过一个类的名字获取对应的类的Type然后再做一系列的操作，但是笔者发现无法直接获取，于是笔者通过</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="C#反射" scheme="http://yoursite.com/tags/C-%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——按行删除字符串</title>
    <link href="http://yoursite.com/2022/03/10/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2022/03/10/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-03-10T09:02:29.000Z</published>
    <updated>2022-03-10T09:07:58.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>笔者在项目开发过程中需要做一个聊天的假数据显示，是用于demo的，于是笔者就直接用string字符串来模拟显示的数据，但是当聊天内容过多的时候就需要删除历史的聊天内容，于是笔者就想按照行数删除字符串，发现string并不包含这种接口，于是写下了下面的代码。  </p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><pre><code>private static string DeleteStrLine(string text, int startLine, int lineCount)&#123;    var curIndex = 0;    int? remStartIndex = null;    var sum = 1;    while (sum &lt; startLine + lineCount)     &#123;        if (sum == startLine) remStartIndex = curIndex;                curIndex = text.IndexOf(&quot;\n&quot;, curIndex, StringComparison.Ordinal);        if (curIndex &lt; 0)        &#123;            curIndex = text.Length;            break;        &#125;        curIndex++;        sum++;    &#125;    if (remStartIndex == null)    &#123;        return text;    &#125;    text = text.Remove(remStartIndex.Value, curIndex - remStartIndex.Value);    return text;&#125;</code></pre><p>上述代码是笔者的解决方案，原理很简单，遍历查找字符串的换行字符**”\n”**,然后记录下索引，根据传入的需要删除的行数找到对应的索引，最后使用Remove函数按照开始和结束的索引进行删除。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;笔者在项目开发过程中需要做一个聊天的假数据显示，是用于demo的，于是笔者就直接用string字符串来模拟显示的数据，但是当聊天内容过多的时</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>StarUML使用笔记</title>
    <link href="http://yoursite.com/2022/03/04/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/StarUML%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/03/04/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/StarUML%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-04T07:46:19.000Z</published>
    <updated>2022-03-10T07:01:11.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图操作菜单"><a href="#图操作菜单" class="headerlink" title="图操作菜单"></a>图操作菜单</h1><h2 id="Add-Diagram"><a href="#Add-Diagram" class="headerlink" title="Add Diagram"></a>Add Diagram</h2><pre><code>Class Diagram                   类图Package Diagram                 包图Object Diagram                  对象图Composite Structure Diagram     复合结构图Component Diagram               组件图Deployment Diagram              展开图Use Case Diagram                用例图Sequence Diagram                时序图Communication Diagram           交流图Statechart Diagram              状态图Activity Diagram                活动图Profile DiagramER Diagram                      E-R图Flowchart Diagram               流程图Data Flow Diagram               数据流程图</code></pre><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><pre><code>Tempalate Parameter     模板参数Attribute               属性Port                    端口Operation               操作Reception               接待Class                   类Interface               接口Signal                  信号DataType                数据类型PrimitiveType           原始类型Enumeration             枚举Artifact                工件Component               组件Node                    节点UseCaseActorInformationItemCollaborationInteraction             交互State Machine           状态机Activity                活动Opaque Behavior         不透明树Constraint              约束Requirement             要求Block                   块Value Type              数值类型Interface Block         接口块Constraint Block        约束快Tag                     标签</code></pre><h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1646381948452-2022-3-416:19:09.png">   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图操作菜单&quot;&gt;&lt;a href=&quot;#图操作菜单&quot; class=&quot;headerlink&quot; title=&quot;图操作菜单&quot;&gt;&lt;/a&gt;图操作菜单&lt;/h1&gt;&lt;h2 id=&quot;Add-Diagram&quot;&gt;&lt;a href=&quot;#Add-Diagram&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="个人笔记" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity杂文——String按行删除</title>
    <link href="http://yoursite.com/2022/03/03/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94string%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4/"/>
    <id>http://yoursite.com/2022/03/03/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94string%E6%8C%89%E8%A1%8C%E5%88%A0%E9%99%A4/</id>
    <published>2022-03-03T07:19:36.000Z</published>
    <updated>2022-03-04T02:16:15.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在unity开发过程中，如果一个string字符串有多行，如果我们想删除前面一行或者多行应该如何操作？  </p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><pre><code>private static string DeleteStrLine(string text, int startLine, int lineCount)&#123;    var curIndex = 0;    int? remStartIndex = null;    var sum = 1;    while (sum &lt; startLine + lineCount)     &#123;        if (sum == startLine) remStartIndex = curIndex;                curIndex = text.IndexOf(&quot;\n&quot;, curIndex, StringComparison.Ordinal);        if (curIndex &lt; 0)        &#123;            curIndex = text.Length;            break;        &#125;        curIndex++;        sum++;    &#125;    if (remStartIndex == null)    &#123;        return text;    &#125;    text = text.Remove(remStartIndex.Value, curIndex - remStartIndex.Value);    return text;&#125;</code></pre><p>思路就是通过<strong>IndexOf</strong>函数遍历找到需要删除的行对应的”\n”(换行)的索引，然后再通过<strong>Remove</strong>函数对开始和结束的索引进行删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;在unity开发过程中，如果一个string字符串有多行，如果我们想删除前面一行或者多行应该如何操作？  &lt;/p&gt;
&lt;h1 id=&quot;解决方案</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Unity笔记</title>
    <link href="http://yoursite.com/2022/03/03/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Unity%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/03/03/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/Unity%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-03T07:14:26.000Z</published>
    <updated>2022-03-18T08:43:22.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p><strong>[Conditional(“XXX”)]</strong>: 指定XXX宏下进行编译<br><strong>[RuntimeInitializeOnLoadMethod]</strong>:游戏运行是就执行的方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;特性&quot;&gt;&lt;a href=&quot;#特性&quot; class=&quot;headerlink&quot; title=&quot;特性&quot;&gt;&lt;/a&gt;特性&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;[Conditional(“XXX”)]&lt;/strong&gt;: 指定XXX宏下进行编译&lt;br&gt;&lt;strong&gt;[Runtime</summary>
      
    
    
    
    <category term="个人笔记" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Unity" scheme="http://yoursite.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——扩展Inspector面板(二)</title>
    <link href="http://yoursite.com/2022/02/23/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95Inspector%E9%9D%A2%E6%9D%BF(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2022/02/23/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95Inspector%E9%9D%A2%E6%9D%BF(%E4%BA%8C)/</id>
    <published>2022-02-23T10:30:36.000Z</published>
    <updated>2022-02-25T02:08:27.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>上次笔者讲解了如何自定义Inspector面板的显示，但是这里还有一个问题，就是对于支持的字段我们可以绘制对应的属性，但是有些字段我们并不支持绘制，比如一些类定义的变量，我们又改如何绘制？下面笔者介绍一下如何绘制一些本身不支持的字段。  </p><h1 id="自定义绘制Inspector"><a href="#自定义绘制Inspector" class="headerlink" title="自定义绘制Inspector"></a>自定义绘制Inspector</h1><p>笔者依旧拿笔者写的动画编辑器作为案例来进行讲解。  </p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>存放文件的目录如下  </p><blockquote><p>—Asset<br>——Scripts<br>———Editor<br>————UIAnimManagerEditor.cs<br>————<font color="#00FF00">UIAnimTransformInfoEditor.cs</font><br>———Engine<br>————UIAnimManager.cs<br>————<font color="#00FF00">UIAnimInfoBase.cs</font><br>————<font color="#00FF00">UIAnimTransformInfo.cs</font>  </p></blockquote><h2 id="创建一个Transform的信息的类（UIAnimTransformInfo）"><a href="#创建一个Transform的信息的类（UIAnimTransformInfo）" class="headerlink" title="创建一个Transform的信息的类（UIAnimTransformInfo）"></a>创建一个Transform的信息的类（UIAnimTransformInfo）</h2><p>为了方便我们可以绘制动画信息在Inspector面板上，我们需要在信息类上加上**[Serializable]**标签方便我们序列化</p><pre><code>[Serializable]public class UIAnimTransformInfo&#123;        public Transform m_Transform;&#125;</code></pre><p>然后我们在UIAnimManager上添加我们的信息就可以了</p><pre><code>public class UIAnimManager : MonoBehaviour&#123;    public float m_SumTime;                                                     //总时间    public bool m_IsDefReversed;                                                //默认的是否倒放    public bool m_IsDefLoop;                                                    //默认的是否循环    public bool m_IsDefAutoPlay;                                                //默认的是否自动播放    public UIAnimTransformInfo m_UIAnimTransformInfo;                           //Transform动画信息        [NonSerialized]    public float m_CurTime;                                                     //当前时间    [NonSerialized]    public UIAnimPlayState m_UIAnimPlayState = UIAnimPlayState.Stop;            //当前状态    &#125;</code></pre><h2 id="默认绘制类中类对象的Inspector面板"><a href="#默认绘制类中类对象的Inspector面板" class="headerlink" title="默认绘制类中类对象的Inspector面板"></a>默认绘制类中类对象的Inspector面板</h2><p>我们可以通过绘制属性的方式直接绘制我们的变量，代码如下：  </p><pre><code>EditorGUILayout.PropertyField(m_UIAnimTransformInfo);</code></pre><p>效果如下：  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1645698365713-2022-2-2418:26:06.png">  </p><p>这个绘制是unity默认的绘制。  </p><h2 id="自定义绘制类中类对象的Inspector面板"><a href="#自定义绘制类中类对象的Inspector面板" class="headerlink" title="自定义绘制类中类对象的Inspector面板"></a>自定义绘制类中类对象的Inspector面板</h2><p>如果我们类中的对象不想使用自定义的绘制，我们可以采用CustomPropertyDrawer这个属性标签来绑定我们类的绘制编辑器类。<br>代码如下  </p><pre><code>[CustomPropertyDrawer(typeof(UIAnimTransformInfo))]public class UIAnimTransformInfoEditor : PropertyDrawer&#123;    /// &lt;summary&gt;    /// 获取属性绘制的高度    /// &lt;/summary&gt;    /// &lt;param name=&quot;property&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;label&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public override float GetPropertyHeight(SerializedProperty property, GUIContent label)    &#123;        return EditorGUI.GetPropertyHeight(property);    &#125;    /// &lt;summary&gt;    /// 绘制自定义的面板    /// &lt;/summary&gt;    /// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;property&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;label&quot;&gt;&lt;/param&gt;    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)    &#123;            &#125;&#125;</code></pre><p>上述代码中，GetPropertyHeight函数是用来设置绘制面板的高度的，然后OnGUI的函数是写自定义的绘制的。  </p><font size="5" color="FF0000">提示：   在GetPropertyHeight函数离，如果类比较复杂，通过EditorGUI.GetPropertyHeight(property)获取的高度会出错，最好把属性里的需要绘制的字段分别获取高度再加一起返回。  在OnGUI函数里绘制的时候不能采用GUILayout和EditorGuiLayout的绘制方式，因为这个是给Rect进行绘制的，每次绘制的时候只需要计算宽度，然后绘制后坐标再自己移动绘制下一个。举例代码如下：</font>  <pre><code>/// &lt;summary&gt;/// 绘制单个可滑动的列表/// &lt;/summary&gt;/// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;property&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;uiReorderableList&quot;&gt;&lt;/param&gt;public static void OnReorderableListPropertyItemGUI(ref Rect position, SerializedProperty property,ReorderableList uiReorderableList)&#123;    position.height = GetReorderableListHeight(property);    uiReorderableList.DoList(position);    position.y += position.height;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;上次笔者讲解了如何自定义Inspector面板的显示，但是这里还有一个问题，就是对于支持的字段我们可以绘制对应的属性，但是有些字段我们并不支</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Unity编辑器" scheme="http://yoursite.com/tags/Unity%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Unity杂文——扩展Inspector面板(一)</title>
    <link href="http://yoursite.com/2022/02/18/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95Inspector%E9%9D%A2%E6%9D%BF(%E4%B8%80)/"/>
    <id>http://yoursite.com/2022/02/18/Unity%E6%9D%82%E6%96%87/Unity%E6%9D%82%E6%96%87%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95Inspector%E9%9D%A2%E6%9D%BF(%E4%B8%80)/</id>
    <published>2022-02-18T05:45:59.000Z</published>
    <updated>2022-02-18T07:23:45.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在使用unity的时候我们会经常使用到inspector面板来查看我们选中对象的信息，也会经常修改一些信息，但是，untiy默认的指挥显示我们组件上序列化的信息，也并不是所有的序列化的信息都显示，我们只需要添加**[HideInInspector]**标签就可以隐藏信息。但是这些并不能满足我们修改信息的需求，unity也为我们提供了自动绘制面板，这样我们不仅仅有修改字段的功能，还可以添加更多的功能了。  </p><h1 id="自定义绘制Inspector"><a href="#自定义绘制Inspector" class="headerlink" title="自定义绘制Inspector"></a>自定义绘制Inspector</h1><p>笔者是以自己写的一个UI的动画控制器为例来讲解的。  </p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>存放文件的目录如下  </p><blockquote><p>—Asset<br>——Scripts<br>———Editor<br>————UIAnimManagerEditor.cs<br>———Engine<br>————UIAnimManager.cs  </p></blockquote><h2 id="组件脚本"><a href="#组件脚本" class="headerlink" title="组件脚本"></a>组件脚本</h2><p>首先我们先创建一个需要绘制的脚本：  </p><pre><code>/// &lt;summary&gt;/// 动画播放状态/// &lt;/summary&gt;public enum UIAnimPlayState&#123;    Stop,                   //停止    Playing,                //播放中    Pause,                  //暂停    Finish,                 //完成&#125;/// &lt;summary&gt;/// 动画播放控制器/// &lt;/summary&gt;public class UIAnimManager : MonoBehaviour&#123;    public float m_SumTime;                                                     //总时间    public bool m_IsDefReversed;                                                //默认的是否倒放    public bool m_IsDefLoop;                                                    //默认的是否循环    public bool m_IsDefAutoPlay;                                                //默认的是否自动播放        [NonSerialized]    public float m_CurTime;                                                     //当前时间    [NonSerialized]    public UIAnimPlayState m_UIAnimPlayState = UIAnimPlayState.Stop;            //当前状态&#125;</code></pre><p>下面我们来看看默认的inspector的面板显示：  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1645165132213-2022-2-1814:18:53.png"></p><p>不仅仅**[HideInInspector]<strong>标签会隐藏字段，</strong>[NonSerialized]**标记没有序列化的字段也不会显示出来。  </p><h2 id="绘制Inspector面板脚本-CustomEditor"><a href="#绘制Inspector面板脚本-CustomEditor" class="headerlink" title="绘制Inspector面板脚本(CustomEditor)"></a>绘制Inspector面板脚本(CustomEditor)</h2><pre><code>[CustomEditor(typeof(UIAnimManager))]public class UIAnimManagerEditor : UnityEditor.Editor&#123;    #region 字段    private UIAnimManager m_UIAnimManager;                                      //面板的脚本        private SerializedProperty m_IsDefReversed;                                 //是否倒放    private SerializedProperty m_IsDefLoop;                                     //是否循环    private SerializedProperty m_IsDefAutoPlay;                                 //是否自动播放    #endregion        #region 继承方法    private void OnEnable()    &#123;        m_UIAnimManager = (UIAnimManager) target;                               //获取绑定的脚本                m_IsDefReversed = serializedObject.FindProperty(&quot;m_IsDefReversed&quot;);     //获取m_IsDefReversed字段        m_IsDefLoop = serializedObject.FindProperty(&quot;m_IsDefLoop&quot;);             //获取m_IsDefLoop字段        m_IsDefAutoPlay = serializedObject.FindProperty(&quot;m_IsDefAutoPlay&quot;);     //获取m_IsDefAutoPlay字段    &#125;    /// &lt;summary&gt;    /// 自定义绘制Inspector面板    /// &lt;/summary&gt;    public override void OnInspectorGUI()    &#123;        OnPropertyFieldGUI();    &#125;    #endregion        #region 自定义方法    /// &lt;summary&gt;    /// 绘制属性字段    /// &lt;/summary&gt;    private void OnPropertyFieldGUI()    &#123;        EditorGUI.BeginChangeCheck();                                       //监听面板是否发生变化        &#123;            EditorGUILayout.PropertyField(m_IsDefReversed);                 //绘制m_IsDefReversed属性            EditorGUILayout.PropertyField(m_IsDefLoop);                     //绘制m_IsDefLoop属性            EditorGUILayout.PropertyField(m_IsDefAutoPlay);                    //绘制m_IsAutoPlay属性        &#125;        if (EditorGUI.EndChangeCheck())                                     //如果发生变化为true        &#123;            EditorUtility.SetDirty(target);                                 //标记用于触发保存            serializedObject.ApplyModifiedProperties();                     //更新序列化的数据        &#125;    &#125;    #endregion&#125;</code></pre><p>如上述代码，编写脚本只需要类上面打上**[CustomEditor(typeof(UIAnimManager))]<strong>即可，中间的UIAnimManager换成需要绑定的类即可，然后在代码中继承</strong>OnInspectorGUI**方法，在这个方法里绘制自己想绘制的面板。<br>绘制样子如下：  </p><p><img src="https://gitee.com/lian_bai/img-warehouse/raw/master/BlogImg/1645168657839-2022-2-1815:17:38.png">  </p><h2 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h2><p>首先开<strong>OnEnable</strong>函数里：  </p><blockquote><p>m_UIAnimManager &#x3D; (UIAnimManager) target;获取当前绑定的脚本对象<br>serializedObject.FindProperty是获取脚本上的属性，是拿这些属性绘制的  </p></blockquote><p><strong>OnInspectorGUI</strong>函数就是我们编写绘制Inspector面板的函数，在代码里我们可以编写untiy提供的编辑器代码，笔者这里只是通过EditorGUILayout.PropertyField来绘制属性，也可以使用其他unity的编辑器绘制代码，这里就不举例了。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在使用unity的时候我们会经常使用到inspector面板来查看我们选中对象的信息，也会经常修改一些信息，但是，untiy默认的指挥显示我</summary>
      
    
    
    
    <category term="Unity杂文" scheme="http://yoursite.com/categories/Unity%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Unity编辑器" scheme="http://yoursite.com/tags/Unity%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>解决Hexo博客提交Warning</title>
    <link href="http://yoursite.com/2022/01/29/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E8%A7%A3%E5%86%B3Hexo%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4Warning/"/>
    <id>http://yoursite.com/2022/01/29/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E8%A7%A3%E5%86%B3Hexo%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4Warning/</id>
    <published>2022-01-29T07:19:22.000Z</published>
    <updated>2022-01-29T07:26:23.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Warning-Accessing-non-existent-property-‘XXX’-of-module-exports-inside-circular-dependency"><a href="#Warning-Accessing-non-existent-property-‘XXX’-of-module-exports-inside-circular-dependency" class="headerlink" title="Warning: Accessing non-existent property ‘XXX’ of module exports inside circular dependency"></a>Warning: Accessing non-existent property ‘XXX’ of module exports inside circular dependency</h1><p>笔者在更新本地npm和node后，提交hexo博客的时候遇到了这个问题。原因在于本地node的版本太高导致的。  </p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>降低node的版本，选择一个低版本的node，node的12版本应该就可以。  </p><p><a href="https://nodejs.org/download/release/"><font color="steelblue" size="5">node各版本下载</font></a>  </p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>笔者并不想更新node版本，于是笔者找到了第二种解决方案，在博客目录下：  </p><pre><code>myBlog\node_modules\nib\node_modules\stylus\lib\nodes\index.jsmyBlog\node_modules\stylus\lib\nodes\index.js.</code></pre><p>上面两个路径下的<strong>index.js</strong>文件的前面分别添加下面代码即可。(两个文件都需要添加)  </p><pre><code>exports.lineno = null;exports.column = null;exports.filename = null;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Warning-Accessing-non-existent-property-‘XXX’-of-module-exports-inside-circular-dependency&quot;&gt;&lt;a href=&quot;#Warning-Accessing-non-existent</summary>
      
    
    
    
    <category term="搭建博客" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客Warning" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2Warning/"/>
    
  </entry>
  
</feed>
